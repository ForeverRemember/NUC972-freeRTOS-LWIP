; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\mem.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\mem.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\mem.crf lwip-1.4.1\src\core\mem.c]
                          ARM

                          AREA ||i.mem_calloc||, CODE, READONLY, ALIGN=2

                  mem_calloc PROC
;;;645     */
;;;646    void *mem_calloc(mem_size_t count, mem_size_t size)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;647    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;648      void *p;
;;;649    
;;;650      /* allocate 'count' objects of size 'size' */
;;;651      p = mem_malloc(count * size);
00000c  e0010594          MUL      r1,r4,r5
000010  e1a00801          LSL      r0,r1,#16
000014  e1a00820          LSR      r0,r0,#16
000018  ebfffffe          BL       mem_malloc
00001c  e1a06000          MOV      r6,r0
;;;652      if (p) {
000020  e3560000          CMP      r6,#0
000024  0a000002          BEQ      |L1.52|
;;;653        /* zero the memory */
;;;654        memset(p, 0, count * size);
000028  e0010594          MUL      r1,r4,r5
00002c  e1a00006          MOV      r0,r6
000030  ebfffffe          BL       __aeabi_memclr
                  |L1.52|
;;;655      }
;;;656      return p;
000034  e1a00006          MOV      r0,r6
;;;657    }
000038  e8bd8070          POP      {r4-r6,pc}
;;;658    
                          ENDP


                          AREA ||i.mem_free||, CODE, READONLY, ALIGN=2

                  mem_free PROC
;;;310    void
;;;311    mem_free(void *rmem)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;312    {
000004  e1a04000          MOV      r4,r0
;;;313      struct mem *mem;
;;;314      LWIP_MEM_FREE_DECL_PROTECT();
;;;315    
;;;316      if (rmem == NULL) {
000008  e3540000          CMP      r4,#0
00000c  1a000000          BNE      |L2.20|
                  |L2.16|
;;;317        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
;;;318        return;
;;;319      }
;;;320      LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
;;;321    
;;;322      LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;323        (u8_t *)rmem < (u8_t *)ram_end);
;;;324    
;;;325      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;326        SYS_ARCH_DECL_PROTECT(lev);
;;;327        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
;;;328        /* protect mem stats from concurrent access */
;;;329        SYS_ARCH_PROTECT(lev);
;;;330        MEM_STATS_INC(illegal);
;;;331        SYS_ARCH_UNPROTECT(lev);
;;;332        return;
;;;333      }
;;;334      /* protect the heap from concurrent access */
;;;335      LWIP_MEM_FREE_PROTECT();
;;;336      /* Get the corresponding struct mem ... */
;;;337      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;338      /* ... which has to be in a used state ... */
;;;339      LWIP_ASSERT("mem_free: mem->used", mem->used);
;;;340      /* ... and is now unused. */
;;;341      mem->used = 0;
;;;342    
;;;343      if (mem < lfree) {
;;;344        /* the newly freed struct is now the lowest */
;;;345        lfree = mem;
;;;346      }
;;;347    
;;;348      MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
;;;349    
;;;350      /* finally, see if prev or next are free also */
;;;351      plug_holes(mem);
;;;352    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;353      mem_free_count = 1;
;;;354    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;355      LWIP_MEM_FREE_UNPROTECT();
;;;356    }
000010  e8bd8070          POP      {r4-r6,pc}
                  |L2.20|
000014  e1a00000          MOV      r0,r0                 ;320
000018  e2040003          AND      r0,r4,#3              ;320
00001c  e3500000          CMP      r0,#0                 ;320
000020  0a000006          BEQ      |L2.64|
000024  e1a00000          MOV      r0,r0                 ;320
000028  e28f3f42          ADR      r3,|L2.312|
00002c  e3a02d05          MOV      r2,#0x140             ;320
000030  e28f1f47          ADR      r1,|L2.340|
000034  e28f0f4f          ADR      r0,|L2.376|
000038  ebfffffe          BL       sysprintf
00003c  e1a00000          MOV      r0,r0                 ;320
                  |L2.64|
000040  e1a00000          MOV      r0,r0                 ;320
000044  e1a00000          MOV      r0,r0                 ;322
000048  e59f0150          LDR      r0,|L2.416|
00004c  e5900000          LDR      r0,[r0,#0]            ;322  ; ram
000050  e1540000          CMP      r4,r0                 ;322
000054  3a000003          BCC      |L2.104|
000058  e59f0144          LDR      r0,|L2.420|
00005c  e5900000          LDR      r0,[r0,#0]            ;322  ; ram_end
000060  e1540000          CMP      r4,r0                 ;322
000064  3a000006          BCC      |L2.132|
                  |L2.104|
000068  e1a00000          MOV      r0,r0                 ;322
00006c  e28f30c4          ADR      r3,|L2.312|
000070  e59f2130          LDR      r2,|L2.424|
000074  e28f1e13          ADR      r1,|L2.428|
000078  e28f00f8          ADR      r0,|L2.376|
00007c  ebfffffe          BL       sysprintf
000080  e1a00000          MOV      r0,r0                 ;322
                  |L2.132|
000084  e1a00000          MOV      r0,r0                 ;322
000088  e59f0110          LDR      r0,|L2.416|
00008c  e5900000          LDR      r0,[r0,#0]            ;325  ; ram
000090  e1540000          CMP      r4,r0                 ;325
000094  3a000003          BCC      |L2.168|
000098  e59f0104          LDR      r0,|L2.420|
00009c  e5900000          LDR      r0,[r0,#0]            ;325  ; ram_end
0000a0  e1540000          CMP      r4,r0                 ;325
0000a4  3a000004          BCC      |L2.188|
                  |L2.168|
0000a8  ebfffffe          BL       sys_arch_protect
0000ac  e1a06000          MOV      r6,r0                 ;329
0000b0  e1a00006          MOV      r0,r6                 ;331
0000b4  ebfffffe          BL       sys_arch_unprotect
0000b8  eaffffd4          B        |L2.16|
                  |L2.188|
0000bc  e1a00000          MOV      r0,r0                 ;333
0000c0  e3a01000          MOV      r1,#0                 ;335
0000c4  e59f00f8          LDR      r0,|L2.452|
0000c8  ebfffffe          BL       sys_arch_sem_wait
0000cc  e2445008          SUB      r5,r4,#8              ;337
0000d0  e1a00000          MOV      r0,r0                 ;339
0000d4  e5d50004          LDRB     r0,[r5,#4]            ;339
0000d8  e3500000          CMP      r0,#0                 ;339
0000dc  1a000006          BNE      |L2.252|
0000e0  e1a00000          MOV      r0,r0                 ;339
0000e4  e28f304c          ADR      r3,|L2.312|
0000e8  e59f20d8          LDR      r2,|L2.456|
0000ec  e28f10d8          ADR      r1,|L2.460|
0000f0  e28f0080          ADR      r0,|L2.376|
0000f4  ebfffffe          BL       sysprintf
0000f8  e1a00000          MOV      r0,r0                 ;339
                  |L2.252|
0000fc  e1a00000          MOV      r0,r0                 ;339
000100  e3a00000          MOV      r0,#0                 ;341
000104  e5c50004          STRB     r0,[r5,#4]            ;341
000108  e59f00d0          LDR      r0,|L2.480|
00010c  e5900000          LDR      r0,[r0,#0]            ;343  ; lfree
000110  e1550000          CMP      r5,r0                 ;343
000114  2a000001          BCS      |L2.288|
000118  e59f00c0          LDR      r0,|L2.480|
00011c  e5805000          STR      r5,[r0,#0]            ;345  ; lfree
                  |L2.288|
000120  e1a00005          MOV      r0,r5                 ;351
000124  ebfffffe          BL       plug_holes
000128  e59f0094          LDR      r0,|L2.452|
00012c  ebfffffe          BL       sys_sem_signal
000130  e1a00000          MOV      r0,r0
000134  eaffffb5          B        |L2.16|
;;;357    
                          ENDP

                  |L2.312|
000138  6c776970          DCB      "lwip-1.4.1\\src\\core\\mem.c",0
00013c  2d312e34
000140  2e315c73
000144  72635c63
000148  6f72655c
00014c  6d656d2e
000150  6300    
000152  00                DCB      0
000153  00                DCB      0
                  |L2.340|
000154  6d656d5f          DCB      "mem_free: sanity check alignment",0
000158  66726565
00015c  3a207361
000160  6e697479
000164  20636865
000168  636b2061
00016c  6c69676e
000170  6d656e74
000174  00      
000175  00                DCB      0
000176  00                DCB      0
000177  00                DCB      0
                  |L2.376|
000178  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00017c  7274696f
000180  6e202225
000184  73222066
000188  61696c65
00018c  64206174
000190  206c696e
000194  65202564
000198  20696e20
00019c  25730a00
                  |L2.416|
                          DCD      ||ram||
                  |L2.420|
                          DCD      ram_end
                  |L2.424|
                          DCD      0x00000142
                  |L2.428|
0001ac  6d656d5f          DCB      "mem_free: legal memory",0
0001b0  66726565
0001b4  3a206c65
0001b8  67616c20
0001bc  6d656d6f
0001c0  727900  
0001c3  00                DCB      0
                  |L2.452|
                          DCD      mem_mutex
                  |L2.456|
                          DCD      0x00000153
                  |L2.460|
0001cc  6d656d5f          DCB      "mem_free: mem->used",0
0001d0  66726565
0001d4  3a206d65
0001d8  6d2d3e75
0001dc  73656400
                  |L2.480|
                          DCD      lfree

                          AREA ||i.mem_init||, CODE, READONLY, ALIGN=2

                  mem_init PROC
;;;273    void
;;;274    mem_init(void)
000000  e92d4010          PUSH     {r4,lr}
;;;275    {
;;;276      struct mem *mem;
;;;277    
;;;278      LWIP_ASSERT("Sanity check alignment",
000004  e1a00000          MOV      r0,r0
000008  e1a00000          MOV      r0,r0
;;;279        (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
;;;280    
;;;281      /* align the heap */
;;;282      ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
00000c  e59f00ac          LDR      r0,|L3.192|
000010  e3c00003          BIC      r0,r0,#3
000014  e59f10a8          LDR      r1,|L3.196|
000018  e5810000          STR      r0,[r1,#0]  ; ram
;;;283      /* initialize the start of the heap */
;;;284      mem = (struct mem *)(void *)ram;
00001c  e2810000          ADD      r0,r1,#0
000020  e5904000          LDR      r4,[r0,#0]  ; ram
;;;285      mem->next = MEM_SIZE_ALIGNED;
000024  e3a00901          MOV      r0,#0x4000
000028  e1c400b0          STRH     r0,[r4,#0]
;;;286      mem->prev = 0;
00002c  e3a00000          MOV      r0,#0
000030  e1c400b2          STRH     r0,[r4,#2]
;;;287      mem->used = 0;
000034  e5c40004          STRB     r0,[r4,#4]
;;;288      /* initialize the end of the heap */
;;;289      ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
000038  e2810000          ADD      r0,r1,#0
00003c  e5900000          LDR      r0,[r0,#0]  ; ram
000040  e2800901          ADD      r0,r0,#0x4000
000044  e59f107c          LDR      r1,|L3.200|
000048  e5810000          STR      r0,[r1,#0]  ; ram_end
;;;290      ram_end->used = 1;
00004c  e3a00001          MOV      r0,#1
000050  e5911000          LDR      r1,[r1,#0]  ; ram_end
000054  e5c10004          STRB     r0,[r1,#4]
;;;291      ram_end->next = MEM_SIZE_ALIGNED;
000058  e3a00901          MOV      r0,#0x4000
00005c  e59f1064          LDR      r1,|L3.200|
000060  e5911000          LDR      r1,[r1,#0]  ; ram_end
000064  e1c100b0          STRH     r0,[r1,#0]
;;;292      ram_end->prev = MEM_SIZE_ALIGNED;
000068  e59f1058          LDR      r1,|L3.200|
00006c  e5911000          LDR      r1,[r1,#0]  ; ram_end
000070  e1c100b2          STRH     r0,[r1,#2]
;;;293    
;;;294      /* initialize the lowest-free pointer to the start of the heap */
;;;295      lfree = (struct mem *)(void *)ram;
000074  e59f0048          LDR      r0,|L3.196|
000078  e5900000          LDR      r0,[r0,#0]  ; ram
00007c  e59f1048          LDR      r1,|L3.204|
000080  e5810000          STR      r0,[r1,#0]  ; lfree
;;;296    
;;;297      MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
;;;298    
;;;299      if(sys_mutex_new(&mem_mutex) != ERR_OK) {
000084  e3a01001          MOV      r1,#1
000088  e59f0040          LDR      r0,|L3.208|
00008c  ebfffffe          BL       sys_sem_new
000090  e3500000          CMP      r0,#0
000094  0a000008          BEQ      |L3.188|
;;;300        LWIP_ASSERT("failed to create mem_mutex", 0);
000098  e1a00000          MOV      r0,r0
00009c  e1a00000          MOV      r0,r0
0000a0  e28f302c          ADR      r3,|L3.212|
0000a4  e3a02f4b          MOV      r2,#0x12c
0000a8  e28f1040          ADR      r1,|L3.240|
0000ac  e28f0058          ADR      r0,|L3.268|
0000b0  ebfffffe          BL       sysprintf
0000b4  e1a00000          MOV      r0,r0
0000b8  e1a00000          MOV      r0,r0
                  |L3.188|
;;;301      }
;;;302    }
0000bc  e8bd8010          POP      {r4,pc}
;;;303    
                          ENDP

                  |L3.192|
                          DCD      ram_heap+0x3
                  |L3.196|
                          DCD      ||ram||
                  |L3.200|
                          DCD      ram_end
                  |L3.204|
                          DCD      lfree
                  |L3.208|
                          DCD      mem_mutex
                  |L3.212|
0000d4  6c776970          DCB      "lwip-1.4.1\\src\\core\\mem.c",0
0000d8  2d312e34
0000dc  2e315c73
0000e0  72635c63
0000e4  6f72655c
0000e8  6d656d2e
0000ec  6300    
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L3.240|
0000f0  6661696c          DCB      "failed to create mem_mutex",0
0000f4  65642074
0000f8  6f206372
0000fc  65617465
000100  206d656d
000104  5f6d7574
000108  657800  
00010b  00                DCB      0
                  |L3.268|
00010c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000110  7274696f
000114  6e202225
000118  73222066
00011c  61696c65
000120  64206174
000124  206c696e
000128  65202564
00012c  20696e20
000130  25730a00

                          AREA ||i.mem_malloc||, CODE, READONLY, ALIGN=2

                  mem_malloc PROC
;;;493    void *
;;;494    mem_malloc(mem_size_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;495    {
000004  e1a05000          MOV      r5,r0
;;;496      mem_size_t ptr, ptr2;
;;;497      struct mem *mem, *mem2;
;;;498    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;499      u8_t local_mem_free_count = 0;
;;;500    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;501      LWIP_MEM_ALLOC_DECL_PROTECT();
;;;502    
;;;503      if (size == 0) {
000008  e3550000          CMP      r5,#0
00000c  1a000001          BNE      |L4.24|
;;;504        return NULL;
000010  e3a00000          MOV      r0,#0
                  |L4.20|
;;;505      }
;;;506    
;;;507      /* Expand the size of the allocated memory region so that we can
;;;508         adjust for alignment. */
;;;509      size = LWIP_MEM_ALIGN_SIZE(size);
;;;510    
;;;511      if(size < MIN_SIZE_ALIGNED) {
;;;512        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;513        size = MIN_SIZE_ALIGNED;
;;;514      }
;;;515    
;;;516      if (size > MEM_SIZE_ALIGNED) {
;;;517        return NULL;
;;;518      }
;;;519    
;;;520      /* protect the heap from concurrent access */
;;;521      sys_mutex_lock(&mem_mutex);
;;;522      LWIP_MEM_ALLOC_PROTECT();
;;;523    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;524      /* run as long as a mem_free disturbed mem_malloc or mem_trim */
;;;525      do {
;;;526        local_mem_free_count = 0;
;;;527    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;528    
;;;529        /* Scan through the heap searching for a free block that is big enough,
;;;530         * beginning with the lowest free block.
;;;531         */
;;;532        for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
;;;533             ptr = ((struct mem *)(void *)&ram[ptr])->next) {
;;;534          mem = (struct mem *)(void *)&ram[ptr];
;;;535    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;536          mem_free_count = 0;
;;;537          LWIP_MEM_ALLOC_UNPROTECT();
;;;538          /* allow mem_free or mem_trim to run */
;;;539          LWIP_MEM_ALLOC_PROTECT();
;;;540          if (mem_free_count != 0) {
;;;541            /* If mem_free or mem_trim have run, we have to restart since they
;;;542               could have altered our current struct mem. */
;;;543            local_mem_free_count = 1;
;;;544            break;
;;;545          }
;;;546    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;547    
;;;548          if ((!mem->used) &&
;;;549              (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
;;;550            /* mem is not used and at least perfect fit is possible:
;;;551             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;552    
;;;553            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
;;;554              /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
;;;555               * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;556               * -> split large block, create empty remainder,
;;;557               * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;558               * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;559               * struct mem would fit in but no data between mem2 and mem2->next
;;;560               * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;561               *       region that couldn't hold data, but when mem->next gets freed,
;;;562               *       the 2 regions would be combined, resulting in more free memory
;;;563               */
;;;564              ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;565              /* create mem2 struct */
;;;566              mem2 = (struct mem *)(void *)&ram[ptr2];
;;;567              mem2->used = 0;
;;;568              mem2->next = mem->next;
;;;569              mem2->prev = ptr;
;;;570              /* and insert it between mem and mem->next */
;;;571              mem->next = ptr2;
;;;572              mem->used = 1;
;;;573    
;;;574              if (mem2->next != MEM_SIZE_ALIGNED) {
;;;575                ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;576              }
;;;577              MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
;;;578            } else {
;;;579              /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;580               * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;581               * take care of this).
;;;582               * -> near fit or excact fit: do not split, no mem2 creation
;;;583               * also can't move mem->next directly behind mem, since mem->next
;;;584               * will always be used at this point!
;;;585               */
;;;586              mem->used = 1;
;;;587              MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
;;;588            }
;;;589    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;590    mem_malloc_adjust_lfree:
;;;591    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;592            if (mem == lfree) {
;;;593              struct mem *cur = lfree;
;;;594              /* Find next free block after mem and update lowest free pointer */
;;;595              while (cur->used && cur != ram_end) {
;;;596    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;597                mem_free_count = 0;
;;;598                LWIP_MEM_ALLOC_UNPROTECT();
;;;599                /* prevent high interrupt latency... */
;;;600                LWIP_MEM_ALLOC_PROTECT();
;;;601                if (mem_free_count != 0) {
;;;602                  /* If mem_free or mem_trim have run, we have to restart since they
;;;603                     could have altered our current struct mem or lfree. */
;;;604                  goto mem_malloc_adjust_lfree;
;;;605                }
;;;606    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;607                cur = (struct mem *)(void *)&ram[cur->next];
;;;608              }
;;;609              lfree = cur;
;;;610              LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
;;;611            }
;;;612            LWIP_MEM_ALLOC_UNPROTECT();
;;;613            sys_mutex_unlock(&mem_mutex);
;;;614            LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
;;;615             (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
;;;616            LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
;;;617             ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
;;;618            LWIP_ASSERT("mem_malloc: sanity check alignment",
;;;619              (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
;;;620    
;;;621            return (u8_t *)mem + SIZEOF_STRUCT_MEM;
;;;622          }
;;;623        }
;;;624    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;625        /* if we got interrupted by a mem_free, try again */
;;;626      } while(local_mem_free_count != 0);
;;;627    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;628      LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
;;;629      MEM_STATS_INC(err);
;;;630      LWIP_MEM_ALLOC_UNPROTECT();
;;;631      sys_mutex_unlock(&mem_mutex);
;;;632      return NULL;
;;;633    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L4.24|
000018  e2850003          ADD      r0,r5,#3              ;509
00001c  e3c00003          BIC      r0,r0,#3              ;509
000020  e1a05800          LSL      r5,r0,#16             ;509
000024  e1a05825          LSR      r5,r5,#16             ;509
000028  e355000c          CMP      r5,#0xc               ;511
00002c  aa000000          BGE      |L4.52|
000030  e3a0500c          MOV      r5,#0xc               ;513
                  |L4.52|
000034  e3550901          CMP      r5,#0x4000            ;516
000038  da000001          BLE      |L4.68|
00003c  e3a00000          MOV      r0,#0                 ;517
000040  eafffff3          B        |L4.20|
                  |L4.68|
000044  e3a01000          MOV      r1,#0                 ;521
000048  e59f021c          LDR      r0,|L4.620|
00004c  ebfffffe          BL       sys_arch_sem_wait
000050  e59f0218          LDR      r0,|L4.624|
000054  e1d000b0          LDRH     r0,[r0,#0]            ;532  ; lfree
000058  e59f1214          LDR      r1,|L4.628|
00005c  e1d110b0          LDRH     r1,[r1,#0]            ;532  ; ram
000060  e0400001          SUB      r0,r0,r1              ;532
000064  e1a06800          LSL      r6,r0,#16             ;532
000068  e1a06826          LSR      r6,r6,#16             ;532
00006c  ea0000c1          B        |L4.888|
                  |L4.112|
000070  e59f01fc          LDR      r0,|L4.628|
000074  e5900000          LDR      r0,[r0,#0]            ;534  ; ram
000078  e0804006          ADD      r4,r0,r6              ;534
00007c  e5d40004          LDRB     r0,[r4,#4]            ;548
000080  e3500000          CMP      r0,#0                 ;548
000084  1a0000b8          BNE      |L4.876|
000088  e1d400b0          LDRH     r0,[r4,#0]            ;549
00008c  e2861008          ADD      r1,r6,#8              ;549
000090  e0400001          SUB      r0,r0,r1              ;549
000094  e1500005          CMP      r0,r5                 ;549
000098  3a0000b3          BCC      |L4.876|
00009c  e1d400b0          LDRH     r0,[r4,#0]            ;553
0000a0  e2861008          ADD      r1,r6,#8              ;553
0000a4  e0400001          SUB      r0,r0,r1              ;553
0000a8  e2851014          ADD      r1,r5,#0x14           ;553
0000ac  e1500001          CMP      r0,r1                 ;553
0000b0  3a000017          BCC      |L4.276|
0000b4  e2860008          ADD      r0,r6,#8              ;564
0000b8  e0800005          ADD      r0,r0,r5              ;564
0000bc  e1a08800          LSL      r8,r0,#16             ;564
0000c0  e1a08828          LSR      r8,r8,#16             ;564
0000c4  e59f01a8          LDR      r0,|L4.628|
0000c8  e5900000          LDR      r0,[r0,#0]            ;566  ; ram
0000cc  e0807008          ADD      r7,r0,r8              ;566
0000d0  e3a00000          MOV      r0,#0                 ;567
0000d4  e5c70004          STRB     r0,[r7,#4]            ;567
0000d8  e1d400b0          LDRH     r0,[r4,#0]            ;568
0000dc  e1c700b0          STRH     r0,[r7,#0]            ;568
0000e0  e1c760b2          STRH     r6,[r7,#2]            ;569
0000e4  e1c480b0          STRH     r8,[r4,#0]            ;571
0000e8  e3a00001          MOV      r0,#1                 ;572
0000ec  e5c40004          STRB     r0,[r4,#4]            ;572
0000f0  e1d700b0          LDRH     r0,[r7,#0]            ;574
0000f4  e3500901          CMP      r0,#0x4000            ;574
0000f8  0a000007          BEQ      |L4.284|
0000fc  e1d700b0          LDRH     r0,[r7,#0]            ;575
000100  e59f116c          LDR      r1,|L4.628|
000104  e5911000          LDR      r1,[r1,#0]            ;575  ; ram
000108  e0800001          ADD      r0,r0,r1              ;575
00010c  e1c080b2          STRH     r8,[r0,#2]            ;575
000110  ea000001          B        |L4.284|
                  |L4.276|
000114  e3a00001          MOV      r0,#1                 ;586
000118  e5c40004          STRB     r0,[r4,#4]            ;586
                  |L4.284|
00011c  e59f014c          LDR      r0,|L4.624|
000120  e5900000          LDR      r0,[r0,#0]            ;592  ; lfree
000124  e1540000          CMP      r4,r0                 ;592
000128  1a000023          BNE      |L4.444|
00012c  e59f013c          LDR      r0,|L4.624|
000130  e5909000          LDR      r9,[r0,#0]            ;593  ; lfree
000134  ea000003          B        |L4.328|
                  |L4.312|
000138  e1d900b0          LDRH     r0,[r9,#0]            ;607
00013c  e59f1130          LDR      r1,|L4.628|
000140  e5911000          LDR      r1,[r1,#0]            ;607  ; ram
000144  e0809001          ADD      r9,r0,r1              ;607
                  |L4.328|
000148  e5d90004          LDRB     r0,[r9,#4]            ;595
00014c  e3500000          CMP      r0,#0                 ;595
000150  0a000003          BEQ      |L4.356|
000154  e59f011c          LDR      r0,|L4.632|
000158  e5900000          LDR      r0,[r0,#0]            ;595  ; ram_end
00015c  e1590000          CMP      r9,r0                 ;595
000160  1afffff4          BNE      |L4.312|
                  |L4.356|
000164  e59f0104          LDR      r0,|L4.624|
000168  e5809000          STR      r9,[r0,#0]            ;609  ; lfree
00016c  e1a00000          MOV      r0,r0                 ;610
000170  e5900000          LDR      r0,[r0,#0]            ;610  ; lfree
000174  e59f10fc          LDR      r1,|L4.632|
000178  e5911000          LDR      r1,[r1,#0]            ;610  ; ram_end
00017c  e1500001          CMP      r0,r1                 ;610
000180  0a00000b          BEQ      |L4.436|
000184  e59f00e4          LDR      r0,|L4.624|
000188  e5900000          LDR      r0,[r0,#0]            ;610  ; lfree
00018c  e5d00004          LDRB     r0,[r0,#4]            ;610
000190  e3500000          CMP      r0,#0                 ;610
000194  0a000006          BEQ      |L4.436|
000198  e1a00000          MOV      r0,r0                 ;610
00019c  e28f30d8          ADR      r3,|L4.636|
0001a0  e59f20f0          LDR      r2,|L4.664|
0001a4  e28f10f0          ADR      r1,|L4.668|
0001a8  e28f0f42          ADR      r0,|L4.696|
0001ac  ebfffffe          BL       sysprintf
0001b0  e1a00000          MOV      r0,r0                 ;610
                  |L4.436|
0001b4  e1a00000          MOV      r0,r0                 ;610
0001b8  e1a00000          MOV      r0,r0                 ;611
                  |L4.444|
0001bc  e59f00a8          LDR      r0,|L4.620|
0001c0  ebfffffe          BL       sys_sem_signal
0001c4  e1a00000          MOV      r0,r0                 ;614
0001c8  e2840008          ADD      r0,r4,#8              ;614
0001cc  e0800005          ADD      r0,r0,r5              ;614
0001d0  e59f10a0          LDR      r1,|L4.632|
0001d4  e5911000          LDR      r1,[r1,#0]            ;614  ; ram_end
0001d8  e1500001          CMP      r0,r1                 ;614
0001dc  9a000006          BLS      |L4.508|
0001e0  e1a00000          MOV      r0,r0                 ;614
0001e4  e28f3090          ADR      r3,|L4.636|
0001e8  e59f20f0          LDR      r2,|L4.736|
0001ec  e28f10f0          ADR      r1,|L4.740|
0001f0  e28f00c0          ADR      r0,|L4.696|
0001f4  ebfffffe          BL       sysprintf
0001f8  e1a00000          MOV      r0,r0                 ;614
                  |L4.508|
0001fc  e1a00000          MOV      r0,r0                 ;614
000200  e1a00000          MOV      r0,r0                 ;616
000204  e2840008          ADD      r0,r4,#8              ;616
000208  e2000003          AND      r0,r0,#3              ;616
00020c  e3500000          CMP      r0,#0                 ;616
000210  0a000006          BEQ      |L4.560|
000214  e1a00000          MOV      r0,r0                 ;616
000218  e28f305c          ADR      r3,|L4.636|
00021c  e3a02f9a          MOV      r2,#0x268             ;616
000220  e28f10ec          ADR      r1,|L4.788|
000224  e28f008c          ADR      r0,|L4.696|
000228  ebfffffe          BL       sysprintf
00022c  e1a00000          MOV      r0,r0                 ;616
                  |L4.560|
000230  e1a00000          MOV      r0,r0                 ;616
000234  e1a00000          MOV      r0,r0                 ;618
000238  e2040003          AND      r0,r4,#3              ;618
00023c  e3500000          CMP      r0,#0                 ;618
000240  0a000006          BEQ      |L4.608|
000244  e1a00000          MOV      r0,r0                 ;618
000248  e28f302c          ADR      r3,|L4.636|
00024c  e59f20f0          LDR      r2,|L4.836|
000250  e28f10f0          ADR      r1,|L4.840|
000254  e28f005c          ADR      r0,|L4.696|
000258  ebfffffe          BL       sysprintf
00025c  e1a00000          MOV      r0,r0                 ;618
                  |L4.608|
000260  e1a00000          MOV      r0,r0                 ;618
000264  e2840008          ADD      r0,r4,#8              ;621
000268  eaffff69          B        |L4.20|
                  |L4.620|
                          DCD      mem_mutex
                  |L4.624|
                          DCD      lfree
                  |L4.628|
                          DCD      ||ram||
                  |L4.632|
                          DCD      ram_end
                  |L4.636|
00027c  6c776970          DCB      "lwip-1.4.1\\src\\core\\mem.c",0
000280  2d312e34
000284  2e315c73
000288  72635c63
00028c  6f72655c
000290  6d656d2e
000294  6300    
000296  00                DCB      0
000297  00                DCB      0
                  |L4.664|
                          DCD      0x00000262
                  |L4.668|
00029c  6d656d5f          DCB      "mem_malloc: !lfree->used",0
0002a0  6d616c6c
0002a4  6f633a20
0002a8  216c6672
0002ac  65652d3e
0002b0  75736564
0002b4  00      
0002b5  00                DCB      0
0002b6  00                DCB      0
0002b7  00                DCB      0
                  |L4.696|
0002b8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0002bc  7274696f
0002c0  6e202225
0002c4  73222066
0002c8  61696c65
0002cc  64206174
0002d0  206c696e
0002d4  65202564
0002d8  20696e20
0002dc  25730a00
                  |L4.736|
                          DCD      0x00000266
                  |L4.740|
0002e4  6d656d5f          DCB      "mem_malloc: allocated memory not above ram_end.",0
0002e8  6d616c6c
0002ec  6f633a20
0002f0  616c6c6f
0002f4  63617465
0002f8  64206d65
0002fc  6d6f7279
000300  206e6f74
000304  2061626f
000308  76652072
00030c  616d5f65
000310  6e642e00
                  |L4.788|
000314  6d656d5f          DCB      "mem_malloc: allocated memory properly aligned.",0
000318  6d616c6c
00031c  6f633a20
000320  616c6c6f
000324  63617465
000328  64206d65
00032c  6d6f7279
000330  2070726f
000334  7065726c
000338  7920616c
00033c  69676e65
000340  642e00  
000343  00                DCB      0
                  |L4.836|
                          DCD      0x0000026a
                  |L4.840|
000348  6d656d5f          DCB      "mem_malloc: sanity check alignment",0
00034c  6d616c6c
000350  6f633a20
000354  73616e69
000358  74792063
00035c  6865636b
000360  20616c69
000364  676e6d65
000368  6e7400  
00036b  00                DCB      0
                  |L4.876|
00036c  e51f0100          LDR      r0,|L4.628|
000370  e5900000          LDR      r0,[r0,#0]            ;533  ; ram
000374  e19060b6          LDRH     r6,[r0,r6]            ;533
                  |L4.888|
000378  e2650901          RSB      r0,r5,#0x4000         ;532
00037c  e1500006          CMP      r0,r6                 ;532
000380  caffff3a          BGT      |L4.112|
000384  e51f0120          LDR      r0,|L4.620|
000388  ebfffffe          BL       sys_sem_signal
00038c  e3a00000          MOV      r0,#0                 ;632
000390  eaffff1f          B        |L4.20|
;;;634    
                          ENDP


                          AREA ||i.mem_trim||, CODE, READONLY, ALIGN=2

                  mem_trim PROC
;;;368    void *
;;;369    mem_trim(void *rmem, mem_size_t newsize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;370    {
000004  e1a08000          MOV      r8,r0
000008  e1a05001          MOV      r5,r1
;;;371      mem_size_t size;
;;;372      mem_size_t ptr, ptr2;
;;;373      struct mem *mem, *mem2;
;;;374      /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
;;;375      LWIP_MEM_FREE_DECL_PROTECT();
;;;376    
;;;377      /* Expand the size of the allocated memory region so that we can
;;;378         adjust for alignment. */
;;;379      newsize = LWIP_MEM_ALIGN_SIZE(newsize);
00000c  e2850003          ADD      r0,r5,#3
000010  e3c00003          BIC      r0,r0,#3
000014  e1a05800          LSL      r5,r0,#16
000018  e1a05825          LSR      r5,r5,#16
;;;380    
;;;381      if(newsize < MIN_SIZE_ALIGNED) {
00001c  e355000c          CMP      r5,#0xc
000020  aa000000          BGE      |L5.40|
;;;382        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;383        newsize = MIN_SIZE_ALIGNED;
000024  e3a0500c          MOV      r5,#0xc
                  |L5.40|
;;;384      }
;;;385    
;;;386      if (newsize > MEM_SIZE_ALIGNED) {
000028  e3550901          CMP      r5,#0x4000
00002c  da000001          BLE      |L5.56|
;;;387        return NULL;
000030  e3a00000          MOV      r0,#0
                  |L5.52|
;;;388      }
;;;389    
;;;390      LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;391       (u8_t *)rmem < (u8_t *)ram_end);
;;;392    
;;;393      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;394        SYS_ARCH_DECL_PROTECT(lev);
;;;395        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
;;;396        /* protect mem stats from concurrent access */
;;;397        SYS_ARCH_PROTECT(lev);
;;;398        MEM_STATS_INC(illegal);
;;;399        SYS_ARCH_UNPROTECT(lev);
;;;400        return rmem;
;;;401      }
;;;402      /* Get the corresponding struct mem ... */
;;;403      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;404      /* ... and its offset pointer */
;;;405      ptr = (mem_size_t)((u8_t *)mem - ram);
;;;406    
;;;407      size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;408      LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
;;;409      if (newsize > size) {
;;;410        /* not supported */
;;;411        return NULL;
;;;412      }
;;;413      if (newsize == size) {
;;;414        /* No change in size, simply return */
;;;415        return rmem;
;;;416      }
;;;417    
;;;418      /* protect the heap from concurrent access */
;;;419      LWIP_MEM_FREE_PROTECT();
;;;420    
;;;421      mem2 = (struct mem *)(void *)&ram[mem->next];
;;;422      if(mem2->used == 0) {
;;;423        /* The next struct is unused, we can simply move it at little */
;;;424        mem_size_t next;
;;;425        /* remember the old next pointer */
;;;426        next = mem2->next;
;;;427        /* create new struct mem which is moved directly after the shrinked mem */
;;;428        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;429        if (lfree == mem2) {
;;;430          lfree = (struct mem *)(void *)&ram[ptr2];
;;;431        }
;;;432        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;433        mem2->used = 0;
;;;434        /* restore the next pointer */
;;;435        mem2->next = next;
;;;436        /* link it back to mem */
;;;437        mem2->prev = ptr;
;;;438        /* link mem to it */
;;;439        mem->next = ptr2;
;;;440        /* last thing to restore linked list: as we have moved mem2,
;;;441         * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
;;;442         * the end of the heap */
;;;443        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;444          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;445        }
;;;446        MEM_STATS_DEC_USED(used, (size - newsize));
;;;447        /* no need to plug holes, we've already done that */
;;;448      } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
;;;449        /* Next struct is used but there's room for another struct mem with
;;;450         * at least MIN_SIZE_ALIGNED of data.
;;;451         * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
;;;452         * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
;;;453         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;454         *       region that couldn't hold data, but when mem->next gets freed,
;;;455         *       the 2 regions would be combined, resulting in more free memory */
;;;456        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;457        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;458        if (mem2 < lfree) {
;;;459          lfree = mem2;
;;;460        }
;;;461        mem2->used = 0;
;;;462        mem2->next = mem->next;
;;;463        mem2->prev = ptr;
;;;464        mem->next = ptr2;
;;;465        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;466          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;467        }
;;;468        MEM_STATS_DEC_USED(used, (size - newsize));
;;;469        /* the original mem->next is used, so no need to plug holes! */
;;;470      }
;;;471      /* else {
;;;472        next struct mem is used but size between mem and mem2 is not big enough
;;;473        to create another struct mem
;;;474        -> don't do anyhting. 
;;;475        -> the remaining space stays unused since it is too small
;;;476      } */
;;;477    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;478      mem_free_count = 1;
;;;479    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;480      LWIP_MEM_FREE_UNPROTECT();
;;;481      return rmem;
;;;482    }
000034  e8bd9ff0          POP      {r4-r12,pc}
                  |L5.56|
000038  e1a00000          MOV      r0,r0                 ;390
00003c  e59f0218          LDR      r0,|L5.604|
000040  e5900000          LDR      r0,[r0,#0]            ;390  ; ram
000044  e1580000          CMP      r8,r0                 ;390
000048  3a000003          BCC      |L5.92|
00004c  e59f020c          LDR      r0,|L5.608|
000050  e5900000          LDR      r0,[r0,#0]            ;390  ; ram_end
000054  e1580000          CMP      r8,r0                 ;390
000058  3a000006          BCC      |L5.120|
                  |L5.92|
00005c  e1a00000          MOV      r0,r0                 ;390
000060  e28f3f7f          ADR      r3,|L5.612|
000064  e59f2214          LDR      r2,|L5.640|
000068  e28f1f85          ADR      r1,|L5.644|
00006c  e28f0f8a          ADR      r0,|L5.668|
000070  ebfffffe          BL       sysprintf
000074  e1a00000          MOV      r0,r0                 ;390
                  |L5.120|
000078  e1a00000          MOV      r0,r0                 ;390
00007c  e59f01d8          LDR      r0,|L5.604|
000080  e5900000          LDR      r0,[r0,#0]            ;393  ; ram
000084  e1580000          CMP      r8,r0                 ;393
000088  3a000003          BCC      |L5.156|
00008c  e59f01cc          LDR      r0,|L5.608|
000090  e5900000          LDR      r0,[r0,#0]            ;393  ; ram_end
000094  e1580000          CMP      r8,r0                 ;393
000098  3a000005          BCC      |L5.180|
                  |L5.156|
00009c  ebfffffe          BL       sys_arch_protect
0000a0  e1a0b000          MOV      r11,r0                ;397
0000a4  e1a0000b          MOV      r0,r11                ;399
0000a8  ebfffffe          BL       sys_arch_unprotect
0000ac  e1a00008          MOV      r0,r8                 ;400
0000b0  eaffffdf          B        |L5.52|
                  |L5.180|
0000b4  e1a00000          MOV      r0,r0                 ;401
0000b8  e2487008          SUB      r7,r8,#8              ;403
0000bc  e59f0198          LDR      r0,|L5.604|
0000c0  e1d000b0          LDRH     r0,[r0,#0]            ;405  ; ram
0000c4  e0470000          SUB      r0,r7,r0              ;405
0000c8  e1a09800          LSL      r9,r0,#16             ;405
0000cc  e1a09829          LSR      r9,r9,#16             ;405
0000d0  e1d700b0          LDRH     r0,[r7,#0]            ;407
0000d4  e0400009          SUB      r0,r0,r9              ;407
0000d8  e2400008          SUB      r0,r0,#8              ;407
0000dc  e1a0a800          LSL      r10,r0,#16            ;407
0000e0  e1a0a82a          LSR      r10,r10,#16           ;407
0000e4  e1a00000          MOV      r0,r0                 ;408
0000e8  e155000a          CMP      r5,r10                ;408
0000ec  da000006          BLE      |L5.268|
0000f0  e1a00000          MOV      r0,r0                 ;408
0000f4  e28f3f5a          ADR      r3,|L5.612|
0000f8  e3a02f66          MOV      r2,#0x198             ;408
0000fc  e28f1d07          ADR      r1,|L5.708|
000100  e28f0f65          ADR      r0,|L5.668|
000104  ebfffffe          BL       sysprintf
000108  e1a00000          MOV      r0,r0                 ;408
                  |L5.268|
00010c  e1a00000          MOV      r0,r0                 ;408
000110  e155000a          CMP      r5,r10                ;409
000114  da000001          BLE      |L5.288|
000118  e3a00000          MOV      r0,#0                 ;411
00011c  eaffffc4          B        |L5.52|
                  |L5.288|
000120  e155000a          CMP      r5,r10                ;413
000124  1a000001          BNE      |L5.304|
000128  e1a00008          MOV      r0,r8                 ;415
00012c  eaffffc0          B        |L5.52|
                  |L5.304|
000130  e3a01000          MOV      r1,#0                 ;419
000134  e59f01a8          LDR      r0,|L5.740|
000138  ebfffffe          BL       sys_arch_sem_wait
00013c  e1d700b0          LDRH     r0,[r7,#0]            ;421
000140  e59f1114          LDR      r1,|L5.604|
000144  e5911000          LDR      r1,[r1,#0]            ;421  ; ram
000148  e0804001          ADD      r4,r0,r1              ;421
00014c  e5d40004          LDRB     r0,[r4,#4]            ;422
000150  e3500000          CMP      r0,#0                 ;422
000154  1a00001e          BNE      |L5.468|
000158  e1d400b0          LDRH     r0,[r4,#0]            ;426
00015c  e2891008          ADD      r1,r9,#8              ;428
000160  e0811005          ADD      r1,r1,r5              ;428
000164  e1a06801          LSL      r6,r1,#16             ;428
000168  e1a06826          LSR      r6,r6,#16             ;428
00016c  e59f1174          LDR      r1,|L5.744|
000170  e5911000          LDR      r1,[r1,#0]            ;429  ; lfree
000174  e1510004          CMP      r1,r4                 ;429
000178  1a000004          BNE      |L5.400|
00017c  e59f10d8          LDR      r1,|L5.604|
000180  e5911000          LDR      r1,[r1,#0]            ;430  ; ram
000184  e0811006          ADD      r1,r1,r6              ;430
000188  e59f2158          LDR      r2,|L5.744|
00018c  e5821000          STR      r1,[r2,#0]            ;430  ; lfree
                  |L5.400|
000190  e59f10c4          LDR      r1,|L5.604|
000194  e5911000          LDR      r1,[r1,#0]            ;432  ; ram
000198  e0814006          ADD      r4,r1,r6              ;432
00019c  e3a01000          MOV      r1,#0                 ;433
0001a0  e5c41004          STRB     r1,[r4,#4]            ;433
0001a4  e1c400b0          STRH     r0,[r4,#0]            ;435
0001a8  e1c490b2          STRH     r9,[r4,#2]            ;437
0001ac  e1c760b0          STRH     r6,[r7,#0]            ;439
0001b0  e1d410b0          LDRH     r1,[r4,#0]            ;443
0001b4  e3510901          CMP      r1,#0x4000            ;443
0001b8  0a000004          BEQ      |L5.464|
0001bc  e1d410b0          LDRH     r1,[r4,#0]            ;444
0001c0  e59f2094          LDR      r2,|L5.604|
0001c4  e5922000          LDR      r2,[r2,#0]            ;444  ; ram
0001c8  e0811002          ADD      r1,r1,r2              ;444
0001cc  e1c160b2          STRH     r6,[r1,#2]            ;444
                  |L5.464|
0001d0  ea00001d          B        |L5.588|
                  |L5.468|
0001d4  e2850014          ADD      r0,r5,#0x14           ;448
0001d8  e150000a          CMP      r0,r10                ;448
0001dc  8a00001a          BHI      |L5.588|
0001e0  e2890008          ADD      r0,r9,#8              ;456
0001e4  e0800005          ADD      r0,r0,r5              ;456
0001e8  e1a06800          LSL      r6,r0,#16             ;456
0001ec  e1a06826          LSR      r6,r6,#16             ;456
0001f0  e59f0064          LDR      r0,|L5.604|
0001f4  e5900000          LDR      r0,[r0,#0]            ;457  ; ram
0001f8  e0804006          ADD      r4,r0,r6              ;457
0001fc  e59f00e4          LDR      r0,|L5.744|
000200  e5900000          LDR      r0,[r0,#0]            ;458  ; lfree
000204  e1540000          CMP      r4,r0                 ;458
000208  2a000001          BCS      |L5.532|
00020c  e59f00d4          LDR      r0,|L5.744|
000210  e5804000          STR      r4,[r0,#0]            ;459  ; lfree
                  |L5.532|
000214  e3a00000          MOV      r0,#0                 ;461
000218  e5c40004          STRB     r0,[r4,#4]            ;461
00021c  e1d700b0          LDRH     r0,[r7,#0]            ;462
000220  e1c400b0          STRH     r0,[r4,#0]            ;462
000224  e1c490b2          STRH     r9,[r4,#2]            ;463
000228  e1c760b0          STRH     r6,[r7,#0]            ;464
00022c  e1d400b0          LDRH     r0,[r4,#0]            ;465
000230  e3500901          CMP      r0,#0x4000            ;465
000234  0a000004          BEQ      |L5.588|
000238  e1d400b0          LDRH     r0,[r4,#0]            ;466
00023c  e59f1018          LDR      r1,|L5.604|
000240  e5911000          LDR      r1,[r1,#0]            ;466  ; ram
000244  e0800001          ADD      r0,r0,r1              ;466
000248  e1c060b2          STRH     r6,[r0,#2]            ;466
                  |L5.588|
00024c  e59f0090          LDR      r0,|L5.740|
000250  ebfffffe          BL       sys_sem_signal
000254  e1a00008          MOV      r0,r8                 ;481
000258  eaffff75          B        |L5.52|
                  |L5.604|
                          DCD      ||ram||
                  |L5.608|
                          DCD      ram_end
                  |L5.612|
000264  6c776970          DCB      "lwip-1.4.1\\src\\core\\mem.c",0
000268  2d312e34
00026c  2e315c73
000270  72635c63
000274  6f72655c
000278  6d656d2e
00027c  6300    
00027e  00                DCB      0
00027f  00                DCB      0
                  |L5.640|
                          DCD      0x00000186
                  |L5.644|
000284  6d656d5f          DCB      "mem_trim: legal memory",0
000288  7472696d
00028c  3a206c65
000290  67616c20
000294  6d656d6f
000298  727900  
00029b  00                DCB      0
                  |L5.668|
00029c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0002a0  7274696f
0002a4  6e202225
0002a8  73222066
0002ac  61696c65
0002b0  64206174
0002b4  206c696e
0002b8  65202564
0002bc  20696e20
0002c0  25730a00
                  |L5.708|
0002c4  6d656d5f          DCB      "mem_trim can only shrink memory",0
0002c8  7472696d
0002cc  2063616e
0002d0  206f6e6c
0002d4  79207368
0002d8  72696e6b
0002dc  206d656d
0002e0  6f727900
                  |L5.740|
                          DCD      mem_mutex
                  |L5.744|
                          DCD      lfree
                          ENDP


                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;235    static void
;;;236    plug_holes(struct mem *mem)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;237    {
000004  e1a04000          MOV      r4,r0
;;;238      struct mem *nmem;
;;;239      struct mem *pmem;
;;;240    
;;;241      LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
000008  e1a00000          MOV      r0,r0
00000c  e59f0198          LDR      r0,|L6.428|
000010  e5900000          LDR      r0,[r0,#0]  ; ram
000014  e1540000          CMP      r4,r0
000018  2a000006          BCS      |L6.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f3f62          ADR      r3,|L6.432|
000024  e3a020f1          MOV      r2,#0xf1
000028  e28f1f67          ADR      r1,|L6.460|
00002c  e28f0e1b          ADR      r0,|L6.484|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L6.56|
000038  e1a00000          MOV      r0,r0
;;;242      LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
00003c  e1a00000          MOV      r0,r0
000040  e59f01c4          LDR      r0,|L6.524|
000044  e5900000          LDR      r0,[r0,#0]  ; ram_end
000048  e1540000          CMP      r4,r0
00004c  3a000006          BCC      |L6.108|
000050  e1a00000          MOV      r0,r0
000054  e28f3f55          ADR      r3,|L6.432|
000058  e3a020f2          MOV      r2,#0xf2
00005c  e28f1f6b          ADR      r1,|L6.528|
000060  e28f0f5f          ADR      r0,|L6.484|
000064  ebfffffe          BL       sysprintf
000068  e1a00000          MOV      r0,r0
                  |L6.108|
00006c  e1a00000          MOV      r0,r0
;;;243      LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
000070  e1a00000          MOV      r0,r0
000074  e5d40004          LDRB     r0,[r4,#4]
000078  e3500000          CMP      r0,#0
00007c  0a000006          BEQ      |L6.156|
000080  e1a00000          MOV      r0,r0
000084  e28f3f49          ADR      r3,|L6.432|
000088  e3a020f3          MOV      r2,#0xf3
00008c  e28f1f66          ADR      r1,|L6.556|
000090  e28f0f53          ADR      r0,|L6.484|
000094  ebfffffe          BL       sysprintf
000098  e1a00000          MOV      r0,r0
                  |L6.156|
00009c  e1a00000          MOV      r0,r0
;;;244    
;;;245      /* plug hole forward */
;;;246      LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
0000a0  e1a00000          MOV      r0,r0
0000a4  e1d400b0          LDRH     r0,[r4,#0]
0000a8  e3500901          CMP      r0,#0x4000
0000ac  da000006          BLE      |L6.204|
0000b0  e1a00000          MOV      r0,r0
0000b4  e28f30f4          ADR      r3,|L6.432|
0000b8  e3a020f6          MOV      r2,#0xf6
0000bc  e28f1f61          ADR      r1,|L6.584|
0000c0  e28f0f47          ADR      r0,|L6.484|
0000c4  ebfffffe          BL       sysprintf
0000c8  e1a00000          MOV      r0,r0
                  |L6.204|
0000cc  e1a00000          MOV      r0,r0
;;;247    
;;;248      nmem = (struct mem *)(void *)&ram[mem->next];
0000d0  e1d400b0          LDRH     r0,[r4,#0]
0000d4  e59f10d0          LDR      r1,|L6.428|
0000d8  e5911000          LDR      r1,[r1,#0]  ; ram
0000dc  e0805001          ADD      r5,r0,r1
;;;249      if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
0000e0  e1540005          CMP      r4,r5
0000e4  0a000016          BEQ      |L6.324|
0000e8  e5d50004          LDRB     r0,[r5,#4]
0000ec  e3500000          CMP      r0,#0
0000f0  1a000013          BNE      |L6.324|
0000f4  e59f0110          LDR      r0,|L6.524|
0000f8  e5900000          LDR      r0,[r0,#0]  ; ram_end
0000fc  e1550000          CMP      r5,r0
000100  0a00000f          BEQ      |L6.324|
;;;250        /* if mem->next is unused and not end of ram, combine mem and mem->next */
;;;251        if (lfree == nmem) {
000104  e59f0168          LDR      r0,|L6.628|
000108  e5900000          LDR      r0,[r0,#0]  ; lfree
00010c  e1500005          CMP      r0,r5
000110  1a000001          BNE      |L6.284|
;;;252          lfree = mem;
000114  e59f0158          LDR      r0,|L6.628|
000118  e5804000          STR      r4,[r0,#0]  ; lfree
                  |L6.284|
;;;253        }
;;;254        mem->next = nmem->next;
00011c  e1d500b0          LDRH     r0,[r5,#0]
000120  e1c400b0          STRH     r0,[r4,#0]
;;;255        ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
000124  e59f0080          LDR      r0,|L6.428|
000128  e1d000b0          LDRH     r0,[r0,#0]  ; ram
00012c  e0440000          SUB      r0,r4,r0
000130  e1d510b0          LDRH     r1,[r5,#0]
000134  e59f2070          LDR      r2,|L6.428|
000138  e5922000          LDR      r2,[r2,#0]  ; ram
00013c  e0811002          ADD      r1,r1,r2
000140  e1c100b2          STRH     r0,[r1,#2]
                  |L6.324|
;;;256      }
;;;257    
;;;258      /* plug hole backward */
;;;259      pmem = (struct mem *)(void *)&ram[mem->prev];
000144  e1d400b2          LDRH     r0,[r4,#2]
000148  e59f105c          LDR      r1,|L6.428|
00014c  e5911000          LDR      r1,[r1,#0]  ; ram
000150  e0806001          ADD      r6,r0,r1
;;;260      if (pmem != mem && pmem->used == 0) {
000154  e1560004          CMP      r6,r4
000158  0a000012          BEQ      |L6.424|
00015c  e5d60004          LDRB     r0,[r6,#4]
000160  e3500000          CMP      r0,#0
000164  1a00000f          BNE      |L6.424|
;;;261        /* if mem->prev is unused, combine mem and mem->prev */
;;;262        if (lfree == mem) {
000168  e59f0104          LDR      r0,|L6.628|
00016c  e5900000          LDR      r0,[r0,#0]  ; lfree
000170  e1500004          CMP      r0,r4
000174  1a000001          BNE      |L6.384|
;;;263          lfree = pmem;
000178  e59f00f4          LDR      r0,|L6.628|
00017c  e5806000          STR      r6,[r0,#0]  ; lfree
                  |L6.384|
;;;264        }
;;;265        pmem->next = mem->next;
000180  e1d400b0          LDRH     r0,[r4,#0]
000184  e1c600b0          STRH     r0,[r6,#0]
;;;266        ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
000188  e59f001c          LDR      r0,|L6.428|
00018c  e1d000b0          LDRH     r0,[r0,#0]  ; ram
000190  e0460000          SUB      r0,r6,r0
000194  e1d410b0          LDRH     r1,[r4,#0]
000198  e59f200c          LDR      r2,|L6.428|
00019c  e5922000          LDR      r2,[r2,#0]  ; ram
0001a0  e0811002          ADD      r1,r1,r2
0001a4  e1c100b2          STRH     r0,[r1,#2]
                  |L6.424|
;;;267      }
;;;268    }
0001a8  e8bd8070          POP      {r4-r6,pc}
;;;269    
                          ENDP

                  |L6.428|
                          DCD      ||ram||
                  |L6.432|
0001b0  6c776970          DCB      "lwip-1.4.1\\src\\core\\mem.c",0
0001b4  2d312e34
0001b8  2e315c73
0001bc  72635c63
0001c0  6f72655c
0001c4  6d656d2e
0001c8  6300    
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L6.460|
0001cc  706c7567          DCB      "plug_holes: mem >= ram",0
0001d0  5f686f6c
0001d4  65733a20
0001d8  6d656d20
0001dc  3e3d2072
0001e0  616d00  
0001e3  00                DCB      0
                  |L6.484|
0001e4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001e8  7274696f
0001ec  6e202225
0001f0  73222066
0001f4  61696c65
0001f8  64206174
0001fc  206c696e
000200  65202564
000204  20696e20
000208  25730a00
                  |L6.524|
                          DCD      ram_end
                  |L6.528|
000210  706c7567          DCB      "plug_holes: mem < ram_end",0
000214  5f686f6c
000218  65733a20
00021c  6d656d20
000220  3c207261
000224  6d5f656e
000228  6400    
00022a  00                DCB      0
00022b  00                DCB      0
                  |L6.556|
00022c  706c7567          DCB      "plug_holes: mem->used == 0",0
000230  5f686f6c
000234  65733a20
000238  6d656d2d
00023c  3e757365
000240  64203d3d
000244  203000  
000247  00                DCB      0
                  |L6.584|
000248  706c7567          DCB      "plug_holes: mem->next <= MEM_SIZE_ALIGNED",0
00024c  5f686f6c
000250  65733a20
000254  6d656d2d
000258  3e6e6578
00025c  74203c3d
000260  204d454d
000264  5f53495a
000268  455f414c
00026c  49474e45
000270  4400    
000272  00                DCB      0
000273  00                DCB      0
                  |L6.628|
                          DCD      lfree

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ram_heap
                          %        16404

                          AREA ||.data||, DATA, ALIGN=2

                  ||ram||
                          DCD      0x00000000
                  ram_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
                  mem_mutex
                          DCD      0x00000000
