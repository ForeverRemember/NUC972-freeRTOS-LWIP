; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\mem.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\mem.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\mem.crf lwip-1.4.1\src\core\mem.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;235    static void
;;;236    plug_holes(struct mem *mem)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;237    {
;;;238      struct mem *nmem;
;;;239      struct mem *pmem;
;;;240    
;;;241      LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
000004  e59f51d0          LDR      r5,|L1.476|
000008  e1a04000          MOV      r4,r0                 ;237
00000c  e5950000          LDR      r0,[r5,#0]  ; ram
000010  e1540000          CMP      r4,r0
000014  2a000004          BCS      |L1.44|
000018  e28f3d07          ADR      r3,|L1.480|
00001c  e3a020f1          MOV      r2,#0xf1
000020  e28f1f75          ADR      r1,|L1.508|
000024  e28f0f7a          ADR      r0,|L1.532|
000028  ebfffffe          BL       sysprintf
                  |L1.44|
;;;242      LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
00002c  e5950004          LDR      r0,[r5,#4]  ; ram_end
000030  e1540000          CMP      r4,r0
000034  3a000004          BCC      |L1.76|
000038  e28f3e1a          ADR      r3,|L1.480|
00003c  e3a020f2          MOV      r2,#0xf2
000040  e28f1f7d          ADR      r1,|L1.572|
000044  e28f0f72          ADR      r0,|L1.532|
000048  ebfffffe          BL       sysprintf
                  |L1.76|
;;;243      LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
00004c  e5d40004          LDRB     r0,[r4,#4]
000050  e3500000          CMP      r0,#0
000054  0a000004          BEQ      |L1.108|
000058  e28f3d06          ADR      r3,|L1.480|
00005c  e3a020f3          MOV      r2,#0xf3
000060  e28f1e1f          ADR      r1,|L1.600|
000064  e28f0f6a          ADR      r0,|L1.532|
000068  ebfffffe          BL       sysprintf
                  |L1.108|
;;;244    
;;;245      /* plug hole forward */
;;;246      LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
00006c  e1d400b0          LDRH     r0,[r4,#0]
000070  e3500901          CMP      r0,#0x4000
000074  9a000004          BLS      |L1.140|
000078  e28f3e16          ADR      r3,|L1.480|
00007c  e3a020f6          MOV      r2,#0xf6
000080  e28f1f7b          ADR      r1,|L1.628|
000084  e28f0f62          ADR      r0,|L1.532|
000088  ebfffffe          BL       sysprintf
                  |L1.140|
;;;247    
;;;248      nmem = (struct mem *)(void *)&ram[mem->next];
00008c  e1d400b0          LDRH     r0,[r4,#0]
000090  e5951000          LDR      r1,[r5,#0]  ; ram
000094  e0800001          ADD      r0,r0,r1
;;;249      if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
000098  e1540000          CMP      r4,r0
00009c  0a00000e          BEQ      |L1.220|
0000a0  e5d02004          LDRB     r2,[r0,#4]
0000a4  e3520000          CMP      r2,#0
0000a8  1a00000b          BNE      |L1.220|
0000ac  e5952004          LDR      r2,[r5,#4]  ; ram_end
0000b0  e1500002          CMP      r0,r2
0000b4  0a000008          BEQ      |L1.220|
;;;250        /* if mem->next is unused and not end of ram, combine mem and mem->next */
;;;251        if (lfree == nmem) {
0000b8  e5952008          LDR      r2,[r5,#8]  ; lfree
0000bc  e1520000          CMP      r2,r0
;;;252          lfree = mem;
0000c0  05854008          STREQ    r4,[r5,#8]  ; lfree
;;;253        }
;;;254        mem->next = nmem->next;
0000c4  e1d020b0          LDRH     r2,[r0,#0]
0000c8  e1c420b0          STRH     r2,[r4,#0]
;;;255        ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
0000cc  e1d000b0          LDRH     r0,[r0,#0]
0000d0  e0442001          SUB      r2,r4,r1
0000d4  e0800001          ADD      r0,r0,r1
0000d8  e1c020b2          STRH     r2,[r0,#2]
                  |L1.220|
;;;256      }
;;;257    
;;;258      /* plug hole backward */
;;;259      pmem = (struct mem *)(void *)&ram[mem->prev];
0000dc  e1d400b2          LDRH     r0,[r4,#2]
0000e0  e0800001          ADD      r0,r0,r1
;;;260      if (pmem != mem && pmem->used == 0) {
0000e4  e1500004          CMP      r0,r4
;;;261        /* if mem->prev is unused, combine mem and mem->prev */
;;;262        if (lfree == mem) {
;;;263          lfree = pmem;
;;;264        }
;;;265        pmem->next = mem->next;
;;;266        ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
;;;267      }
;;;268    }
0000e8  08bd8070          POPEQ    {r4-r6,pc}
0000ec  e5d02004          LDRB     r2,[r0,#4]            ;260
0000f0  e3520000          CMP      r2,#0                 ;260
0000f4  18bd8070          POPNE    {r4-r6,pc}
0000f8  e5952008          LDR      r2,[r5,#8]            ;262  ; lfree
0000fc  e1520004          CMP      r2,r4                 ;262
000100  05850008          STREQ    r0,[r5,#8]            ;263  ; lfree
000104  e1d420b0          LDRH     r2,[r4,#0]            ;265
000108  e1c020b0          STRH     r2,[r0,#0]            ;265
00010c  e1d420b0          LDRH     r2,[r4,#0]            ;266
000110  e0400001          SUB      r0,r0,r1              ;266
000114  e0811002          ADD      r1,r1,r2              ;266
000118  e1c100b2          STRH     r0,[r1,#2]            ;266
00011c  e8bd8070          POP      {r4-r6,pc}
;;;269    
                          ENDP

                  mem_init PROC
;;;273    void
;;;274    mem_init(void)
000120  e59f0178          LDR      r0,|L1.672|
;;;275    {
;;;276      struct mem *mem;
;;;277    
;;;278      LWIP_ASSERT("Sanity check alignment",
;;;279        (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
;;;280    
;;;281      /* align the heap */
;;;282      ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
000124  e59f20b0          LDR      r2,|L1.476|
000128  e3c00003          BIC      r0,r0,#3
;;;283      /* initialize the start of the heap */
;;;284      mem = (struct mem *)(void *)ram;
;;;285      mem->next = MEM_SIZE_ALIGNED;
00012c  e3a03901          MOV      r3,#0x4000
000130  e5820000          STR      r0,[r2,#0]  ; ram
;;;286      mem->prev = 0;
000134  e3a01000          MOV      r1,#0
000138  e1c030b0          STRH     r3,[r0,#0]            ;285
00013c  e1c010b2          STRH     r1,[r0,#2]
;;;287      mem->used = 0;
000140  e5c01004          STRB     r1,[r0,#4]
;;;288      /* initialize the end of the heap */
;;;289      ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
000144  e2801901          ADD      r1,r0,#0x4000
;;;290      ram_end->used = 1;
000148  e3a0c001          MOV      r12,#1
00014c  e5821004          STR      r1,[r2,#4]  ; ram_end
000150  e5c1c004          STRB     r12,[r1,#4]
;;;291      ram_end->next = MEM_SIZE_ALIGNED;
000154  e1c130b0          STRH     r3,[r1,#0]
;;;292      ram_end->prev = MEM_SIZE_ALIGNED;
000158  e1c130b2          STRH     r3,[r1,#2]
;;;293    
;;;294      /* initialize the lowest-free pointer to the start of the heap */
;;;295      lfree = (struct mem *)(void *)ram;
00015c  e5820008          STR      r0,[r2,#8]  ; lfree
;;;296    
;;;297      MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
;;;298    
;;;299      if(sys_mutex_new(&mem_mutex) != ERR_OK) {
;;;300        LWIP_ASSERT("failed to create mem_mutex", 0);
;;;301      }
;;;302    }
000160  e12fff1e          BX       lr
;;;303    
                          ENDP

                  mem_free PROC
;;;310    void
;;;311    mem_free(void *rmem)
000164  e92d4070          PUSH     {r4-r6,lr}
;;;312    {
000168  e1b04000          MOVS     r4,r0
;;;313      struct mem *mem;
;;;314      LWIP_MEM_FREE_DECL_PROTECT();
;;;315    
;;;316      if (rmem == NULL) {
;;;317        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
;;;318        return;
;;;319      }
;;;320      LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
;;;321    
;;;322      LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;323        (u8_t *)rmem < (u8_t *)ram_end);
;;;324    
;;;325      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;326        SYS_ARCH_DECL_PROTECT(lev);
;;;327        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
;;;328        /* protect mem stats from concurrent access */
;;;329        SYS_ARCH_PROTECT(lev);
;;;330        MEM_STATS_INC(illegal);
;;;331        SYS_ARCH_UNPROTECT(lev);
;;;332        return;
;;;333      }
;;;334      /* protect the heap from concurrent access */
;;;335      LWIP_MEM_FREE_PROTECT();
;;;336      /* Get the corresponding struct mem ... */
;;;337      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;338      /* ... which has to be in a used state ... */
;;;339      LWIP_ASSERT("mem_free: mem->used", mem->used);
;;;340      /* ... and is now unused. */
;;;341      mem->used = 0;
;;;342    
;;;343      if (mem < lfree) {
;;;344        /* the newly freed struct is now the lowest */
;;;345        lfree = mem;
;;;346      }
;;;347    
;;;348      MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
;;;349    
;;;350      /* finally, see if prev or next are free also */
;;;351      plug_holes(mem);
;;;352    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;353      mem_free_count = 1;
;;;354    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;355      LWIP_MEM_FREE_UNPROTECT();
;;;356    }
00016c  08bd8070          POPEQ    {r4-r6,pc}
000170  e3140003          TST      r4,#3                 ;320
000174  0a000004          BEQ      |L1.396|
000178  e28f3060          ADR      r3,|L1.480|
00017c  e3a02d05          MOV      r2,#0x140             ;320
000180  e28f1f47          ADR      r1,|L1.676|
000184  e28f0088          ADR      r0,|L1.532|
000188  ebfffffe          BL       sysprintf
                  |L1.396|
00018c  e59f5048          LDR      r5,|L1.476|
000190  e5950000          LDR      r0,[r5,#0]            ;322  ; ram
000194  e1540000          CMP      r4,r0                 ;322
000198  3a000002          BCC      |L1.424|
00019c  e5950004          LDR      r0,[r5,#4]            ;322  ; ram_end
0001a0  e1540000          CMP      r4,r0                 ;322
0001a4  3a000004          BCC      |L1.444|
                  |L1.424|
0001a8  e59f2118          LDR      r2,|L1.712|
0001ac  e28f302c          ADR      r3,|L1.480|
0001b0  e28f1f45          ADR      r1,|L1.716|
0001b4  e28f0058          ADR      r0,|L1.532|
0001b8  ebfffffe          BL       sysprintf
                  |L1.444|
0001bc  e5950000          LDR      r0,[r5,#0]            ;325  ; ram
0001c0  e1540000          CMP      r4,r0                 ;325
0001c4  25950004          LDRCS    r0,[r5,#4]            ;325  ; ram_end
0001c8  21500004          CMPCS    r0,r4                 ;325
0001cc  8a000044          BHI      |L1.740|
0001d0  ebfffffe          BL       sys_arch_protect
0001d4  e8bd4070          POP      {r4-r6,lr}            ;331
0001d8  eafffffe          B        sys_arch_unprotect
                  |L1.476|
                          DCD      ||.data||
                  |L1.480|
0001e0  6c776970          DCB      "lwip-1.4.1\\src\\core\\mem.c",0
0001e4  2d312e34
0001e8  2e315c73
0001ec  72635c63
0001f0  6f72655c
0001f4  6d656d2e
0001f8  6300    
0001fa  00                DCB      0
0001fb  00                DCB      0
                  |L1.508|
0001fc  706c7567          DCB      "plug_holes: mem >= ram",0
000200  5f686f6c
000204  65733a20
000208  6d656d20
00020c  3e3d2072
000210  616d00  
000213  00                DCB      0
                  |L1.532|
000214  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000218  7274696f
00021c  6e202225
000220  73222066
000224  61696c65
000228  64206174
00022c  206c696e
000230  65202564
000234  20696e20
000238  25730a00
                  |L1.572|
00023c  706c7567          DCB      "plug_holes: mem < ram_end",0
000240  5f686f6c
000244  65733a20
000248  6d656d20
00024c  3c207261
000250  6d5f656e
000254  6400    
000256  00                DCB      0
000257  00                DCB      0
                  |L1.600|
000258  706c7567          DCB      "plug_holes: mem->used == 0",0
00025c  5f686f6c
000260  65733a20
000264  6d656d2d
000268  3e757365
00026c  64203d3d
000270  203000  
000273  00                DCB      0
                  |L1.628|
000274  706c7567          DCB      "plug_holes: mem->next <= MEM_SIZE_ALIGNED",0
000278  5f686f6c
00027c  65733a20
000280  6d656d2d
000284  3e6e6578
000288  74203c3d
00028c  204d454d
000290  5f53495a
000294  455f414c
000298  49474e45
00029c  4400    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L1.672|
                          DCD      ||.bss||+0x3
                  |L1.676|
0002a4  6d656d5f          DCB      "mem_free: sanity check alignment",0
0002a8  66726565
0002ac  3a207361
0002b0  6e697479
0002b4  20636865
0002b8  636b2061
0002bc  6c69676e
0002c0  6d656e74
0002c4  00      
0002c5  00                DCB      0
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L1.712|
                          DCD      0x00000142
                  |L1.716|
0002cc  6d656d5f          DCB      "mem_free: legal memory",0
0002d0  66726565
0002d4  3a206c65
0002d8  67616c20
0002dc  6d656d6f
0002e0  727900  
0002e3  00                DCB      0
                  |L1.740|
0002e4  e5540004          LDRB     r0,[r4,#-4]           ;339
0002e8  e2444008          SUB      r4,r4,#8              ;339
0002ec  e3500000          CMP      r0,#0                 ;339
0002f0  1a000004          BNE      |L1.776|
0002f4  e59f2310          LDR      r2,|L1.1548|
0002f8  e24f3e12          ADR      r3,|L1.480|
0002fc  e28f1fc3          ADR      r1,|L1.1552|
000300  e24f00f4          ADR      r0,|L1.532|
000304  ebfffffe          BL       sysprintf
                  |L1.776|
000308  e3a00000          MOV      r0,#0                 ;341
00030c  e5c40004          STRB     r0,[r4,#4]            ;341
000310  e5950008          LDR      r0,[r5,#8]            ;343  ; lfree
000314  e1540000          CMP      r4,r0                 ;343
000318  e1a00004          MOV      r0,r4                 ;351
00031c  35854008          STRCC    r4,[r5,#8]            ;345  ; lfree
000320  e8bd4070          POP      {r4-r6,lr}            ;351
000324  eafffffe          B        plug_holes
;;;357    
                          ENDP

                  mem_trim PROC
;;;368    void *
;;;369    mem_trim(void *rmem, mem_size_t newsize)
000328  e92d47f0          PUSH     {r4-r10,lr}
;;;370    {
00032c  e1a07000          MOV      r7,r0
;;;371      mem_size_t size;
;;;372      mem_size_t ptr, ptr2;
;;;373      struct mem *mem, *mem2;
;;;374      /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
;;;375      LWIP_MEM_FREE_DECL_PROTECT();
;;;376    
;;;377      /* Expand the size of the allocated memory region so that we can
;;;378         adjust for alignment. */
;;;379      newsize = LWIP_MEM_ALIGN_SIZE(newsize);
000330  e2810003          ADD      r0,r1,#3
000334  e3c04801          BIC      r4,r0,#0x10000
000338  e3c44003          BIC      r4,r4,#3
;;;380    
;;;381      if(newsize < MIN_SIZE_ALIGNED) {
00033c  e354000c          CMP      r4,#0xc
;;;382        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;383        newsize = MIN_SIZE_ALIGNED;
000340  33a0400c          MOVCC    r4,#0xc
;;;384      }
;;;385    
;;;386      if (newsize > MEM_SIZE_ALIGNED) {
000344  23540901          CMPCS    r4,#0x4000
000348  8a000025          BHI      |L1.996|
;;;387        return NULL;
;;;388      }
;;;389    
;;;390      LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
00034c  e51f8178          LDR      r8,|L1.476|
000350  e5980000          LDR      r0,[r8,#0]  ; ram
000354  e1500007          CMP      r0,r7
000358  8a000002          BHI      |L1.872|
00035c  e5980004          LDR      r0,[r8,#4]  ; ram_end
000360  e1500007          CMP      r0,r7
000364  8a000004          BHI      |L1.892|
                  |L1.872|
000368  e59f22b4          LDR      r2,|L1.1572|
00036c  e24f3f65          ADR      r3,|L1.480|
000370  e28f1e2b          ADR      r1,|L1.1576|
000374  e24f0f5a          ADR      r0,|L1.532|
000378  ebfffffe          BL       sysprintf
                  |L1.892|
;;;391       (u8_t *)rmem < (u8_t *)ram_end);
;;;392    
;;;393      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
00037c  e5980000          LDR      r0,[r8,#0]  ; ram
000380  e1570000          CMP      r7,r0
000384  25981004          LDRCS    r1,[r8,#4]  ; ram_end
000388  21510007          CMPCS    r1,r7
00038c  8a000002          BHI      |L1.924|
;;;394        SYS_ARCH_DECL_PROTECT(lev);
;;;395        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
;;;396        /* protect mem stats from concurrent access */
;;;397        SYS_ARCH_PROTECT(lev);
000390  ebfffffe          BL       sys_arch_protect
;;;398        MEM_STATS_INC(illegal);
;;;399        SYS_ARCH_UNPROTECT(lev);
000394  ebfffffe          BL       sys_arch_unprotect
;;;400        return rmem;
000398  ea00002e          B        |L1.1112|
                  |L1.924|
;;;401      }
;;;402      /* Get the corresponding struct mem ... */
;;;403      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
00039c  e2475008          SUB      r5,r7,#8
;;;404      /* ... and its offset pointer */
;;;405      ptr = (mem_size_t)((u8_t *)mem - ram);
0003a0  e0450000          SUB      r0,r5,r0
0003a4  e1a06800          LSL      r6,r0,#16
;;;406    
;;;407      size = mem->next - ptr - SIZEOF_STRUCT_MEM;
0003a8  e15700b8          LDRH     r0,[r7,#-8]
0003ac  e1a06826          LSR      r6,r6,#16             ;405
0003b0  e0400006          SUB      r0,r0,r6
0003b4  e2400008          SUB      r0,r0,#8
0003b8  e1a09800          LSL      r9,r0,#16
0003bc  e1a09829          LSR      r9,r9,#16
;;;408      LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
0003c0  e1540009          CMP      r4,r9
0003c4  9a000004          BLS      |L1.988|
0003c8  e24f3e1f          ADR      r3,|L1.480|
0003cc  e3a02f66          MOV      r2,#0x198
0003d0  e28f1f9a          ADR      r1,|L1.1600|
0003d4  e24f0f72          ADR      r0,|L1.532|
0003d8  ebfffffe          BL       sysprintf
                  |L1.988|
;;;409      if (newsize > size) {
0003dc  e1540009          CMP      r4,r9
0003e0  9a000001          BLS      |L1.1004|
                  |L1.996|
;;;410        /* not supported */
;;;411        return NULL;
0003e4  e3a00000          MOV      r0,#0
;;;412      }
;;;413      if (newsize == size) {
;;;414        /* No change in size, simply return */
;;;415        return rmem;
;;;416      }
;;;417    
;;;418      /* protect the heap from concurrent access */
;;;419      LWIP_MEM_FREE_PROTECT();
;;;420    
;;;421      mem2 = (struct mem *)(void *)&ram[mem->next];
;;;422      if(mem2->used == 0) {
;;;423        /* The next struct is unused, we can simply move it at little */
;;;424        mem_size_t next;
;;;425        /* remember the old next pointer */
;;;426        next = mem2->next;
;;;427        /* create new struct mem which is moved directly after the shrinked mem */
;;;428        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;429        if (lfree == mem2) {
;;;430          lfree = (struct mem *)(void *)&ram[ptr2];
;;;431        }
;;;432        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;433        mem2->used = 0;
;;;434        /* restore the next pointer */
;;;435        mem2->next = next;
;;;436        /* link it back to mem */
;;;437        mem2->prev = ptr;
;;;438        /* link mem to it */
;;;439        mem->next = ptr2;
;;;440        /* last thing to restore linked list: as we have moved mem2,
;;;441         * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
;;;442         * the end of the heap */
;;;443        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;444          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;445        }
;;;446        MEM_STATS_DEC_USED(used, (size - newsize));
;;;447        /* no need to plug holes, we've already done that */
;;;448      } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
;;;449        /* Next struct is used but there's room for another struct mem with
;;;450         * at least MIN_SIZE_ALIGNED of data.
;;;451         * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
;;;452         * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
;;;453         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;454         *       region that couldn't hold data, but when mem->next gets freed,
;;;455         *       the 2 regions would be combined, resulting in more free memory */
;;;456        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;457        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;458        if (mem2 < lfree) {
;;;459          lfree = mem2;
;;;460        }
;;;461        mem2->used = 0;
;;;462        mem2->next = mem->next;
;;;463        mem2->prev = ptr;
;;;464        mem->next = ptr2;
;;;465        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;466          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;467        }
;;;468        MEM_STATS_DEC_USED(used, (size - newsize));
;;;469        /* the original mem->next is used, so no need to plug holes! */
;;;470      }
;;;471      /* else {
;;;472        next struct mem is used but size between mem and mem2 is not big enough
;;;473        to create another struct mem
;;;474        -> don't do anyhting. 
;;;475        -> the remaining space stays unused since it is too small
;;;476      } */
;;;477    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;478      mem_free_count = 1;
;;;479    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;480      LWIP_MEM_FREE_UNPROTECT();
;;;481      return rmem;
;;;482    }
0003e8  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1004|
0003ec  0a000019          BEQ      |L1.1112|
0003f0  e1d500b0          LDRH     r0,[r5,#0]            ;421
0003f4  e5982000          LDR      r2,[r8,#0]            ;421  ; ram
0003f8  e3a0c000          MOV      r12,#0                ;422
0003fc  e0801002          ADD      r1,r0,r2              ;421
000400  e5d10004          LDRB     r0,[r1,#4]            ;422
000404  e3500000          CMP      r0,#0                 ;422
000408  0a000014          BEQ      |L1.1120|
00040c  e2840014          ADD      r0,r4,#0x14           ;448
000410  e1500009          CMP      r0,r9                 ;448
000414  8a00000f          BHI      |L1.1112|
000418  e0860004          ADD      r0,r6,r4              ;456
00041c  e2800008          ADD      r0,r0,#8              ;456
000420  e5983008          LDR      r3,[r8,#8]            ;458  ; lfree
000424  e3c00803          BIC      r0,r0,#0x30000        ;456
000428  e0821000          ADD      r1,r2,r0              ;457
00042c  e1510003          CMP      r1,r3                 ;458
000430  35881008          STRCC    r1,[r8,#8]            ;459  ; lfree
000434  e5c1c004          STRB     r12,[r1,#4]           ;461
000438  e1d530b0          LDRH     r3,[r5,#0]            ;462
                  |L1.1084|
00043c  e1c130b0          STRH     r3,[r1,#0]            ;435
000440  e1c160b2          STRH     r6,[r1,#2]            ;437
000444  e1c500b0          STRH     r0,[r5,#0]            ;439
000448  e1d110b0          LDRH     r1,[r1,#0]            ;443
00044c  e3510901          CMP      r1,#0x4000            ;443
000450  10811002          ADDNE    r1,r1,r2              ;444
000454  11c100b2          STRHNE   r0,[r1,#2]            ;444
                  |L1.1112|
000458  e1a00007          MOV      r0,r7                 ;481
00045c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1120|
000460  e0860004          ADD      r0,r6,r4              ;428
000464  e5984008          LDR      r4,[r8,#8]            ;429  ; lfree
000468  e2800008          ADD      r0,r0,#8              ;428
00046c  e1d130b0          LDRH     r3,[r1,#0]            ;426
000470  e1540001          CMP      r4,r1                 ;429
000474  e3c00803          BIC      r0,r0,#0x30000        ;428
000478  00821000          ADDEQ    r1,r2,r0              ;430
00047c  05881008          STREQ    r1,[r8,#8]            ;430  ; lfree
000480  e0821000          ADD      r1,r2,r0              ;432
000484  e5c1c004          STRB     r12,[r1,#4]           ;433
000488  eaffffeb          B        |L1.1084|
;;;483    
                          ENDP

                  mem_malloc PROC
;;;493    void *
;;;494    mem_malloc(mem_size_t size)
00048c  e92d41f0          PUSH     {r4-r8,lr}
;;;495    {
;;;496      mem_size_t ptr, ptr2;
;;;497      struct mem *mem, *mem2;
;;;498    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;499      u8_t local_mem_free_count = 0;
;;;500    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;501      LWIP_MEM_ALLOC_DECL_PROTECT();
;;;502    
;;;503      if (size == 0) {
000490  e3500000          CMP      r0,#0
;;;504        return NULL;
;;;505      }
;;;506    
;;;507      /* Expand the size of the allocated memory region so that we can
;;;508         adjust for alignment. */
;;;509      size = LWIP_MEM_ALIGN_SIZE(size);
;;;510    
;;;511      if(size < MIN_SIZE_ALIGNED) {
;;;512        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;513        size = MIN_SIZE_ALIGNED;
;;;514      }
;;;515    
;;;516      if (size > MEM_SIZE_ALIGNED) {
;;;517        return NULL;
;;;518      }
;;;519    
;;;520      /* protect the heap from concurrent access */
;;;521      sys_mutex_lock(&mem_mutex);
;;;522      LWIP_MEM_ALLOC_PROTECT();
;;;523    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;524      /* run as long as a mem_free disturbed mem_malloc or mem_trim */
;;;525      do {
;;;526        local_mem_free_count = 0;
;;;527    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;528    
;;;529        /* Scan through the heap searching for a free block that is big enough,
;;;530         * beginning with the lowest free block.
;;;531         */
;;;532        for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
;;;533             ptr = ((struct mem *)(void *)&ram[ptr])->next) {
;;;534          mem = (struct mem *)(void *)&ram[ptr];
;;;535    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;536          mem_free_count = 0;
;;;537          LWIP_MEM_ALLOC_UNPROTECT();
;;;538          /* allow mem_free or mem_trim to run */
;;;539          LWIP_MEM_ALLOC_PROTECT();
;;;540          if (mem_free_count != 0) {
;;;541            /* If mem_free or mem_trim have run, we have to restart since they
;;;542               could have altered our current struct mem. */
;;;543            local_mem_free_count = 1;
;;;544            break;
;;;545          }
;;;546    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;547    
;;;548          if ((!mem->used) &&
;;;549              (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
;;;550            /* mem is not used and at least perfect fit is possible:
;;;551             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;552    
;;;553            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
;;;554              /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
;;;555               * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;556               * -> split large block, create empty remainder,
;;;557               * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;558               * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;559               * struct mem would fit in but no data between mem2 and mem2->next
;;;560               * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;561               *       region that couldn't hold data, but when mem->next gets freed,
;;;562               *       the 2 regions would be combined, resulting in more free memory
;;;563               */
;;;564              ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;565              /* create mem2 struct */
;;;566              mem2 = (struct mem *)(void *)&ram[ptr2];
;;;567              mem2->used = 0;
;;;568              mem2->next = mem->next;
;;;569              mem2->prev = ptr;
;;;570              /* and insert it between mem and mem->next */
;;;571              mem->next = ptr2;
;;;572              mem->used = 1;
;;;573    
;;;574              if (mem2->next != MEM_SIZE_ALIGNED) {
;;;575                ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;576              }
;;;577              MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
;;;578            } else {
;;;579              /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;580               * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;581               * take care of this).
;;;582               * -> near fit or excact fit: do not split, no mem2 creation
;;;583               * also can't move mem->next directly behind mem, since mem->next
;;;584               * will always be used at this point!
;;;585               */
;;;586              mem->used = 1;
;;;587              MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
;;;588            }
;;;589    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;590    mem_malloc_adjust_lfree:
;;;591    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;592            if (mem == lfree) {
;;;593              struct mem *cur = lfree;
;;;594              /* Find next free block after mem and update lowest free pointer */
;;;595              while (cur->used && cur != ram_end) {
;;;596    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;597                mem_free_count = 0;
;;;598                LWIP_MEM_ALLOC_UNPROTECT();
;;;599                /* prevent high interrupt latency... */
;;;600                LWIP_MEM_ALLOC_PROTECT();
;;;601                if (mem_free_count != 0) {
;;;602                  /* If mem_free or mem_trim have run, we have to restart since they
;;;603                     could have altered our current struct mem or lfree. */
;;;604                  goto mem_malloc_adjust_lfree;
;;;605                }
;;;606    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;607                cur = (struct mem *)(void *)&ram[cur->next];
;;;608              }
;;;609              lfree = cur;
;;;610              LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
;;;611            }
;;;612            LWIP_MEM_ALLOC_UNPROTECT();
;;;613            sys_mutex_unlock(&mem_mutex);
;;;614            LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
;;;615             (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
;;;616            LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
;;;617             ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
;;;618            LWIP_ASSERT("mem_malloc: sanity check alignment",
;;;619              (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
;;;620    
;;;621            return (u8_t *)mem + SIZEOF_STRUCT_MEM;
;;;622          }
;;;623        }
;;;624    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;625        /* if we got interrupted by a mem_free, try again */
;;;626      } while(local_mem_free_count != 0);
;;;627    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;628      LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
;;;629      MEM_STATS_INC(err);
;;;630      LWIP_MEM_ALLOC_UNPROTECT();
;;;631      sys_mutex_unlock(&mem_mutex);
;;;632      return NULL;
;;;633    }
000494  08bd81f0          POPEQ    {r4-r8,pc}
000498  e2800003          ADD      r0,r0,#3
00049c  e3c05801          BIC      r5,r0,#0x10000        ;509
0004a0  e3c55003          BIC      r5,r5,#3              ;509
0004a4  e355000c          CMP      r5,#0xc               ;511
0004a8  33a0500c          MOVCC    r5,#0xc               ;513
0004ac  23550901          CMPCS    r5,#0x4000            ;516
0004b0  8a000099          BHI      |L1.1820|
0004b4  e51f62e0          LDR      r6,|L1.476|
0004b8  e2653901          RSB      r3,r5,#0x4000         ;532
0004bc  e5961008          LDR      r1,[r6,#8]            ;532  ; lfree, ram
0004c0  e5962000          LDR      r2,[r6,#0]            ;532
0004c4  e0410002          SUB      r0,r1,r2              ;532
0004c8  e1a00800          LSL      r0,r0,#16             ;532
0004cc  e1a00820          LSR      r0,r0,#16             ;532
0004d0  ea00008f          B        |L1.1812|
                  |L1.1236|
0004d4  e0824000          ADD      r4,r2,r0              ;534
0004d8  e5d4c004          LDRB     r12,[r4,#4]           ;548
0004dc  e35c0000          CMP      r12,#0                ;548
0004e0  1a00008a          BNE      |L1.1808|
0004e4  e1d4c0b0          LDRH     r12,[r4,#0]           ;549
0004e8  e04cc000          SUB      r12,r12,r0            ;549
0004ec  e24cc008          SUB      r12,r12,#8            ;549
0004f0  e15c0005          CMP      r12,r5                ;549
0004f4  3a000085          BCC      |L1.1808|
0004f8  e1d430b0          LDRH     r3,[r4,#0]            ;553
0004fc  e285c014          ADD      r12,r5,#0x14          ;553
000500  e3a07001          MOV      r7,#1                 ;572
000504  e0433000          SUB      r3,r3,r0              ;553
000508  e2433008          SUB      r3,r3,#8              ;572
00050c  e153000c          CMP      r3,r12                ;553
000510  35c47004          STRBCC   r7,[r4,#4]            ;586
000514  3a00000e          BCC      |L1.1364|
000518  e0803005          ADD      r3,r0,r5              ;564
00051c  e2833008          ADD      r3,r3,#8              ;564
000520  e3c3c803          BIC      r12,r3,#0x30000       ;564
000524  e082300c          ADD      r3,r2,r12             ;566
000528  e3a08000          MOV      r8,#0                 ;567
00052c  e5c38004          STRB     r8,[r3,#4]            ;567
000530  e1d480b0          LDRH     r8,[r4,#0]            ;568
000534  e1c380b0          STRH     r8,[r3,#0]            ;568
000538  e1c300b2          STRH     r0,[r3,#2]            ;569
00053c  e1c4c0b0          STRH     r12,[r4,#0]           ;571
000540  e5c47004          STRB     r7,[r4,#4]            ;572
000544  e1d300b0          LDRH     r0,[r3,#0]            ;574
000548  e3500901          CMP      r0,#0x4000            ;574
00054c  10800002          ADDNE    r0,r0,r2              ;575
000550  11c0c0b2          STRHNE   r12,[r0,#2]           ;575
                  |L1.1364|
000554  e1540001          CMP      r4,r1                 ;592
000558  05960004          LDREQ    r0,[r6,#4]            ;595
00055c  1a00000f          BNE      |L1.1440|
                  |L1.1376|
000560  e5d13004          LDRB     r3,[r1,#4]            ;595
000564  e3530000          CMP      r3,#0                 ;595
000568  11510000          CMPNE    r1,r0                 ;595
00056c  11d110b0          LDRHNE   r1,[r1,#0]            ;607
000570  10811002          ADDNE    r1,r1,r2              ;607
000574  1afffff9          BNE      |L1.1376|
000578  e1510000          CMP      r1,r0                 ;610
00057c  e5861008          STR      r1,[r6,#8]            ;609  ; lfree
000580  15d10004          LDRBNE   r0,[r1,#4]            ;610
000584  13500000          CMPNE    r0,#0                 ;610
000588  0a000004          BEQ      |L1.1440|
00058c  e59f20cc          LDR      r2,|L1.1632|
000590  e24f3fee          ADR      r3,|L1.480|
000594  e28f10c8          ADR      r1,|L1.1636|
000598  e24f0fe3          ADR      r0,|L1.532|
00059c  ebfffffe          BL       sysprintf
                  |L1.1440|
0005a0  e5961004          LDR      r1,[r6,#4]            ;614  ; ram_end
0005a4  e0840005          ADD      r0,r4,r5              ;614
0005a8  e2800008          ADD      r0,r0,#8              ;614
0005ac  e1500001          CMP      r0,r1                 ;614
0005b0  9a000004          BLS      |L1.1480|
0005b4  e59f20c4          LDR      r2,|L1.1664|
0005b8  e24f3e3e          ADR      r3,|L1.480|
0005bc  e28f10c0          ADR      r1,|L1.1668|
0005c0  e24f0fed          ADR      r0,|L1.532|
0005c4  ebfffffe          BL       sysprintf
                  |L1.1480|
0005c8  e2840008          ADD      r0,r4,#8              ;616
0005cc  e3100003          TST      r0,#3                 ;616
0005d0  0a000004          BEQ      |L1.1512|
0005d4  e24f3fff          ADR      r3,|L1.480|
0005d8  e3a02f9a          MOV      r2,#0x268             ;616
0005dc  e28f10d0          ADR      r1,|L1.1716|
0005e0  e24f0ff5          ADR      r0,|L1.532|
0005e4  ebfffffe          BL       sysprintf
                  |L1.1512|
0005e8  e3140003          TST      r4,#3                 ;618
0005ec  0a000004          BEQ      |L1.1540|
0005f0  e59f30ec          LDR      r3,|L1.1764|
0005f4  e59f20ec          LDR      r2,|L1.1768|
0005f8  e28f10ec          ADR      r1,|L1.1772|
0005fc  e24f0e3f          ADR      r0,|L1.532|
000600  ebfffffe          BL       sysprintf
                  |L1.1540|
000604  e2840008          ADD      r0,r4,#8              ;621
000608  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1548|
                          DCD      0x00000153
                  |L1.1552|
000610  6d656d5f          DCB      "mem_free: mem->used",0
000614  66726565
000618  3a206d65
00061c  6d2d3e75
000620  73656400
                  |L1.1572|
                          DCD      0x00000186
                  |L1.1576|
000628  6d656d5f          DCB      "mem_trim: legal memory",0
00062c  7472696d
000630  3a206c65
000634  67616c20
000638  6d656d6f
00063c  727900  
00063f  00                DCB      0
                  |L1.1600|
000640  6d656d5f          DCB      "mem_trim can only shrink memory",0
000644  7472696d
000648  2063616e
00064c  206f6e6c
000650  79207368
000654  72696e6b
000658  206d656d
00065c  6f727900
                  |L1.1632|
                          DCD      0x00000262
                  |L1.1636|
000664  6d656d5f          DCB      "mem_malloc: !lfree->used",0
000668  6d616c6c
00066c  6f633a20
000670  216c6672
000674  65652d3e
000678  75736564
00067c  00      
00067d  00                DCB      0
00067e  00                DCB      0
00067f  00                DCB      0
                  |L1.1664|
                          DCD      0x00000266
                  |L1.1668|
000684  6d656d5f          DCB      "mem_malloc: allocated memory not above ram_end.",0
000688  6d616c6c
00068c  6f633a20
000690  616c6c6f
000694  63617465
000698  64206d65
00069c  6d6f7279
0006a0  206e6f74
0006a4  2061626f
0006a8  76652072
0006ac  616d5f65
0006b0  6e642e00
                  |L1.1716|
0006b4  6d656d5f          DCB      "mem_malloc: allocated memory properly aligned.",0
0006b8  6d616c6c
0006bc  6f633a20
0006c0  616c6c6f
0006c4  63617465
0006c8  64206d65
0006cc  6d6f7279
0006d0  2070726f
0006d4  7065726c
0006d8  7920616c
0006dc  69676e65
0006e0  642e00  
0006e3  00                DCB      0
                  |L1.1764|
                          DCD      ||.text||+0x1e0
                  |L1.1768|
                          DCD      0x0000026a
                  |L1.1772|
0006ec  6d656d5f          DCB      "mem_malloc: sanity check alignment",0
0006f0  6d616c6c
0006f4  6f633a20
0006f8  73616e69
0006fc  74792063
000700  6865636b
000704  20616c69
000708  676e6d65
00070c  6e7400  
00070f  00                DCB      0
                  |L1.1808|
000710  e19200b0          LDRH     r0,[r2,r0]            ;533
                  |L1.1812|
000714  e1530000          CMP      r3,r0                 ;532
000718  caffff6d          BGT      |L1.1236|
                  |L1.1820|
00071c  e3a00000          MOV      r0,#0                 ;632
000720  e8bd81f0          POP      {r4-r8,pc}
;;;634    
                          ENDP

                  mem_calloc PROC
;;;645     */
;;;646    void *mem_calloc(mem_size_t count, mem_size_t size)
000724  e92d4070          PUSH     {r4-r6,lr}
;;;647    {
;;;648      void *p;
;;;649    
;;;650      /* allocate 'count' objects of size 'size' */
;;;651      p = mem_malloc(count * size);
000728  e0040190          MUL      r4,r0,r1
00072c  e1a00804          LSL      r0,r4,#16
000730  e1a00820          LSR      r0,r0,#16
000734  ebfffffe          BL       mem_malloc
000738  e1b05000          MOVS     r5,r0
00073c  11a01004          MOVNE    r1,r4
;;;652      if (p) {
;;;653        /* zero the memory */
;;;654        memset(p, 0, count * size);
000740  1bfffffe          BLNE     __aeabi_memclr
;;;655      }
;;;656      return p;
000744  e1a00005          MOV      r0,r5
;;;657    }
000748  e8bd8070          POP      {r4-r6,pc}
;;;658    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ram_heap
                          %        16404

                          AREA ||.data||, DATA, ALIGN=2

                  ||ram||
                          DCD      0x00000000
                  ram_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
