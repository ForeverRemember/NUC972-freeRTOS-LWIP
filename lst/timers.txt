; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\timers.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timers.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\timers.crf lwip-1.4.1\src\core\timers.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sys_timeout PROC
;;;265    void
;;;266    sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;267    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;268    {
000004  e1a04000          MOV      r4,r0
000008  e1a06002          MOV      r6,r2
00000c  e1a05001          MOV      r5,r1
;;;269      struct sys_timeo *timeout, *t;
;;;270    
;;;271      timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
000010  e3a00007          MOV      r0,#7
000014  ebfffffe          BL       memp_malloc
;;;272      if (timeout == NULL) {
000018  e3500000          CMP      r0,#0
00001c  0a00000d          BEQ      |L1.88|
;;;273        LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
;;;274        return;
;;;275      }
;;;276      timeout->next = NULL;
000020  e3a02000          MOV      r2,#0
;;;277      timeout->h = handler;
;;;278      timeout->arg = arg;
;;;279      timeout->time = msecs;
;;;280    #if LWIP_DEBUG_TIMERNAMES
;;;281      timeout->handler_name = handler_name;
;;;282      LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
;;;283        (void *)timeout, msecs, handler_name, (void *)arg));
;;;284    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;285    
;;;286      if (next_timeout == NULL) {
000024  e8800074          STM      r0,{r2,r4-r6}
000028  e59f31c8          LDR      r3,|L1.504|
00002c  e5931000          LDR      r1,[r3,#0]  ; next_timeout
000030  e3510000          CMP      r1,#0
000034  0a000005          BEQ      |L1.80|
;;;287        next_timeout = timeout;
;;;288        return;
;;;289      }
;;;290    
;;;291      if (next_timeout->time > msecs) {
000038  e5912004          LDR      r2,[r1,#4]
00003c  e1520004          CMP      r2,r4
;;;292        next_timeout->time -= msecs;
000040  80422004          SUBHI    r2,r2,r4
000044  85812004          STRHI    r2,[r1,#4]
;;;293        timeout->next = next_timeout;
000048  85801000          STRHI    r1,[r0,#0]
00004c  9a000013          BLS      |L1.160|
                  |L1.80|
000050  e5830000          STR      r0,[r3,#0]            ;287  ; next_timeout
;;;294        next_timeout = timeout;
;;;295      } else {
;;;296        for(t = next_timeout; t != NULL; t = t->next) {
;;;297          timeout->time -= t->time;
;;;298          if (t->next == NULL || t->next->time > timeout->time) {
;;;299            if (t->next != NULL) {
;;;300              t->next->time -= timeout->time;
;;;301            }
;;;302            timeout->next = t->next;
;;;303            t->next = timeout;
;;;304            break;
;;;305          }
;;;306        }
;;;307      }
;;;308    }
000054  e8bd8070          POP      {r4-r6,pc}
                  |L1.88|
000058  e8bd4070          POP      {r4-r6,lr}            ;273
00005c  e59f21b8          LDR      r2,|L1.540|
000060  e28f3f65          ADR      r3,|L1.508|
000064  e28f1f6d          ADR      r1,|L1.544|
000068  e28f0e1f          ADR      r0,|L1.608|
00006c  eafffffe          B        sysprintf
                  |L1.112|
000070  e592c004          LDR      r12,[r2,#4]           ;298
000074  e15c0003          CMP      r12,r3                ;298
000078  91a01002          MOVLS    r1,r2                 ;298
00007c  9a000007          BLS      |L1.160|
000080  e5923004          LDR      r3,[r2,#4]            ;300
000084  e590c004          LDR      r12,[r0,#4]           ;300
000088  e043300c          SUB      r3,r3,r12             ;300
00008c  e5823004          STR      r3,[r2,#4]            ;300
                  |L1.144|
000090  e5912000          LDR      r2,[r1,#0]            ;302
000094  e5802000          STR      r2,[r0,#0]            ;303
000098  e5810000          STR      r0,[r1,#0]            ;303
00009c  e8bd8070          POP      {r4-r6,pc}
                  |L1.160|
0000a0  e5902004          LDR      r2,[r0,#4]            ;297
0000a4  e5913004          LDR      r3,[r1,#4]            ;297
0000a8  e0423003          SUB      r3,r2,r3              ;297
0000ac  e5803004          STR      r3,[r0,#4]            ;298
0000b0  e5912000          LDR      r2,[r1,#0]            ;298
0000b4  e3520000          CMP      r2,#0                 ;298
0000b8  0afffff4          BEQ      |L1.144|
0000bc  eaffffeb          B        |L1.112|
;;;309    
                          ENDP

                  tcpip_tcp_timer PROC
;;;78     static void
;;;79     tcpip_tcp_timer(void *arg)
0000c0  e92d4010          PUSH     {r4,lr}
;;;80     {
;;;81       LWIP_UNUSED_ARG(arg);
;;;82     
;;;83       /* call TCP timer handler */
;;;84       tcp_tmr();
0000c4  ebfffffe          BL       tcp_tmr
;;;85       /* timer still needed? */
;;;86       if (tcp_active_pcbs || tcp_tw_pcbs) {
0000c8  e59f01b8          LDR      r0,|L1.648|
0000cc  e59f11b8          LDR      r1,|L1.652|
0000d0  e5900000          LDR      r0,[r0,#0]  ; tcp_active_pcbs
0000d4  e5911000          LDR      r1,[r1,#0]  ; tcp_tw_pcbs
0000d8  e1900001          ORRS     r0,r0,r1
;;;87         /* restart timer */
;;;88         sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
;;;89       } else {
;;;90         /* disable timer */
;;;91         tcpip_tcp_timer_active = 0;
0000dc  059f1114          LDREQ    r1,|L1.504|
0000e0  03a00000          MOVEQ    r0,#0
0000e4  05810004          STREQ    r0,[r1,#4]  ; tcpip_tcp_timer_active
;;;92       }
;;;93     }
0000e8  08bd8010          POPEQ    {r4,pc}
0000ec  e8bd4010          POP      {r4,lr}               ;88
0000f0  e59f1198          LDR      r1,|L1.656|
0000f4  e3a02000          MOV      r2,#0                 ;88
0000f8  e3a000fa          MOV      r0,#0xfa              ;88
0000fc  eafffffe          B        sys_timeout
;;;94     
                          ENDP

                  tcp_timer_needed PROC
;;;100    void
;;;101    tcp_timer_needed(void)
000100  e59f00f0          LDR      r0,|L1.504|
;;;102    {
;;;103      /* timer is off but needed again? */
;;;104      if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
000104  e5901004          LDR      r1,[r0,#4]  ; tcpip_tcp_timer_active
000108  e3510000          CMP      r1,#0
;;;105        /* enable and start timer */
;;;106        tcpip_tcp_timer_active = 1;
;;;107        sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
;;;108      }
;;;109    }
00010c  112fff1e          BXNE     lr
000110  e59f1170          LDR      r1,|L1.648|
000114  e59f2170          LDR      r2,|L1.652|
000118  e5911000          LDR      r1,[r1,#0]            ;104  ; tcp_active_pcbs
00011c  e5922000          LDR      r2,[r2,#0]            ;104  ; tcp_tw_pcbs
000120  e1911002          ORRS     r1,r1,r2              ;104
000124  012fff1e          BXEQ     lr
000128  e3a01001          MOV      r1,#1                 ;106
00012c  e5801004          STR      r1,[r0,#4]            ;107  ; tcpip_tcp_timer_active
000130  e3a02000          MOV      r2,#0                 ;107
000134  e59f1154          LDR      r1,|L1.656|
000138  e3a000fa          MOV      r0,#0xfa              ;107
00013c  eafffffe          B        sys_timeout
;;;110    #endif /* LWIP_TCP */
                          ENDP

                  ip_reass_timer PROC
;;;118    static void
;;;119    ip_reass_timer(void *arg)
000140  e92d4010          PUSH     {r4,lr}
;;;120    {
;;;121      LWIP_UNUSED_ARG(arg);
;;;122      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
;;;123      ip_reass_tmr();
000144  ebfffffe          BL       ip_reass_tmr
;;;124      sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
000148  e8bd4010          POP      {r4,lr}
00014c  e59f1140          LDR      r1,|L1.660|
000150  e3a02000          MOV      r2,#0
000154  e3a00ffa          MOV      r0,#0x3e8
000158  eafffffe          B        sys_timeout
;;;125    }
;;;126    #endif /* IP_REASSEMBLY */
                          ENDP

                  arp_timer PROC
;;;134    static void
;;;135    arp_timer(void *arg)
00015c  e92d4010          PUSH     {r4,lr}
;;;136    {
;;;137      LWIP_UNUSED_ARG(arg);
;;;138      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
;;;139      etharp_tmr();
000160  ebfffffe          BL       etharp_tmr
;;;140      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
000164  e8bd4010          POP      {r4,lr}
000168  e59f1128          LDR      r1,|L1.664|
00016c  e59f0128          LDR      r0,|L1.668|
000170  e3a02000          MOV      r2,#0
000174  eafffffe          B        sys_timeout
;;;141    }
;;;142    #endif /* LWIP_ARP */
                          ENDP

                  dhcp_timer_coarse PROC
;;;150    static void
;;;151    dhcp_timer_coarse(void *arg)
000178  e92d4010          PUSH     {r4,lr}
;;;152    {
;;;153      LWIP_UNUSED_ARG(arg);
;;;154      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
;;;155      dhcp_coarse_tmr();
00017c  ebfffffe          BL       dhcp_coarse_tmr
;;;156      sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
000180  e8bd4010          POP      {r4,lr}
000184  e59f1114          LDR      r1,|L1.672|
000188  e59f0114          LDR      r0,|L1.676|
00018c  e3a02000          MOV      r2,#0
000190  eafffffe          B        sys_timeout
;;;157    }
;;;158    
                          ENDP

                  dhcp_timer_fine PROC
;;;164    static void
;;;165    dhcp_timer_fine(void *arg)
000194  e92d4010          PUSH     {r4,lr}
;;;166    {
;;;167      LWIP_UNUSED_ARG(arg);
;;;168      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
;;;169      dhcp_fine_tmr();
000198  ebfffffe          BL       dhcp_fine_tmr
;;;170      sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
00019c  e8bd4010          POP      {r4,lr}
0001a0  e59f1100          LDR      r1,|L1.680|
0001a4  e3a02000          MOV      r2,#0
0001a8  e3a00f7d          MOV      r0,#0x1f4
0001ac  eafffffe          B        sys_timeout
;;;171    }
;;;172    #endif /* LWIP_DHCP */
                          ENDP

                  sys_timeouts_init PROC
;;;222    /** Initialize this module */
;;;223    void sys_timeouts_init(void)
0001b0  e92d4010          PUSH     {r4,lr}
;;;224    {
;;;225    #if IP_REASSEMBLY
;;;226      sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
0001b4  e59f10d8          LDR      r1,|L1.660|
0001b8  e3a02000          MOV      r2,#0
0001bc  e3a00ffa          MOV      r0,#0x3e8
0001c0  ebfffffe          BL       sys_timeout
;;;227    #endif /* IP_REASSEMBLY */
;;;228    #if LWIP_ARP
;;;229      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
0001c4  e59f10cc          LDR      r1,|L1.664|
0001c8  e59f00cc          LDR      r0,|L1.668|
0001cc  e3a02000          MOV      r2,#0
0001d0  ebfffffe          BL       sys_timeout
;;;230    #endif /* LWIP_ARP */
;;;231    #if LWIP_DHCP
;;;232      sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
0001d4  e59f10c4          LDR      r1,|L1.672|
0001d8  e59f00c4          LDR      r0,|L1.676|
0001dc  e3a02000          MOV      r2,#0
0001e0  ebfffffe          BL       sys_timeout
;;;233      sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
0001e4  e8bd4010          POP      {r4,lr}
0001e8  e59f10b8          LDR      r1,|L1.680|
0001ec  e3a02000          MOV      r2,#0
0001f0  e3a00f7d          MOV      r0,#0x1f4
0001f4  eafffffe          B        sys_timeout
                  |L1.504|
                          DCD      ||.data||
                  |L1.508|
0001fc  6c776970          DCB      "lwip-1.4.1\\src\\core\\timers.c",0
000200  2d312e34
000204  2e315c73
000208  72635c63
00020c  6f72655c
000210  74696d65
000214  72732e63
000218  00      
000219  00                DCB      0
00021a  00                DCB      0
00021b  00                DCB      0
                  |L1.540|
                          DCD      0x00000111
                  |L1.544|
000220  7379735f          DCB      "sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is "
000224  74696d65
000228  6f75743a
00022c  2074696d
000230  656f7574
000234  20213d20
000238  4e554c4c
00023c  2c20706f
000240  6f6c204d
000244  454d505f
000248  5359535f
00024c  54494d45
000250  4f555420
000254  697320  
000257  656d7074          DCB      "empty",0
00025b  7900    
00025d  00                DCB      0
00025e  00                DCB      0
00025f  00                DCB      0
                  |L1.608|
000260  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000264  7274696f
000268  6e202225
00026c  73222066
000270  61696c65
000274  64206174
000278  206c696e
00027c  65202564
000280  20696e20
000284  25730a00
                  |L1.648|
                          DCD      tcp_active_pcbs
                  |L1.652|
                          DCD      tcp_tw_pcbs
                  |L1.656|
                          DCD      tcpip_tcp_timer
                  |L1.660|
                          DCD      ip_reass_timer
                  |L1.664|
                          DCD      arp_timer
                  |L1.668|
                          DCD      0x00001388
                  |L1.672|
                          DCD      dhcp_timer_coarse
                  |L1.676|
                          DCD      0x0000ea60
                  |L1.680|
                          DCD      dhcp_timer_fine
                          ENDP

                  sys_untimeout PROC
;;;320    void
;;;321    sys_untimeout(sys_timeout_handler handler, void *arg)
0002ac  e92d0030          PUSH     {r4,r5}
;;;322    {
;;;323      struct sys_timeo *prev_t, *t;
;;;324    
;;;325      if (next_timeout == NULL) {
0002b0  e51f40c0          LDR      r4,|L1.504|
0002b4  e1a03001          MOV      r3,r1                 ;322
0002b8  e5941000          LDR      r1,[r4,#0]  ; next_timeout
0002bc  e3510000          CMP      r1,#0
;;;326        return;
;;;327      }
;;;328    
;;;329      for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
0002c0  13a02000          MOVNE    r2,#0
0002c4  0a000016          BEQ      |L1.804|
                  |L1.712|
;;;330        if ((t->h == handler) && (t->arg == arg)) {
0002c8  e591c008          LDR      r12,[r1,#8]
0002cc  e15c0000          CMP      r12,r0
0002d0  0591c00c          LDREQ    r12,[r1,#0xc]
0002d4  015c0003          CMPEQ    r12,r3
0002d8  1a00000d          BNE      |L1.788|
;;;331          /* We have a match */
;;;332          /* Unlink from previous in list */
;;;333          if (prev_t == NULL) {
;;;334            next_timeout = t->next;
;;;335          } else {
;;;336            prev_t->next = t->next;
0002dc  e5910000          LDR      r0,[r1,#0]
0002e0  e3520000          CMP      r2,#0                 ;333
0002e4  05840000          STREQ    r0,[r4,#0]            ;334  ; next_timeout
0002e8  15820000          STRNE    r0,[r2,#0]
;;;337          }
;;;338          /* If not the last one, add time of this one back to next */
;;;339          if (t->next != NULL) {
0002ec  e5910000          LDR      r0,[r1,#0]
0002f0  e3500000          CMP      r0,#0
0002f4  0a000003          BEQ      |L1.776|
;;;340            t->next->time += t->time;
0002f8  e5902004          LDR      r2,[r0,#4]
0002fc  e5913004          LDR      r3,[r1,#4]
000300  e0822003          ADD      r2,r2,r3
000304  e5802004          STR      r2,[r0,#4]
                  |L1.776|
;;;341          }
;;;342          memp_free(MEMP_SYS_TIMEOUT, t);
000308  e8bd0030          POP      {r4,r5}
00030c  e3a00007          MOV      r0,#7
000310  eafffffe          B        memp_free
                  |L1.788|
000314  e1a02001          MOV      r2,r1                 ;329
000318  e5911000          LDR      r1,[r1,#0]            ;329
00031c  e3510000          CMP      r1,#0                 ;329
000320  1affffe8          BNE      |L1.712|
                  |L1.804|
;;;343          return;
;;;344        }
;;;345      }
;;;346      return;
;;;347    }
000324  e8bd0030          POP      {r4,r5}
000328  e12fff1e          BX       lr
;;;348    
                          ENDP

                  sys_timeouts_mbox_fetch PROC
;;;422    void
;;;423    sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
00032c  e92d41f0          PUSH     {r4-r8,lr}
;;;424    {
;;;425      u32_t time_needed;
;;;426      struct sys_timeo *tmptimeout;
;;;427      sys_timeout_handler handler;
;;;428      void *arg;
;;;429    
;;;430     again:
;;;431      if (!next_timeout) {
000330  e51f5140          LDR      r5,|L1.504|
000334  e1a06001          MOV      r6,r1                 ;424
000338  e1a07000          MOV      r7,r0                 ;424
                  |L1.828|
00033c  e5950000          LDR      r0,[r5,#0]  ; next_timeout
000340  e3500000          CMP      r0,#0
000344  0a00000e          BEQ      |L1.900|
;;;432        time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
;;;433      } else {
;;;434        if (next_timeout->time > 0) {
000348  e5902004          LDR      r2,[r0,#4]
00034c  e3520000          CMP      r2,#0
000350  0a000010          BEQ      |L1.920|
;;;435          time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
000354  e1a01006          MOV      r1,r6
000358  e1a00007          MOV      r0,r7
00035c  ebfffffe          BL       sys_arch_mbox_fetch
;;;436        } else {
;;;437          time_needed = SYS_ARCH_TIMEOUT;
;;;438        }
;;;439    
;;;440        if (time_needed == SYS_ARCH_TIMEOUT) {
000360  e3700001          CMN      r0,#1
000364  0a00000b          BEQ      |L1.920|
;;;441          /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
;;;442             could be fetched. We should now call the timeout handler and
;;;443             deallocate the memory allocated for the timeout. */
;;;444          tmptimeout = next_timeout;
;;;445          next_timeout = tmptimeout->next;
;;;446          handler = tmptimeout->h;
;;;447          arg = tmptimeout->arg;
;;;448    #if LWIP_DEBUG_TIMERNAMES
;;;449          if (handler != NULL) {
;;;450            LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
;;;451              tmptimeout->handler_name, arg));
;;;452          }
;;;453    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;454          memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
;;;455          if (handler != NULL) {
;;;456            /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
;;;457               timeout handler function. */
;;;458            LOCK_TCPIP_CORE();
;;;459            handler(arg);
;;;460            UNLOCK_TCPIP_CORE();
;;;461          }
;;;462          LWIP_TCPIP_THREAD_ALIVE();
;;;463    
;;;464          /* We try again to fetch a message from the mbox. */
;;;465          goto again;
;;;466        } else {
;;;467          /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
;;;468             occured. The time variable is set to the number of
;;;469             milliseconds we waited for the message. */
;;;470          if (time_needed < next_timeout->time) {
000368  e5951000          LDR      r1,[r5,#0]  ; next_timeout
00036c  e5912004          LDR      r2,[r1,#4]
000370  e1520000          CMP      r2,r0
;;;471            next_timeout->time -= time_needed;
;;;472          } else {
;;;473            next_timeout->time = 0;
000374  93a00000          MOVLS    r0,#0
000378  80420000          SUBHI    r0,r2,r0              ;471
00037c  e5810004          STR      r0,[r1,#4]
;;;474          }
;;;475        }
;;;476      }
;;;477    }
000380  e8bd81f0          POP      {r4-r8,pc}
                  |L1.900|
000384  e1a01006          MOV      r1,r6                 ;432
000388  e1a00007          MOV      r0,r7                 ;432
00038c  e8bd41f0          POP      {r4-r8,lr}            ;432
000390  e3a02000          MOV      r2,#0                 ;432
000394  eafffffe          B        sys_arch_mbox_fetch
                  |L1.920|
000398  e5951000          LDR      r1,[r5,#0]            ;445  ; next_timeout
00039c  e5910000          LDR      r0,[r1,#0]            ;445
0003a0  e5850000          STR      r0,[r5,#0]            ;446  ; next_timeout
0003a4  e5914008          LDR      r4,[r1,#8]            ;454
0003a8  e591800c          LDR      r8,[r1,#0xc]          ;454
0003ac  e3a00007          MOV      r0,#7                 ;454
0003b0  ebfffffe          BL       memp_free
0003b4  e3540000          CMP      r4,#0                 ;455
0003b8  11a00008          MOVNE    r0,r8                 ;459
0003bc  112fff34          BLXNE    r4                    ;459
0003c0  eaffffdd          B        |L1.828|
;;;478    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  next_timeout
                          DCD      0x00000000
                  tcpip_tcp_timer_active
                          DCD      0x00000000
