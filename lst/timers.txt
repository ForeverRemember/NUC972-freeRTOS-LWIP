; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\timers.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timers.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\timers.crf lwip-1.4.1\src\core\timers.c]
                          ARM

                          AREA ||i.arp_timer||, CODE, READONLY, ALIGN=2

                  arp_timer PROC
;;;134    static void
;;;135    arp_timer(void *arg)
000000  e92d4010          PUSH     {r4,lr}
;;;136    {
000004  e1a04000          MOV      r4,r0
;;;137      LWIP_UNUSED_ARG(arg);
;;;138      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
;;;139      etharp_tmr();
000008  ebfffffe          BL       etharp_tmr
;;;140      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
00000c  e3a02000          MOV      r2,#0
000010  e59f1008          LDR      r1,|L1.32|
000014  e59f0008          LDR      r0,|L1.36|
000018  ebfffffe          BL       sys_timeout
;;;141    }
00001c  e8bd8010          POP      {r4,pc}
;;;142    #endif /* LWIP_ARP */
                          ENDP

                  |L1.32|
                          DCD      arp_timer
                  |L1.36|
                          DCD      0x00001388

                          AREA ||i.dhcp_timer_coarse||, CODE, READONLY, ALIGN=2

                  dhcp_timer_coarse PROC
;;;150    static void
;;;151    dhcp_timer_coarse(void *arg)
000000  e92d4010          PUSH     {r4,lr}
;;;152    {
000004  e1a04000          MOV      r4,r0
;;;153      LWIP_UNUSED_ARG(arg);
;;;154      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
;;;155      dhcp_coarse_tmr();
000008  ebfffffe          BL       dhcp_coarse_tmr
;;;156      sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
00000c  e3a02000          MOV      r2,#0
000010  e59f1008          LDR      r1,|L2.32|
000014  e59f0008          LDR      r0,|L2.36|
000018  ebfffffe          BL       sys_timeout
;;;157    }
00001c  e8bd8010          POP      {r4,pc}
;;;158    
                          ENDP

                  |L2.32|
                          DCD      dhcp_timer_coarse
                  |L2.36|
                          DCD      0x0000ea60

                          AREA ||i.dhcp_timer_fine||, CODE, READONLY, ALIGN=2

                  dhcp_timer_fine PROC
;;;164    static void
;;;165    dhcp_timer_fine(void *arg)
000000  e92d4010          PUSH     {r4,lr}
;;;166    {
000004  e1a04000          MOV      r4,r0
;;;167      LWIP_UNUSED_ARG(arg);
;;;168      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
;;;169      dhcp_fine_tmr();
000008  ebfffffe          BL       dhcp_fine_tmr
;;;170      sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
00000c  e3a02000          MOV      r2,#0
000010  e59f1008          LDR      r1,|L3.32|
000014  e3a00f7d          MOV      r0,#0x1f4
000018  ebfffffe          BL       sys_timeout
;;;171    }
00001c  e8bd8010          POP      {r4,pc}
;;;172    #endif /* LWIP_DHCP */
                          ENDP

                  |L3.32|
                          DCD      dhcp_timer_fine

                          AREA ||i.ip_reass_timer||, CODE, READONLY, ALIGN=2

                  ip_reass_timer PROC
;;;118    static void
;;;119    ip_reass_timer(void *arg)
000000  e92d4010          PUSH     {r4,lr}
;;;120    {
000004  e1a04000          MOV      r4,r0
;;;121      LWIP_UNUSED_ARG(arg);
;;;122      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
;;;123      ip_reass_tmr();
000008  ebfffffe          BL       ip_reass_tmr
;;;124      sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
00000c  e3a02000          MOV      r2,#0
000010  e59f1008          LDR      r1,|L4.32|
000014  e3a00ffa          MOV      r0,#0x3e8
000018  ebfffffe          BL       sys_timeout
;;;125    }
00001c  e8bd8010          POP      {r4,pc}
;;;126    #endif /* IP_REASSEMBLY */
                          ENDP

                  |L4.32|
                          DCD      ip_reass_timer

                          AREA ||i.sys_timeout||, CODE, READONLY, ALIGN=2

                  sys_timeout PROC
;;;265    void
;;;266    sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;267    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;268    {
000004  e1a06000          MOV      r6,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a08002          MOV      r8,r2
;;;269      struct sys_timeo *timeout, *t;
;;;270    
;;;271      timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
000010  e3a00009          MOV      r0,#9
000014  ebfffffe          BL       memp_malloc
000018  e1a04000          MOV      r4,r0
;;;272      if (timeout == NULL) {
00001c  e3540000          CMP      r4,#0
000020  1a00000b          BNE      |L5.84|
;;;273        LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
000024  e1a00000          MOV      r0,r0
000028  e3540000          CMP      r4,#0
00002c  1a000006          BNE      |L5.76|
000030  e1a00000          MOV      r0,r0
000034  e28f3f46          ADR      r3,|L5.340|
000038  e59f2134          LDR      r2,|L5.372|
00003c  e28f1f4d          ADR      r1,|L5.376|
000040  e28f0e17          ADR      r0,|L5.440|
000044  ebfffffe          BL       sysprintf
000048  e1a00000          MOV      r0,r0
                  |L5.76|
00004c  e1a00000          MOV      r0,r0
                  |L5.80|
;;;274        return;
;;;275      }
;;;276      timeout->next = NULL;
;;;277      timeout->h = handler;
;;;278      timeout->arg = arg;
;;;279      timeout->time = msecs;
;;;280    #if LWIP_DEBUG_TIMERNAMES
;;;281      timeout->handler_name = handler_name;
;;;282      LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
;;;283        (void *)timeout, msecs, handler_name, (void *)arg));
;;;284    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;285    
;;;286      if (next_timeout == NULL) {
;;;287        next_timeout = timeout;
;;;288        return;
;;;289      }
;;;290    
;;;291      if (next_timeout->time > msecs) {
;;;292        next_timeout->time -= msecs;
;;;293        timeout->next = next_timeout;
;;;294        next_timeout = timeout;
;;;295      } else {
;;;296        for(t = next_timeout; t != NULL; t = t->next) {
;;;297          timeout->time -= t->time;
;;;298          if (t->next == NULL || t->next->time > timeout->time) {
;;;299            if (t->next != NULL) {
;;;300              t->next->time -= timeout->time;
;;;301            }
;;;302            timeout->next = t->next;
;;;303            t->next = timeout;
;;;304            break;
;;;305          }
;;;306        }
;;;307      }
;;;308    }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L5.84|
000054  e3a00000          MOV      r0,#0                 ;276
000058  e5840000          STR      r0,[r4,#0]            ;276
00005c  e5847008          STR      r7,[r4,#8]            ;277
000060  e584800c          STR      r8,[r4,#0xc]          ;278
000064  e5846004          STR      r6,[r4,#4]            ;279
000068  e59f0170          LDR      r0,|L5.480|
00006c  e5900000          LDR      r0,[r0,#0]            ;286  ; next_timeout
000070  e3500000          CMP      r0,#0                 ;286
000074  1a000002          BNE      |L5.132|
000078  e59f0160          LDR      r0,|L5.480|
00007c  e5804000          STR      r4,[r0,#0]            ;287  ; next_timeout
000080  eafffff2          B        |L5.80|
                  |L5.132|
000084  e59f0154          LDR      r0,|L5.480|
000088  e5900000          LDR      r0,[r0,#0]            ;291  ; next_timeout
00008c  e5900004          LDR      r0,[r0,#4]            ;291
000090  e1500006          CMP      r0,r6                 ;291
000094  9a00000c          BLS      |L5.204|
000098  e59f0140          LDR      r0,|L5.480|
00009c  e5900000          LDR      r0,[r0,#0]            ;292  ; next_timeout
0000a0  e5900004          LDR      r0,[r0,#4]            ;292
0000a4  e0400006          SUB      r0,r0,r6              ;292
0000a8  e59f1130          LDR      r1,|L5.480|
0000ac  e5911000          LDR      r1,[r1,#0]            ;292  ; next_timeout
0000b0  e5810004          STR      r0,[r1,#4]            ;292
0000b4  e59f0124          LDR      r0,|L5.480|
0000b8  e5900000          LDR      r0,[r0,#0]            ;293  ; next_timeout
0000bc  e5840000          STR      r0,[r4,#0]            ;293
0000c0  e59f0118          LDR      r0,|L5.480|
0000c4  e5804000          STR      r4,[r0,#0]            ;294  ; next_timeout
0000c8  ea00001f          B        |L5.332|
                  |L5.204|
0000cc  e59f010c          LDR      r0,|L5.480|
0000d0  e5905000          LDR      r5,[r0,#0]            ;296  ; next_timeout
0000d4  ea000019          B        |L5.320|
                  |L5.216|
0000d8  e5940004          LDR      r0,[r4,#4]            ;297
0000dc  e5951004          LDR      r1,[r5,#4]            ;297
0000e0  e0400001          SUB      r0,r0,r1              ;297
0000e4  e5840004          STR      r0,[r4,#4]            ;297
0000e8  e5950000          LDR      r0,[r5,#0]            ;298
0000ec  e3500000          CMP      r0,#0                 ;298
0000f0  0a000004          BEQ      |L5.264|
0000f4  e5950000          LDR      r0,[r5,#0]            ;298
0000f8  e5900004          LDR      r0,[r0,#4]            ;298
0000fc  e5941004          LDR      r1,[r4,#4]            ;298
000100  e1500001          CMP      r0,r1                 ;298
000104  9a00000c          BLS      |L5.316|
                  |L5.264|
000108  e5950000          LDR      r0,[r5,#0]            ;299
00010c  e3500000          CMP      r0,#0                 ;299
000110  0a000005          BEQ      |L5.300|
000114  e5950000          LDR      r0,[r5,#0]            ;300
000118  e5900004          LDR      r0,[r0,#4]            ;300
00011c  e5941004          LDR      r1,[r4,#4]            ;300
000120  e0400001          SUB      r0,r0,r1              ;300
000124  e5951000          LDR      r1,[r5,#0]            ;300
000128  e5810004          STR      r0,[r1,#4]            ;300
                  |L5.300|
00012c  e5950000          LDR      r0,[r5,#0]            ;302
000130  e5840000          STR      r0,[r4,#0]            ;302
000134  e5854000          STR      r4,[r5,#0]            ;303
000138  ea000002          B        |L5.328|
                  |L5.316|
00013c  e5955000          LDR      r5,[r5,#0]            ;296
                  |L5.320|
000140  e3550000          CMP      r5,#0                 ;296
000144  1affffe3          BNE      |L5.216|
                  |L5.328|
000148  e1a00000          MOV      r0,r0                 ;304
                  |L5.332|
00014c  e1a00000          MOV      r0,r0
000150  eaffffbe          B        |L5.80|
;;;309    
                          ENDP

                  |L5.340|
000154  6c776970          DCB      "lwip-1.4.1\\src\\core\\timers.c",0
000158  2d312e34
00015c  2e315c73
000160  72635c63
000164  6f72655c
000168  74696d65
00016c  72732e63
000170  00      
000171  00                DCB      0
000172  00                DCB      0
000173  00                DCB      0
                  |L5.372|
                          DCD      0x00000111
                  |L5.376|
000178  7379735f          DCB      "sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is "
00017c  74696d65
000180  6f75743a
000184  2074696d
000188  656f7574
00018c  20213d20
000190  4e554c4c
000194  2c20706f
000198  6f6c204d
00019c  454d505f
0001a0  5359535f
0001a4  54494d45
0001a8  4f555420
0001ac  697320  
0001af  656d7074          DCB      "empty",0
0001b3  7900    
0001b5  00                DCB      0
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L5.440|
0001b8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001bc  7274696f
0001c0  6e202225
0001c4  73222066
0001c8  61696c65
0001cc  64206174
0001d0  206c696e
0001d4  65202564
0001d8  20696e20
0001dc  25730a00
                  |L5.480|
                          DCD      next_timeout

                          AREA ||i.sys_timeouts_init||, CODE, READONLY, ALIGN=2

                  sys_timeouts_init PROC
;;;222    /** Initialize this module */
;;;223    void sys_timeouts_init(void)
000000  e92d4010          PUSH     {r4,lr}
;;;224    {
;;;225    #if IP_REASSEMBLY
;;;226      sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
000004  e3a02000          MOV      r2,#0
000008  e59f1038          LDR      r1,|L6.72|
00000c  e3a00ffa          MOV      r0,#0x3e8
000010  ebfffffe          BL       sys_timeout
;;;227    #endif /* IP_REASSEMBLY */
;;;228    #if LWIP_ARP
;;;229      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
000014  e3a02000          MOV      r2,#0
000018  e59f102c          LDR      r1,|L6.76|
00001c  e59f002c          LDR      r0,|L6.80|
000020  ebfffffe          BL       sys_timeout
;;;230    #endif /* LWIP_ARP */
;;;231    #if LWIP_DHCP
;;;232      sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
000024  e3a02000          MOV      r2,#0
000028  e59f1024          LDR      r1,|L6.84|
00002c  e59f0024          LDR      r0,|L6.88|
000030  ebfffffe          BL       sys_timeout
;;;233      sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
000034  e3a02000          MOV      r2,#0
000038  e59f101c          LDR      r1,|L6.92|
00003c  e3a00f7d          MOV      r0,#0x1f4
000040  ebfffffe          BL       sys_timeout
;;;234    #endif /* LWIP_DHCP */
;;;235    #if LWIP_AUTOIP
;;;236      sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
;;;237    #endif /* LWIP_AUTOIP */
;;;238    #if LWIP_IGMP
;;;239      sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
;;;240    #endif /* LWIP_IGMP */
;;;241    #if LWIP_DNS
;;;242      sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
;;;243    #endif /* LWIP_DNS */
;;;244    
;;;245    #if NO_SYS
;;;246      /* Initialise timestamp for sys_check_timeouts */
;;;247      timeouts_last_time = sys_now();
;;;248    #endif
;;;249    }
000044  e8bd8010          POP      {r4,pc}
;;;250    
                          ENDP

                  |L6.72|
                          DCD      ip_reass_timer
                  |L6.76|
                          DCD      arp_timer
                  |L6.80|
                          DCD      0x00001388
                  |L6.84|
                          DCD      dhcp_timer_coarse
                  |L6.88|
                          DCD      0x0000ea60
                  |L6.92|
                          DCD      dhcp_timer_fine

                          AREA ||i.sys_timeouts_mbox_fetch||, CODE, READONLY, ALIGN=2

                  sys_timeouts_mbox_fetch PROC
;;;422    void
;;;423    sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;424    {
000004  e1a08000          MOV      r8,r0
000008  e1a09001          MOV      r9,r1
;;;425      u32_t time_needed;
;;;426      struct sys_timeo *tmptimeout;
;;;427      sys_timeout_handler handler;
;;;428      void *arg;
;;;429    
;;;430     again:
00000c  e1a00000          MOV      r0,r0
                  |L7.16|
;;;431      if (!next_timeout) {
000010  e59f00e4          LDR      r0,|L7.252|
000014  e5900000          LDR      r0,[r0,#0]  ; next_timeout
000018  e3500000          CMP      r0,#0
00001c  1a000005          BNE      |L7.56|
;;;432        time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
000020  e3a02000          MOV      r2,#0
000024  e1a01009          MOV      r1,r9
000028  e1a00008          MOV      r0,r8
00002c  ebfffffe          BL       sys_arch_mbox_fetch
000030  e1a05000          MOV      r5,r0
000034  ea00002f          B        |L7.248|
                  |L7.56|
;;;433      } else {
;;;434        if (next_timeout->time > 0) {
000038  e59f00bc          LDR      r0,|L7.252|
00003c  e5900000          LDR      r0,[r0,#0]  ; next_timeout
000040  e5900004          LDR      r0,[r0,#4]
000044  e3500000          CMP      r0,#0
000048  0a000007          BEQ      |L7.108|
;;;435          time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
00004c  e59f00a8          LDR      r0,|L7.252|
000050  e5900000          LDR      r0,[r0,#0]  ; next_timeout
000054  e1a01009          MOV      r1,r9
000058  e5902004          LDR      r2,[r0,#4]
00005c  e1a00008          MOV      r0,r8
000060  ebfffffe          BL       sys_arch_mbox_fetch
000064  e1a05000          MOV      r5,r0
000068  ea000000          B        |L7.112|
                  |L7.108|
;;;436        } else {
;;;437          time_needed = SYS_ARCH_TIMEOUT;
00006c  e3e05000          MVN      r5,#0
                  |L7.112|
;;;438        }
;;;439    
;;;440        if (time_needed == SYS_ARCH_TIMEOUT) {
000070  e3750001          CMN      r5,#1
000074  1a00000e          BNE      |L7.180|
;;;441          /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
;;;442             could be fetched. We should now call the timeout handler and
;;;443             deallocate the memory allocated for the timeout. */
;;;444          tmptimeout = next_timeout;
000078  e59f007c          LDR      r0,|L7.252|
00007c  e5904000          LDR      r4,[r0,#0]  ; next_timeout
;;;445          next_timeout = tmptimeout->next;
000080  e2801000          ADD      r1,r0,#0
000084  e5940000          LDR      r0,[r4,#0]
000088  e5810000          STR      r0,[r1,#0]  ; next_timeout
;;;446          handler = tmptimeout->h;
00008c  e5946008          LDR      r6,[r4,#8]
;;;447          arg = tmptimeout->arg;
000090  e594700c          LDR      r7,[r4,#0xc]
;;;448    #if LWIP_DEBUG_TIMERNAMES
;;;449          if (handler != NULL) {
;;;450            LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
;;;451              tmptimeout->handler_name, arg));
;;;452          }
;;;453    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;454          memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
000094  e1a01004          MOV      r1,r4
000098  e3a00009          MOV      r0,#9
00009c  ebfffffe          BL       memp_free
;;;455          if (handler != NULL) {
0000a0  e3560000          CMP      r6,#0
0000a4  0a000001          BEQ      |L7.176|
;;;456            /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
;;;457               timeout handler function. */
;;;458            LOCK_TCPIP_CORE();
;;;459            handler(arg);
0000a8  e1a00007          MOV      r0,r7
0000ac  e12fff36          BLX      r6
                  |L7.176|
;;;460            UNLOCK_TCPIP_CORE();
;;;461          }
;;;462          LWIP_TCPIP_THREAD_ALIVE();
;;;463    
;;;464          /* We try again to fetch a message from the mbox. */
;;;465          goto again;
0000b0  eaffffd6          B        |L7.16|
                  |L7.180|
;;;466        } else {
;;;467          /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
;;;468             occured. The time variable is set to the number of
;;;469             milliseconds we waited for the message. */
;;;470          if (time_needed < next_timeout->time) {
0000b4  e59f0040          LDR      r0,|L7.252|
0000b8  e5900000          LDR      r0,[r0,#0]  ; next_timeout
0000bc  e5900004          LDR      r0,[r0,#4]
0000c0  e1500005          CMP      r0,r5
0000c4  9a000007          BLS      |L7.232|
;;;471            next_timeout->time -= time_needed;
0000c8  e59f002c          LDR      r0,|L7.252|
0000cc  e5900000          LDR      r0,[r0,#0]  ; next_timeout
0000d0  e5900004          LDR      r0,[r0,#4]
0000d4  e0400005          SUB      r0,r0,r5
0000d8  e59f101c          LDR      r1,|L7.252|
0000dc  e5911000          LDR      r1,[r1,#0]  ; next_timeout
0000e0  e5810004          STR      r0,[r1,#4]
0000e4  ea000003          B        |L7.248|
                  |L7.232|
;;;472          } else {
;;;473            next_timeout->time = 0;
0000e8  e3a00000          MOV      r0,#0
0000ec  e59f1008          LDR      r1,|L7.252|
0000f0  e5911000          LDR      r1,[r1,#0]  ; next_timeout
0000f4  e5810004          STR      r0,[r1,#4]
                  |L7.248|
;;;474          }
;;;475        }
;;;476      }
;;;477    }
0000f8  e8bd87f0          POP      {r4-r10,pc}
;;;478    
                          ENDP

                  |L7.252|
                          DCD      next_timeout

                          AREA ||i.sys_untimeout||, CODE, READONLY, ALIGN=2

                  sys_untimeout PROC
;;;320    void
;;;321    sys_untimeout(sys_timeout_handler handler, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;322    {
000004  e1a06000          MOV      r6,r0
000008  e1a07001          MOV      r7,r1
;;;323      struct sys_timeo *prev_t, *t;
;;;324    
;;;325      if (next_timeout == NULL) {
00000c  e59f00a0          LDR      r0,|L8.180|
000010  e5900000          LDR      r0,[r0,#0]  ; next_timeout
000014  e3500000          CMP      r0,#0
000018  1a000000          BNE      |L8.32|
                  |L8.28|
;;;326        return;
;;;327      }
;;;328    
;;;329      for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
;;;330        if ((t->h == handler) && (t->arg == arg)) {
;;;331          /* We have a match */
;;;332          /* Unlink from previous in list */
;;;333          if (prev_t == NULL) {
;;;334            next_timeout = t->next;
;;;335          } else {
;;;336            prev_t->next = t->next;
;;;337          }
;;;338          /* If not the last one, add time of this one back to next */
;;;339          if (t->next != NULL) {
;;;340            t->next->time += t->time;
;;;341          }
;;;342          memp_free(MEMP_SYS_TIMEOUT, t);
;;;343          return;
;;;344        }
;;;345      }
;;;346      return;
;;;347    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L8.32|
000020  e59f008c          LDR      r0,|L8.180|
000024  e5904000          LDR      r4,[r0,#0]            ;329  ; next_timeout
000028  e3a05000          MOV      r5,#0                 ;329
00002c  ea00001c          B        |L8.164|
                  |L8.48|
000030  e5940008          LDR      r0,[r4,#8]            ;330
000034  e1500006          CMP      r0,r6                 ;330
000038  1a000017          BNE      |L8.156|
00003c  e594000c          LDR      r0,[r4,#0xc]          ;330
000040  e1500007          CMP      r0,r7                 ;330
000044  1a000014          BNE      |L8.156|
000048  e3550000          CMP      r5,#0                 ;333
00004c  1a000003          BNE      |L8.96|
000050  e59f105c          LDR      r1,|L8.180|
000054  e5940000          LDR      r0,[r4,#0]            ;334
000058  e5810000          STR      r0,[r1,#0]            ;334  ; next_timeout
00005c  ea000001          B        |L8.104|
                  |L8.96|
000060  e5940000          LDR      r0,[r4,#0]            ;336
000064  e5850000          STR      r0,[r5,#0]            ;336
                  |L8.104|
000068  e5940000          LDR      r0,[r4,#0]            ;339
00006c  e3500000          CMP      r0,#0                 ;339
000070  0a000005          BEQ      |L8.140|
000074  e5940000          LDR      r0,[r4,#0]            ;340
000078  e5900004          LDR      r0,[r0,#4]            ;340
00007c  e5941004          LDR      r1,[r4,#4]            ;340
000080  e0800001          ADD      r0,r0,r1              ;340
000084  e5941000          LDR      r1,[r4,#0]            ;340
000088  e5810004          STR      r0,[r1,#4]            ;340
                  |L8.140|
00008c  e1a01004          MOV      r1,r4                 ;342
000090  e3a00009          MOV      r0,#9                 ;342
000094  ebfffffe          BL       memp_free
000098  eaffffdf          B        |L8.28|
                  |L8.156|
00009c  e1a05004          MOV      r5,r4                 ;329
0000a0  e5944000          LDR      r4,[r4,#0]            ;329
                  |L8.164|
0000a4  e3540000          CMP      r4,#0                 ;329
0000a8  1affffe0          BNE      |L8.48|
0000ac  e1a00000          MOV      r0,r0                 ;346
0000b0  eaffffd9          B        |L8.28|
;;;348    
                          ENDP

                  |L8.180|
                          DCD      next_timeout

                          AREA ||i.tcp_timer_needed||, CODE, READONLY, ALIGN=2

                  tcp_timer_needed PROC
;;;100    void
;;;101    tcp_timer_needed(void)
000000  e92d4010          PUSH     {r4,lr}
;;;102    {
;;;103      /* timer is off but needed again? */
;;;104      if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
000004  e59f0048          LDR      r0,|L9.84|
000008  e5900000          LDR      r0,[r0,#0]  ; tcpip_tcp_timer_active
00000c  e3500000          CMP      r0,#0
000010  1a00000e          BNE      |L9.80|
000014  e59f003c          LDR      r0,|L9.88|
000018  e5900000          LDR      r0,[r0,#0]  ; tcp_active_pcbs
00001c  e3500000          CMP      r0,#0
000020  1a000003          BNE      |L9.52|
000024  e59f0030          LDR      r0,|L9.92|
000028  e5900000          LDR      r0,[r0,#0]  ; tcp_tw_pcbs
00002c  e3500000          CMP      r0,#0
000030  0a000006          BEQ      |L9.80|
                  |L9.52|
;;;105        /* enable and start timer */
;;;106        tcpip_tcp_timer_active = 1;
000034  e3a00001          MOV      r0,#1
000038  e59f1014          LDR      r1,|L9.84|
00003c  e5810000          STR      r0,[r1,#0]  ; tcpip_tcp_timer_active
;;;107        sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
000040  e3a02000          MOV      r2,#0
000044  e59f1014          LDR      r1,|L9.96|
000048  e3a000fa          MOV      r0,#0xfa
00004c  ebfffffe          BL       sys_timeout
                  |L9.80|
;;;108      }
;;;109    }
000050  e8bd8010          POP      {r4,pc}
;;;110    #endif /* LWIP_TCP */
                          ENDP

                  |L9.84|
                          DCD      tcpip_tcp_timer_active
                  |L9.88|
                          DCD      tcp_active_pcbs
                  |L9.92|
                          DCD      tcp_tw_pcbs
                  |L9.96|
                          DCD      tcpip_tcp_timer

                          AREA ||i.tcpip_tcp_timer||, CODE, READONLY, ALIGN=2

                  tcpip_tcp_timer PROC
;;;78     static void
;;;79     tcpip_tcp_timer(void *arg)
000000  e92d4010          PUSH     {r4,lr}
;;;80     {
000004  e1a04000          MOV      r4,r0
;;;81       LWIP_UNUSED_ARG(arg);
;;;82     
;;;83       /* call TCP timer handler */
;;;84       tcp_tmr();
000008  ebfffffe          BL       tcp_tmr
;;;85       /* timer still needed? */
;;;86       if (tcp_active_pcbs || tcp_tw_pcbs) {
00000c  e59f003c          LDR      r0,|L10.80|
000010  e5900000          LDR      r0,[r0,#0]  ; tcp_active_pcbs
000014  e3500000          CMP      r0,#0
000018  1a000003          BNE      |L10.44|
00001c  e59f0030          LDR      r0,|L10.84|
000020  e5900000          LDR      r0,[r0,#0]  ; tcp_tw_pcbs
000024  e3500000          CMP      r0,#0
000028  0a000004          BEQ      |L10.64|
                  |L10.44|
;;;87         /* restart timer */
;;;88         sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
00002c  e3a02000          MOV      r2,#0
000030  e59f1020          LDR      r1,|L10.88|
000034  e3a000fa          MOV      r0,#0xfa
000038  ebfffffe          BL       sys_timeout
00003c  ea000002          B        |L10.76|
                  |L10.64|
;;;89       } else {
;;;90         /* disable timer */
;;;91         tcpip_tcp_timer_active = 0;
000040  e3a00000          MOV      r0,#0
000044  e59f1010          LDR      r1,|L10.92|
000048  e5810000          STR      r0,[r1,#0]  ; tcpip_tcp_timer_active
                  |L10.76|
;;;92       }
;;;93     }
00004c  e8bd8010          POP      {r4,pc}
;;;94     
                          ENDP

                  |L10.80|
                          DCD      tcp_active_pcbs
                  |L10.84|
                          DCD      tcp_tw_pcbs
                  |L10.88|
                          DCD      tcpip_tcp_timer
                  |L10.92|
                          DCD      tcpip_tcp_timer_active

                          AREA ||.data||, DATA, ALIGN=2

                  next_timeout
                          DCD      0x00000000
                  tcpip_tcp_timer_active
                          DCD      0x00000000
