; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tasks.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tasks.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\tasks.crf FreeRTOS\Source\tasks.c]
                          ARM

                          AREA ||i.eTaskGetState||, CODE, READONLY, ALIGN=2

                  eTaskGetState PROC
;;;1268   
;;;1269   	eTaskState eTaskGetState( TaskHandle_t xTask )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1270   	{
000004  e1a07000          MOV      r7,r0
;;;1271   	eTaskState eReturn;
;;;1272   	List_t *pxStateList;
;;;1273   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
000008  e1a06007          MOV      r6,r7
;;;1274   
;;;1275   		configASSERT( pxTCB );
00000c  e3560000          CMP      r6,#0
000010  1a000005          BNE      |L1.44|
000014  e1a00000          MOV      r0,r0
000018  e28f20a8          ADR      r2,|L1.200|
00001c  e59f10bc          LDR      r1,|L1.224|
000020  e28f00bc          ADR      r0,|L1.228|
000024  ebfffffe          BL       sysprintf
000028  e1a00000          MOV      r0,r0
                  |L1.44|
;;;1276   
;;;1277   		if( pxTCB == pxCurrentTCB )
00002c  e59f00dc          LDR      r0,|L1.272|
000030  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  e1560000          CMP      r6,r0
000038  1a000001          BNE      |L1.68|
;;;1278   		{
;;;1279   			/* The task calling this function is querying its own state. */
;;;1280   			eReturn = eRunning;
00003c  e3a04000          MOV      r4,#0
000040  ea00001e          B        |L1.192|
                  |L1.68|
;;;1281   		}
;;;1282   		else
;;;1283   		{
;;;1284   			taskENTER_CRITICAL();
000044  ebfffffe          BL       vPortEnterCritical
;;;1285   			{
;;;1286   				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
000048  e5965014          LDR      r5,[r6,#0x14]
;;;1287   			}
;;;1288   			taskEXIT_CRITICAL();
00004c  ebfffffe          BL       vPortExitCritical
;;;1289   
;;;1290   			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
000050  e59f00bc          LDR      r0,|L1.276|
000054  e5900000          LDR      r0,[r0,#0]  ; pxDelayedTaskList
000058  e1550000          CMP      r5,r0
00005c  0a000003          BEQ      |L1.112|
000060  e59f00b0          LDR      r0,|L1.280|
000064  e5900000          LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000068  e1550000          CMP      r5,r0
00006c  1a000001          BNE      |L1.120|
                  |L1.112|
;;;1291   			{
;;;1292   				/* The task being queried is referenced from one of the Blocked
;;;1293   				lists. */
;;;1294   				eReturn = eBlocked;
000070  e3a04002          MOV      r4,#2
000074  ea000011          B        |L1.192|
                  |L1.120|
;;;1295   			}
;;;1296   
;;;1297   			#if ( INCLUDE_vTaskSuspend == 1 )
;;;1298   				else if( pxStateList == &xSuspendedTaskList )
000078  e59f009c          LDR      r0,|L1.284|
00007c  e1550000          CMP      r5,r0
000080  1a000006          BNE      |L1.160|
;;;1299   				{
;;;1300   					/* The task being queried is referenced from the suspended
;;;1301   					list.  Is it genuinely suspended or is it block
;;;1302   					indefinitely? */
;;;1303   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
000084  e5960028          LDR      r0,[r6,#0x28]
000088  e3500000          CMP      r0,#0
00008c  1a000001          BNE      |L1.152|
;;;1304   					{
;;;1305   						eReturn = eSuspended;
000090  e3a04003          MOV      r4,#3
000094  ea000009          B        |L1.192|
                  |L1.152|
;;;1306   					}
;;;1307   					else
;;;1308   					{
;;;1309   						eReturn = eBlocked;
000098  e3a04002          MOV      r4,#2
00009c  ea000007          B        |L1.192|
                  |L1.160|
;;;1310   					}
;;;1311   				}
;;;1312   			#endif
;;;1313   
;;;1314   			#if ( INCLUDE_vTaskDelete == 1 )
;;;1315   				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
0000a0  e59f0078          LDR      r0,|L1.288|
0000a4  e1550000          CMP      r5,r0
0000a8  0a000001          BEQ      |L1.180|
0000ac  e3550000          CMP      r5,#0
0000b0  1a000001          BNE      |L1.188|
                  |L1.180|
;;;1316   				{
;;;1317   					/* The task being queried is referenced from the deleted
;;;1318   					tasks list, or it is not referenced from any lists at
;;;1319   					all. */
;;;1320   					eReturn = eDeleted;
0000b4  e3a04004          MOV      r4,#4
0000b8  ea000000          B        |L1.192|
                  |L1.188|
;;;1321   				}
;;;1322   			#endif
;;;1323   
;;;1324   			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
;;;1325   			{
;;;1326   				/* If the task is not in any other state, it must be in the
;;;1327   				Ready (including pending ready) state. */
;;;1328   				eReturn = eReady;
0000bc  e3a04001          MOV      r4,#1
                  |L1.192|
;;;1329   			}
;;;1330   		}
;;;1331   
;;;1332   		return eReturn;
0000c0  e1a00004          MOV      r0,r4
;;;1333   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
0000c4  e8bd81f0          POP      {r4-r8,pc}
;;;1334   
                          ENDP

                  |L1.200|
0000c8  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0000cc  52544f53
0000d0  5c536f75
0000d4  7263655c
0000d8  7461736b
0000dc  732e6300
                  |L1.224|
                          DCD      0x000004fb
                  |L1.228|
0000e4  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000e8  7274696f
0000ec  6e202220
0000f0  3f3f3f20
0000f4  22206661
0000f8  696c6564
0000fc  20617420
000100  6c696e65
000104  20256420
000108  696e2025
00010c  730a00  
00010f  00                DCB      0
                  |L1.272|
                          DCD      pxCurrentTCB
                  |L1.276|
                          DCD      pxDelayedTaskList
                  |L1.280|
                          DCD      pxOverflowDelayedTaskList
                  |L1.284|
                          DCD      xSuspendedTaskList
                  |L1.288|
                          DCD      xTasksWaitingTermination

                          AREA ||i.pcTaskGetName||, CODE, READONLY, ALIGN=2

                  pcTaskGetName PROC
;;;2180   
;;;2181   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d4070          PUSH     {r4-r6,lr}
;;;2182   {
000004  e1a04000          MOV      r4,r0
;;;2183   TCB_t *pxTCB;
;;;2184   
;;;2185   	/* If null is passed in here then the name of the calling task is being
;;;2186   	queried. */
;;;2187   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000008  e3540000          CMP      r4,#0
00000c  1a000002          BNE      |L2.28|
000010  e59f0034          LDR      r0,|L2.76|
000014  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000018  ea000000          B        |L2.32|
                  |L2.28|
00001c  e1a00004          MOV      r0,r4
                  |L2.32|
000020  e1a05000          MOV      r5,r0
;;;2188   	configASSERT( pxTCB );
000024  e3550000          CMP      r5,#0
000028  1a000005          BNE      |L2.68|
00002c  e1a00000          MOV      r0,r0
000030  e28f2018          ADR      r2,|L2.80|
000034  e59f102c          LDR      r1,|L2.104|
000038  e28f002c          ADR      r0,|L2.108|
00003c  ebfffffe          BL       sysprintf
000040  e1a00000          MOV      r0,r0
                  |L2.68|
;;;2189   	return &( pxTCB->pcTaskName[ 0 ] );
000044  e2850034          ADD      r0,r5,#0x34
;;;2190   }
000048  e8bd8070          POP      {r4-r6,pc}
;;;2191   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.76|
                          DCD      pxCurrentTCB
                  |L2.80|
000050  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
000054  52544f53
000058  5c536f75
00005c  7263655c
000060  7461736b
000064  732e6300
                  |L2.104|
                          DCD      0x0000088c
                  |L2.108|
00006c  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000070  7274696f
000074  6e202220
000078  3f3f3f20
00007c  22206661
000080  696c6564
000084  20617420
000088  6c696e65
00008c  20256420
000090  696e2025
000094  730a00  
000097  00                DCB      0

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;4691   
;;;4692   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4693   {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;4694   TickType_t xTimeToWake;
;;;4695   const TickType_t xConstTickCount = xTickCount;
00000c  e59f00a0          LDR      r0,|L3.180|
000010  e5907000          LDR      r7,[r0,#0]  ; xTickCount
;;;4696   
;;;4697   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;4698   	{
;;;4699   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;4700   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;4701   		when the task leaves the Blocked state. */
;;;4702   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;4703   	}
;;;4704   	#endif
;;;4705   
;;;4706   	/* Remove the task from the ready list before adding it to the blocked list
;;;4707   	as the same list item is used for both lists. */
;;;4708   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  e59f009c          LDR      r0,|L3.184|
000018  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
00001c  e2800004          ADD      r0,r0,#4
000020  ebfffffe          BL       uxListRemove
;;;4709   	{
;;;4710   		/* The current task must be in a ready list, so there is no need to
;;;4711   		check, and the port reset macro can be called directly. */
;;;4712   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;4713   	}
;;;4714   	else
;;;4715   	{
;;;4716   		mtCOVERAGE_TEST_MARKER();
;;;4717   	}
;;;4718   
;;;4719   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;4720   	{
;;;4721   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
000024  e3750001          CMN      r5,#1
000028  1a000007          BNE      |L3.76|
00002c  e3560000          CMP      r6,#0
000030  0a000005          BEQ      |L3.76|
;;;4722   		{
;;;4723   			/* Add the task to the suspended task list instead of a delayed task
;;;4724   			list to ensure it is not woken by a timing event.  It will block
;;;4725   			indefinitely. */
;;;4726   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
000034  e59f007c          LDR      r0,|L3.184|
000038  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
00003c  e2801004          ADD      r1,r0,#4
000040  e59f0074          LDR      r0,|L3.188|
000044  ebfffffe          BL       vListInsertEnd
000048  ea000018          B        |L3.176|
                  |L3.76|
;;;4727   		}
;;;4728   		else
;;;4729   		{
;;;4730   			/* Calculate the time at which the task should be woken if the event
;;;4731   			does not occur.  This may overflow but this doesn't matter, the
;;;4732   			kernel will manage it correctly. */
;;;4733   			xTimeToWake = xConstTickCount + xTicksToWait;
00004c  e0874005          ADD      r4,r7,r5
;;;4734   
;;;4735   			/* The list item will be inserted in wake time order. */
;;;4736   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
000050  e59f0060          LDR      r0,|L3.184|
000054  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000058  e5804004          STR      r4,[r0,#4]
;;;4737   
;;;4738   			if( xTimeToWake < xConstTickCount )
00005c  e1540007          CMP      r4,r7
000060  2a000006          BCS      |L3.128|
;;;4739   			{
;;;4740   				/* Wake time has overflowed.  Place this item in the overflow
;;;4741   				list. */
;;;4742   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
000064  e59f004c          LDR      r0,|L3.184|
000068  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
00006c  e2801004          ADD      r1,r0,#4
000070  e59f0048          LDR      r0,|L3.192|
000074  e5900000          LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000078  ebfffffe          BL       vListInsert
00007c  ea00000b          B        |L3.176|
                  |L3.128|
;;;4743   			}
;;;4744   			else
;;;4745   			{
;;;4746   				/* The wake time has not overflowed, so the current block list
;;;4747   				is used. */
;;;4748   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
000080  e59f0030          LDR      r0,|L3.184|
000084  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000088  e2801004          ADD      r1,r0,#4
00008c  e59f0030          LDR      r0,|L3.196|
000090  e5900000          LDR      r0,[r0,#0]  ; pxDelayedTaskList
000094  ebfffffe          BL       vListInsert
;;;4749   
;;;4750   				/* If the task entering the blocked state was placed at the
;;;4751   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;4752   				needs to be updated too. */
;;;4753   				if( xTimeToWake < xNextTaskUnblockTime )
000098  e59f0028          LDR      r0,|L3.200|
00009c  e5900000          LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
0000a0  e1540000          CMP      r4,r0
0000a4  2a000001          BCS      |L3.176|
;;;4754   				{
;;;4755   					xNextTaskUnblockTime = xTimeToWake;
0000a8  e59f0018          LDR      r0,|L3.200|
0000ac  e5804000          STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L3.176|
;;;4756   				}
;;;4757   				else
;;;4758   				{
;;;4759   					mtCOVERAGE_TEST_MARKER();
;;;4760   				}
;;;4761   			}
;;;4762   		}
;;;4763   	}
;;;4764   	#else /* INCLUDE_vTaskSuspend */
;;;4765   	{
;;;4766   		/* Calculate the time at which the task should be woken if the event
;;;4767   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;4768   		will manage it correctly. */
;;;4769   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;4770   
;;;4771   		/* The list item will be inserted in wake time order. */
;;;4772   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;4773   
;;;4774   		if( xTimeToWake < xConstTickCount )
;;;4775   		{
;;;4776   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;4777   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4778   		}
;;;4779   		else
;;;4780   		{
;;;4781   			/* The wake time has not overflowed, so the current block list is used. */
;;;4782   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4783   
;;;4784   			/* If the task entering the blocked state was placed at the head of the
;;;4785   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;4786   			too. */
;;;4787   			if( xTimeToWake < xNextTaskUnblockTime )
;;;4788   			{
;;;4789   				xNextTaskUnblockTime = xTimeToWake;
;;;4790   			}
;;;4791   			else
;;;4792   			{
;;;4793   				mtCOVERAGE_TEST_MARKER();
;;;4794   			}
;;;4795   		}
;;;4796   
;;;4797   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;4798   		( void ) xCanBlockIndefinitely;
;;;4799   	}
;;;4800   	#endif /* INCLUDE_vTaskSuspend */
;;;4801   }
0000b0  e8bd81f0          POP      {r4-r8,pc}
;;;4802   
                          ENDP

                  |L3.180|
                          DCD      xTickCount
                  |L3.184|
                          DCD      pxCurrentTCB
                  |L3.188|
                          DCD      xSuspendedTaskList
                  |L3.192|
                          DCD      pxOverflowDelayedTaskList
                  |L3.196|
                          DCD      pxDelayedTaskList
                  |L3.200|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvAddNewTaskToReadyList||, CODE, READONLY, ALIGN=2

                  prvAddNewTaskToReadyList PROC
;;;962    
;;;963    static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  e92d4010          PUSH     {r4,lr}
;;;964    {
000004  e1a04000          MOV      r4,r0
;;;965    	/* Ensure interrupts don't access the task lists while the lists are being
;;;966    	updated. */
;;;967    	taskENTER_CRITICAL();
000008  ebfffffe          BL       vPortEnterCritical
;;;968    	{
;;;969    		uxCurrentNumberOfTasks++;
00000c  e59f00f8          LDR      r0,|L4.268|
000010  e5900000          LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000014  e2800001          ADD      r0,r0,#1
000018  e59f10ec          LDR      r1,|L4.268|
00001c  e5810000          STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;970    		if( pxCurrentTCB == NULL )
000020  e59f00e8          LDR      r0,|L4.272|
000024  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000028  e3500000          CMP      r0,#0
00002c  1a000007          BNE      |L4.80|
;;;971    		{
;;;972    			/* There are no other tasks, or all the other tasks are in
;;;973    			the suspended state - make this the current task. */
;;;974    			pxCurrentTCB = pxNewTCB;
000030  e59f00d8          LDR      r0,|L4.272|
000034  e5804000          STR      r4,[r0,#0]  ; pxCurrentTCB
;;;975    
;;;976    			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
000038  e2810000          ADD      r0,r1,#0
00003c  e5900000          LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000040  e3500001          CMP      r0,#1
000044  1a00000d          BNE      |L4.128|
;;;977    			{
;;;978    				/* This is the first task to be created so do the preliminary
;;;979    				initialisation required.  We will not recover if this call
;;;980    				fails, but we will report the failure. */
;;;981    				prvInitialiseTaskLists();
000048  ebfffffe          BL       prvInitialiseTaskLists
00004c  ea00000b          B        |L4.128|
                  |L4.80|
;;;982    			}
;;;983    			else
;;;984    			{
;;;985    				mtCOVERAGE_TEST_MARKER();
;;;986    			}
;;;987    		}
;;;988    		else
;;;989    		{
;;;990    			/* If the scheduler is not already running, make this task the
;;;991    			current task if it is the highest priority task to be created
;;;992    			so far. */
;;;993    			if( xSchedulerRunning == pdFALSE )
000050  e59f00bc          LDR      r0,|L4.276|
000054  e5900000          LDR      r0,[r0,#0]  ; xSchedulerRunning
000058  e3500000          CMP      r0,#0
00005c  1a000007          BNE      |L4.128|
;;;994    			{
;;;995    				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
000060  e59f00a8          LDR      r0,|L4.272|
000064  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000068  e590002c          LDR      r0,[r0,#0x2c]
00006c  e594102c          LDR      r1,[r4,#0x2c]
000070  e1500001          CMP      r0,r1
000074  8a000001          BHI      |L4.128|
;;;996    				{
;;;997    					pxCurrentTCB = pxNewTCB;
000078  e59f0090          LDR      r0,|L4.272|
00007c  e5804000          STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L4.128|
;;;998    				}
;;;999    				else
;;;1000   				{
;;;1001   					mtCOVERAGE_TEST_MARKER();
;;;1002   				}
;;;1003   			}
;;;1004   			else
;;;1005   			{
;;;1006   				mtCOVERAGE_TEST_MARKER();
;;;1007   			}
;;;1008   		}
;;;1009   
;;;1010   		uxTaskNumber++;
000080  e59f0090          LDR      r0,|L4.280|
000084  e5900000          LDR      r0,[r0,#0]  ; uxTaskNumber
000088  e2800001          ADD      r0,r0,#1
00008c  e59f1084          LDR      r1,|L4.280|
000090  e5810000          STR      r0,[r1,#0]  ; uxTaskNumber
;;;1011   
;;;1012   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1013   		{
;;;1014   			/* Add a counter into the TCB for tracing only. */
;;;1015   			pxNewTCB->uxTCBNumber = uxTaskNumber;
000094  e2810000          ADD      r0,r1,#0
000098  e5900000          LDR      r0,[r0,#0]  ; uxTaskNumber
00009c  e584003c          STR      r0,[r4,#0x3c]
;;;1016   		}
;;;1017   		#endif /* configUSE_TRACE_FACILITY */
;;;1018   		traceTASK_CREATE( pxNewTCB );
;;;1019   
;;;1020   		prvAddTaskToReadyList( pxNewTCB );
0000a0  e59f1074          LDR      r1,|L4.284|
0000a4  e594002c          LDR      r0,[r4,#0x2c]
0000a8  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000ac  e1500001          CMP      r0,r1
0000b0  9a000002          BLS      |L4.192|
0000b4  e59f1060          LDR      r1,|L4.284|
0000b8  e594002c          LDR      r0,[r4,#0x2c]
0000bc  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L4.192|
0000c0  e594102c          LDR      r1,[r4,#0x2c]
0000c4  e0811101          ADD      r1,r1,r1,LSL #2
0000c8  e59f2050          LDR      r2,|L4.288|
0000cc  e0820101          ADD      r0,r2,r1,LSL #2
0000d0  e2841004          ADD      r1,r4,#4
0000d4  ebfffffe          BL       vListInsertEnd
;;;1021   
;;;1022   		portSETUP_TCB( pxNewTCB );
;;;1023   	}
;;;1024   	taskEXIT_CRITICAL();
0000d8  ebfffffe          BL       vPortExitCritical
;;;1025   
;;;1026   	if( xSchedulerRunning != pdFALSE )
0000dc  e59f0030          LDR      r0,|L4.276|
0000e0  e5900000          LDR      r0,[r0,#0]  ; xSchedulerRunning
0000e4  e3500000          CMP      r0,#0
0000e8  0a000006          BEQ      |L4.264|
;;;1027   	{
;;;1028   		/* If the created task is of a higher priority than the current task
;;;1029   		then it should run now. */
;;;1030   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
0000ec  e59f001c          LDR      r0,|L4.272|
0000f0  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
0000f4  e590002c          LDR      r0,[r0,#0x2c]
0000f8  e594102c          LDR      r1,[r4,#0x2c]
0000fc  e1500001          CMP      r0,r1
000100  2a000000          BCS      |L4.264|
;;;1031   		{
;;;1032   			taskYIELD_IF_USING_PREEMPTION();
000104  ebfffffe          BL       vPortYield
                  |L4.264|
;;;1033   		}
;;;1034   		else
;;;1035   		{
;;;1036   			mtCOVERAGE_TEST_MARKER();
;;;1037   		}
;;;1038   	}
;;;1039   	else
;;;1040   	{
;;;1041   		mtCOVERAGE_TEST_MARKER();
;;;1042   	}
;;;1043   }
000108  e8bd8010          POP      {r4,pc}
;;;1044   /*-----------------------------------------------------------*/
                          ENDP

                  |L4.268|
                          DCD      uxCurrentNumberOfTasks
                  |L4.272|
                          DCD      pxCurrentTCB
                  |L4.276|
                          DCD      xSchedulerRunning
                  |L4.280|
                          DCD      uxTaskNumber
                  |L4.284|
                          DCD      uxTopReadyPriority
                  |L4.288|
                          DCD      pxReadyTasksLists

                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;3364   
;;;3365   static void prvCheckTasksWaitingTermination( void )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;3366   {
;;;3367   
;;;3368   	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
;;;3369   
;;;3370   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3371   	{
;;;3372   		BaseType_t xListIsEmpty;
;;;3373   
;;;3374   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;3375   		too often in the idle task. */
;;;3376   		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
000004  ea00001f          B        |L5.136|
                  |L5.8|
;;;3377   		{
;;;3378   			vTaskSuspendAll();
000008  ebfffffe          BL       vTaskSuspendAll
;;;3379   			{
;;;3380   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
00000c  e59f0088          LDR      r0,|L5.156|
000010  e5900000          LDR      r0,[r0,#0]  ; xTasksWaitingTermination
000014  e3500000          CMP      r0,#0
000018  1a000001          BNE      |L5.36|
00001c  e3a00001          MOV      r0,#1
000020  ea000000          B        |L5.40|
                  |L5.36|
000024  e3a00000          MOV      r0,#0
                  |L5.40|
000028  e1a05000          MOV      r5,r0
;;;3381   			}
;;;3382   			( void ) xTaskResumeAll();
00002c  ebfffffe          BL       xTaskResumeAll
;;;3383   
;;;3384   			if( xListIsEmpty == pdFALSE )
000030  e3550000          CMP      r5,#0
000034  1a000013          BNE      |L5.136|
;;;3385   			{
;;;3386   				TCB_t *pxTCB;
;;;3387   
;;;3388   				taskENTER_CRITICAL();
000038  ebfffffe          BL       vPortEnterCritical
;;;3389   				{
;;;3390   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
00003c  e59f0058          LDR      r0,|L5.156|
000040  e590000c          LDR      r0,[r0,#0xc]
000044  e590400c          LDR      r4,[r0,#0xc]
;;;3391   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000048  e2840004          ADD      r0,r4,#4
00004c  ebfffffe          BL       uxListRemove
;;;3392   					--uxCurrentNumberOfTasks;
000050  e59f0048          LDR      r0,|L5.160|
000054  e5900000          LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000058  e2400001          SUB      r0,r0,#1
00005c  e59f103c          LDR      r1,|L5.160|
000060  e5810000          STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;3393   					--uxDeletedTasksWaitingCleanUp;
000064  e59f0038          LDR      r0,|L5.164|
000068  e5900000          LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
00006c  e2400001          SUB      r0,r0,#1
000070  e59f102c          LDR      r1,|L5.164|
000074  e5810000          STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
;;;3394   				}
;;;3395   				taskEXIT_CRITICAL();
000078  ebfffffe          BL       vPortExitCritical
;;;3396   
;;;3397   				prvDeleteTCB( pxTCB );
00007c  e1a00004          MOV      r0,r4
000080  ebfffffe          BL       prvDeleteTCB
;;;3398   			}
000084  e1a00000          MOV      r0,r0
                  |L5.136|
000088  e59f0014          LDR      r0,|L5.164|
00008c  e5900000          LDR      r0,[r0,#0]            ;3376  ; uxDeletedTasksWaitingCleanUp
000090  e3500000          CMP      r0,#0                 ;3376
000094  1affffdb          BNE      |L5.8|
;;;3399   			else
;;;3400   			{
;;;3401   				mtCOVERAGE_TEST_MARKER();
;;;3402   			}
;;;3403   		}
;;;3404   	}
;;;3405   	#endif /* INCLUDE_vTaskDelete */
;;;3406   }
000098  e8bd8070          POP      {r4-r6,pc}
;;;3407   /*-----------------------------------------------------------*/
                          ENDP

                  |L5.156|
                          DCD      xTasksWaitingTermination
                  |L5.160|
                          DCD      uxCurrentNumberOfTasks
                  |L5.164|
                          DCD      uxDeletedTasksWaitingCleanUp

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=2

                  prvDeleteTCB PROC
;;;3580   
;;;3581   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  e92d4010          PUSH     {r4,lr}
;;;3582   	{
000004  e1a04000          MOV      r4,r0
;;;3583   		/* This call is required specifically for the TriCore port.  It must be
;;;3584   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3585   		want to allocate and clean RAM statically. */
;;;3586   		portCLEAN_UP_TCB( pxTCB );
;;;3587   
;;;3588   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3589   		to the task to free any memory allocated at the application level. */
;;;3590   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3591   		{
;;;3592   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3593   		}
;;;3594   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3595   
;;;3596   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3597   		{
;;;3598   			/* The task can only have been allocated dynamically - free both
;;;3599   			the stack and TCB. */
;;;3600   			vPortFree( pxTCB->pxStack );
000008  e5940030          LDR      r0,[r4,#0x30]
00000c  ebfffffe          BL       vPortFree
;;;3601   			vPortFree( pxTCB );
000010  e1a00004          MOV      r0,r4
000014  ebfffffe          BL       vPortFree
;;;3602   		}
;;;3603   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
;;;3604   		{
;;;3605   			/* The task could have been allocated statically or dynamically, so
;;;3606   			check what was statically allocated before trying to free the
;;;3607   			memory. */
;;;3608   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
;;;3609   			{
;;;3610   				/* Both the stack and TCB were allocated dynamically, so both
;;;3611   				must be freed. */
;;;3612   				vPortFree( pxTCB->pxStack );
;;;3613   				vPortFree( pxTCB );
;;;3614   			}
;;;3615   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
;;;3616   			{
;;;3617   				/* Only the stack was statically allocated, so the TCB is the
;;;3618   				only memory that must be freed. */
;;;3619   				vPortFree( pxTCB );
;;;3620   			}
;;;3621   			else
;;;3622   			{
;;;3623   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3624   				nothing needs to be freed. */
;;;3625   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
;;;3626   				mtCOVERAGE_TEST_MARKER();
;;;3627   			}
;;;3628   		}
;;;3629   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3630   	}
000018  e8bd8010          POP      {r4,pc}
;;;3631   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;3130    */
;;;3131   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  e1a00000          MOV      r0,r0
                  |L7.4|
;;;3132   {
;;;3133   	/* Stop warnings. */
;;;3134   	( void ) pvParameters;
;;;3135   
;;;3136   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3137   	SCHEDULER IS STARTED. **/
;;;3138   
;;;3139   	for( ;; )
;;;3140   	{
;;;3141   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3142   		is responsible for freeing the deleted task's TCB and stack. */
;;;3143   		prvCheckTasksWaitingTermination();
000004  ebfffffe          BL       prvCheckTasksWaitingTermination
;;;3144   
;;;3145   		#if ( configUSE_PREEMPTION == 0 )
;;;3146   		{
;;;3147   			/* If we are not using preemption we keep forcing a task switch to
;;;3148   			see if any other task has become available.  If we are using
;;;3149   			preemption we don't need to do this as any task becoming available
;;;3150   			will automatically get the processor anyway. */
;;;3151   			taskYIELD();
;;;3152   		}
;;;3153   		#endif /* configUSE_PREEMPTION */
;;;3154   
;;;3155   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3156   		{
;;;3157   			/* When using preemption tasks of equal priority will be
;;;3158   			timesliced.  If a task that is sharing the idle priority is ready
;;;3159   			to run then the idle task should yield before the end of the
;;;3160   			timeslice.
;;;3161   
;;;3162   			A critical region is not required here as we are just reading from
;;;3163   			the list, and an occasional incorrect value will not matter.  If
;;;3164   			the ready list at the idle priority contains more than one task
;;;3165   			then a task other than the idle task is ready to execute. */
;;;3166   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000008  e59f0010          LDR      r0,|L7.32|
00000c  e5900000          LDR      r0,[r0,#0]  ; pxReadyTasksLists
000010  e3500001          CMP      r0,#1
000014  9afffffa          BLS      |L7.4|
;;;3167   			{
;;;3168   				taskYIELD();
000018  ebfffffe          BL       vPortYield
00001c  eafffff8          B        |L7.4|
;;;3169   			}
;;;3170   			else
;;;3171   			{
;;;3172   				mtCOVERAGE_TEST_MARKER();
;;;3173   			}
;;;3174   		}
;;;3175   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3176   
;;;3177   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3178   		{
;;;3179   			extern void vApplicationIdleHook( void );
;;;3180   
;;;3181   			/* Call the user defined function from within the idle task.  This
;;;3182   			allows the application designer to add background functionality
;;;3183   			without the overhead of a separate task.
;;;3184   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3185   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3186   			vApplicationIdleHook();
;;;3187   		}
;;;3188   		#endif /* configUSE_IDLE_HOOK */
;;;3189   
;;;3190   		/* This conditional compilation should use inequality to 0, not equality
;;;3191   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3192   		user defined low power mode	implementations require
;;;3193   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3194   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3195   		{
;;;3196   		TickType_t xExpectedIdleTime;
;;;3197   
;;;3198   			/* It is not desirable to suspend then resume the scheduler on
;;;3199   			each iteration of the idle task.  Therefore, a preliminary
;;;3200   			test of the expected idle time is performed without the
;;;3201   			scheduler suspended.  The result here is not necessarily
;;;3202   			valid. */
;;;3203   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3204   
;;;3205   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3206   			{
;;;3207   				vTaskSuspendAll();
;;;3208   				{
;;;3209   					/* Now the scheduler is suspended, the expected idle
;;;3210   					time can be sampled again, and this time its value can
;;;3211   					be used. */
;;;3212   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3213   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3214   
;;;3215   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3216   					{
;;;3217   						traceLOW_POWER_IDLE_BEGIN();
;;;3218   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3219   						traceLOW_POWER_IDLE_END();
;;;3220   					}
;;;3221   					else
;;;3222   					{
;;;3223   						mtCOVERAGE_TEST_MARKER();
;;;3224   					}
;;;3225   				}
;;;3226   				( void ) xTaskResumeAll();
;;;3227   			}
;;;3228   			else
;;;3229   			{
;;;3230   				mtCOVERAGE_TEST_MARKER();
;;;3231   			}
;;;3232   		}
;;;3233   		#endif /* configUSE_TICKLESS_IDLE */
;;;3234   	}
;;;3235   }
;;;3236   /*-----------------------------------------------------------*/
                          ENDP

                  |L7.32|
                          DCD      pxReadyTasksLists

                          AREA ||i.prvInitialiseNewTask||, CODE, READONLY, ALIGN=2

                  prvInitialiseNewTask PROC
;;;766    
;;;767    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;768    									const char * const pcName,
;;;769    									const uint32_t ulStackDepth,
;;;770    									void * const pvParameters,
;;;771    									UBaseType_t uxPriority,
;;;772    									TaskHandle_t * const pxCreatedTask,
;;;773    									TCB_t *pxNewTCB,
;;;774    									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;775    {
000004  e1a0a000          MOV      r10,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a07002          MOV      r7,r2
000010  e1a0b003          MOV      r11,r3
000014  e59d4030          LDR      r4,[sp,#0x30]
000018  e59d8028          LDR      r8,[sp,#0x28]
;;;776    StackType_t *pxTopOfStack;
;;;777    UBaseType_t x;
;;;778    
;;;779    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;780    		/* Should the task be created in privileged mode? */
;;;781    		BaseType_t xRunPrivileged;
;;;782    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;783    		{
;;;784    			xRunPrivileged = pdTRUE;
;;;785    		}
;;;786    		else
;;;787    		{
;;;788    			xRunPrivileged = pdFALSE;
;;;789    		}
;;;790    		uxPriority &= ~portPRIVILEGE_BIT;
;;;791    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;792    
;;;793    	/* Avoid dependency on memset() if it is not required. */
;;;794    	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
;;;795    	{
;;;796    		/* Fill the stack with a known value to assist debugging. */
;;;797    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
00001c  e1a01107          LSL      r1,r7,#2
000020  e3a020a5          MOV      r2,#0xa5
000024  e5940030          LDR      r0,[r4,#0x30]
000028  ebfffffe          BL       __aeabi_memset
;;;798    	}
;;;799    	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
;;;800    
;;;801    	/* Calculate the top of stack address.  This depends on whether the stack
;;;802    	grows from high memory to low (as per the 80x86) or vice versa.
;;;803    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;804    	by the port. */
;;;805    	#if( portSTACK_GROWTH < 0 )
;;;806    	{
;;;807    		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
00002c  e2471001          SUB      r1,r7,#1
000030  e5940030          LDR      r0,[r4,#0x30]
000034  e0809101          ADD      r9,r0,r1,LSL #2
;;;808    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
000038  e3c99007          BIC      r9,r9,#7
;;;809    
;;;810    		/* Check the alignment of the calculated top of stack is correct. */
;;;811    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
00003c  e2090007          AND      r0,r9,#7
000040  e3500000          CMP      r0,#0
000044  1a000001          BNE      |L8.80|
000048  e3a00001          MOV      r0,#1
00004c  ea000000          B        |L8.84|
                  |L8.80|
000050  e3a00000          MOV      r0,#0
                  |L8.84|
000054  e3500000          CMP      r0,#0
000058  1a000005          BNE      |L8.116|
00005c  e1a00000          MOV      r0,r0
000060  e28f20b0          ADR      r2,|L8.280|
000064  e59f10c4          LDR      r1,|L8.304|
000068  e28f00c4          ADR      r0,|L8.308|
00006c  ebfffffe          BL       sysprintf
000070  e1a00000          MOV      r0,r0
                  |L8.116|
;;;812    	}
;;;813    	#else /* portSTACK_GROWTH */
;;;814    	{
;;;815    		pxTopOfStack = pxNewTCB->pxStack;
;;;816    
;;;817    		/* Check the alignment of the stack buffer is correct. */
;;;818    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;819    
;;;820    		/* The other extreme of the stack space is required if stack checking is
;;;821    		performed. */
;;;822    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;823    	}
;;;824    	#endif /* portSTACK_GROWTH */
;;;825    
;;;826    	/* Store the task name in the TCB. */
;;;827    	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
000074  e3a05000          MOV      r5,#0
000078  ea000007          B        |L8.156|
                  |L8.124|
;;;828    	{
;;;829    		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
00007c  e7d60005          LDRB     r0,[r6,r5]
000080  e2841034          ADD      r1,r4,#0x34
000084  e7c10005          STRB     r0,[r1,r5]
;;;830    
;;;831    		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;832    		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;833    		string is not accessible (extremely unlikely). */
;;;834    		if( pcName[ x ] == 0x00 )
000088  e7d60005          LDRB     r0,[r6,r5]
00008c  e3500000          CMP      r0,#0
000090  1a000000          BNE      |L8.152|
;;;835    		{
;;;836    			break;
000094  ea000002          B        |L8.164|
                  |L8.152|
000098  e2855001          ADD      r5,r5,#1              ;827
                  |L8.156|
00009c  e3550008          CMP      r5,#8                 ;827
0000a0  3afffff5          BCC      |L8.124|
                  |L8.164|
0000a4  e1a00000          MOV      r0,r0
;;;837    		}
;;;838    		else
;;;839    		{
;;;840    			mtCOVERAGE_TEST_MARKER();
;;;841    		}
;;;842    	}
;;;843    
;;;844    	/* Ensure the name string is terminated in the case that the string length
;;;845    	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;846    	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
0000a8  e3a00000          MOV      r0,#0
0000ac  e5c4003b          STRB     r0,[r4,#0x3b]
;;;847    
;;;848    	/* This is used as an array index so must ensure it's not too large.  First
;;;849    	remove the privilege bit if one is present. */
;;;850    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
0000b0  e3580020          CMP      r8,#0x20
0000b4  3a000000          BCC      |L8.188|
;;;851    	{
;;;852    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
0000b8  e3a0801f          MOV      r8,#0x1f
                  |L8.188|
;;;853    	}
;;;854    	else
;;;855    	{
;;;856    		mtCOVERAGE_TEST_MARKER();
;;;857    	}
;;;858    
;;;859    	pxNewTCB->uxPriority = uxPriority;
0000bc  e584802c          STR      r8,[r4,#0x2c]
;;;860    	#if ( configUSE_MUTEXES == 1 )
;;;861    	{
;;;862    		pxNewTCB->uxBasePriority = uxPriority;
;;;863    		pxNewTCB->uxMutexesHeld = 0;
;;;864    	}
;;;865    	#endif /* configUSE_MUTEXES */
;;;866    
;;;867    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
0000c0  e2840004          ADD      r0,r4,#4
0000c4  ebfffffe          BL       vListInitialiseItem
;;;868    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
0000c8  e2840018          ADD      r0,r4,#0x18
0000cc  ebfffffe          BL       vListInitialiseItem
;;;869    
;;;870    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;871    	back to	the containing TCB from a generic item in a list. */
;;;872    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
0000d0  e5844010          STR      r4,[r4,#0x10]
;;;873    
;;;874    	/* Event lists are always in priority order. */
;;;875    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0000d4  e2680020          RSB      r0,r8,#0x20
0000d8  e5840018          STR      r0,[r4,#0x18]
;;;876    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
0000dc  e5844024          STR      r4,[r4,#0x24]
;;;877    
;;;878    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;879    	{
;;;880    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;881    	}
;;;882    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;883    
;;;884    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;885    	{
;;;886    		pxNewTCB->pxTaskTag = NULL;
;;;887    	}
;;;888    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;889    
;;;890    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;891    	{
;;;892    		pxNewTCB->ulRunTimeCounter = 0UL;
;;;893    	}
;;;894    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;895    
;;;896    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;897    	{
;;;898    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;899    	}
;;;900    	#else
;;;901    	{
;;;902    		/* Avoid compiler warning about unreferenced parameter. */
;;;903    		( void ) xRegions;
;;;904    	}
;;;905    	#endif
;;;906    
;;;907    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;908    	{
;;;909    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;910    		{
;;;911    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;912    		}
;;;913    	}
;;;914    	#endif
;;;915    
;;;916    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;917    	{
;;;918    		pxNewTCB->ulNotifiedValue = 0;
0000e0  e3a00000          MOV      r0,#0
0000e4  e5840044          STR      r0,[r4,#0x44]
;;;919    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
0000e8  e5c40048          STRB     r0,[r4,#0x48]
;;;920    	}
;;;921    	#endif
;;;922    
;;;923    	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;924    	{
;;;925    		/* Initialise this task's Newlib reent structure. */
;;;926    		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;927    	}
;;;928    	#endif
;;;929    
;;;930    	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;931    	{
;;;932    		pxNewTCB->ucDelayAborted = pdFALSE;
;;;933    	}
;;;934    	#endif
;;;935    
;;;936    	/* Initialize the TCB stack to look as if the task was already running,
;;;937    	but had been interrupted by the scheduler.  The return address is set
;;;938    	to the start of the task function. Once the stack has been initialised
;;;939    	the	top of stack variable is updated. */
;;;940    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;941    	{
;;;942    		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;943    	}
;;;944    	#else /* portUSING_MPU_WRAPPERS */
;;;945    	{
;;;946    		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
0000ec  e1a0200b          MOV      r2,r11
0000f0  e1a0100a          MOV      r1,r10
0000f4  e1a00009          MOV      r0,r9
0000f8  ebfffffe          BL       pxPortInitialiseStack
0000fc  e5840000          STR      r0,[r4,#0]
;;;947    	}
;;;948    	#endif /* portUSING_MPU_WRAPPERS */
;;;949    
;;;950    	if( ( void * ) pxCreatedTask != NULL )
000100  e59d002c          LDR      r0,[sp,#0x2c]
000104  e3500000          CMP      r0,#0
000108  0a000001          BEQ      |L8.276|
;;;951    	{
;;;952    		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;953    		change the created task's priority, delete the created task, etc.*/
;;;954    		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
00010c  e59d002c          LDR      r0,[sp,#0x2c]
000110  e5804000          STR      r4,[r0,#0]
                  |L8.276|
;;;955    	}
;;;956    	else
;;;957    	{
;;;958    		mtCOVERAGE_TEST_MARKER();
;;;959    	}
;;;960    }
000114  e8bd9ff0          POP      {r4-r12,pc}
;;;961    /*-----------------------------------------------------------*/
                          ENDP

                  |L8.280|
000118  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
00011c  52544f53
000120  5c536f75
000124  7263655c
000128  7461736b
00012c  732e6300
                  |L8.304|
                          DCD      0x0000032b
                  |L8.308|
000134  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000138  7274696f
00013c  6e202220
000140  3f3f3f20
000144  22206661
000148  696c6564
00014c  20617420
000150  6c696e65
000154  20256420
000158  696e2025
00015c  730a00  
00015f  00                DCB      0

                          AREA ||i.prvInitialiseTaskLists||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;3332   
;;;3333   static void prvInitialiseTaskLists( void )
000000  e92d4010          PUSH     {r4,lr}
;;;3334   {
;;;3335   UBaseType_t uxPriority;
;;;3336   
;;;3337   	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000004  e3a04000          MOV      r4,#0
000008  ea000004          B        |L9.32|
                  |L9.12|
;;;3338   	{
;;;3339   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
00000c  e0841104          ADD      r1,r4,r4,LSL #2
000010  e59f2054          LDR      r2,|L9.108|
000014  e0820101          ADD      r0,r2,r1,LSL #2
000018  ebfffffe          BL       vListInitialise
00001c  e2844001          ADD      r4,r4,#1              ;3337
                  |L9.32|
000020  e3540020          CMP      r4,#0x20              ;3337
000024  3afffff8          BCC      |L9.12|
;;;3340   	}
;;;3341   
;;;3342   	vListInitialise( &xDelayedTaskList1 );
000028  e59f0040          LDR      r0,|L9.112|
00002c  ebfffffe          BL       vListInitialise
;;;3343   	vListInitialise( &xDelayedTaskList2 );
000030  e59f003c          LDR      r0,|L9.116|
000034  ebfffffe          BL       vListInitialise
;;;3344   	vListInitialise( &xPendingReadyList );
000038  e59f0038          LDR      r0,|L9.120|
00003c  ebfffffe          BL       vListInitialise
;;;3345   
;;;3346   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3347   	{
;;;3348   		vListInitialise( &xTasksWaitingTermination );
000040  e59f0034          LDR      r0,|L9.124|
000044  ebfffffe          BL       vListInitialise
;;;3349   	}
;;;3350   	#endif /* INCLUDE_vTaskDelete */
;;;3351   
;;;3352   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;3353   	{
;;;3354   		vListInitialise( &xSuspendedTaskList );
000048  e59f0030          LDR      r0,|L9.128|
00004c  ebfffffe          BL       vListInitialise
;;;3355   	}
;;;3356   	#endif /* INCLUDE_vTaskSuspend */
;;;3357   
;;;3358   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;3359   	using list2. */
;;;3360   	pxDelayedTaskList = &xDelayedTaskList1;
000050  e59f0018          LDR      r0,|L9.112|
000054  e59f1028          LDR      r1,|L9.132|
000058  e5810000          STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;3361   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00005c  e59f0010          LDR      r0,|L9.116|
000060  e59f1020          LDR      r1,|L9.136|
000064  e5810000          STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;3362   }
000068  e8bd8010          POP      {r4,pc}
;;;3363   /*-----------------------------------------------------------*/
                          ENDP

                  |L9.108|
                          DCD      pxReadyTasksLists
                  |L9.112|
                          DCD      xDelayedTaskList1
                  |L9.116|
                          DCD      xDelayedTaskList2
                  |L9.120|
                          DCD      xPendingReadyList
                  |L9.124|
                          DCD      xTasksWaitingTermination
                  |L9.128|
                          DCD      xSuspendedTaskList
                  |L9.132|
                          DCD      pxDelayedTaskList
                  |L9.136|
                          DCD      pxOverflowDelayedTaskList

                          AREA ||i.prvListTasksWithinSingleList||, CODE, READONLY, ALIGN=2

                  prvListTasksWithinSingleList PROC
;;;3499   
;;;3500   	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3501   	{
000004  e1a07000          MOV      r7,r0
000008  e1a04001          MOV      r4,r1
00000c  e1a08002          MOV      r8,r2
;;;3502   	volatile TCB_t *pxNextTCB, *pxFirstTCB;
;;;3503   	UBaseType_t uxTask = 0;
000010  e3a06000          MOV      r6,#0
;;;3504   
;;;3505   		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
000014  e5940000          LDR      r0,[r4,#0]
000018  e3500000          CMP      r0,#0
00001c  0a000023          BEQ      |L10.176|
;;;3506   		{
;;;3507   			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
000020  e1a00004          MOV      r0,r4
000024  e5901004          LDR      r1,[r0,#4]
000028  e5911004          LDR      r1,[r1,#4]
00002c  e5801004          STR      r1,[r0,#4]
000030  e5901004          LDR      r1,[r0,#4]
000034  e2802008          ADD      r2,r0,#8
000038  e1510002          CMP      r1,r2
00003c  1a000002          BNE      |L10.76|
000040  e5901004          LDR      r1,[r0,#4]
000044  e5911004          LDR      r1,[r1,#4]
000048  e5801004          STR      r1,[r0,#4]
                  |L10.76|
00004c  e5901004          LDR      r1,[r0,#4]
000050  e591900c          LDR      r9,[r1,#0xc]
;;;3508   
;;;3509   			/* Populate an TaskStatus_t structure within the
;;;3510   			pxTaskStatusArray array for each task that is referenced from
;;;3511   			pxList.  See the definition of TaskStatus_t in task.h for the
;;;3512   			meaning of each TaskStatus_t structure member. */
;;;3513   			do
000054  e1a00000          MOV      r0,r0
                  |L10.88|
;;;3514   			{
;;;3515   				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
000058  e1a00004          MOV      r0,r4
00005c  e5901004          LDR      r1,[r0,#4]
000060  e5911004          LDR      r1,[r1,#4]
000064  e5801004          STR      r1,[r0,#4]
000068  e5901004          LDR      r1,[r0,#4]
00006c  e2802008          ADD      r2,r0,#8
000070  e1510002          CMP      r1,r2
000074  1a000002          BNE      |L10.132|
000078  e5901004          LDR      r1,[r0,#4]
00007c  e5911004          LDR      r1,[r1,#4]
000080  e5801004          STR      r1,[r0,#4]
                  |L10.132|
000084  e5901004          LDR      r1,[r0,#4]
000088  e591500c          LDR      r5,[r1,#0xc]
;;;3516   				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
00008c  e0860186          ADD      r0,r6,r6,LSL #3
000090  e0871100          ADD      r1,r7,r0,LSL #2
000094  e1a03008          MOV      r3,r8
000098  e3a02001          MOV      r2,#1
00009c  e1a00005          MOV      r0,r5
0000a0  ebfffffe          BL       vTaskGetInfo
;;;3517   				uxTask++;
0000a4  e2866001          ADD      r6,r6,#1
;;;3518   			} while( pxNextTCB != pxFirstTCB );
0000a8  e1550009          CMP      r5,r9
0000ac  1affffe9          BNE      |L10.88|
                  |L10.176|
;;;3519   		}
;;;3520   		else
;;;3521   		{
;;;3522   			mtCOVERAGE_TEST_MARKER();
;;;3523   		}
;;;3524   
;;;3525   		return uxTask;
0000b0  e1a00006          MOV      r0,r6
;;;3526   	}
0000b4  e8bd87f0          POP      {r4-r10,pc}
;;;3527   
                          ENDP


                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3634   
;;;3635   static void prvResetNextTaskUnblockTime( void )
000000  e59f1050          LDR      r1,|L11.88|
;;;3636   {
;;;3637   TCB_t *pxTCB;
;;;3638   
;;;3639   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000004  e5911000          LDR      r1,[r1,#0]  ; pxDelayedTaskList
000008  e5911000          LDR      r1,[r1,#0]
00000c  e3510000          CMP      r1,#0
000010  1a000001          BNE      |L11.28|
000014  e3a01001          MOV      r1,#1
000018  ea000000          B        |L11.32|
                  |L11.28|
00001c  e3a01000          MOV      r1,#0
                  |L11.32|
000020  e3510000          CMP      r1,#0
000024  0a000003          BEQ      |L11.56|
;;;3640   	{
;;;3641   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3642   		the maximum possible value so it is	extremely unlikely that the
;;;3643   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3644   		there is an item in the delayed list. */
;;;3645   		xNextTaskUnblockTime = portMAX_DELAY;
000028  e3e01000          MVN      r1,#0
00002c  e59f2028          LDR      r2,|L11.92|
000030  e5821000          STR      r1,[r2,#0]  ; xNextTaskUnblockTime
000034  ea000006          B        |L11.84|
                  |L11.56|
;;;3646   	}
;;;3647   	else
;;;3648   	{
;;;3649   		/* The new current delayed list is not empty, get the value of
;;;3650   		the item at the head of the delayed list.  This is the time at
;;;3651   		which the task at the head of the delayed list should be removed
;;;3652   		from the Blocked state. */
;;;3653   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
000038  e59f1018          LDR      r1,|L11.88|
00003c  e5911000          LDR      r1,[r1,#0]  ; pxDelayedTaskList
000040  e591100c          LDR      r1,[r1,#0xc]
000044  e591000c          LDR      r0,[r1,#0xc]
;;;3654   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
000048  e59f200c          LDR      r2,|L11.92|
00004c  e5901004          LDR      r1,[r0,#4]
000050  e5821000          STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L11.84|
;;;3655   	}
;;;3656   }
000054  e12fff1e          BX       lr
;;;3657   /*-----------------------------------------------------------*/
                          ENDP

                  |L11.88|
                          DCD      pxDelayedTaskList
                  |L11.92|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvTaskCheckFreeStackSpace||, CODE, READONLY, ALIGN=2

                  prvTaskCheckFreeStackSpace PROC
;;;3532   
;;;3533   	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
000000  e1a01000          MOV      r1,r0
;;;3534   	{
;;;3535   	uint32_t ulCount = 0U;
000004  e3a02000          MOV      r2,#0
;;;3536   
;;;3537   		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
000008  ea000001          B        |L12.20|
                  |L12.12|
;;;3538   		{
;;;3539   			pucStackByte -= portSTACK_GROWTH;
00000c  e2811001          ADD      r1,r1,#1
;;;3540   			ulCount++;
000010  e2822001          ADD      r2,r2,#1
                  |L12.20|
000014  e5d10000          LDRB     r0,[r1,#0]            ;3537
000018  e35000a5          CMP      r0,#0xa5              ;3537
00001c  0afffffa          BEQ      |L12.12|
;;;3541   		}
;;;3542   
;;;3543   		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
000020  e1a02122          LSR      r2,r2,#2
;;;3544   
;;;3545   		return ( uint16_t ) ulCount;
000024  e1a00802          LSL      r0,r2,#16
000028  e1a00820          LSR      r0,r0,#16
;;;3546   	}
00002c  e12fff1e          BX       lr
;;;3547   
                          ENDP


                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  prvTaskIsTaskSuspended PROC
;;;1655   
;;;1656   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1657   	{
000004  e1a05000          MOV      r5,r0
;;;1658   	BaseType_t xReturn = pdFALSE;
000008  e3a06000          MOV      r6,#0
;;;1659   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
00000c  e1a04005          MOV      r4,r5
;;;1660   
;;;1661   		/* Accesses xPendingReadyList so must be called from a critical
;;;1662   		section. */
;;;1663   
;;;1664   		/* It does not make sense to check if the calling task is suspended. */
;;;1665   		configASSERT( xTask );
000010  e3550000          CMP      r5,#0
000014  1a000005          BNE      |L13.48|
000018  e1a00000          MOV      r0,r0
00001c  e28f2080          ADR      r2,|L13.164|
000020  e59f1094          LDR      r1,|L13.188|
000024  e28f0094          ADR      r0,|L13.192|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L13.48|
;;;1666   
;;;1667   		/* Is the task being resumed actually in the suspended list? */
;;;1668   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000030  e59f10b4          LDR      r1,|L13.236|
000034  e5940014          LDR      r0,[r4,#0x14]
000038  e1500001          CMP      r0,r1
00003c  1a000001          BNE      |L13.72|
000040  e3a00001          MOV      r0,#1
000044  ea000000          B        |L13.76|
                  |L13.72|
000048  e3a00000          MOV      r0,#0
                  |L13.76|
00004c  e3500000          CMP      r0,#0
000050  0a000011          BEQ      |L13.156|
;;;1669   		{
;;;1670   			/* Has the task already been resumed from within an ISR? */
;;;1671   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000054  e59f1094          LDR      r1,|L13.240|
000058  e5940028          LDR      r0,[r4,#0x28]
00005c  e1500001          CMP      r0,r1
000060  1a000001          BNE      |L13.108|
000064  e3a00001          MOV      r0,#1
000068  ea000000          B        |L13.112|
                  |L13.108|
00006c  e3a00000          MOV      r0,#0
                  |L13.112|
000070  e3500000          CMP      r0,#0
000074  1a000008          BNE      |L13.156|
;;;1672   			{
;;;1673   				/* Is it in the suspended list because it is in the	Suspended
;;;1674   				state, or because is is blocked with no timeout? */
;;;1675   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
000078  e5940028          LDR      r0,[r4,#0x28]
00007c  e3500000          CMP      r0,#0
000080  1a000001          BNE      |L13.140|
000084  e3a00001          MOV      r0,#1
000088  ea000000          B        |L13.144|
                  |L13.140|
00008c  e3a00000          MOV      r0,#0
                  |L13.144|
000090  e3500000          CMP      r0,#0
000094  0a000000          BEQ      |L13.156|
;;;1676   				{
;;;1677   					xReturn = pdTRUE;
000098  e3a06001          MOV      r6,#1
                  |L13.156|
;;;1678   				}
;;;1679   				else
;;;1680   				{
;;;1681   					mtCOVERAGE_TEST_MARKER();
;;;1682   				}
;;;1683   			}
;;;1684   			else
;;;1685   			{
;;;1686   				mtCOVERAGE_TEST_MARKER();
;;;1687   			}
;;;1688   		}
;;;1689   		else
;;;1690   		{
;;;1691   			mtCOVERAGE_TEST_MARKER();
;;;1692   		}
;;;1693   
;;;1694   		return xReturn;
00009c  e1a00006          MOV      r0,r6
;;;1695   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
0000a0  e8bd8070          POP      {r4-r6,pc}
;;;1696   
                          ENDP

                  |L13.164|
0000a4  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0000a8  52544f53
0000ac  5c536f75
0000b0  7263655c
0000b4  7461736b
0000b8  732e6300
                  |L13.188|
                          DCD      0x00000681
                  |L13.192|
0000c0  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000c4  7274696f
0000c8  6e202220
0000cc  3f3f3f20
0000d0  22206661
0000d4  696c6564
0000d8  20617420
0000dc  6c696e65
0000e0  20256420
0000e4  696e2025
0000e8  730a00  
0000eb  00                DCB      0
                  |L13.236|
                          DCD      xSuspendedTaskList
                  |L13.240|
                          DCD      xPendingReadyList

                          AREA ||i.prvWriteNameToBuffer||, CODE, READONLY, ALIGN=2

                  prvWriteNameToBuffer PROC
;;;3915   
;;;3916   	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;3917   	{
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;3918   	size_t x;
;;;3919   
;;;3920   		/* Start by copying the entire string. */
;;;3921   		strcpy( pcBuffer, pcTaskName );
00000c  e1a01006          MOV      r1,r6
000010  e1a00005          MOV      r0,r5
000014  ebfffffe          BL       strcpy
;;;3922   
;;;3923   		/* Pad the end of the string with spaces to ensure columns line up when
;;;3924   		printed out. */
;;;3925   		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
000018  e1a00005          MOV      r0,r5
00001c  ebfffffe          BL       strlen
000020  e1a04000          MOV      r4,r0
000024  ea000002          B        |L14.52|
                  |L14.40|
;;;3926   		{
;;;3927   			pcBuffer[ x ] = ' ';
000028  e3a00020          MOV      r0,#0x20
00002c  e7c50004          STRB     r0,[r5,r4]
000030  e2844001          ADD      r4,r4,#1              ;3925
                  |L14.52|
000034  e3540007          CMP      r4,#7                 ;3925
000038  3afffffa          BCC      |L14.40|
;;;3928   		}
;;;3929   
;;;3930   		/* Terminate. */
;;;3931   		pcBuffer[ x ] = 0x00;
00003c  e3a00000          MOV      r0,#0
000040  e7c50004          STRB     r0,[r5,r4]
;;;3932   
;;;3933   		/* Return the new end of string. */
;;;3934   		return &( pcBuffer[ x ] );
000044  e0850004          ADD      r0,r5,r4
;;;3935   	}
000048  e8bd8070          POP      {r4-r6,pc}
;;;3936   
                          ENDP


                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;4194   
;;;4195   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;4196   	{
000004  e1a06000          MOV      r6,r0
000008  e1a05001          MOV      r5,r1
;;;4197   	uint32_t ulReturn;
;;;4198   
;;;4199   		taskENTER_CRITICAL();
00000c  ebfffffe          BL       vPortEnterCritical
;;;4200   		{
;;;4201   			/* Only block if the notification count is not already non-zero. */
;;;4202   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
000010  e59f0098          LDR      r0,|L15.176|
000014  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000018  e5900044          LDR      r0,[r0,#0x44]
00001c  e3500000          CMP      r0,#0
000020  1a000009          BNE      |L15.76|
;;;4203   			{
;;;4204   				/* Mark this task as waiting for a notification. */
;;;4205   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000024  e3a00001          MOV      r0,#1
000028  e59f1080          LDR      r1,|L15.176|
00002c  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000030  e5c10048          STRB     r0,[r1,#0x48]
;;;4206   
;;;4207   				if( xTicksToWait > ( TickType_t ) 0 )
000034  e3550000          CMP      r5,#0
000038  0a000003          BEQ      |L15.76|
;;;4208   				{
;;;4209   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00003c  e3a01001          MOV      r1,#1
000040  e1a00005          MOV      r0,r5
000044  ebfffffe          BL       prvAddCurrentTaskToDelayedList
;;;4210   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4211   
;;;4212   					/* All ports are written to allow a yield in a critical
;;;4213   					section (some will yield immediately, others wait until the
;;;4214   					critical section exits) - but it is not something that
;;;4215   					application code should ever do. */
;;;4216   					portYIELD_WITHIN_API();
000048  ebfffffe          BL       vPortYield
                  |L15.76|
;;;4217   				}
;;;4218   				else
;;;4219   				{
;;;4220   					mtCOVERAGE_TEST_MARKER();
;;;4221   				}
;;;4222   			}
;;;4223   			else
;;;4224   			{
;;;4225   				mtCOVERAGE_TEST_MARKER();
;;;4226   			}
;;;4227   		}
;;;4228   		taskEXIT_CRITICAL();
00004c  ebfffffe          BL       vPortExitCritical
;;;4229   
;;;4230   		taskENTER_CRITICAL();
000050  ebfffffe          BL       vPortEnterCritical
;;;4231   		{
;;;4232   			traceTASK_NOTIFY_TAKE();
;;;4233   			ulReturn = pxCurrentTCB->ulNotifiedValue;
000054  e59f0054          LDR      r0,|L15.176|
000058  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
00005c  e5904044          LDR      r4,[r0,#0x44]
;;;4234   
;;;4235   			if( ulReturn != 0UL )
000060  e3540000          CMP      r4,#0
000064  0a00000a          BEQ      |L15.148|
;;;4236   			{
;;;4237   				if( xClearCountOnExit != pdFALSE )
000068  e3560000          CMP      r6,#0
00006c  0a000004          BEQ      |L15.132|
;;;4238   				{
;;;4239   					pxCurrentTCB->ulNotifiedValue = 0UL;
000070  e3a00000          MOV      r0,#0
000074  e59f1034          LDR      r1,|L15.176|
000078  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
00007c  e5810044          STR      r0,[r1,#0x44]
000080  ea000003          B        |L15.148|
                  |L15.132|
;;;4240   				}
;;;4241   				else
;;;4242   				{
;;;4243   					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
000084  e2440001          SUB      r0,r4,#1
000088  e59f1020          LDR      r1,|L15.176|
00008c  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000090  e5810044          STR      r0,[r1,#0x44]
                  |L15.148|
;;;4244   				}
;;;4245   			}
;;;4246   			else
;;;4247   			{
;;;4248   				mtCOVERAGE_TEST_MARKER();
;;;4249   			}
;;;4250   
;;;4251   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000094  e3a00000          MOV      r0,#0
000098  e59f1010          LDR      r1,|L15.176|
00009c  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
0000a0  e5c10048          STRB     r0,[r1,#0x48]
;;;4252   		}
;;;4253   		taskEXIT_CRITICAL();
0000a4  ebfffffe          BL       vPortExitCritical
;;;4254   
;;;4255   		return ulReturn;
0000a8  e1a00004          MOV      r0,r4
;;;4256   	}
0000ac  e8bd8070          POP      {r4-r6,pc}
;;;4257   
                          ENDP

                  |L15.176|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;2172   
;;;2173   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  e59f0004          LDR      r0,|L16.12|
;;;2174   {
;;;2175   	/* A critical section is not required because the variables are of type
;;;2176   	BaseType_t. */
;;;2177   	return uxCurrentNumberOfTasks;
000004  e5900000          LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;2178   }
000008  e12fff1e          BX       lr
;;;2179   /*-----------------------------------------------------------*/
                          ENDP

                  |L16.12|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.uxTaskGetSystemState||, CODE, READONLY, ALIGN=2

                  uxTaskGetSystemState PROC
;;;2320   
;;;2321   	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2322   	{
000004  e1a05000          MOV      r5,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a06002          MOV      r6,r2
;;;2323   	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
000010  e3a04000          MOV      r4,#0
000014  e3a07020          MOV      r7,#0x20
;;;2324   
;;;2325   		vTaskSuspendAll();
000018  ebfffffe          BL       vTaskSuspendAll
;;;2326   		{
;;;2327   			/* Is there a space in the array for each task in the system? */
;;;2328   			if( uxArraySize >= uxCurrentNumberOfTasks )
00001c  e59f00bc          LDR      r0,|L17.224|
000020  e5900000          LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000024  e1580000          CMP      r8,r0
000028  3a000029          BCC      |L17.212|
;;;2329   			{
;;;2330   				/* Fill in an TaskStatus_t structure with information on each
;;;2331   				task in the Ready state. */
;;;2332   				do
00002c  e1a00000          MOV      r0,r0
                  |L17.48|
;;;2333   				{
;;;2334   					uxQueue--;
000030  e2477001          SUB      r7,r7,#1
;;;2335   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
000034  e0872107          ADD      r2,r7,r7,LSL #2
000038  e59f30a4          LDR      r3,|L17.228|
00003c  e0831102          ADD      r1,r3,r2,LSL #2
000040  e0842184          ADD      r2,r4,r4,LSL #3
000044  e0850102          ADD      r0,r5,r2,LSL #2
000048  e3a02001          MOV      r2,#1
00004c  ebfffffe          BL       prvListTasksWithinSingleList
000050  e0844000          ADD      r4,r4,r0
;;;2336   
;;;2337   				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000054  e3570000          CMP      r7,#0
000058  1afffff4          BNE      |L17.48|
;;;2338   
;;;2339   				/* Fill in an TaskStatus_t structure with information on each
;;;2340   				task in the Blocked state. */
;;;2341   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
00005c  e0841184          ADD      r1,r4,r4,LSL #3
000060  e0850101          ADD      r0,r5,r1,LSL #2
000064  e3a02002          MOV      r2,#2
000068  e59f1078          LDR      r1,|L17.232|
00006c  e5911000          LDR      r1,[r1,#0]  ; pxDelayedTaskList
000070  ebfffffe          BL       prvListTasksWithinSingleList
000074  e0844000          ADD      r4,r4,r0
;;;2342   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
000078  e0841184          ADD      r1,r4,r4,LSL #3
00007c  e0850101          ADD      r0,r5,r1,LSL #2
000080  e3a02002          MOV      r2,#2
000084  e59f1060          LDR      r1,|L17.236|
000088  e5911000          LDR      r1,[r1,#0]  ; pxOverflowDelayedTaskList
00008c  ebfffffe          BL       prvListTasksWithinSingleList
000090  e0844000          ADD      r4,r4,r0
;;;2343   
;;;2344   				#if( INCLUDE_vTaskDelete == 1 )
;;;2345   				{
;;;2346   					/* Fill in an TaskStatus_t structure with information on
;;;2347   					each task that has been deleted but not yet cleaned up. */
;;;2348   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
000094  e0841184          ADD      r1,r4,r4,LSL #3
000098  e0850101          ADD      r0,r5,r1,LSL #2
00009c  e3a02004          MOV      r2,#4
0000a0  e59f1048          LDR      r1,|L17.240|
0000a4  ebfffffe          BL       prvListTasksWithinSingleList
0000a8  e0844000          ADD      r4,r4,r0
;;;2349   				}
;;;2350   				#endif
;;;2351   
;;;2352   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;2353   				{
;;;2354   					/* Fill in an TaskStatus_t structure with information on
;;;2355   					each task in the Suspended state. */
;;;2356   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
0000ac  e0841184          ADD      r1,r4,r4,LSL #3
0000b0  e0850101          ADD      r0,r5,r1,LSL #2
0000b4  e3a02003          MOV      r2,#3
0000b8  e59f1034          LDR      r1,|L17.244|
0000bc  ebfffffe          BL       prvListTasksWithinSingleList
0000c0  e0844000          ADD      r4,r4,r0
;;;2357   				}
;;;2358   				#endif
;;;2359   
;;;2360   				#if ( configGENERATE_RUN_TIME_STATS == 1)
;;;2361   				{
;;;2362   					if( pulTotalRunTime != NULL )
;;;2363   					{
;;;2364   						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2365   							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
;;;2366   						#else
;;;2367   							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2368   						#endif
;;;2369   					}
;;;2370   				}
;;;2371   				#else
;;;2372   				{
;;;2373   					if( pulTotalRunTime != NULL )
0000c4  e3560000          CMP      r6,#0
0000c8  0a000001          BEQ      |L17.212|
;;;2374   					{
;;;2375   						*pulTotalRunTime = 0;
0000cc  e3a00000          MOV      r0,#0
0000d0  e5860000          STR      r0,[r6,#0]
                  |L17.212|
;;;2376   					}
;;;2377   				}
;;;2378   				#endif
;;;2379   			}
;;;2380   			else
;;;2381   			{
;;;2382   				mtCOVERAGE_TEST_MARKER();
;;;2383   			}
;;;2384   		}
;;;2385   		( void ) xTaskResumeAll();
0000d4  ebfffffe          BL       xTaskResumeAll
;;;2386   
;;;2387   		return uxTask;
0000d8  e1a00004          MOV      r0,r4
;;;2388   	}
0000dc  e8bd81f0          POP      {r4-r8,pc}
;;;2389   
                          ENDP

                  |L17.224|
                          DCD      uxCurrentNumberOfTasks
                  |L17.228|
                          DCD      pxReadyTasksLists
                  |L17.232|
                          DCD      pxDelayedTaskList
                  |L17.236|
                          DCD      pxOverflowDelayedTaskList
                  |L17.240|
                          DCD      xTasksWaitingTermination
                  |L17.244|
                          DCD      xSuspendedTaskList

                          AREA ||i.uxTaskGetTaskNumber||, CODE, READONLY, ALIGN=2

                  uxTaskGetTaskNumber PROC
;;;3083   
;;;3084   	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
000000  e1a01000          MOV      r1,r0
;;;3085   	{
;;;3086   	UBaseType_t uxReturn;
;;;3087   	TCB_t *pxTCB;
;;;3088   
;;;3089   		if( xTask != NULL )
000004  e3510000          CMP      r1,#0
000008  0a000002          BEQ      |L18.24|
;;;3090   		{
;;;3091   			pxTCB = ( TCB_t * ) xTask;
00000c  e1a02001          MOV      r2,r1
;;;3092   			uxReturn = pxTCB->uxTaskNumber;
000010  e5920040          LDR      r0,[r2,#0x40]
000014  ea000000          B        |L18.28|
                  |L18.24|
;;;3093   		}
;;;3094   		else
;;;3095   		{
;;;3096   			uxReturn = 0U;
000018  e3a00000          MOV      r0,#0
                  |L18.28|
;;;3097   		}
;;;3098   
;;;3099   		return uxReturn;
;;;3100   	}
00001c  e12fff1e          BX       lr
;;;3101   
                          ENDP


                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1339   
;;;1340   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1341   	{
000004  e1a04000          MOV      r4,r0
;;;1342   	TCB_t *pxTCB;
;;;1343   	UBaseType_t uxReturn;
;;;1344   
;;;1345   		taskENTER_CRITICAL();
000008  ebfffffe          BL       vPortEnterCritical
;;;1346   		{
;;;1347   			/* If null is passed in here then it is the priority of the that
;;;1348   			called uxTaskPriorityGet() that is being queried. */
;;;1349   			pxTCB = prvGetTCBFromHandle( xTask );
00000c  e3540000          CMP      r4,#0
000010  1a000002          BNE      |L19.32|
000014  e59f001c          LDR      r0,|L19.56|
000018  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
00001c  ea000000          B        |L19.36|
                  |L19.32|
000020  e1a00004          MOV      r0,r4
                  |L19.36|
000024  e1a06000          MOV      r6,r0
;;;1350   			uxReturn = pxTCB->uxPriority;
000028  e596502c          LDR      r5,[r6,#0x2c]
;;;1351   		}
;;;1352   		taskEXIT_CRITICAL();
00002c  ebfffffe          BL       vPortExitCritical
;;;1353   
;;;1354   		return uxReturn;
000030  e1a00005          MOV      r0,r5
;;;1355   	}
000034  e8bd8070          POP      {r4-r6,pc}
;;;1356   
                          ENDP

                  |L19.56|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1361   
;;;1362   	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
000000  e1a01000          MOV      r1,r0
;;;1363   	{
;;;1364   	TCB_t *pxTCB;
;;;1365   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1366   
;;;1367   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1368   		maximum	system call (or maximum API call) interrupt priority.
;;;1369   		Interrupts that are	above the maximum system call priority are keep
;;;1370   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1371   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1372   		is defined in FreeRTOSConfig.h then
;;;1373   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1374   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1375   		been assigned a priority above the configured maximum system call
;;;1376   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1377   		from interrupts	that have been assigned a priority at or (logically)
;;;1378   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1379   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1380   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1381   		provided on the following link:
;;;1382   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1383   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1384   
;;;1385   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
000004  e3a03000          MOV      r3,#0
;;;1386   		{
;;;1387   			/* If null is passed in here then it is the priority of the calling
;;;1388   			task that is being queried. */
;;;1389   			pxTCB = prvGetTCBFromHandle( xTask );
000008  e3510000          CMP      r1,#0
00000c  1a000002          BNE      |L20.28|
000010  e59fc014          LDR      r12,|L20.44|
000014  e59cc000          LDR      r12,[r12,#0]  ; pxCurrentTCB
000018  ea000000          B        |L20.32|
                  |L20.28|
00001c  e1a0c001          MOV      r12,r1
                  |L20.32|
000020  e1a0200c          MOV      r2,r12
;;;1390   			uxReturn = pxTCB->uxPriority;
000024  e592002c          LDR      r0,[r2,#0x2c]
;;;1391   		}
;;;1392   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
;;;1393   
;;;1394   		return uxReturn;
;;;1395   	}
000028  e12fff1e          BX       lr
;;;1396   
                          ENDP

                  |L20.44|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;4161   
;;;4162   TickType_t uxTaskResetEventItemValue( void )
000000  e59f1024          LDR      r1,|L21.44|
;;;4163   {
;;;4164   TickType_t uxReturn;
;;;4165   
;;;4166   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000004  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000008  e5910018          LDR      r0,[r1,#0x18]
;;;4167   
;;;4168   	/* Reset the event list item to its normal value - so it can be used with
;;;4169   	queues and semaphores. */
;;;4170   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00000c  e59f1018          LDR      r1,|L21.44|
000010  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000014  e591102c          LDR      r1,[r1,#0x2c]
000018  e2611020          RSB      r1,r1,#0x20
00001c  e59f2008          LDR      r2,|L21.44|
000020  e5922000          LDR      r2,[r2,#0]  ; pxCurrentTCB
000024  e5821018          STR      r1,[r2,#0x18]
;;;4171   
;;;4172   	return uxReturn;
;;;4173   }
000028  e12fff1e          BX       lr
;;;4174   /*-----------------------------------------------------------*/
                          ENDP

                  |L21.44|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;1223   
;;;1224   	void vTaskDelay( const TickType_t xTicksToDelay )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1225   	{
000004  e1a04000          MOV      r4,r0
;;;1226   	BaseType_t xAlreadyYielded = pdFALSE;
000008  e3a05000          MOV      r5,#0
;;;1227   
;;;1228   		/* A delay time of zero just forces a reschedule. */
;;;1229   		if( xTicksToDelay > ( TickType_t ) 0U )
00000c  e3540000          CMP      r4,#0
000010  0a000014          BEQ      |L22.104|
;;;1230   		{
;;;1231   			configASSERT( uxSchedulerSuspended == 0 );
000014  e59f005c          LDR      r0,|L22.120|
000018  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00001c  e3500000          CMP      r0,#0
000020  1a000001          BNE      |L22.44|
000024  e3a00001          MOV      r0,#1
000028  ea000000          B        |L22.48|
                  |L22.44|
00002c  e3a00000          MOV      r0,#0
                  |L22.48|
000030  e3500000          CMP      r0,#0
000034  1a000005          BNE      |L22.80|
000038  e1a00000          MOV      r0,r0
00003c  e28f2038          ADR      r2,|L22.124|
000040  e59f104c          LDR      r1,|L22.148|
000044  e28f004c          ADR      r0,|L22.152|
000048  ebfffffe          BL       sysprintf
00004c  e1a00000          MOV      r0,r0
                  |L22.80|
;;;1232   			vTaskSuspendAll();
000050  ebfffffe          BL       vTaskSuspendAll
;;;1233   			{
;;;1234   				traceTASK_DELAY();
;;;1235   
;;;1236   				/* A task that is removed from the event list while the
;;;1237   				scheduler is suspended will not get placed in the ready
;;;1238   				list or removed from the blocked list until the scheduler
;;;1239   				is resumed.
;;;1240   
;;;1241   				This task cannot be in an event list as it is the currently
;;;1242   				executing task. */
;;;1243   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
000054  e3a01000          MOV      r1,#0
000058  e1a00004          MOV      r0,r4
00005c  ebfffffe          BL       prvAddCurrentTaskToDelayedList
;;;1244   			}
;;;1245   			xAlreadyYielded = xTaskResumeAll();
000060  ebfffffe          BL       xTaskResumeAll
000064  e1a05000          MOV      r5,r0
                  |L22.104|
;;;1246   		}
;;;1247   		else
;;;1248   		{
;;;1249   			mtCOVERAGE_TEST_MARKER();
;;;1250   		}
;;;1251   
;;;1252   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1253   		have put ourselves to sleep. */
;;;1254   		if( xAlreadyYielded == pdFALSE )
000068  e3550000          CMP      r5,#0
00006c  1a000000          BNE      |L22.116|
;;;1255   		{
;;;1256   			portYIELD_WITHIN_API();
000070  ebfffffe          BL       vPortYield
                  |L22.116|
;;;1257   		}
;;;1258   		else
;;;1259   		{
;;;1260   			mtCOVERAGE_TEST_MARKER();
;;;1261   		}
;;;1262   	}
000074  e8bd8070          POP      {r4-r6,pc}
;;;1263   
                          ENDP

                  |L22.120|
                          DCD      uxSchedulerSuspended
                  |L22.124|
00007c  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
000080  52544f53
000084  5c536f75
000088  7263655c
00008c  7461736b
000090  732e6300
                  |L22.148|
                          DCD      0x000004cf
                  |L22.152|
000098  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
00009c  7274696f
0000a0  6e202220
0000a4  3f3f3f20
0000a8  22206661
0000ac  696c6564
0000b0  20617420
0000b4  6c696e65
0000b8  20256420
0000bc  696e2025
0000c0  730a00  
0000c3  00                DCB      0

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;1139   
;;;1140   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1141   	{
000004  e1a04000          MOV      r4,r0
000008  e1a07001          MOV      r7,r1
;;;1142   	TickType_t xTimeToWake;
;;;1143   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
00000c  e3a09000          MOV      r9,#0
;;;1144   
;;;1145   		configASSERT( pxPreviousWakeTime );
000010  e3540000          CMP      r4,#0
000014  1a000005          BNE      |L23.48|
000018  e1a00000          MOV      r0,r0
00001c  e28f2c01          ADR      r2,|L23.292|
000020  e59f1114          LDR      r1,|L23.316|
000024  e28f0f45          ADR      r0,|L23.320|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L23.48|
;;;1146   		configASSERT( ( xTimeIncrement > 0U ) );
000030  e3570000          CMP      r7,#0
000034  0a000001          BEQ      |L23.64|
000038  e3a00001          MOV      r0,#1
00003c  ea000000          B        |L23.68|
                  |L23.64|
000040  e3a00000          MOV      r0,#0
                  |L23.68|
000044  e3500000          CMP      r0,#0
000048  1a000005          BNE      |L23.100|
00004c  e1a00000          MOV      r0,r0
000050  e28f20cc          ADR      r2,|L23.292|
000054  e59f1110          LDR      r1,|L23.364|
000058  e28f00e0          ADR      r0,|L23.320|
00005c  ebfffffe          BL       sysprintf
000060  e1a00000          MOV      r0,r0
                  |L23.100|
;;;1147   		configASSERT( uxSchedulerSuspended == 0 );
000064  e59f0104          LDR      r0,|L23.368|
000068  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00006c  e3500000          CMP      r0,#0
000070  1a000001          BNE      |L23.124|
000074  e3a00001          MOV      r0,#1
000078  ea000000          B        |L23.128|
                  |L23.124|
00007c  e3a00000          MOV      r0,#0
                  |L23.128|
000080  e3500000          CMP      r0,#0
000084  1a000005          BNE      |L23.160|
000088  e1a00000          MOV      r0,r0
00008c  e28f2090          ADR      r2,|L23.292|
000090  e59f10dc          LDR      r1,|L23.372|
000094  e28f00a4          ADR      r0,|L23.320|
000098  ebfffffe          BL       sysprintf
00009c  e1a00000          MOV      r0,r0
                  |L23.160|
;;;1148   
;;;1149   		vTaskSuspendAll();
0000a0  ebfffffe          BL       vTaskSuspendAll
;;;1150   		{
;;;1151   			/* Minor optimisation.  The tick count cannot change in this
;;;1152   			block. */
;;;1153   			const TickType_t xConstTickCount = xTickCount;
0000a4  e59f00cc          LDR      r0,|L23.376|
0000a8  e5906000          LDR      r6,[r0,#0]  ; xTickCount
;;;1154   
;;;1155   			/* Generate the tick time at which the task wants to wake. */
;;;1156   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
0000ac  e5940000          LDR      r0,[r4,#0]
0000b0  e0805007          ADD      r5,r0,r7
;;;1157   
;;;1158   			if( xConstTickCount < *pxPreviousWakeTime )
0000b4  e5940000          LDR      r0,[r4,#0]
0000b8  e1500006          CMP      r0,r6
0000bc  9a000006          BLS      |L23.220|
;;;1159   			{
;;;1160   				/* The tick count has overflowed since this function was
;;;1161   				lasted called.  In this case the only time we should ever
;;;1162   				actually delay is if the wake time has also	overflowed,
;;;1163   				and the wake time is greater than the tick time.  When this
;;;1164   				is the case it is as if neither time had overflowed. */
;;;1165   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
0000c0  e5940000          LDR      r0,[r4,#0]
0000c4  e1500005          CMP      r0,r5
0000c8  9a000009          BLS      |L23.244|
0000cc  e1550006          CMP      r5,r6
0000d0  9a000007          BLS      |L23.244|
;;;1166   				{
;;;1167   					xShouldDelay = pdTRUE;
0000d4  e3a09001          MOV      r9,#1
0000d8  ea000005          B        |L23.244|
                  |L23.220|
;;;1168   				}
;;;1169   				else
;;;1170   				{
;;;1171   					mtCOVERAGE_TEST_MARKER();
;;;1172   				}
;;;1173   			}
;;;1174   			else
;;;1175   			{
;;;1176   				/* The tick time has not overflowed.  In this case we will
;;;1177   				delay if either the wake time has overflowed, and/or the
;;;1178   				tick time is less than the wake time. */
;;;1179   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
0000dc  e5940000          LDR      r0,[r4,#0]
0000e0  e1500005          CMP      r0,r5
0000e4  8a000001          BHI      |L23.240|
0000e8  e1550006          CMP      r5,r6
0000ec  9a000000          BLS      |L23.244|
                  |L23.240|
;;;1180   				{
;;;1181   					xShouldDelay = pdTRUE;
0000f0  e3a09001          MOV      r9,#1
                  |L23.244|
;;;1182   				}
;;;1183   				else
;;;1184   				{
;;;1185   					mtCOVERAGE_TEST_MARKER();
;;;1186   				}
;;;1187   			}
;;;1188   
;;;1189   			/* Update the wake time ready for the next call. */
;;;1190   			*pxPreviousWakeTime = xTimeToWake;
0000f4  e5845000          STR      r5,[r4,#0]
;;;1191   
;;;1192   			if( xShouldDelay != pdFALSE )
0000f8  e3590000          CMP      r9,#0
0000fc  0a000002          BEQ      |L23.268|
;;;1193   			{
;;;1194   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1195   
;;;1196   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1197   				the time to wake, so subtract the current tick count. */
;;;1198   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
000100  e0450006          SUB      r0,r5,r6
000104  e3a01000          MOV      r1,#0
000108  ebfffffe          BL       prvAddCurrentTaskToDelayedList
                  |L23.268|
;;;1199   			}
;;;1200   			else
;;;1201   			{
;;;1202   				mtCOVERAGE_TEST_MARKER();
;;;1203   			}
;;;1204   		}
;;;1205   		xAlreadyYielded = xTaskResumeAll();
00010c  ebfffffe          BL       xTaskResumeAll
000110  e1a08000          MOV      r8,r0
;;;1206   
;;;1207   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1208   		have put ourselves to sleep. */
;;;1209   		if( xAlreadyYielded == pdFALSE )
000114  e3580000          CMP      r8,#0
000118  1a000000          BNE      |L23.288|
;;;1210   		{
;;;1211   			portYIELD_WITHIN_API();
00011c  ebfffffe          BL       vPortYield
                  |L23.288|
;;;1212   		}
;;;1213   		else
;;;1214   		{
;;;1215   			mtCOVERAGE_TEST_MARKER();
;;;1216   		}
;;;1217   	}
000120  e8bd87f0          POP      {r4-r10,pc}
;;;1218   
                          ENDP

                  |L23.292|
000124  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
000128  52544f53
00012c  5c536f75
000130  7263655c
000134  7461736b
000138  732e6300
                  |L23.316|
                          DCD      0x00000479
                  |L23.320|
000140  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000144  7274696f
000148  6e202220
00014c  3f3f3f20
000150  22206661
000154  696c6564
000158  20617420
00015c  6c696e65
000160  20256420
000164  696e2025
000168  730a00  
00016b  00                DCB      0
                  |L23.364|
                          DCD      0x0000047a
                  |L23.368|
                          DCD      uxSchedulerSuspended
                  |L23.372|
                          DCD      0x0000047b
                  |L23.376|
                          DCD      xTickCount

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;1047   
;;;1048   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1049   	{
000004  e1a05000          MOV      r5,r0
;;;1050   	TCB_t *pxTCB;
;;;1051   
;;;1052   		taskENTER_CRITICAL();
000008  ebfffffe          BL       vPortEnterCritical
;;;1053   		{
;;;1054   			/* If null is passed in here then it is the calling task that is
;;;1055   			being deleted. */
;;;1056   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
00000c  e3550000          CMP      r5,#0
000010  1a000002          BNE      |L24.32|
000014  e59f00f8          LDR      r0,|L24.276|
000018  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
00001c  ea000000          B        |L24.36|
                  |L24.32|
000020  e1a00005          MOV      r0,r5
                  |L24.36|
000024  e1a04000          MOV      r4,r0
;;;1057   
;;;1058   			/* Remove task from the ready list. */
;;;1059   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000028  e2840004          ADD      r0,r4,#4
00002c  ebfffffe          BL       uxListRemove
;;;1060   			{
;;;1061   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1062   			}
;;;1063   			else
;;;1064   			{
;;;1065   				mtCOVERAGE_TEST_MARKER();
;;;1066   			}
;;;1067   
;;;1068   			/* Is the task waiting on an event also? */
;;;1069   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000030  e5940028          LDR      r0,[r4,#0x28]
000034  e3500000          CMP      r0,#0
000038  0a000001          BEQ      |L24.68|
;;;1070   			{
;;;1071   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00003c  e2840018          ADD      r0,r4,#0x18
000040  ebfffffe          BL       uxListRemove
                  |L24.68|
;;;1072   			}
;;;1073   			else
;;;1074   			{
;;;1075   				mtCOVERAGE_TEST_MARKER();
;;;1076   			}
;;;1077   
;;;1078   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1079   			detect that the task lists need re-generating.  This is done before
;;;1080   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1081   			not return. */
;;;1082   			uxTaskNumber++;
000044  e59f00cc          LDR      r0,|L24.280|
000048  e5900000          LDR      r0,[r0,#0]  ; uxTaskNumber
00004c  e2800001          ADD      r0,r0,#1
000050  e59f10c0          LDR      r1,|L24.280|
000054  e5810000          STR      r0,[r1,#0]  ; uxTaskNumber
;;;1083   
;;;1084   			if( pxTCB == pxCurrentTCB )
000058  e59f00b4          LDR      r0,|L24.276|
00005c  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000060  e1540000          CMP      r4,r0
000064  1a000008          BNE      |L24.140|
;;;1085   			{
;;;1086   				/* A task is deleting itself.  This cannot complete within the
;;;1087   				task itself, as a context switch to another task is required.
;;;1088   				Place the task in the termination list.  The idle task will
;;;1089   				check the termination list and free up any memory allocated by
;;;1090   				the scheduler for the TCB and stack of the deleted task. */
;;;1091   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
000068  e2841004          ADD      r1,r4,#4
00006c  e59f00a8          LDR      r0,|L24.284|
000070  ebfffffe          BL       vListInsertEnd
;;;1092   
;;;1093   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1094   				there is a task that has been deleted and that it should therefore
;;;1095   				check the xTasksWaitingTermination list. */
;;;1096   				++uxDeletedTasksWaitingCleanUp;
000074  e59f00a4          LDR      r0,|L24.288|
000078  e5900000          LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
00007c  e2800001          ADD      r0,r0,#1
000080  e59f1098          LDR      r1,|L24.288|
000084  e5810000          STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
000088  ea000007          B        |L24.172|
                  |L24.140|
;;;1097   
;;;1098   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1099   				in which Windows specific clean up operations are performed,
;;;1100   				after which it is not possible to yield away from this task -
;;;1101   				hence xYieldPending is used to latch that a context switch is
;;;1102   				required. */
;;;1103   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1104   			}
;;;1105   			else
;;;1106   			{
;;;1107   				--uxCurrentNumberOfTasks;
00008c  e59f0090          LDR      r0,|L24.292|
000090  e5900000          LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000094  e2400001          SUB      r0,r0,#1
000098  e59f1084          LDR      r1,|L24.292|
00009c  e5810000          STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;1108   				prvDeleteTCB( pxTCB );
0000a0  e1a00004          MOV      r0,r4
0000a4  ebfffffe          BL       prvDeleteTCB
;;;1109   
;;;1110   				/* Reset the next expected unblock time in case it referred to
;;;1111   				the task that has just been deleted. */
;;;1112   				prvResetNextTaskUnblockTime();
0000a8  ebfffffe          BL       prvResetNextTaskUnblockTime
                  |L24.172|
;;;1113   			}
;;;1114   
;;;1115   			traceTASK_DELETE( pxTCB );
;;;1116   		}
;;;1117   		taskEXIT_CRITICAL();
0000ac  ebfffffe          BL       vPortExitCritical
;;;1118   
;;;1119   		/* Force a reschedule if it is the currently running task that has just
;;;1120   		been deleted. */
;;;1121   		if( xSchedulerRunning != pdFALSE )
0000b0  e59f0070          LDR      r0,|L24.296|
0000b4  e5900000          LDR      r0,[r0,#0]  ; xSchedulerRunning
0000b8  e3500000          CMP      r0,#0
0000bc  0a000013          BEQ      |L24.272|
;;;1122   		{
;;;1123   			if( pxTCB == pxCurrentTCB )
0000c0  e59f004c          LDR      r0,|L24.276|
0000c4  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
0000c8  e1540000          CMP      r4,r0
0000cc  1a00000f          BNE      |L24.272|
;;;1124   			{
;;;1125   				configASSERT( uxSchedulerSuspended == 0 );
0000d0  e59f0054          LDR      r0,|L24.300|
0000d4  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
0000d8  e3500000          CMP      r0,#0
0000dc  1a000001          BNE      |L24.232|
0000e0  e3a00001          MOV      r0,#1
0000e4  ea000000          B        |L24.236|
                  |L24.232|
0000e8  e3a00000          MOV      r0,#0
                  |L24.236|
0000ec  e3500000          CMP      r0,#0
0000f0  1a000005          BNE      |L24.268|
0000f4  e1a00000          MOV      r0,r0
0000f8  e28f2030          ADR      r2,|L24.304|
0000fc  e59f1044          LDR      r1,|L24.328|
000100  e28f0044          ADR      r0,|L24.332|
000104  ebfffffe          BL       sysprintf
000108  e1a00000          MOV      r0,r0
                  |L24.268|
;;;1126   				portYIELD_WITHIN_API();
00010c  ebfffffe          BL       vPortYield
                  |L24.272|
;;;1127   			}
;;;1128   			else
;;;1129   			{
;;;1130   				mtCOVERAGE_TEST_MARKER();
;;;1131   			}
;;;1132   		}
;;;1133   	}
000110  e8bd8070          POP      {r4-r6,pc}
;;;1134   
                          ENDP

                  |L24.276|
                          DCD      pxCurrentTCB
                  |L24.280|
                          DCD      uxTaskNumber
                  |L24.284|
                          DCD      xTasksWaitingTermination
                  |L24.288|
                          DCD      uxDeletedTasksWaitingCleanUp
                  |L24.292|
                          DCD      uxCurrentNumberOfTasks
                  |L24.296|
                          DCD      xSchedulerRunning
                  |L24.300|
                          DCD      uxSchedulerSuspended
                  |L24.304|
000130  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
000134  52544f53
000138  5c536f75
00013c  7263655c
000140  7461736b
000144  732e6300
                  |L24.328|
                          DCD      0x00000465
                  |L24.332|
00014c  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000150  7274696f
000154  6e202220
000158  3f3f3f20
00015c  22206661
000160  696c6564
000164  20617420
000168  6c696e65
00016c  20256420
000170  696e2025
000174  730a00  
000177  00                DCB      0

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;1932   
;;;1933   void vTaskEndScheduler( void )
000000  e92d4010          PUSH     {r4,lr}
;;;1934   {
;;;1935   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1936   	routine so the original ISRs can be restored if necessary.  The port
;;;1937   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1938   	portDISABLE_INTERRUPTS();
000004  e10f0000          MRS      r0,APSR ; formerly CPSR
000008  e3800080          ORR      r0,r0,#0x80
00000c  e121f000          MSR      CPSR_c,r0
;;;1939   	xSchedulerRunning = pdFALSE;
000010  e3a00000          MOV      r0,#0
000014  e59f1008          LDR      r1,|L25.36|
000018  e5810000          STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1940   	vPortEndScheduler();
00001c  ebfffffe          BL       vPortEndScheduler
;;;1941   }
000020  e8bd8010          POP      {r4,pc}
;;;1942   /*----------------------------------------------------------*/
                          ENDP

                  |L25.36|
                          DCD      xSchedulerRunning

                          AREA ||i.vTaskGetInfo||, CODE, READONLY, ALIGN=2

                  vTaskGetInfo PROC
;;;3410   
;;;3411   	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3412   	{
000004  e1a07000          MOV      r7,r0
000008  e1a04001          MOV      r4,r1
00000c  e1a08002          MOV      r8,r2
000010  e1a06003          MOV      r6,r3
;;;3413   	TCB_t *pxTCB;
;;;3414   
;;;3415   		/* xTask is NULL then get the state of the calling task. */
;;;3416   		pxTCB = prvGetTCBFromHandle( xTask );
000014  e3570000          CMP      r7,#0
000018  1a000002          BNE      |L26.40|
00001c  e59f00a4          LDR      r0,|L26.200|
000020  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000024  ea000000          B        |L26.44|
                  |L26.40|
000028  e1a00007          MOV      r0,r7
                  |L26.44|
00002c  e1a05000          MOV      r5,r0
;;;3417   
;;;3418   		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
000030  e5845000          STR      r5,[r4,#0]
;;;3419   		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
000034  e2850034          ADD      r0,r5,#0x34
000038  e5840004          STR      r0,[r4,#4]
;;;3420   		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
00003c  e595002c          LDR      r0,[r5,#0x2c]
000040  e5840010          STR      r0,[r4,#0x10]
;;;3421   		pxTaskStatus->pxStackBase = pxTCB->pxStack;
000044  e5950030          LDR      r0,[r5,#0x30]
000048  e584001c          STR      r0,[r4,#0x1c]
;;;3422   		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
00004c  e595003c          LDR      r0,[r5,#0x3c]
000050  e5840008          STR      r0,[r4,#8]
;;;3423   
;;;3424   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3425   		{
;;;3426   			/* If the task is in the suspended list then there is a chance it is
;;;3427   			actually just blocked indefinitely - so really it should be reported as
;;;3428   			being in the Blocked state. */
;;;3429   			if( pxTaskStatus->eCurrentState == eSuspended )
000054  e5d4000c          LDRB     r0,[r4,#0xc]
000058  e3500003          CMP      r0,#3
00005c  1a000006          BNE      |L26.124|
;;;3430   			{
;;;3431   				vTaskSuspendAll();
000060  ebfffffe          BL       vTaskSuspendAll
;;;3432   				{
;;;3433   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000064  e5950028          LDR      r0,[r5,#0x28]
000068  e3500000          CMP      r0,#0
00006c  0a000001          BEQ      |L26.120|
;;;3434   					{
;;;3435   						pxTaskStatus->eCurrentState = eBlocked;
000070  e3a00002          MOV      r0,#2
000074  e5c4000c          STRB     r0,[r4,#0xc]
                  |L26.120|
;;;3436   					}
;;;3437   				}
;;;3438   				xTaskResumeAll();
000078  ebfffffe          BL       xTaskResumeAll
                  |L26.124|
;;;3439   			}
;;;3440   		}
;;;3441   		#endif /* INCLUDE_vTaskSuspend */
;;;3442   
;;;3443   		#if ( configUSE_MUTEXES == 1 )
;;;3444   		{
;;;3445   			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
;;;3446   		}
;;;3447   		#else
;;;3448   		{
;;;3449   			pxTaskStatus->uxBasePriority = 0;
00007c  e3a00000          MOV      r0,#0
000080  e5840014          STR      r0,[r4,#0x14]
;;;3450   		}
;;;3451   		#endif
;;;3452   
;;;3453   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;3454   		{
;;;3455   			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
;;;3456   		}
;;;3457   		#else
;;;3458   		{
;;;3459   			pxTaskStatus->ulRunTimeCounter = 0;
000084  e5840018          STR      r0,[r4,#0x18]
;;;3460   		}
;;;3461   		#endif
;;;3462   
;;;3463   		/* Obtaining the task state is a little fiddly, so is only done if the value
;;;3464   		of eState passed into this function is eInvalid - otherwise the state is
;;;3465   		just set to whatever is passed in. */
;;;3466   		if( eState != eInvalid )
000088  e3560005          CMP      r6,#5
00008c  0a000001          BEQ      |L26.152|
;;;3467   		{
;;;3468   			pxTaskStatus->eCurrentState = eState;
000090  e5c4600c          STRB     r6,[r4,#0xc]
000094  ea000002          B        |L26.164|
                  |L26.152|
;;;3469   		}
;;;3470   		else
;;;3471   		{
;;;3472   			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
000098  e1a00007          MOV      r0,r7
00009c  ebfffffe          BL       eTaskGetState
0000a0  e5c4000c          STRB     r0,[r4,#0xc]
                  |L26.164|
;;;3473   		}
;;;3474   
;;;3475   		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
;;;3476   		parameter is provided to allow it to be skipped. */
;;;3477   		if( xGetFreeStackSpace != pdFALSE )
0000a4  e3580000          CMP      r8,#0
0000a8  0a000003          BEQ      |L26.188|
;;;3478   		{
;;;3479   			#if ( portSTACK_GROWTH > 0 )
;;;3480   			{
;;;3481   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
;;;3482   			}
;;;3483   			#else
;;;3484   			{
;;;3485   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
0000ac  e5950030          LDR      r0,[r5,#0x30]
0000b0  ebfffffe          BL       prvTaskCheckFreeStackSpace
0000b4  e1c402b0          STRH     r0,[r4,#0x20]
0000b8  ea000001          B        |L26.196|
                  |L26.188|
;;;3486   			}
;;;3487   			#endif
;;;3488   		}
;;;3489   		else
;;;3490   		{
;;;3491   			pxTaskStatus->usStackHighWaterMark = 0;
0000bc  e3a00000          MOV      r0,#0
0000c0  e1c402b0          STRH     r0,[r4,#0x20]
                  |L26.196|
;;;3492   		}
;;;3493   	}
0000c4  e8bd81f0          POP      {r4-r8,pc}
;;;3494   
                          ENDP

                  |L26.200|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskList||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_c
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskList PROC
;;;3941   
;;;3942   	void vTaskList( char * pcWriteBuffer )
000000  e92d407f          PUSH     {r0-r6,lr}
;;;3943   	{
000004  e1a05000          MOV      r5,r0
;;;3944   	TaskStatus_t *pxTaskStatusArray;
;;;3945   	volatile UBaseType_t uxArraySize, x;
;;;3946   	char cStatus;
;;;3947   
;;;3948   		/*
;;;3949   		 * PLEASE NOTE:
;;;3950   		 *
;;;3951   		 * This function is provided for convenience only, and is used by many
;;;3952   		 * of the demo applications.  Do not consider it to be part of the
;;;3953   		 * scheduler.
;;;3954   		 *
;;;3955   		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
;;;3956   		 * uxTaskGetSystemState() output into a human readable table that
;;;3957   		 * displays task names, states and stack usage.
;;;3958   		 *
;;;3959   		 * vTaskList() has a dependency on the sprintf() C library function that
;;;3960   		 * might bloat the code size, use a lot of stack, and provide different
;;;3961   		 * results on different platforms.  An alternative, tiny, third party,
;;;3962   		 * and limited functionality implementation of sprintf() is provided in
;;;3963   		 * many of the FreeRTOS/Demo sub-directories in a file called
;;;3964   		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
;;;3965   		 * snprintf() implementation!).
;;;3966   		 *
;;;3967   		 * It is recommended that production systems call uxTaskGetSystemState()
;;;3968   		 * directly to get access to raw stats data, rather than indirectly
;;;3969   		 * through a call to vTaskList().
;;;3970   		 */
;;;3971   
;;;3972   
;;;3973   		/* Make sure the write buffer does not contain a string. */
;;;3974   		*pcWriteBuffer = 0x00;
000008  e3a00000          MOV      r0,#0
00000c  e5c50000          STRB     r0,[r5,#0]
;;;3975   
;;;3976   		/* Take a snapshot of the number of tasks in case it changes while this
;;;3977   		function is executing. */
;;;3978   		uxArraySize = uxCurrentNumberOfTasks;
000010  e59f014c          LDR      r0,|L27.356|
000014  e5900000          LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000018  e58d000c          STR      r0,[sp,#0xc]
;;;3979   
;;;3980   		/* Allocate an array index for each task.  NOTE!  if
;;;3981   		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
;;;3982   		equate to NULL. */
;;;3983   		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
00001c  e59f1140          LDR      r1,|L27.356|
000020  e5911000          LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
000024  e0811181          ADD      r1,r1,r1,LSL #3
000028  e1a00101          LSL      r0,r1,#2
00002c  ebfffffe          BL       pvPortMalloc
000030  e1a04000          MOV      r4,r0
;;;3984   
;;;3985   		if( pxTaskStatusArray != NULL )
000034  e3540000          CMP      r4,#0
000038  0a000048          BEQ      |L27.352|
;;;3986   		{
;;;3987   			/* Generate the (binary) data. */
;;;3988   			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
00003c  e3a02000          MOV      r2,#0
000040  e1a00004          MOV      r0,r4
000044  e59d100c          LDR      r1,[sp,#0xc]
000048  ebfffffe          BL       uxTaskGetSystemState
00004c  e58d000c          STR      r0,[sp,#0xc]
;;;3989   
;;;3990   			/* Create a human readable table from the binary data. */
;;;3991   			for( x = 0; x < uxArraySize; x++ )
000050  e3a00000          MOV      r0,#0
000054  e58d0008          STR      r0,[sp,#8]
000058  ea00003b          B        |L27.332|
                  |L27.92|
;;;3992   			{
;;;3993   				switch( pxTaskStatusArray[ x ].eCurrentState )
00005c  e59d0008          LDR      r0,[sp,#8]
000060  e0800180          ADD      r0,r0,r0,LSL #3
000064  e0840100          ADD      r0,r4,r0,LSL #2
000068  e5d0000c          LDRB     r0,[r0,#0xc]
00006c  e3500001          CMP      r0,#1
000070  0a000006          BEQ      |L27.144|
000074  e3500002          CMP      r0,#2
000078  0a000007          BEQ      |L27.156|
00007c  e3500003          CMP      r0,#3
000080  0a000008          BEQ      |L27.168|
000084  e3500004          CMP      r0,#4
000088  1a00000c          BNE      |L27.192|
00008c  ea000008          B        |L27.180|
                  |L27.144|
;;;3994   				{
;;;3995   					case eReady:		cStatus = tskREADY_CHAR;
000090  e1a00000          MOV      r0,r0
000094  e3a06052          MOV      r6,#0x52
;;;3996   										break;
000098  ea00000b          B        |L27.204|
                  |L27.156|
;;;3997   
;;;3998   					case eBlocked:		cStatus = tskBLOCKED_CHAR;
00009c  e1a00000          MOV      r0,r0
0000a0  e3a06042          MOV      r6,#0x42
;;;3999   										break;
0000a4  ea000008          B        |L27.204|
                  |L27.168|
;;;4000   
;;;4001   					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
0000a8  e1a00000          MOV      r0,r0
0000ac  e3a06053          MOV      r6,#0x53
;;;4002   										break;
0000b0  ea000005          B        |L27.204|
                  |L27.180|
;;;4003   
;;;4004   					case eDeleted:		cStatus = tskDELETED_CHAR;
0000b4  e1a00000          MOV      r0,r0
0000b8  e3a06044          MOV      r6,#0x44
;;;4005   										break;
0000bc  ea000002          B        |L27.204|
                  |L27.192|
;;;4006   
;;;4007   					default:			/* Should not get here, but it is included
0000c0  e1a00000          MOV      r0,r0
;;;4008   										to prevent static checking errors. */
;;;4009   										cStatus = 0x00;
0000c4  e3a06000          MOV      r6,#0
;;;4010   										break;
0000c8  e1a00000          MOV      r0,r0
                  |L27.204|
0000cc  e1a00000          MOV      r0,r0                 ;3996
;;;4011   				}
;;;4012   
;;;4013   				/* Write the task name to the string, padding with spaces so it
;;;4014   				can be printed in tabular form more easily. */
;;;4015   				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
0000d0  e59d0008          LDR      r0,[sp,#8]
0000d4  e0800180          ADD      r0,r0,r0,LSL #3
0000d8  e0840100          ADD      r0,r4,r0,LSL #2
0000dc  e5901004          LDR      r1,[r0,#4]
0000e0  e1a00005          MOV      r0,r5
0000e4  ebfffffe          BL       prvWriteNameToBuffer
0000e8  e1a05000          MOV      r5,r0
;;;4016   
;;;4017   				/* Write the rest of the string. */
;;;4018   				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
0000ec  e59d0008          LDR      r0,[sp,#8]
0000f0  e0800180          ADD      r0,r0,r0,LSL #3
0000f4  e0840100          ADD      r0,r4,r0,LSL #2
0000f8  e5900008          LDR      r0,[r0,#8]
0000fc  e59d1008          LDR      r1,[sp,#8]
000100  e0811181          ADD      r1,r1,r1,LSL #3
000104  e0841101          ADD      r1,r4,r1,LSL #2
000108  e1d112b0          LDRH     r1,[r1,#0x20]
00010c  e58d0004          STR      r0,[sp,#4]
000110  e58d1000          STR      r1,[sp,#0]
000114  e59d0008          LDR      r0,[sp,#8]
000118  e0800180          ADD      r0,r0,r0,LSL #3
00011c  e0840100          ADD      r0,r4,r0,LSL #2
000120  e1a02006          MOV      r2,r6
000124  e28f103c          ADR      r1,|L27.360|
000128  e5903010          LDR      r3,[r0,#0x10]
00012c  e1a00005          MOV      r0,r5
000130  ebfffffe          BL       __2sprintf
;;;4019   				pcWriteBuffer += strlen( pcWriteBuffer );
000134  e1a00005          MOV      r0,r5
000138  ebfffffe          BL       strlen
00013c  e0855000          ADD      r5,r5,r0
000140  e59d0008          LDR      r0,[sp,#8]            ;3991
000144  e2800001          ADD      r0,r0,#1              ;3991
000148  e58d0008          STR      r0,[sp,#8]            ;3991
                  |L27.332|
00014c  e1cd00d8          LDRD     r0,r1,[sp,#8]         ;3991
000150  e1500001          CMP      r0,r1                 ;3991
000154  3affffc0          BCC      |L27.92|
;;;4020   			}
;;;4021   
;;;4022   			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
;;;4023   			is 0 then vPortFree() will be #defined to nothing. */
;;;4024   			vPortFree( pxTaskStatusArray );
000158  e1a00004          MOV      r0,r4
00015c  ebfffffe          BL       vPortFree
                  |L27.352|
;;;4025   		}
;;;4026   		else
;;;4027   		{
;;;4028   			mtCOVERAGE_TEST_MARKER();
;;;4029   		}
;;;4030   	}
000160  e8bd807f          POP      {r0-r6,pc}
;;;4031   
                          ENDP

                  |L27.356|
                          DCD      uxCurrentNumberOfTasks
                  |L27.360|
000168  09256309          DCB      "\t%c\t%u\t%u\t%u\r\n",0
00016c  25750925
000170  75092575
000174  0d0a00  
000177  00                DCB      0

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;3075   
;;;3076   void vTaskMissedYield( void )
000000  e3a00001          MOV      r0,#1
;;;3077   {
;;;3078   	xYieldPending = pdTRUE;
000004  e59f1004          LDR      r1,|L28.16|
000008  e5810000          STR      r0,[r1,#0]  ; xYieldPending
;;;3079   }
00000c  e12fff1e          BX       lr
;;;3080   /*-----------------------------------------------------------*/
                          ENDP

                  |L28.16|
                          DCD      xYieldPending

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                  vTaskNotifyGiveFromISR PROC
;;;4572   
;;;4573   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4574   	{
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;4575   	TCB_t * pxTCB;
;;;4576   	uint8_t ucOriginalNotifyState;
;;;4577   	UBaseType_t uxSavedInterruptStatus;
;;;4578   
;;;4579   		configASSERT( xTaskToNotify );
00000c  e3550000          CMP      r5,#0
000010  1a000005          BNE      |L29.44|
000014  e1a00000          MOV      r0,r0
000018  e28f2f42          ADR      r2,|L29.296|
00001c  e59f111c          LDR      r1,|L29.320|
000020  e28f0f47          ADR      r0,|L29.324|
000024  ebfffffe          BL       sysprintf
000028  e1a00000          MOV      r0,r0
                  |L29.44|
;;;4580   
;;;4581   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4582   		maximum	system call (or maximum API call) interrupt priority.
;;;4583   		Interrupts that are	above the maximum system call priority are keep
;;;4584   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4585   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4586   		is defined in FreeRTOSConfig.h then
;;;4587   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4588   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4589   		been assigned a priority above the configured maximum system call
;;;4590   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4591   		from interrupts	that have been assigned a priority at or (logically)
;;;4592   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4593   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4594   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4595   		provided on the following link:
;;;4596   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4597   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4598   
;;;4599   		pxTCB = ( TCB_t * ) xTaskToNotify;
00002c  e1a04005          MOV      r4,r5
;;;4600   
;;;4601   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000030  e3a08000          MOV      r8,#0
;;;4602   		{
;;;4603   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000034  e5d47048          LDRB     r7,[r4,#0x48]
;;;4604   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000038  e3a00002          MOV      r0,#2
00003c  e5c40048          STRB     r0,[r4,#0x48]
;;;4605   
;;;4606   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4607   			semaphore. */
;;;4608   			( pxTCB->ulNotifiedValue )++;
000040  e5940044          LDR      r0,[r4,#0x44]
000044  e2800001          ADD      r0,r0,#1
000048  e5840044          STR      r0,[r4,#0x44]
;;;4609   
;;;4610   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4611   
;;;4612   			/* If the task is in the blocked state specifically to wait for a
;;;4613   			notification then unblock it now. */
;;;4614   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
00004c  e3570001          CMP      r7,#1
000050  1a000033          BNE      |L29.292|
;;;4615   			{
;;;4616   				/* The task should not have been on an event list. */
;;;4617   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000054  e5940028          LDR      r0,[r4,#0x28]
000058  e3500000          CMP      r0,#0
00005c  1a000001          BNE      |L29.104|
000060  e3a00001          MOV      r0,#1
000064  ea000000          B        |L29.108|
                  |L29.104|
000068  e3a00000          MOV      r0,#0
                  |L29.108|
00006c  e3500000          CMP      r0,#0
000070  1a000005          BNE      |L29.140|
000074  e1a00000          MOV      r0,r0
000078  e28f20a8          ADR      r2,|L29.296|
00007c  e59f10ec          LDR      r1,|L29.368|
000080  e28f00bc          ADR      r0,|L29.324|
000084  ebfffffe          BL       sysprintf
000088  e1a00000          MOV      r0,r0
                  |L29.140|
;;;4618   
;;;4619   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00008c  e59f00e0          LDR      r0,|L29.372|
000090  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000094  e3500000          CMP      r0,#0
000098  1a000010          BNE      |L29.224|
;;;4620   				{
;;;4621   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00009c  e2840004          ADD      r0,r4,#4
0000a0  ebfffffe          BL       uxListRemove
;;;4622   					prvAddTaskToReadyList( pxTCB );
0000a4  e59f10cc          LDR      r1,|L29.376|
0000a8  e594002c          LDR      r0,[r4,#0x2c]
0000ac  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000b0  e1500001          CMP      r0,r1
0000b4  9a000002          BLS      |L29.196|
0000b8  e59f10b8          LDR      r1,|L29.376|
0000bc  e594002c          LDR      r0,[r4,#0x2c]
0000c0  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L29.196|
0000c4  e594102c          LDR      r1,[r4,#0x2c]
0000c8  e0811101          ADD      r1,r1,r1,LSL #2
0000cc  e59f20a8          LDR      r2,|L29.380|
0000d0  e0820101          ADD      r0,r2,r1,LSL #2
0000d4  e2841004          ADD      r1,r4,#4
0000d8  ebfffffe          BL       vListInsertEnd
0000dc  ea000002          B        |L29.236|
                  |L29.224|
;;;4623   				}
;;;4624   				else
;;;4625   				{
;;;4626   					/* The delayed and ready lists cannot be accessed, so hold
;;;4627   					this task pending until the scheduler is resumed. */
;;;4628   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0000e0  e2841018          ADD      r1,r4,#0x18
0000e4  e59f0094          LDR      r0,|L29.384|
0000e8  ebfffffe          BL       vListInsertEnd
                  |L29.236|
;;;4629   				}
;;;4630   
;;;4631   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000ec  e59f1090          LDR      r1,|L29.388|
0000f0  e594002c          LDR      r0,[r4,#0x2c]
0000f4  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
0000f8  e591102c          LDR      r1,[r1,#0x2c]
0000fc  e1500001          CMP      r0,r1
000100  9a000007          BLS      |L29.292|
;;;4632   				{
;;;4633   					/* The notified task has a priority above the currently
;;;4634   					executing task so a yield is required. */
;;;4635   					if( pxHigherPriorityTaskWoken != NULL )
000104  e3560000          CMP      r6,#0
000108  0a000002          BEQ      |L29.280|
;;;4636   					{
;;;4637   						*pxHigherPriorityTaskWoken = pdTRUE;
00010c  e3a00001          MOV      r0,#1
000110  e5860000          STR      r0,[r6,#0]
000114  ea000002          B        |L29.292|
                  |L29.280|
;;;4638   					}
;;;4639   					else
;;;4640   					{
;;;4641   						/* Mark that a yield is pending in case the user is not
;;;4642   						using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;4643   						safe FreeRTOS function. */
;;;4644   						xYieldPending = pdTRUE;
000118  e3a00001          MOV      r0,#1
00011c  e59f1064          LDR      r1,|L29.392|
000120  e5810000          STR      r0,[r1,#0]  ; xYieldPending
                  |L29.292|
;;;4645   					}
;;;4646   				}
;;;4647   				else
;;;4648   				{
;;;4649   					mtCOVERAGE_TEST_MARKER();
;;;4650   				}
;;;4651   			}
;;;4652   		}
;;;4653   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;4654   	}
000124  e8bd81f0          POP      {r4-r8,pc}
;;;4655   
                          ENDP

                  |L29.296|
000128  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
00012c  52544f53
000130  5c536f75
000134  7263655c
000138  7461736b
00013c  732e6300
                  |L29.320|
                          DCD      0x000011e3
                  |L29.324|
000144  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000148  7274696f
00014c  6e202220
000150  3f3f3f20
000154  22206661
000158  696c6564
00015c  20617420
000160  6c696e65
000164  20256420
000168  696e2025
00016c  730a00  
00016f  00                DCB      0
                  |L29.368|
                          DCD      0x00001209
                  |L29.372|
                          DCD      uxSchedulerSuspended
                  |L29.376|
                          DCD      uxTopReadyPriority
                  |L29.380|
                          DCD      pxReadyTasksLists
                  |L29.384|
                          DCD      xPendingReadyList
                  |L29.388|
                          DCD      pxCurrentTCB
                  |L29.392|
                          DCD      xYieldPending

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;2819   
;;;2820   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;2821   {
000004  e1a05000          MOV      r5,r0
000008  e1a04001          MOV      r4,r1
;;;2822   	configASSERT( pxEventList );
00000c  e3550000          CMP      r5,#0
000010  1a000005          BNE      |L30.44|
000014  e1a00000          MOV      r0,r0
000018  e28f2030          ADR      r2,|L30.80|
00001c  e59f1044          LDR      r1,|L30.104|
000020  e28f0044          ADR      r0,|L30.108|
000024  ebfffffe          BL       sysprintf
000028  e1a00000          MOV      r0,r0
                  |L30.44|
;;;2823   
;;;2824   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2825   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2826   
;;;2827   	/* Place the event list item of the TCB in the appropriate event list.
;;;2828   	This is placed in the list in priority order so the highest priority task
;;;2829   	is the first to be woken by the event.  The queue that contains the event
;;;2830   	list is locked, preventing simultaneous access from interrupts. */
;;;2831   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00002c  e59f0064          LDR      r0,|L30.152|
000030  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  e2801018          ADD      r1,r0,#0x18
000038  e1a00005          MOV      r0,r5
00003c  ebfffffe          BL       vListInsert
;;;2832   
;;;2833   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000040  e3a01001          MOV      r1,#1
000044  e1a00004          MOV      r0,r4
000048  ebfffffe          BL       prvAddCurrentTaskToDelayedList
;;;2834   }
00004c  e8bd8070          POP      {r4-r6,pc}
;;;2835   /*-----------------------------------------------------------*/
                          ENDP

                  |L30.80|
000050  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
000054  52544f53
000058  5c536f75
00005c  7263655c
000060  7461736b
000064  732e6300
                  |L30.104|
                          DCD      0x00000b06
                  |L30.108|
00006c  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000070  7274696f
000074  6e202220
000078  3f3f3f20
00007c  22206661
000080  696c6564
000084  20617420
000088  6c696e65
00008c  20256420
000090  696e2025
000094  730a00  
000097  00                DCB      0
                  |L30.152|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;2836   
;;;2837   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;2838   {
000004  e1a06000          MOV      r6,r0
000008  e1a04001          MOV      r4,r1
00000c  e1a05002          MOV      r5,r2
;;;2839   	configASSERT( pxEventList );
000010  e3560000          CMP      r6,#0
000014  1a000005          BNE      |L31.48|
000018  e1a00000          MOV      r0,r0
00001c  e28f207c          ADR      r2,|L31.160|
000020  e59f1090          LDR      r1,|L31.184|
000024  e28f0090          ADR      r0,|L31.188|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L31.48|
;;;2840   
;;;2841   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2842   	the event groups implementation. */
;;;2843   	configASSERT( uxSchedulerSuspended != 0 );
000030  e59f00b0          LDR      r0,|L31.232|
000034  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000038  e3500000          CMP      r0,#0
00003c  0a000001          BEQ      |L31.72|
000040  e3a00001          MOV      r0,#1
000044  ea000000          B        |L31.76|
                  |L31.72|
000048  e3a00000          MOV      r0,#0
                  |L31.76|
00004c  e3500000          CMP      r0,#0
000050  1a000005          BNE      |L31.108|
000054  e1a00000          MOV      r0,r0
000058  e28f2040          ADR      r2,|L31.160|
00005c  e59f1088          LDR      r1,|L31.236|
000060  e28f0054          ADR      r0,|L31.188|
000064  ebfffffe          BL       sysprintf
000068  e1a00000          MOV      r0,r0
                  |L31.108|
;;;2844   
;;;2845   	/* Store the item value in the event list item.  It is safe to access the
;;;2846   	event list item here as interrupts won't access the event list item of a
;;;2847   	task that is not in the Blocked state. */
;;;2848   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
00006c  e3840102          ORR      r0,r4,#0x80000000
000070  e59f1078          LDR      r1,|L31.240|
000074  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000078  e5810018          STR      r0,[r1,#0x18]
;;;2849   
;;;2850   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2851   	list.  It is safe to access the event list here because it is part of an
;;;2852   	event group implementation - and interrupts don't access event groups
;;;2853   	directly (instead they access them indirectly by pending function calls to
;;;2854   	the task level). */
;;;2855   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00007c  e59f006c          LDR      r0,|L31.240|
000080  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000084  e2801018          ADD      r1,r0,#0x18
000088  e1a00006          MOV      r0,r6
00008c  ebfffffe          BL       vListInsertEnd
;;;2856   
;;;2857   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000090  e3a01001          MOV      r1,#1
000094  e1a00005          MOV      r0,r5
000098  ebfffffe          BL       prvAddCurrentTaskToDelayedList
;;;2858   }
00009c  e8bd8070          POP      {r4-r6,pc}
;;;2859   /*-----------------------------------------------------------*/
                          ENDP

                  |L31.160|
0000a0  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0000a4  52544f53
0000a8  5c536f75
0000ac  7263655c
0000b0  7461736b
0000b4  732e6300
                  |L31.184|
                          DCD      0x00000b17
                  |L31.188|
0000bc  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000c0  7274696f
0000c4  6e202220
0000c8  3f3f3f20
0000cc  22206661
0000d0  696c6564
0000d4  20617420
0000d8  6c696e65
0000dc  20256420
0000e0  696e2025
0000e4  730a00  
0000e7  00                DCB      0
                  |L31.232|
                          DCD      uxSchedulerSuspended
                  |L31.236|
                          DCD      0x00000b1b
                  |L31.240|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1401   
;;;1402   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1403   	{
000004  e1a07000          MOV      r7,r0
000008  e1a05001          MOV      r5,r1
;;;1404   	TCB_t *pxTCB;
;;;1405   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1406   	BaseType_t xYieldRequired = pdFALSE;
00000c  e3a09000          MOV      r9,#0
;;;1407   
;;;1408   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
000010  e3550020          CMP      r5,#0x20
000014  2a000001          BCS      |L32.32|
000018  e3a00001          MOV      r0,#1
00001c  ea000000          B        |L32.36|
                  |L32.32|
000020  e3a00000          MOV      r0,#0
                  |L32.36|
000024  e3500000          CMP      r0,#0
000028  1a000005          BNE      |L32.68|
00002c  e1a00000          MOV      r0,r0
000030  e28f2e13          ADR      r2,|L32.360|
000034  e3a01d16          MOV      r1,#0x580
000038  e28f0d05          ADR      r0,|L32.384|
00003c  ebfffffe          BL       sysprintf
000040  e1a00000          MOV      r0,r0
                  |L32.68|
;;;1409   
;;;1410   		/* Ensure the new priority is valid. */
;;;1411   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000044  e3550020          CMP      r5,#0x20
000048  3a000000          BCC      |L32.80|
;;;1412   		{
;;;1413   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
00004c  e3a0501f          MOV      r5,#0x1f
                  |L32.80|
;;;1414   		}
;;;1415   		else
;;;1416   		{
;;;1417   			mtCOVERAGE_TEST_MARKER();
;;;1418   		}
;;;1419   
;;;1420   		taskENTER_CRITICAL();
000050  ebfffffe          BL       vPortEnterCritical
;;;1421   		{
;;;1422   			/* If null is passed in here then it is the priority of the calling
;;;1423   			task that is being changed. */
;;;1424   			pxTCB = prvGetTCBFromHandle( xTask );
000054  e3570000          CMP      r7,#0
000058  1a000002          BNE      |L32.104|
00005c  e59f0148          LDR      r0,|L32.428|
000060  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000064  ea000000          B        |L32.108|
                  |L32.104|
000068  e1a00007          MOV      r0,r7
                  |L32.108|
00006c  e1a04000          MOV      r4,r0
;;;1425   
;;;1426   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1427   
;;;1428   			#if ( configUSE_MUTEXES == 1 )
;;;1429   			{
;;;1430   				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;1431   			}
;;;1432   			#else
;;;1433   			{
;;;1434   				uxCurrentBasePriority = pxTCB->uxPriority;
000070  e594602c          LDR      r6,[r4,#0x2c]
;;;1435   			}
;;;1436   			#endif
;;;1437   
;;;1438   			if( uxCurrentBasePriority != uxNewPriority )
000074  e1560005          CMP      r6,r5
000078  0a000038          BEQ      |L32.352|
;;;1439   			{
;;;1440   				/* The priority change may have readied a task of higher
;;;1441   				priority than the calling task. */
;;;1442   				if( uxNewPriority > uxCurrentBasePriority )
00007c  e1550006          CMP      r5,r6
000080  9a00000a          BLS      |L32.176|
;;;1443   				{
;;;1444   					if( pxTCB != pxCurrentTCB )
000084  e59f0120          LDR      r0,|L32.428|
000088  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
00008c  e1540000          CMP      r4,r0
000090  0a00000b          BEQ      |L32.196|
;;;1445   					{
;;;1446   						/* The priority of a task other than the currently
;;;1447   						running task is being raised.  Is the priority being
;;;1448   						raised above that of the running task? */
;;;1449   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
000094  e59f0110          LDR      r0,|L32.428|
000098  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
00009c  e590002c          LDR      r0,[r0,#0x2c]
0000a0  e1500005          CMP      r0,r5
0000a4  8a000006          BHI      |L32.196|
;;;1450   						{
;;;1451   							xYieldRequired = pdTRUE;
0000a8  e3a09001          MOV      r9,#1
0000ac  ea000004          B        |L32.196|
                  |L32.176|
;;;1452   						}
;;;1453   						else
;;;1454   						{
;;;1455   							mtCOVERAGE_TEST_MARKER();
;;;1456   						}
;;;1457   					}
;;;1458   					else
;;;1459   					{
;;;1460   						/* The priority of the running task is being raised,
;;;1461   						but the running task must already be the highest
;;;1462   						priority task able to run so no yield is required. */
;;;1463   					}
;;;1464   				}
;;;1465   				else if( pxTCB == pxCurrentTCB )
0000b0  e59f00f4          LDR      r0,|L32.428|
0000b4  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
0000b8  e1540000          CMP      r4,r0
0000bc  1a000000          BNE      |L32.196|
;;;1466   				{
;;;1467   					/* Setting the priority of the running task down means
;;;1468   					there may now be another task of higher priority that
;;;1469   					is ready to execute. */
;;;1470   					xYieldRequired = pdTRUE;
0000c0  e3a09001          MOV      r9,#1
                  |L32.196|
;;;1471   				}
;;;1472   				else
;;;1473   				{
;;;1474   					/* Setting the priority of any other task down does not
;;;1475   					require a yield as the running task must be above the
;;;1476   					new priority of the task being modified. */
;;;1477   				}
;;;1478   
;;;1479   				/* Remember the ready list the task might be referenced from
;;;1480   				before its uxPriority member is changed so the
;;;1481   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1482   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
0000c4  e594802c          LDR      r8,[r4,#0x2c]
;;;1483   
;;;1484   				#if ( configUSE_MUTEXES == 1 )
;;;1485   				{
;;;1486   					/* Only change the priority being used if the task is not
;;;1487   					currently using an inherited priority. */
;;;1488   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
;;;1489   					{
;;;1490   						pxTCB->uxPriority = uxNewPriority;
;;;1491   					}
;;;1492   					else
;;;1493   					{
;;;1494   						mtCOVERAGE_TEST_MARKER();
;;;1495   					}
;;;1496   
;;;1497   					/* The base priority gets set whatever. */
;;;1498   					pxTCB->uxBasePriority = uxNewPriority;
;;;1499   				}
;;;1500   				#else
;;;1501   				{
;;;1502   					pxTCB->uxPriority = uxNewPriority;
0000c8  e584502c          STR      r5,[r4,#0x2c]
;;;1503   				}
;;;1504   				#endif
;;;1505   
;;;1506   				/* Only reset the event list item value if the value is not
;;;1507   				being used for anything else. */
;;;1508   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
0000cc  e5940018          LDR      r0,[r4,#0x18]
0000d0  e2000102          AND      r0,r0,#0x80000000
0000d4  e3500000          CMP      r0,#0
0000d8  1a000001          BNE      |L32.228|
;;;1509   				{
;;;1510   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0000dc  e2650020          RSB      r0,r5,#0x20
0000e0  e5840018          STR      r0,[r4,#0x18]
                  |L32.228|
;;;1511   				}
;;;1512   				else
;;;1513   				{
;;;1514   					mtCOVERAGE_TEST_MARKER();
;;;1515   				}
;;;1516   
;;;1517   				/* If the task is in the blocked or suspended list we need do
;;;1518   				nothing more than change it's priority variable. However, if
;;;1519   				the task is in a ready list it needs to be removed and placed
;;;1520   				in the list appropriate to its new priority. */
;;;1521   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
0000e4  e0881108          ADD      r1,r8,r8,LSL #2
0000e8  e59f20c0          LDR      r2,|L32.432|
0000ec  e0821101          ADD      r1,r2,r1,LSL #2
0000f0  e5940014          LDR      r0,[r4,#0x14]
0000f4  e1500001          CMP      r0,r1
0000f8  1a000001          BNE      |L32.260|
0000fc  e3a00001          MOV      r0,#1
000100  ea000000          B        |L32.264|
                  |L32.260|
000104  e3a00000          MOV      r0,#0
                  |L32.264|
000108  e3500000          CMP      r0,#0
00010c  0a00000f          BEQ      |L32.336|
;;;1522   				{
;;;1523   					/* The task is currently in its ready list - remove before adding
;;;1524   					it to it's new ready list.  As we are in a critical section we
;;;1525   					can do this even if the scheduler is suspended. */
;;;1526   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000110  e2840004          ADD      r0,r4,#4
000114  ebfffffe          BL       uxListRemove
;;;1527   					{
;;;1528   						/* It is known that the task is in its ready list so
;;;1529   						there is no need to check again and the port level
;;;1530   						reset macro can be called directly. */
;;;1531   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
;;;1532   					}
;;;1533   					else
;;;1534   					{
;;;1535   						mtCOVERAGE_TEST_MARKER();
;;;1536   					}
;;;1537   					prvAddTaskToReadyList( pxTCB );
000118  e59f1094          LDR      r1,|L32.436|
00011c  e594002c          LDR      r0,[r4,#0x2c]
000120  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
000124  e1500001          CMP      r0,r1
000128  9a000002          BLS      |L32.312|
00012c  e59f1080          LDR      r1,|L32.436|
000130  e594002c          LDR      r0,[r4,#0x2c]
000134  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L32.312|
000138  e594102c          LDR      r1,[r4,#0x2c]
00013c  e0811101          ADD      r1,r1,r1,LSL #2
000140  e59f2068          LDR      r2,|L32.432|
000144  e0820101          ADD      r0,r2,r1,LSL #2
000148  e2841004          ADD      r1,r4,#4
00014c  ebfffffe          BL       vListInsertEnd
                  |L32.336|
;;;1538   				}
;;;1539   				else
;;;1540   				{
;;;1541   					mtCOVERAGE_TEST_MARKER();
;;;1542   				}
;;;1543   
;;;1544   				if( xYieldRequired != pdFALSE )
000150  e3590000          CMP      r9,#0
000154  0a000000          BEQ      |L32.348|
;;;1545   				{
;;;1546   					taskYIELD_IF_USING_PREEMPTION();
000158  ebfffffe          BL       vPortYield
                  |L32.348|
;;;1547   				}
;;;1548   				else
;;;1549   				{
;;;1550   					mtCOVERAGE_TEST_MARKER();
;;;1551   				}
;;;1552   
;;;1553   				/* Remove compiler warning about unused variables when the port
;;;1554   				optimised task selection is not being used. */
;;;1555   				( void ) uxPriorityUsedOnEntry;
00015c  e1a00000          MOV      r0,r0
                  |L32.352|
;;;1556   			}
;;;1557   		}
;;;1558   		taskEXIT_CRITICAL();
000160  ebfffffe          BL       vPortExitCritical
;;;1559   	}
000164  e8bd87f0          POP      {r4-r10,pc}
;;;1560   
                          ENDP

                  |L32.360|
000168  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
00016c  52544f53
000170  5c536f75
000174  7263655c
000178  7461736b
00017c  732e6300
                  |L32.384|
000180  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000184  7274696f
000188  6e202220
00018c  3f3f3f20
000190  22206661
000194  696c6564
000198  20617420
00019c  6c696e65
0001a0  20256420
0001a4  696e2025
0001a8  730a00  
0001ab  00                DCB      0
                  |L32.428|
                          DCD      pxCurrentTCB
                  |L32.432|
                          DCD      pxReadyTasksLists
                  |L32.436|
                          DCD      uxTopReadyPriority

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1701   
;;;1702   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1703   	{
000004  e1a05000          MOV      r5,r0
;;;1704   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000008  e1a04005          MOV      r4,r5
;;;1705   
;;;1706   		/* It does not make sense to resume the calling task. */
;;;1707   		configASSERT( xTaskToResume );
00000c  e3550000          CMP      r5,#0
000010  1a000005          BNE      |L33.44|
000014  e1a00000          MOV      r0,r0
000018  e28f209c          ADR      r2,|L33.188|
00001c  e59f10b0          LDR      r1,|L33.212|
000020  e28f00b0          ADR      r0,|L33.216|
000024  ebfffffe          BL       sysprintf
000028  e1a00000          MOV      r0,r0
                  |L33.44|
;;;1708   
;;;1709   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1710   		currently executing task. */
;;;1711   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
00002c  e3540000          CMP      r4,#0
000030  0a000020          BEQ      |L33.184|
000034  e59f00c8          LDR      r0,|L33.260|
000038  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
00003c  e1540000          CMP      r4,r0
000040  0a00001c          BEQ      |L33.184|
;;;1712   		{
;;;1713   			taskENTER_CRITICAL();
000044  ebfffffe          BL       vPortEnterCritical
;;;1714   			{
;;;1715   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000048  e1a00004          MOV      r0,r4
00004c  ebfffffe          BL       prvTaskIsTaskSuspended
000050  e3500000          CMP      r0,#0
000054  0a000016          BEQ      |L33.180|
;;;1716   				{
;;;1717   					traceTASK_RESUME( pxTCB );
;;;1718   
;;;1719   					/* As we are in a critical section we can access the ready
;;;1720   					lists even if the scheduler is suspended. */
;;;1721   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
000058  e2840004          ADD      r0,r4,#4
00005c  ebfffffe          BL       uxListRemove
;;;1722   					prvAddTaskToReadyList( pxTCB );
000060  e59f10a0          LDR      r1,|L33.264|
000064  e594002c          LDR      r0,[r4,#0x2c]
000068  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
00006c  e1500001          CMP      r0,r1
000070  9a000002          BLS      |L33.128|
000074  e59f108c          LDR      r1,|L33.264|
000078  e594002c          LDR      r0,[r4,#0x2c]
00007c  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L33.128|
000080  e594102c          LDR      r1,[r4,#0x2c]
000084  e0811101          ADD      r1,r1,r1,LSL #2
000088  e59f207c          LDR      r2,|L33.268|
00008c  e0820101          ADD      r0,r2,r1,LSL #2
000090  e2841004          ADD      r1,r4,#4
000094  ebfffffe          BL       vListInsertEnd
;;;1723   
;;;1724   					/* We may have just resumed a higher priority task. */
;;;1725   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000098  e59f1064          LDR      r1,|L33.260|
00009c  e594002c          LDR      r0,[r4,#0x2c]
0000a0  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
0000a4  e591102c          LDR      r1,[r1,#0x2c]
0000a8  e1500001          CMP      r0,r1
0000ac  3a000000          BCC      |L33.180|
;;;1726   					{
;;;1727   						/* This yield may not cause the task just resumed to run,
;;;1728   						but will leave the lists in the correct state for the
;;;1729   						next yield. */
;;;1730   						taskYIELD_IF_USING_PREEMPTION();
0000b0  ebfffffe          BL       vPortYield
                  |L33.180|
;;;1731   					}
;;;1732   					else
;;;1733   					{
;;;1734   						mtCOVERAGE_TEST_MARKER();
;;;1735   					}
;;;1736   				}
;;;1737   				else
;;;1738   				{
;;;1739   					mtCOVERAGE_TEST_MARKER();
;;;1740   				}
;;;1741   			}
;;;1742   			taskEXIT_CRITICAL();
0000b4  ebfffffe          BL       vPortExitCritical
                  |L33.184|
;;;1743   		}
;;;1744   		else
;;;1745   		{
;;;1746   			mtCOVERAGE_TEST_MARKER();
;;;1747   		}
;;;1748   	}
0000b8  e8bd8070          POP      {r4-r6,pc}
;;;1749   
                          ENDP

                  |L33.188|
0000bc  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0000c0  52544f53
0000c4  5c536f75
0000c8  7263655c
0000cc  7461736b
0000d0  732e6300
                  |L33.212|
                          DCD      0x000006ab
                  |L33.216|
0000d8  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000dc  7274696f
0000e0  6e202220
0000e4  3f3f3f20
0000e8  22206661
0000ec  696c6564
0000f0  20617420
0000f4  6c696e65
0000f8  20256420
0000fc  696e2025
000100  730a00  
000103  00                DCB      0
                  |L33.260|
                          DCD      pxCurrentTCB
                  |L33.264|
                          DCD      uxTopReadyPriority
                  |L33.268|
                          DCD      pxReadyTasksLists

                          AREA ||i.vTaskSetTaskNumber||, CODE, READONLY, ALIGN=2

                  vTaskSetTaskNumber PROC
;;;3106   
;;;3107   	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
000000  e3500000          CMP      r0,#0
;;;3108   	{
;;;3109   	TCB_t *pxTCB;
;;;3110   
;;;3111   		if( xTask != NULL )
000004  0a000001          BEQ      |L34.16|
;;;3112   		{
;;;3113   			pxTCB = ( TCB_t * ) xTask;
000008  e1a02000          MOV      r2,r0
;;;3114   			pxTCB->uxTaskNumber = uxHandle;
00000c  e5821040          STR      r1,[r2,#0x40]
                  |L34.16|
;;;3115   		}
;;;3116   	}
000010  e12fff1e          BX       lr
;;;3117   
                          ENDP


                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;3006   
;;;3007   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  e92d4010          PUSH     {r4,lr}
;;;3008   {
000004  e1a04000          MOV      r4,r0
;;;3009   	configASSERT( pxTimeOut );
000008  e3540000          CMP      r4,#0
00000c  1a000005          BNE      |L35.40|
000010  e1a00000          MOV      r0,r0
000014  e28f2028          ADR      r2,|L35.68|
000018  e59f103c          LDR      r1,|L35.92|
00001c  e28f003c          ADR      r0,|L35.96|
000020  ebfffffe          BL       sysprintf
000024  e1a00000          MOV      r0,r0
                  |L35.40|
;;;3010   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000028  e59f005c          LDR      r0,|L35.140|
00002c  e5900000          LDR      r0,[r0,#0]  ; xNumOfOverflows
000030  e5840000          STR      r0,[r4,#0]
;;;3011   	pxTimeOut->xTimeOnEntering = xTickCount;
000034  e59f0054          LDR      r0,|L35.144|
000038  e5900000          LDR      r0,[r0,#0]  ; xTickCount
00003c  e5840004          STR      r0,[r4,#4]
;;;3012   }
000040  e8bd8010          POP      {r4,pc}
;;;3013   /*-----------------------------------------------------------*/
                          ENDP

                  |L35.68|
000044  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
000048  52544f53
00004c  5c536f75
000050  7263655c
000054  7461736b
000058  732e6300
                  |L35.92|
                          DCD      0x00000bc1
                  |L35.96|
000060  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000064  7274696f
000068  6e202220
00006c  3f3f3f20
000070  22206661
000074  696c6564
000078  20617420
00007c  6c696e65
000080  20256420
000084  696e2025
000088  730a00  
00008b  00                DCB      0
                  |L35.140|
                          DCD      xNumOfOverflows
                  |L35.144|
                          DCD      xTickCount

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1825   
;;;1826   void vTaskStartScheduler( void )
000000  e92d401c          PUSH     {r2-r4,lr}
;;;1827   {
;;;1828   BaseType_t xReturn;
;;;1829   
;;;1830   	/* Add the idle task at the lowest priority. */
;;;1831   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1832   	{
;;;1833   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
;;;1834   		StackType_t *pxIdleTaskStackBuffer = NULL;
;;;1835   		uint32_t ulIdleTaskStackSize;
;;;1836   
;;;1837   		/* The Idle task is created using user provided RAM - obtain the
;;;1838   		address of the RAM then create the idle task. */
;;;1839   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
;;;1840   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
;;;1841   												"IDLE",
;;;1842   												ulIdleTaskStackSize,
;;;1843   												( void * ) NULL,
;;;1844   												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1845   												pxIdleTaskStackBuffer,
;;;1846   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1847   
;;;1848   		if( xIdleTaskHandle != NULL )
;;;1849   		{
;;;1850   			xReturn = pdPASS;
;;;1851   		}
;;;1852   		else
;;;1853   		{
;;;1854   			xReturn = pdFAIL;
;;;1855   		}
;;;1856   	}
;;;1857   	#else
;;;1858   	{
;;;1859   		/* The Idle task is being created using dynamically allocated RAM. */
;;;1860   		xReturn = xTaskCreate(	prvIdleTask,
000004  e59f0098          LDR      r0,|L36.164|
000008  e3a01000          MOV      r1,#0
00000c  e58d1000          STR      r1,[sp,#0]
000010  e1a03001          MOV      r3,r1
000014  e3a0205a          MOV      r2,#0x5a
000018  e28f1088          ADR      r1,|L36.168|
00001c  e58d0004          STR      r0,[sp,#4]
000020  e59f0088          LDR      r0,|L36.176|
000024  ebfffffe          BL       xTaskCreate
000028  e1a04000          MOV      r4,r0
;;;1861   								"IDLE", configMINIMAL_STACK_SIZE,
;;;1862   								( void * ) NULL,
;;;1863   								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1864   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1865   	}
;;;1866   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;1867   
;;;1868   	#if ( configUSE_TIMERS == 1 )
;;;1869   	{
;;;1870   		if( xReturn == pdPASS )
;;;1871   		{
;;;1872   			xReturn = xTimerCreateTimerTask();
;;;1873   		}
;;;1874   		else
;;;1875   		{
;;;1876   			mtCOVERAGE_TEST_MARKER();
;;;1877   		}
;;;1878   	}
;;;1879   	#endif /* configUSE_TIMERS */
;;;1880   
;;;1881   	if( xReturn == pdPASS )
00002c  e3540001          CMP      r4,#1
000030  1a00000d          BNE      |L36.108|
;;;1882   	{
;;;1883   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1884   		before or during the call to xPortStartScheduler().  The stacks of
;;;1885   		the created tasks contain a status word with interrupts switched on
;;;1886   		so interrupts will automatically get re-enabled when the first task
;;;1887   		starts to run. */
;;;1888   		portDISABLE_INTERRUPTS();
000034  e10f0000          MRS      r0,APSR ; formerly CPSR
000038  e3800080          ORR      r0,r0,#0x80
00003c  e121f000          MSR      CPSR_c,r0
;;;1889   
;;;1890   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1891   		{
;;;1892   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1893   			structure specific to the task that will run first. */
;;;1894   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1895   		}
;;;1896   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1897   
;;;1898   		xNextTaskUnblockTime = portMAX_DELAY;
000040  e3e00000          MVN      r0,#0
000044  e59f1068          LDR      r1,|L36.180|
000048  e5810000          STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;1899   		xSchedulerRunning = pdTRUE;
00004c  e3a00001          MOV      r0,#1
000050  e59f1060          LDR      r1,|L36.184|
000054  e5810000          STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1900   		xTickCount = ( TickType_t ) 0U;
000058  e3a00000          MOV      r0,#0
00005c  e59f1058          LDR      r1,|L36.188|
000060  e5810000          STR      r0,[r1,#0]  ; xTickCount
;;;1901   
;;;1902   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1903   		macro must be defined to configure the timer/counter used to generate
;;;1904   		the run time counter time base. */
;;;1905   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1906   
;;;1907   		/* Setting up the timer tick is hardware specific and thus in the
;;;1908   		portable interface. */
;;;1909   		if( xPortStartScheduler() != pdFALSE )
000064  ebfffffe          BL       xPortStartScheduler
000068  ea00000c          B        |L36.160|
                  |L36.108|
;;;1910   		{
;;;1911   			/* Should not reach here as if the scheduler is running the
;;;1912   			function will not return. */
;;;1913   		}
;;;1914   		else
;;;1915   		{
;;;1916   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1917   		}
;;;1918   	}
;;;1919   	else
;;;1920   	{
;;;1921   		/* This line will only be reached if the kernel could not be started,
;;;1922   		because there was not enough FreeRTOS heap to create the idle task
;;;1923   		or the timer task. */
;;;1924   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
00006c  e3740001          CMN      r4,#1
000070  0a000001          BEQ      |L36.124|
000074  e3a00001          MOV      r0,#1
000078  ea000000          B        |L36.128|
                  |L36.124|
00007c  e3a00000          MOV      r0,#0
                  |L36.128|
000080  e3500000          CMP      r0,#0
000084  1a000005          BNE      |L36.160|
000088  e1a00000          MOV      r0,r0
00008c  e28f202c          ADR      r2,|L36.192|
000090  e59f1040          LDR      r1,|L36.216|
000094  e28f0040          ADR      r0,|L36.220|
000098  ebfffffe          BL       sysprintf
00009c  e1a00000          MOV      r0,r0
                  |L36.160|
;;;1925   	}
;;;1926   
;;;1927   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;1928   	meaning xIdleTaskHandle is not used anywhere else. */
;;;1929   	( void ) xIdleTaskHandle;
;;;1930   }
0000a0  e8bd801c          POP      {r2-r4,pc}
;;;1931   /*-----------------------------------------------------------*/
                          ENDP

                  |L36.164|
                          DCD      xIdleTaskHandle
                  |L36.168|
0000a8  49444c45          DCB      "IDLE",0
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L36.176|
                          DCD      prvIdleTask
                  |L36.180|
                          DCD      xNextTaskUnblockTime
                  |L36.184|
                          DCD      xSchedulerRunning
                  |L36.188|
                          DCD      xTickCount
                  |L36.192|
0000c0  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0000c4  52544f53
0000c8  5c536f75
0000cc  7263655c
0000d0  7461736b
0000d4  732e6300
                  |L36.216|
                          DCD      0x00000784
                  |L36.220|
0000dc  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000e0  7274696f
0000e4  6e202220
0000e8  3f3f3f20
0000ec  22206661
0000f0  696c6564
0000f4  20617420
0000f8  6c696e65
0000fc  20256420
000100  696e2025
000104  730a00  
000107  00                DCB      0

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1565   
;;;1566   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1567   	{
000004  e1a05000          MOV      r5,r0
;;;1568   	TCB_t *pxTCB;
;;;1569   
;;;1570   		taskENTER_CRITICAL();
000008  ebfffffe          BL       vPortEnterCritical
;;;1571   		{
;;;1572   			/* If null is passed in here then it is the running task that is
;;;1573   			being suspended. */
;;;1574   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
00000c  e3550000          CMP      r5,#0
000010  1a000002          BNE      |L37.32|
000014  e59f00e8          LDR      r0,|L37.260|
000018  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
00001c  ea000000          B        |L37.36|
                  |L37.32|
000020  e1a00005          MOV      r0,r5
                  |L37.36|
000024  e1a04000          MOV      r4,r0
;;;1575   
;;;1576   			traceTASK_SUSPEND( pxTCB );
;;;1577   
;;;1578   			/* Remove task from the ready/delayed list and place in the
;;;1579   			suspended list. */
;;;1580   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000028  e2840004          ADD      r0,r4,#4
00002c  ebfffffe          BL       uxListRemove
;;;1581   			{
;;;1582   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1583   			}
;;;1584   			else
;;;1585   			{
;;;1586   				mtCOVERAGE_TEST_MARKER();
;;;1587   			}
;;;1588   
;;;1589   			/* Is the task waiting on an event also? */
;;;1590   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000030  e5940028          LDR      r0,[r4,#0x28]
000034  e3500000          CMP      r0,#0
000038  0a000001          BEQ      |L37.68|
;;;1591   			{
;;;1592   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00003c  e2840018          ADD      r0,r4,#0x18
000040  ebfffffe          BL       uxListRemove
                  |L37.68|
;;;1593   			}
;;;1594   			else
;;;1595   			{
;;;1596   				mtCOVERAGE_TEST_MARKER();
;;;1597   			}
;;;1598   
;;;1599   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000044  e2841004          ADD      r1,r4,#4
000048  e59f00b8          LDR      r0,|L37.264|
00004c  ebfffffe          BL       vListInsertEnd
;;;1600   		}
;;;1601   		taskEXIT_CRITICAL();
000050  ebfffffe          BL       vPortExitCritical
;;;1602   
;;;1603   		if( xSchedulerRunning != pdFALSE )
000054  e59f00b0          LDR      r0,|L37.268|
000058  e5900000          LDR      r0,[r0,#0]  ; xSchedulerRunning
00005c  e3500000          CMP      r0,#0
000060  0a000002          BEQ      |L37.112|
;;;1604   		{
;;;1605   			/* Reset the next expected unblock time in case it referred to the
;;;1606   			task that is now in the Suspended state. */
;;;1607   			taskENTER_CRITICAL();
000064  ebfffffe          BL       vPortEnterCritical
;;;1608   			{
;;;1609   				prvResetNextTaskUnblockTime();
000068  ebfffffe          BL       prvResetNextTaskUnblockTime
;;;1610   			}
;;;1611   			taskEXIT_CRITICAL();
00006c  ebfffffe          BL       vPortExitCritical
                  |L37.112|
;;;1612   		}
;;;1613   		else
;;;1614   		{
;;;1615   			mtCOVERAGE_TEST_MARKER();
;;;1616   		}
;;;1617   
;;;1618   		if( pxTCB == pxCurrentTCB )
000070  e59f008c          LDR      r0,|L37.260|
000074  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000078  e1540000          CMP      r4,r0
00007c  1a00001f          BNE      |L37.256|
;;;1619   		{
;;;1620   			if( xSchedulerRunning != pdFALSE )
000080  e59f0084          LDR      r0,|L37.268|
000084  e5900000          LDR      r0,[r0,#0]  ; xSchedulerRunning
000088  e3500000          CMP      r0,#0
00008c  0a000010          BEQ      |L37.212|
;;;1621   			{
;;;1622   				/* The current task has just been suspended. */
;;;1623   				configASSERT( uxSchedulerSuspended == 0 );
000090  e59f0078          LDR      r0,|L37.272|
000094  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000098  e3500000          CMP      r0,#0
00009c  1a000001          BNE      |L37.168|
0000a0  e3a00001          MOV      r0,#1
0000a4  ea000000          B        |L37.172|
                  |L37.168|
0000a8  e3a00000          MOV      r0,#0
                  |L37.172|
0000ac  e3500000          CMP      r0,#0
0000b0  1a000005          BNE      |L37.204|
0000b4  e1a00000          MOV      r0,r0
0000b8  e28f2054          ADR      r2,|L37.276|
0000bc  e59f1068          LDR      r1,|L37.300|
0000c0  e28f0068          ADR      r0,|L37.304|
0000c4  ebfffffe          BL       sysprintf
0000c8  e1a00000          MOV      r0,r0
                  |L37.204|
;;;1624   				portYIELD_WITHIN_API();
0000cc  ebfffffe          BL       vPortYield
0000d0  ea00000a          B        |L37.256|
                  |L37.212|
;;;1625   			}
;;;1626   			else
;;;1627   			{
;;;1628   				/* The scheduler is not running, but the task that was pointed
;;;1629   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1630   				must be adjusted to point to a different task. */
;;;1631   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
0000d4  e59f002c          LDR      r0,|L37.264|
0000d8  e5900000          LDR      r0,[r0,#0]  ; xSuspendedTaskList
0000dc  e59f1078          LDR      r1,|L37.348|
0000e0  e5911000          LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
0000e4  e1500001          CMP      r0,r1
0000e8  1a000003          BNE      |L37.252|
;;;1632   				{
;;;1633   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1634   					NULL so when the next task is created pxCurrentTCB will
;;;1635   					be set to point to it no matter what its relative priority
;;;1636   					is. */
;;;1637   					pxCurrentTCB = NULL;
0000ec  e3a00000          MOV      r0,#0
0000f0  e59f100c          LDR      r1,|L37.260|
0000f4  e5810000          STR      r0,[r1,#0]  ; pxCurrentTCB
0000f8  ea000000          B        |L37.256|
                  |L37.252|
;;;1638   				}
;;;1639   				else
;;;1640   				{
;;;1641   					vTaskSwitchContext();
0000fc  ebfffffe          BL       vTaskSwitchContext
                  |L37.256|
;;;1642   				}
;;;1643   			}
;;;1644   		}
;;;1645   		else
;;;1646   		{
;;;1647   			mtCOVERAGE_TEST_MARKER();
;;;1648   		}
;;;1649   	}
000100  e8bd8070          POP      {r4-r6,pc}
;;;1650   
                          ENDP

                  |L37.260|
                          DCD      pxCurrentTCB
                  |L37.264|
                          DCD      xSuspendedTaskList
                  |L37.268|
                          DCD      xSchedulerRunning
                  |L37.272|
                          DCD      uxSchedulerSuspended
                  |L37.276|
000114  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
000118  52544f53
00011c  5c536f75
000120  7263655c
000124  7461736b
000128  732e6300
                  |L37.300|
                          DCD      0x00000657
                  |L37.304|
000130  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000134  7274696f
000138  6e202220
00013c  3f3f3f20
000140  22206661
000144  696c6564
000148  20617420
00014c  6c696e65
000150  20256420
000154  696e2025
000158  730a00  
00015b  00                DCB      0
                  |L37.348|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;1943   
;;;1944   void vTaskSuspendAll( void )
000000  e59f0010          LDR      r0,|L38.24|
;;;1945   {
;;;1946   	/* A critical section is not required as the variable is of type
;;;1947   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;1948   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;1949   	http://goo.gl/wu4acr */
;;;1950   	++uxSchedulerSuspended;
000004  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000008  e2800001          ADD      r0,r0,#1
00000c  e59f1004          LDR      r1,|L38.24|
000010  e5810000          STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1951   }
000014  e12fff1e          BX       lr
;;;1952   /*----------------------------------------------------------*/
                          ENDP

                  |L38.24|
                          DCD      uxSchedulerSuspended

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2760   
;;;2761   void vTaskSwitchContext( void )
000000  e92d4010          PUSH     {r4,lr}
;;;2762   {
;;;2763   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000004  e59f00d0          LDR      r0,|L39.220|
000008  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  e3500000          CMP      r0,#0
000010  0a000003          BEQ      |L39.36|
;;;2764   	{
;;;2765   		/* The scheduler is currently suspended - do not allow a context
;;;2766   		switch. */
;;;2767   		xYieldPending = pdTRUE;
000014  e3a00001          MOV      r0,#1
000018  e59f10c0          LDR      r1,|L39.224|
00001c  e5810000          STR      r0,[r1,#0]  ; xYieldPending
000020  ea00002c          B        |L39.216|
                  |L39.36|
;;;2768   	}
;;;2769   	else
;;;2770   	{
;;;2771   		xYieldPending = pdFALSE;
000024  e3a00000          MOV      r0,#0
000028  e59f10b0          LDR      r1,|L39.224|
00002c  e5810000          STR      r0,[r1,#0]  ; xYieldPending
;;;2772   		traceTASK_SWITCHED_OUT();
;;;2773   
;;;2774   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2775   		{
;;;2776   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2777   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2778   				#else
;;;2779   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2780   				#endif
;;;2781   
;;;2782   				/* Add the amount of time the task has been running to the
;;;2783   				accumulated time so far.  The time the task started running was
;;;2784   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2785   				protection here so count values are only valid until the timer
;;;2786   				overflows.  The guard against negative values is to protect
;;;2787   				against suspect run time stat counter implementations - which
;;;2788   				are provided by the application, not the kernel. */
;;;2789   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2790   				{
;;;2791   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2792   				}
;;;2793   				else
;;;2794   				{
;;;2795   					mtCOVERAGE_TEST_MARKER();
;;;2796   				}
;;;2797   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2798   		}
;;;2799   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2800   
;;;2801   		/* Check for stack overflow, if configured. */
;;;2802   		taskCHECK_FOR_STACK_OVERFLOW();
;;;2803   
;;;2804   		/* Select a new task to run using either the generic C or port
;;;2805   		optimised asm code. */
;;;2806   		taskSELECT_HIGHEST_PRIORITY_TASK();
000030  e59f00ac          LDR      r0,|L39.228|
000034  e5904000          LDR      r4,[r0,#0]  ; uxTopReadyPriority
000038  ea000008          B        |L39.96|
                  |L39.60|
00003c  e3540000          CMP      r4,#0
000040  1a000005          BNE      |L39.92|
000044  e1a00000          MOV      r0,r0
000048  e28f2098          ADR      r2,|L39.232|
00004c  e59f10ac          LDR      r1,|L39.256|
000050  e28f00ac          ADR      r0,|L39.260|
000054  ebfffffe          BL       sysprintf
000058  e1a00000          MOV      r0,r0
                  |L39.92|
00005c  e2444001          SUB      r4,r4,#1
                  |L39.96|
000060  e0840104          ADD      r0,r4,r4,LSL #2
000064  e59f10c4          LDR      r1,|L39.304|
000068  e7910100          LDR      r0,[r1,r0,LSL #2]
00006c  e3500000          CMP      r0,#0
000070  1a000001          BNE      |L39.124|
000074  e3a00001          MOV      r0,#1
000078  ea000000          B        |L39.128|
                  |L39.124|
00007c  e3a00000          MOV      r0,#0
                  |L39.128|
000080  e3500000          CMP      r0,#0
000084  1affffec          BNE      |L39.60|
000088  e0841104          ADD      r1,r4,r4,LSL #2
00008c  e59f209c          LDR      r2,|L39.304|
000090  e0820101          ADD      r0,r2,r1,LSL #2
000094  e5901004          LDR      r1,[r0,#4]
000098  e5911004          LDR      r1,[r1,#4]
00009c  e5801004          STR      r1,[r0,#4]
0000a0  e5901004          LDR      r1,[r0,#4]
0000a4  e2802008          ADD      r2,r0,#8
0000a8  e1510002          CMP      r1,r2
0000ac  1a000002          BNE      |L39.188|
0000b0  e5901004          LDR      r1,[r0,#4]
0000b4  e5911004          LDR      r1,[r1,#4]
0000b8  e5801004          STR      r1,[r0,#4]
                  |L39.188|
0000bc  e5901004          LDR      r1,[r0,#4]
0000c0  e591100c          LDR      r1,[r1,#0xc]
0000c4  e59f2068          LDR      r2,|L39.308|
0000c8  e5821000          STR      r1,[r2,#0]  ; pxCurrentTCB
0000cc  e59f0010          LDR      r0,|L39.228|
0000d0  e5804000          STR      r4,[r0,#0]  ; uxTopReadyPriority
0000d4  e1a00000          MOV      r0,r0
                  |L39.216|
;;;2807   		traceTASK_SWITCHED_IN();
;;;2808   
;;;2809   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2810   		{
;;;2811   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2812   			structure specific to this task. */
;;;2813   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2814   		}
;;;2815   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2816   	}
;;;2817   }
0000d8  e8bd8010          POP      {r4,pc}
;;;2818   /*-----------------------------------------------------------*/
                          ENDP

                  |L39.220|
                          DCD      uxSchedulerSuspended
                  |L39.224|
                          DCD      xYieldPending
                  |L39.228|
                          DCD      uxTopReadyPriority
                  |L39.232|
0000e8  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0000ec  52544f53
0000f0  5c536f75
0000f4  7263655c
0000f8  7461736b
0000fc  732e6300
                  |L39.256|
                          DCD      0x00000af6
                  |L39.260|
000104  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000108  7274696f
00010c  6e202220
000110  3f3f3f20
000114  22206661
000118  696c6564
00011c  20617420
000120  6c696e65
000124  20256420
000128  696e2025
00012c  730a00  
00012f  00                DCB      0
                  |L39.304|
                          DCD      pxReadyTasksLists
                  |L39.308|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;3014   
;;;3015   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3016   {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;3017   BaseType_t xReturn;
;;;3018   
;;;3019   	configASSERT( pxTimeOut );
00000c  e3540000          CMP      r4,#0
000010  1a000005          BNE      |L40.44|
000014  e1a00000          MOV      r0,r0
000018  e28f20bc          ADR      r2,|L40.220|
00001c  e59f10d0          LDR      r1,|L40.244|
000020  e28f00d0          ADR      r0,|L40.248|
000024  ebfffffe          BL       sysprintf
000028  e1a00000          MOV      r0,r0
                  |L40.44|
;;;3020   	configASSERT( pxTicksToWait );
00002c  e3550000          CMP      r5,#0
000030  1a000005          BNE      |L40.76|
000034  e1a00000          MOV      r0,r0
000038  e28f209c          ADR      r2,|L40.220|
00003c  e59f10e0          LDR      r1,|L40.292|
000040  e28f00b0          ADR      r0,|L40.248|
000044  ebfffffe          BL       sysprintf
000048  e1a00000          MOV      r0,r0
                  |L40.76|
;;;3021   
;;;3022   	taskENTER_CRITICAL();
00004c  ebfffffe          BL       vPortEnterCritical
;;;3023   	{
;;;3024   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3025   		const TickType_t xConstTickCount = xTickCount;
000050  e59f00d0          LDR      r0,|L40.296|
000054  e5907000          LDR      r7,[r0,#0]  ; xTickCount
;;;3026   
;;;3027   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3028   			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
;;;3029   			{
;;;3030   				/* The delay was aborted, which is not the same as a time out,
;;;3031   				but has the same result. */
;;;3032   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3033   				xReturn = pdTRUE;
;;;3034   			}
;;;3035   			else
;;;3036   		#endif
;;;3037   
;;;3038   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3039   			if( *pxTicksToWait == portMAX_DELAY )
000058  e5950000          LDR      r0,[r5,#0]
00005c  e3700001          CMN      r0,#1
000060  1a000001          BNE      |L40.108|
;;;3040   			{
;;;3041   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3042   				specified is the maximum block time then the task should block
;;;3043   				indefinitely, and therefore never time out. */
;;;3044   				xReturn = pdFALSE;
000064  e3a06000          MOV      r6,#0
000068  ea000018          B        |L40.208|
                  |L40.108|
;;;3045   			}
;;;3046   			else
;;;3047   		#endif
;;;3048   
;;;3049   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
00006c  e59f10b8          LDR      r1,|L40.300|
000070  e5940000          LDR      r0,[r4,#0]
000074  e5911000          LDR      r1,[r1,#0]  ; xNumOfOverflows
000078  e1500001          CMP      r0,r1
00007c  0a000004          BEQ      |L40.148|
000080  e5940004          LDR      r0,[r4,#4]
000084  e1500007          CMP      r0,r7
000088  8a000001          BHI      |L40.148|
;;;3050   		{
;;;3051   			/* The tick count is greater than the time at which
;;;3052   			vTaskSetTimeout() was called, but has also overflowed since
;;;3053   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3054   			around and gone past again. This passed since vTaskSetTimeout()
;;;3055   			was called. */
;;;3056   			xReturn = pdTRUE;
00008c  e3a06001          MOV      r6,#1
000090  ea00000e          B        |L40.208|
                  |L40.148|
;;;3057   		}
;;;3058   		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
000094  e5940004          LDR      r0,[r4,#4]
000098  e0470000          SUB      r0,r7,r0
00009c  e5951000          LDR      r1,[r5,#0]
0000a0  e1500001          CMP      r0,r1
0000a4  2a000008          BCS      |L40.204|
;;;3059   		{
;;;3060   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3061   			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
0000a8  e5950000          LDR      r0,[r5,#0]
0000ac  e5941004          LDR      r1,[r4,#4]
0000b0  e0471001          SUB      r1,r7,r1
0000b4  e0400001          SUB      r0,r0,r1
0000b8  e5850000          STR      r0,[r5,#0]
;;;3062   			vTaskSetTimeOutState( pxTimeOut );
0000bc  e1a00004          MOV      r0,r4
0000c0  ebfffffe          BL       vTaskSetTimeOutState
;;;3063   			xReturn = pdFALSE;
0000c4  e3a06000          MOV      r6,#0
0000c8  ea000000          B        |L40.208|
                  |L40.204|
;;;3064   		}
;;;3065   		else
;;;3066   		{
;;;3067   			xReturn = pdTRUE;
0000cc  e3a06001          MOV      r6,#1
                  |L40.208|
;;;3068   		}
;;;3069   	}
;;;3070   	taskEXIT_CRITICAL();
0000d0  ebfffffe          BL       vPortExitCritical
;;;3071   
;;;3072   	return xReturn;
0000d4  e1a00006          MOV      r0,r6
;;;3073   }
0000d8  e8bd81f0          POP      {r4-r8,pc}
;;;3074   /*-----------------------------------------------------------*/
                          ENDP

                  |L40.220|
0000dc  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0000e0  52544f53
0000e4  5c536f75
0000e8  7263655c
0000ec  7461736b
0000f0  732e6300
                  |L40.244|
                          DCD      0x00000bcb
                  |L40.248|
0000f8  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000fc  7274696f
000100  6e202220
000104  3f3f3f20
000108  22206661
00010c  696c6564
000110  20617420
000114  6c696e65
000118  20256420
00011c  696e2025
000120  730a00  
000123  00                DCB      0
                  |L40.292|
                          DCD      0x00000bcc
                  |L40.296|
                          DCD      xTickCount
                  |L40.300|
                          DCD      xNumOfOverflows

                          AREA ||i.xTaskCreate||, CODE, READONLY, ALIGN=2

                  xTaskCreate PROC
;;;675    
;;;676    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;677    							const char * const pcName,
;;;678    							const uint16_t usStackDepth,
;;;679    							void * const pvParameters,
;;;680    							UBaseType_t uxPriority,
;;;681    							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;682    	{
000004  e24dd014          SUB      sp,sp,#0x14
000008  e1a08000          MOV      r8,r0
00000c  e1a09001          MOV      r9,r1
000010  e1a07002          MOV      r7,r2
000014  e1cda4d8          LDRD     r10,r11,[sp,#0x48]
;;;683    	TCB_t *pxNewTCB;
;;;684    	BaseType_t xReturn;
;;;685    
;;;686    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;687    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;688    		the TCB then the stack. */
;;;689    		#if( portSTACK_GROWTH > 0 )
;;;690    		{
;;;691    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;692    			the implementation of the port malloc function and whether or not static
;;;693    			allocation is being used. */
;;;694    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;695    
;;;696    			if( pxNewTCB != NULL )
;;;697    			{
;;;698    				/* Allocate space for the stack used by the task being created.
;;;699    				The base of the stack memory stored in the TCB so the task can
;;;700    				be deleted later if required. */
;;;701    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;702    
;;;703    				if( pxNewTCB->pxStack == NULL )
;;;704    				{
;;;705    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;706    					vPortFree( pxNewTCB );
;;;707    					pxNewTCB = NULL;
;;;708    				}
;;;709    			}
;;;710    		}
;;;711    		#else /* portSTACK_GROWTH */
;;;712    		{
;;;713    		StackType_t *pxStack;
;;;714    
;;;715    			/* Allocate space for the stack used by the task being created. */
;;;716    			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000018  e1a00107          LSL      r0,r7,#2
00001c  ebfffffe          BL       pvPortMalloc
000020  e1a06000          MOV      r6,r0
;;;717    
;;;718    			if( pxStack != NULL )
000024  e3560000          CMP      r6,#0
000028  0a000009          BEQ      |L41.84|
;;;719    			{
;;;720    				/* Allocate space for the TCB. */
;;;721    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
00002c  e3a0004c          MOV      r0,#0x4c
000030  ebfffffe          BL       pvPortMalloc
000034  e1a04000          MOV      r4,r0
;;;722    
;;;723    				if( pxNewTCB != NULL )
000038  e3540000          CMP      r4,#0
00003c  0a000001          BEQ      |L41.72|
;;;724    				{
;;;725    					/* Store the stack location in the TCB. */
;;;726    					pxNewTCB->pxStack = pxStack;
000040  e5846030          STR      r6,[r4,#0x30]
000044  ea000003          B        |L41.88|
                  |L41.72|
;;;727    				}
;;;728    				else
;;;729    				{
;;;730    					/* The stack cannot be used as the TCB was not created.  Free
;;;731    					it again. */
;;;732    					vPortFree( pxStack );
000048  e1a00006          MOV      r0,r6
00004c  ebfffffe          BL       vPortFree
000050  ea000000          B        |L41.88|
                  |L41.84|
;;;733    				}
;;;734    			}
;;;735    			else
;;;736    			{
;;;737    				pxNewTCB = NULL;
000054  e3a04000          MOV      r4,#0
                  |L41.88|
;;;738    			}
;;;739    		}
;;;740    		#endif /* portSTACK_GROWTH */
;;;741    
;;;742    		if( pxNewTCB != NULL )
000058  e3540000          CMP      r4,#0
00005c  0a00000c          BEQ      |L41.148|
;;;743    		{
;;;744    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
;;;745    			{
;;;746    				/* Tasks can be created statically or dynamically, so note this
;;;747    				task was created dynamically in case it is later deleted. */
;;;748    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
;;;749    			}
;;;750    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;751    
;;;752    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
000060  e3a00000          MOV      r0,#0
000064  e58d000c          STR      r0,[sp,#0xc]
000068  e58d4008          STR      r4,[sp,#8]
00006c  e1cda0f0          STRD     r10,r11,[sp,#0]
000070  e1a02007          MOV      r2,r7
000074  e1a01009          MOV      r1,r9
000078  e1a00008          MOV      r0,r8
00007c  e59d3020          LDR      r3,[sp,#0x20]
000080  ebfffffe          BL       prvInitialiseNewTask
;;;753    			prvAddNewTaskToReadyList( pxNewTCB );
000084  e1a00004          MOV      r0,r4
000088  ebfffffe          BL       prvAddNewTaskToReadyList
;;;754    			xReturn = pdPASS;
00008c  e3a05001          MOV      r5,#1
000090  ea000000          B        |L41.152|
                  |L41.148|
;;;755    		}
;;;756    		else
;;;757    		{
;;;758    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000094  e3e05000          MVN      r5,#0
                  |L41.152|
;;;759    		}
;;;760    
;;;761    		return xReturn;
000098  e1a00005          MOV      r0,r5
00009c  e28dd024          ADD      sp,sp,#0x24
;;;762    	}
0000a0  e8bd8ff0          POP      {r4-r11,pc}
;;;763    
                          ENDP


                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotify PROC
;;;4342   
;;;4343   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4344   	{
000004  e1a06000          MOV      r6,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a07002          MOV      r7,r2
000010  e1a08003          MOV      r8,r3
;;;4345   	TCB_t * pxTCB;
;;;4346   	BaseType_t xReturn = pdPASS;
000014  e3a0a001          MOV      r10,#1
;;;4347   	uint8_t ucOriginalNotifyState;
;;;4348   
;;;4349   		configASSERT( xTaskToNotify );
000018  e3560000          CMP      r6,#0
00001c  1a000005          BNE      |L42.56|
000020  e1a00000          MOV      r0,r0
000024  e28f2f55          ADR      r2,|L42.384|
000028  e59f1168          LDR      r1,|L42.408|
00002c  e28f0f5a          ADR      r0,|L42.412|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L42.56|
;;;4350   		pxTCB = ( TCB_t * ) xTaskToNotify;
000038  e1a04006          MOV      r4,r6
;;;4351   
;;;4352   		taskENTER_CRITICAL();
00003c  ebfffffe          BL       vPortEnterCritical
;;;4353   		{
;;;4354   			if( pulPreviousNotificationValue != NULL )
000040  e3580000          CMP      r8,#0
000044  0a000001          BEQ      |L42.80|
;;;4355   			{
;;;4356   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000048  e5940044          LDR      r0,[r4,#0x44]
00004c  e5880000          STR      r0,[r8,#0]
                  |L42.80|
;;;4357   			}
;;;4358   
;;;4359   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000050  e5d49048          LDRB     r9,[r4,#0x48]
;;;4360   
;;;4361   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000054  e3a00002          MOV      r0,#2
000058  e5c40048          STRB     r0,[r4,#0x48]
;;;4362   
;;;4363   			switch( eAction )
00005c  e3570005          CMP      r7,#5
000060  308ff107          ADDCC    pc,pc,r7,LSL #2
000064  ea00001a          B        |L42.212|
000068  ea000017          B        |L42.204|
00006c  ea000002          B        |L42.124|
000070  ea000006          B        |L42.144|
000074  ea00000a          B        |L42.164|
000078  ea00000c          B        |L42.176|
                  |L42.124|
;;;4364   			{
;;;4365   				case eSetBits	:
00007c  e1a00000          MOV      r0,r0
;;;4366   					pxTCB->ulNotifiedValue |= ulValue;
000080  e5940044          LDR      r0,[r4,#0x44]
000084  e1800005          ORR      r0,r0,r5
000088  e5840044          STR      r0,[r4,#0x44]
;;;4367   					break;
00008c  ea000010          B        |L42.212|
                  |L42.144|
;;;4368   
;;;4369   				case eIncrement	:
000090  e1a00000          MOV      r0,r0
;;;4370   					( pxTCB->ulNotifiedValue )++;
000094  e5940044          LDR      r0,[r4,#0x44]
000098  e2800001          ADD      r0,r0,#1
00009c  e5840044          STR      r0,[r4,#0x44]
;;;4371   					break;
0000a0  ea00000b          B        |L42.212|
                  |L42.164|
;;;4372   
;;;4373   				case eSetValueWithOverwrite	:
0000a4  e1a00000          MOV      r0,r0
;;;4374   					pxTCB->ulNotifiedValue = ulValue;
0000a8  e5845044          STR      r5,[r4,#0x44]
;;;4375   					break;
0000ac  ea000008          B        |L42.212|
                  |L42.176|
;;;4376   
;;;4377   				case eSetValueWithoutOverwrite :
0000b0  e1a00000          MOV      r0,r0
;;;4378   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
0000b4  e3590002          CMP      r9,#2
0000b8  0a000001          BEQ      |L42.196|
;;;4379   					{
;;;4380   						pxTCB->ulNotifiedValue = ulValue;
0000bc  e5845044          STR      r5,[r4,#0x44]
0000c0  ea000000          B        |L42.200|
                  |L42.196|
;;;4381   					}
;;;4382   					else
;;;4383   					{
;;;4384   						/* The value could not be written to the task. */
;;;4385   						xReturn = pdFAIL;
0000c4  e3a0a000          MOV      r10,#0
                  |L42.200|
;;;4386   					}
;;;4387   					break;
0000c8  ea000001          B        |L42.212|
                  |L42.204|
;;;4388   
;;;4389   				case eNoAction:
0000cc  e1a00000          MOV      r0,r0
;;;4390   					/* The task is being notified without its notify value being
;;;4391   					updated. */
;;;4392   					break;
0000d0  e1a00000          MOV      r0,r0
                  |L42.212|
0000d4  e1a00000          MOV      r0,r0                 ;4367
;;;4393   			}
;;;4394   
;;;4395   			traceTASK_NOTIFY();
;;;4396   
;;;4397   			/* If the task is in the blocked state specifically to wait for a
;;;4398   			notification then unblock it now. */
;;;4399   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
0000d8  e3590001          CMP      r9,#1
0000dc  1a000024          BNE      |L42.372|
;;;4400   			{
;;;4401   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0000e0  e2840004          ADD      r0,r4,#4
0000e4  ebfffffe          BL       uxListRemove
;;;4402   				prvAddTaskToReadyList( pxTCB );
0000e8  e59f10d8          LDR      r1,|L42.456|
0000ec  e594002c          LDR      r0,[r4,#0x2c]
0000f0  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000f4  e1500001          CMP      r0,r1
0000f8  9a000002          BLS      |L42.264|
0000fc  e59f10c4          LDR      r1,|L42.456|
000100  e594002c          LDR      r0,[r4,#0x2c]
000104  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L42.264|
000108  e594102c          LDR      r1,[r4,#0x2c]
00010c  e0811101          ADD      r1,r1,r1,LSL #2
000110  e59f20b4          LDR      r2,|L42.460|
000114  e0820101          ADD      r0,r2,r1,LSL #2
000118  e2841004          ADD      r1,r4,#4
00011c  ebfffffe          BL       vListInsertEnd
;;;4403   
;;;4404   				/* The task should not have been on an event list. */
;;;4405   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000120  e5940028          LDR      r0,[r4,#0x28]
000124  e3500000          CMP      r0,#0
000128  1a000001          BNE      |L42.308|
00012c  e3a00001          MOV      r0,#1
000130  ea000000          B        |L42.312|
                  |L42.308|
000134  e3a00000          MOV      r0,#0
                  |L42.312|
000138  e3500000          CMP      r0,#0
00013c  1a000005          BNE      |L42.344|
000140  e1a00000          MOV      r0,r0
000144  e28f2034          ADR      r2,|L42.384|
000148  e59f1080          LDR      r1,|L42.464|
00014c  e28f0048          ADR      r0,|L42.412|
000150  ebfffffe          BL       sysprintf
000154  e1a00000          MOV      r0,r0
                  |L42.344|
;;;4406   
;;;4407   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4408   				{
;;;4409   					/* If a task is blocked waiting for a notification then
;;;4410   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4411   					out time.  If the task is unblocked for a reason other than
;;;4412   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4413   					because it will automatically get reset to a new value when
;;;4414   					the tick count equals xNextTaskUnblockTime.  However if
;;;4415   					tickless idling is used it might be more important to enter
;;;4416   					sleep mode at the earliest possible time - so reset
;;;4417   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4418   					earliest possible time. */
;;;4419   					prvResetNextTaskUnblockTime();
;;;4420   				}
;;;4421   				#endif
;;;4422   
;;;4423   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000158  e59f1074          LDR      r1,|L42.468|
00015c  e594002c          LDR      r0,[r4,#0x2c]
000160  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000164  e591102c          LDR      r1,[r1,#0x2c]
000168  e1500001          CMP      r0,r1
00016c  9a000000          BLS      |L42.372|
;;;4424   				{
;;;4425   					/* The notified task has a priority above the currently
;;;4426   					executing task so a yield is required. */
;;;4427   					taskYIELD_IF_USING_PREEMPTION();
000170  ebfffffe          BL       vPortYield
                  |L42.372|
;;;4428   				}
;;;4429   				else
;;;4430   				{
;;;4431   					mtCOVERAGE_TEST_MARKER();
;;;4432   				}
;;;4433   			}
;;;4434   			else
;;;4435   			{
;;;4436   				mtCOVERAGE_TEST_MARKER();
;;;4437   			}
;;;4438   		}
;;;4439   		taskEXIT_CRITICAL();
000174  ebfffffe          BL       vPortExitCritical
;;;4440   
;;;4441   		return xReturn;
000178  e1a0000a          MOV      r0,r10
;;;4442   	}
00017c  e8bd87f0          POP      {r4-r10,pc}
;;;4443   
                          ENDP

                  |L42.384|
000180  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
000184  52544f53
000188  5c536f75
00018c  7263655c
000190  7461736b
000194  732e6300
                  |L42.408|
                          DCD      0x000010fd
                  |L42.412|
00019c  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0001a0  7274696f
0001a4  6e202220
0001a8  3f3f3f20
0001ac  22206661
0001b0  696c6564
0001b4  20617420
0001b8  6c696e65
0001bc  20256420
0001c0  696e2025
0001c4  730a00  
0001c7  00                DCB      0
                  |L42.456|
                          DCD      uxTopReadyPriority
                  |L42.460|
                          DCD      pxReadyTasksLists
                  |L42.464|
                          DCD      0x00001135
                  |L42.468|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotifyFromISR PROC
;;;4448   
;;;4449   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;4450   	{
000004  e1a06000          MOV      r6,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a07002          MOV      r7,r2
000010  e1a08003          MOV      r8,r3
000014  e59da028          LDR      r10,[sp,#0x28]
;;;4451   	TCB_t * pxTCB;
;;;4452   	uint8_t ucOriginalNotifyState;
;;;4453   	BaseType_t xReturn = pdPASS;
000018  e3a00001          MOV      r0,#1
00001c  e58d0000          STR      r0,[sp,#0]
;;;4454   	UBaseType_t uxSavedInterruptStatus;
;;;4455   
;;;4456   		configASSERT( xTaskToNotify );
000020  e3560000          CMP      r6,#0
000024  1a000005          BNE      |L43.64|
000028  e1a00000          MOV      r0,r0
00002c  e28f2e19          ADR      r2,|L43.452|
000030  e59f11a4          LDR      r1,|L43.476|
000034  e28f0f69          ADR      r0,|L43.480|
000038  ebfffffe          BL       sysprintf
00003c  e1a00000          MOV      r0,r0
                  |L43.64|
;;;4457   
;;;4458   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4459   		maximum	system call (or maximum API call) interrupt priority.
;;;4460   		Interrupts that are	above the maximum system call priority are keep
;;;4461   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4462   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4463   		is defined in FreeRTOSConfig.h then
;;;4464   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4465   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4466   		been assigned a priority above the configured maximum system call
;;;4467   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4468   		from interrupts	that have been assigned a priority at or (logically)
;;;4469   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4470   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4471   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4472   		provided on the following link:
;;;4473   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4474   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4475   
;;;4476   		pxTCB = ( TCB_t * ) xTaskToNotify;
000040  e1a04006          MOV      r4,r6
;;;4477   
;;;4478   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000044  e3a0b000          MOV      r11,#0
;;;4479   		{
;;;4480   			if( pulPreviousNotificationValue != NULL )
000048  e3580000          CMP      r8,#0
00004c  0a000001          BEQ      |L43.88|
;;;4481   			{
;;;4482   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000050  e5940044          LDR      r0,[r4,#0x44]
000054  e5880000          STR      r0,[r8,#0]
                  |L43.88|
;;;4483   			}
;;;4484   
;;;4485   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000058  e5d49048          LDRB     r9,[r4,#0x48]
;;;4486   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
00005c  e3a00002          MOV      r0,#2
000060  e5c40048          STRB     r0,[r4,#0x48]
;;;4487   
;;;4488   			switch( eAction )
000064  e3570005          CMP      r7,#5
000068  308ff107          ADDCC    pc,pc,r7,LSL #2
00006c  ea00001b          B        |L43.224|
000070  ea000018          B        |L43.216|
000074  ea000002          B        |L43.132|
000078  ea000006          B        |L43.152|
00007c  ea00000a          B        |L43.172|
000080  ea00000c          B        |L43.184|
                  |L43.132|
;;;4489   			{
;;;4490   				case eSetBits	:
000084  e1a00000          MOV      r0,r0
;;;4491   					pxTCB->ulNotifiedValue |= ulValue;
000088  e5940044          LDR      r0,[r4,#0x44]
00008c  e1800005          ORR      r0,r0,r5
000090  e5840044          STR      r0,[r4,#0x44]
;;;4492   					break;
000094  ea000011          B        |L43.224|
                  |L43.152|
;;;4493   
;;;4494   				case eIncrement	:
000098  e1a00000          MOV      r0,r0
;;;4495   					( pxTCB->ulNotifiedValue )++;
00009c  e5940044          LDR      r0,[r4,#0x44]
0000a0  e2800001          ADD      r0,r0,#1
0000a4  e5840044          STR      r0,[r4,#0x44]
;;;4496   					break;
0000a8  ea00000c          B        |L43.224|
                  |L43.172|
;;;4497   
;;;4498   				case eSetValueWithOverwrite	:
0000ac  e1a00000          MOV      r0,r0
;;;4499   					pxTCB->ulNotifiedValue = ulValue;
0000b0  e5845044          STR      r5,[r4,#0x44]
;;;4500   					break;
0000b4  ea000009          B        |L43.224|
                  |L43.184|
;;;4501   
;;;4502   				case eSetValueWithoutOverwrite :
0000b8  e1a00000          MOV      r0,r0
;;;4503   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
0000bc  e3590002          CMP      r9,#2
0000c0  0a000001          BEQ      |L43.204|
;;;4504   					{
;;;4505   						pxTCB->ulNotifiedValue = ulValue;
0000c4  e5845044          STR      r5,[r4,#0x44]
0000c8  ea000001          B        |L43.212|
                  |L43.204|
;;;4506   					}
;;;4507   					else
;;;4508   					{
;;;4509   						/* The value could not be written to the task. */
;;;4510   						xReturn = pdFAIL;
0000cc  e3a00000          MOV      r0,#0
0000d0  e58d0000          STR      r0,[sp,#0]
                  |L43.212|
;;;4511   					}
;;;4512   					break;
0000d4  ea000001          B        |L43.224|
                  |L43.216|
;;;4513   
;;;4514   				case eNoAction :
0000d8  e1a00000          MOV      r0,r0
;;;4515   					/* The task is being notified without its notify value being
;;;4516   					updated. */
;;;4517   					break;
0000dc  e1a00000          MOV      r0,r0
                  |L43.224|
0000e0  e1a00000          MOV      r0,r0                 ;4492
;;;4518   			}
;;;4519   
;;;4520   			traceTASK_NOTIFY_FROM_ISR();
;;;4521   
;;;4522   			/* If the task is in the blocked state specifically to wait for a
;;;4523   			notification then unblock it now. */
;;;4524   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
0000e4  e3590001          CMP      r9,#1
0000e8  1a000033          BNE      |L43.444|
;;;4525   			{
;;;4526   				/* The task should not have been on an event list. */
;;;4527   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
0000ec  e5940028          LDR      r0,[r4,#0x28]
0000f0  e3500000          CMP      r0,#0
0000f4  1a000001          BNE      |L43.256|
0000f8  e3a00001          MOV      r0,#1
0000fc  ea000000          B        |L43.260|
                  |L43.256|
000100  e3a00000          MOV      r0,#0
                  |L43.260|
000104  e3500000          CMP      r0,#0
000108  1a000005          BNE      |L43.292|
00010c  e1a00000          MOV      r0,r0
000110  e28f20ac          ADR      r2,|L43.452|
000114  e59f10f0          LDR      r1,|L43.524|
000118  e28f00c0          ADR      r0,|L43.480|
00011c  ebfffffe          BL       sysprintf
000120  e1a00000          MOV      r0,r0
                  |L43.292|
;;;4528   
;;;4529   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000124  e59f00e4          LDR      r0,|L43.528|
000128  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00012c  e3500000          CMP      r0,#0
000130  1a000010          BNE      |L43.376|
;;;4530   				{
;;;4531   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000134  e2840004          ADD      r0,r4,#4
000138  ebfffffe          BL       uxListRemove
;;;4532   					prvAddTaskToReadyList( pxTCB );
00013c  e59f10d0          LDR      r1,|L43.532|
000140  e594002c          LDR      r0,[r4,#0x2c]
000144  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
000148  e1500001          CMP      r0,r1
00014c  9a000002          BLS      |L43.348|
000150  e59f10bc          LDR      r1,|L43.532|
000154  e594002c          LDR      r0,[r4,#0x2c]
000158  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L43.348|
00015c  e594102c          LDR      r1,[r4,#0x2c]
000160  e0811101          ADD      r1,r1,r1,LSL #2
000164  e59f20ac          LDR      r2,|L43.536|
000168  e0820101          ADD      r0,r2,r1,LSL #2
00016c  e2841004          ADD      r1,r4,#4
000170  ebfffffe          BL       vListInsertEnd
000174  ea000002          B        |L43.388|
                  |L43.376|
;;;4533   				}
;;;4534   				else
;;;4535   				{
;;;4536   					/* The delayed and ready lists cannot be accessed, so hold
;;;4537   					this task pending until the scheduler is resumed. */
;;;4538   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000178  e2841018          ADD      r1,r4,#0x18
00017c  e59f0098          LDR      r0,|L43.540|
000180  ebfffffe          BL       vListInsertEnd
                  |L43.388|
;;;4539   				}
;;;4540   
;;;4541   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000184  e59f1094          LDR      r1,|L43.544|
000188  e594002c          LDR      r0,[r4,#0x2c]
00018c  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000190  e591102c          LDR      r1,[r1,#0x2c]
000194  e1500001          CMP      r0,r1
000198  9a000007          BLS      |L43.444|
;;;4542   				{
;;;4543   					/* The notified task has a priority above the currently
;;;4544   					executing task so a yield is required. */
;;;4545   					if( pxHigherPriorityTaskWoken != NULL )
00019c  e35a0000          CMP      r10,#0
0001a0  0a000002          BEQ      |L43.432|
;;;4546   					{
;;;4547   						*pxHigherPriorityTaskWoken = pdTRUE;
0001a4  e3a00001          MOV      r0,#1
0001a8  e58a0000          STR      r0,[r10,#0]
0001ac  ea000002          B        |L43.444|
                  |L43.432|
;;;4548   					}
;;;4549   					else
;;;4550   					{
;;;4551   						/* Mark that a yield is pending in case the user is not
;;;4552   						using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;4553   						safe FreeRTOS function. */
;;;4554   						xYieldPending = pdTRUE;
0001b0  e3a00001          MOV      r0,#1
0001b4  e59f1068          LDR      r1,|L43.548|
0001b8  e5810000          STR      r0,[r1,#0]  ; xYieldPending
                  |L43.444|
;;;4555   					}
;;;4556   				}
;;;4557   				else
;;;4558   				{
;;;4559   					mtCOVERAGE_TEST_MARKER();
;;;4560   				}
;;;4561   			}
;;;4562   		}
;;;4563   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;4564   
;;;4565   		return xReturn;
0001bc  e59d0000          LDR      r0,[sp,#0]
;;;4566   	}
0001c0  e8bd8ff8          POP      {r3-r11,pc}
;;;4567   
                          ENDP

                  |L43.452|
0001c4  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0001c8  52544f53
0001cc  5c536f75
0001d0  7263655c
0001d4  7461736b
0001d8  732e6300
                  |L43.476|
                          DCD      0x00001168
                  |L43.480|
0001e0  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0001e4  7274696f
0001e8  6e202220
0001ec  3f3f3f20
0001f0  22206661
0001f4  696c6564
0001f8  20617420
0001fc  6c696e65
000200  20256420
000204  696e2025
000208  730a00  
00020b  00                DCB      0
                  |L43.524|
                          DCD      0x000011af
                  |L43.528|
                          DCD      uxSchedulerSuspended
                  |L43.532|
                          DCD      uxTopReadyPriority
                  |L43.536|
                          DCD      pxReadyTasksLists
                  |L43.540|
                          DCD      xPendingReadyList
                  |L43.544|
                          DCD      pxCurrentTCB
                  |L43.548|
                          DCD      xYieldPending

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3660   
;;;3661   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  e59f1004          LDR      r1,|L44.12|
;;;3662   	{
;;;3663   	TaskHandle_t xReturn;
;;;3664   
;;;3665   		/* A critical section is not required as this is not called from
;;;3666   		an interrupt and the current TCB will always be the same for any
;;;3667   		individual execution thread. */
;;;3668   		xReturn = pxCurrentTCB;
000004  e5910000          LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3669   
;;;3670   		return xReturn;
;;;3671   	}
000008  e12fff1e          BX       lr
;;;3672   
                          ENDP

                  |L44.12|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskGetSchedulerState||, CODE, READONLY, ALIGN=2

                  xTaskGetSchedulerState PROC
;;;3677   
;;;3678   	BaseType_t xTaskGetSchedulerState( void )
000000  e59f1030          LDR      r1,|L45.56|
;;;3679   	{
;;;3680   	BaseType_t xReturn;
;;;3681   
;;;3682   		if( xSchedulerRunning == pdFALSE )
000004  e5911000          LDR      r1,[r1,#0]  ; xSchedulerRunning
000008  e3510000          CMP      r1,#0
00000c  1a000001          BNE      |L45.24|
;;;3683   		{
;;;3684   			xReturn = taskSCHEDULER_NOT_STARTED;
000010  e3a00001          MOV      r0,#1
000014  ea000006          B        |L45.52|
                  |L45.24|
;;;3685   		}
;;;3686   		else
;;;3687   		{
;;;3688   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000018  e59f101c          LDR      r1,|L45.60|
00001c  e5911000          LDR      r1,[r1,#0]  ; uxSchedulerSuspended
000020  e3510000          CMP      r1,#0
000024  1a000001          BNE      |L45.48|
;;;3689   			{
;;;3690   				xReturn = taskSCHEDULER_RUNNING;
000028  e3a00002          MOV      r0,#2
00002c  ea000000          B        |L45.52|
                  |L45.48|
;;;3691   			}
;;;3692   			else
;;;3693   			{
;;;3694   				xReturn = taskSCHEDULER_SUSPENDED;
000030  e3a00000          MOV      r0,#0
                  |L45.52|
;;;3695   			}
;;;3696   		}
;;;3697   
;;;3698   		return xReturn;
;;;3699   	}
000034  e12fff1e          BX       lr
;;;3700   
                          ENDP

                  |L45.56|
                          DCD      xSchedulerRunning
                  |L45.60|
                          DCD      uxSchedulerSuspended

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;2126   
;;;2127   TickType_t xTaskGetTickCount( void )
000000  e92d4010          PUSH     {r4,lr}
;;;2128   {
;;;2129   TickType_t xTicks;
;;;2130   
;;;2131   	/* Critical section required if running on a 16 bit processor. */
;;;2132   	portTICK_TYPE_ENTER_CRITICAL();
000004  ebfffffe          BL       vPortEnterCritical
;;;2133   	{
;;;2134   		xTicks = xTickCount;
000008  e59f000c          LDR      r0,|L46.28|
00000c  e5904000          LDR      r4,[r0,#0]  ; xTickCount
;;;2135   	}
;;;2136   	portTICK_TYPE_EXIT_CRITICAL();
000010  ebfffffe          BL       vPortExitCritical
;;;2137   
;;;2138   	return xTicks;
000014  e1a00004          MOV      r0,r4
;;;2139   }
000018  e8bd8010          POP      {r4,pc}
;;;2140   /*-----------------------------------------------------------*/
                          ENDP

                  |L46.28|
                          DCD      xTickCount

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;2141   
;;;2142   TickType_t xTaskGetTickCountFromISR( void )
000000  e3a01000          MOV      r1,#0
;;;2143   {
;;;2144   TickType_t xReturn;
;;;2145   UBaseType_t uxSavedInterruptStatus;
;;;2146   
;;;2147   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2148   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2149   	above the maximum system call priority are kept permanently enabled, even
;;;2150   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2151   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2152   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2153   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2154   	assigned a priority above the configured maximum system call priority.
;;;2155   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2156   	that have been assigned a priority at or (logically) below the maximum
;;;2157   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2158   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2159   	More information (albeit Cortex-M specific) is provided on the following
;;;2160   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2161   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;2162   
;;;2163   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
;;;2164   	{
;;;2165   		xReturn = xTickCount;
000004  e59f2004          LDR      r2,|L47.16|
000008  e5920000          LDR      r0,[r2,#0]  ; xTickCount
;;;2166   	}
;;;2167   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2168   
;;;2169   	return xReturn;
;;;2170   }
00000c  e12fff1e          BX       lr
;;;2171   /*-----------------------------------------------------------*/
                          ENDP

                  |L47.16|
                          DCD      xTickCount

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;2498   
;;;2499   BaseType_t xTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2500   {
;;;2501   TCB_t * pxTCB;
;;;2502   TickType_t xItemValue;
;;;2503   BaseType_t xSwitchRequired = pdFALSE;
000004  e3a08000          MOV      r8,#0
;;;2504   
;;;2505   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2506   	Increments the tick then checks to see if the new tick value will cause any
;;;2507   	tasks to be unblocked. */
;;;2508   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2509   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000008  e59f01e4          LDR      r0,|L48.500|
00000c  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000010  e3500000          CMP      r0,#0
000014  1a00006a          BNE      |L48.452|
;;;2510   	{
;;;2511   		/* Minor optimisation.  The tick count cannot change in this
;;;2512   		block. */
;;;2513   		const TickType_t xConstTickCount = xTickCount + 1;
000018  e59f01d8          LDR      r0,|L48.504|
00001c  e5900000          LDR      r0,[r0,#0]  ; xTickCount
000020  e2805001          ADD      r5,r0,#1
;;;2514   
;;;2515   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2516   		delayed lists if it wraps to 0. */
;;;2517   		xTickCount = xConstTickCount;
000024  e59f01cc          LDR      r0,|L48.504|
000028  e5805000          STR      r5,[r0,#0]  ; xTickCount
;;;2518   
;;;2519   		if( xConstTickCount == ( TickType_t ) 0U )
00002c  e3550000          CMP      r5,#0
000030  1a00001e          BNE      |L48.176|
;;;2520   		{
;;;2521   			taskSWITCH_DELAYED_LISTS();
000034  e59f01c0          LDR      r0,|L48.508|
000038  e5900000          LDR      r0,[r0,#0]  ; pxDelayedTaskList
00003c  e5900000          LDR      r0,[r0,#0]
000040  e3500000          CMP      r0,#0
000044  1a000001          BNE      |L48.80|
000048  e3a00001          MOV      r0,#1
00004c  ea000000          B        |L48.84|
                  |L48.80|
000050  e3a00000          MOV      r0,#0
                  |L48.84|
000054  e3500000          CMP      r0,#0
000058  1a000005          BNE      |L48.116|
00005c  e1a00000          MOV      r0,r0
000060  e28f2f66          ADR      r2,|L48.512|
000064  e59f11ac          LDR      r1,|L48.536|
000068  e28f0f6b          ADR      r0,|L48.540|
00006c  ebfffffe          BL       sysprintf
000070  e1a00000          MOV      r0,r0
                  |L48.116|
000074  e59f0180          LDR      r0,|L48.508|
000078  e5907000          LDR      r7,[r0,#0]  ; pxDelayedTaskList
00007c  e59f01c4          LDR      r0,|L48.584|
000080  e5900000          LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000084  e59f1170          LDR      r1,|L48.508|
000088  e5810000          STR      r0,[r1,#0]  ; pxDelayedTaskList
00008c  e59f01b4          LDR      r0,|L48.584|
000090  e5807000          STR      r7,[r0,#0]  ; pxOverflowDelayedTaskList
000094  e59f01b0          LDR      r0,|L48.588|
000098  e5900000          LDR      r0,[r0,#0]  ; xNumOfOverflows
00009c  e2800001          ADD      r0,r0,#1
0000a0  e59f11a4          LDR      r1,|L48.588|
0000a4  e5810000          STR      r0,[r1,#0]  ; xNumOfOverflows
0000a8  ebfffffe          BL       prvResetNextTaskUnblockTime
0000ac  e1a00000          MOV      r0,r0
                  |L48.176|
;;;2522   		}
;;;2523   		else
;;;2524   		{
;;;2525   			mtCOVERAGE_TEST_MARKER();
;;;2526   		}
;;;2527   
;;;2528   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2529   		the	queue in the order of their wake time - meaning once one task
;;;2530   		has been found whose block time has not expired there is no need to
;;;2531   		look any further down the list. */
;;;2532   		if( xConstTickCount >= xNextTaskUnblockTime )
0000b0  e59f0198          LDR      r0,|L48.592|
0000b4  e5900000          LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
0000b8  e1550000          CMP      r5,r0
0000bc  3a000036          BCC      |L48.412|
;;;2533   		{
;;;2534   			for( ;; )
0000c0  e1a00000          MOV      r0,r0
                  |L48.196|
;;;2535   			{
;;;2536   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
0000c4  e59f0130          LDR      r0,|L48.508|
0000c8  e5900000          LDR      r0,[r0,#0]  ; pxDelayedTaskList
0000cc  e5900000          LDR      r0,[r0,#0]
0000d0  e3500000          CMP      r0,#0
0000d4  1a000001          BNE      |L48.224|
0000d8  e3a00001          MOV      r0,#1
0000dc  ea000000          B        |L48.228|
                  |L48.224|
0000e0  e3a00000          MOV      r0,#0
                  |L48.228|
0000e4  e3500000          CMP      r0,#0
0000e8  0a000003          BEQ      |L48.252|
;;;2537   				{
;;;2538   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2539   					to the maximum possible value so it is extremely
;;;2540   					unlikely that the
;;;2541   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2542   					next time through. */
;;;2543   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0000ec  e3e00000          MVN      r0,#0
0000f0  e59f1158          LDR      r1,|L48.592|
0000f4  e5810000          STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;2544   					break;
0000f8  ea000026          B        |L48.408|
                  |L48.252|
;;;2545   				}
;;;2546   				else
;;;2547   				{
;;;2548   					/* The delayed list is not empty, get the value of the
;;;2549   					item at the head of the delayed list.  This is the time
;;;2550   					at which the task at the head of the delayed list must
;;;2551   					be removed from the Blocked state. */
;;;2552   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
0000fc  e59f00f8          LDR      r0,|L48.508|
000100  e5900000          LDR      r0,[r0,#0]  ; pxDelayedTaskList
000104  e590000c          LDR      r0,[r0,#0xc]
000108  e590400c          LDR      r4,[r0,#0xc]
;;;2553   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
00010c  e5946004          LDR      r6,[r4,#4]
;;;2554   
;;;2555   					if( xConstTickCount < xItemValue )
000110  e1550006          CMP      r5,r6
000114  2a000002          BCS      |L48.292|
;;;2556   					{
;;;2557   						/* It is not time to unblock this item yet, but the
;;;2558   						item value is the time at which the task at the head
;;;2559   						of the blocked list must be removed from the Blocked
;;;2560   						state -	so record the item value in
;;;2561   						xNextTaskUnblockTime. */
;;;2562   						xNextTaskUnblockTime = xItemValue;
000118  e59f0130          LDR      r0,|L48.592|
00011c  e5806000          STR      r6,[r0,#0]  ; xNextTaskUnblockTime
;;;2563   						break;
000120  ea00001c          B        |L48.408|
                  |L48.292|
;;;2564   					}
;;;2565   					else
;;;2566   					{
;;;2567   						mtCOVERAGE_TEST_MARKER();
;;;2568   					}
;;;2569   
;;;2570   					/* It is time to remove the item from the Blocked state. */
;;;2571   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000124  e2840004          ADD      r0,r4,#4
000128  ebfffffe          BL       uxListRemove
;;;2572   
;;;2573   					/* Is the task waiting on an event also?  If so remove
;;;2574   					it from the event list. */
;;;2575   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00012c  e5940028          LDR      r0,[r4,#0x28]
000130  e3500000          CMP      r0,#0
000134  0a000001          BEQ      |L48.320|
;;;2576   					{
;;;2577   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000138  e2840018          ADD      r0,r4,#0x18
00013c  ebfffffe          BL       uxListRemove
                  |L48.320|
;;;2578   					}
;;;2579   					else
;;;2580   					{
;;;2581   						mtCOVERAGE_TEST_MARKER();
;;;2582   					}
;;;2583   
;;;2584   					/* Place the unblocked task into the appropriate ready
;;;2585   					list. */
;;;2586   					prvAddTaskToReadyList( pxTCB );
000140  e59f110c          LDR      r1,|L48.596|
000144  e594002c          LDR      r0,[r4,#0x2c]
000148  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
00014c  e1500001          CMP      r0,r1
000150  9a000002          BLS      |L48.352|
000154  e59f10f8          LDR      r1,|L48.596|
000158  e594002c          LDR      r0,[r4,#0x2c]
00015c  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L48.352|
000160  e594102c          LDR      r1,[r4,#0x2c]
000164  e0811101          ADD      r1,r1,r1,LSL #2
000168  e59f20e8          LDR      r2,|L48.600|
00016c  e0820101          ADD      r0,r2,r1,LSL #2
000170  e2841004          ADD      r1,r4,#4
000174  ebfffffe          BL       vListInsertEnd
;;;2587   
;;;2588   					/* A task being unblocked cannot cause an immediate
;;;2589   					context switch if preemption is turned off. */
;;;2590   					#if (  configUSE_PREEMPTION == 1 )
;;;2591   					{
;;;2592   						/* Preemption is on, but a context switch should
;;;2593   						only be performed if the unblocked task has a
;;;2594   						priority that is equal to or higher than the
;;;2595   						currently executing task. */
;;;2596   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000178  e59f10dc          LDR      r1,|L48.604|
00017c  e594002c          LDR      r0,[r4,#0x2c]
000180  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000184  e591102c          LDR      r1,[r1,#0x2c]
000188  e1500001          CMP      r0,r1
00018c  3affffcc          BCC      |L48.196|
;;;2597   						{
;;;2598   							xSwitchRequired = pdTRUE;
000190  e3a08001          MOV      r8,#1
000194  eaffffca          B        |L48.196|
                  |L48.408|
000198  e1a00000          MOV      r0,r0                 ;2544
                  |L48.412|
;;;2599   						}
;;;2600   						else
;;;2601   						{
;;;2602   							mtCOVERAGE_TEST_MARKER();
;;;2603   						}
;;;2604   					}
;;;2605   					#endif /* configUSE_PREEMPTION */
;;;2606   				}
;;;2607   			}
;;;2608   		}
;;;2609   
;;;2610   		/* Tasks of equal priority to the currently running task will share
;;;2611   		processing time (time slice) if preemption is on, and the application
;;;2612   		writer has not explicitly turned time slicing off. */
;;;2613   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2614   		{
;;;2615   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
00019c  e59f00b8          LDR      r0,|L48.604|
0001a0  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
0001a4  e590002c          LDR      r0,[r0,#0x2c]
0001a8  e0800100          ADD      r0,r0,r0,LSL #2
0001ac  e59f10a4          LDR      r1,|L48.600|
0001b0  e7910100          LDR      r0,[r1,r0,LSL #2]
0001b4  e3500001          CMP      r0,#1
0001b8  9a000000          BLS      |L48.448|
;;;2616   			{
;;;2617   				xSwitchRequired = pdTRUE;
0001bc  e3a08001          MOV      r8,#1
                  |L48.448|
;;;2618   			}
;;;2619   			else
;;;2620   			{
;;;2621   				mtCOVERAGE_TEST_MARKER();
;;;2622   			}
;;;2623   		}
;;;2624   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2625   
;;;2626   		#if ( configUSE_TICK_HOOK == 1 )
;;;2627   		{
;;;2628   			/* Guard against the tick hook being called when the pended tick
;;;2629   			count is being unwound (when the scheduler is being unlocked). */
;;;2630   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2631   			{
;;;2632   				vApplicationTickHook();
;;;2633   			}
;;;2634   			else
;;;2635   			{
;;;2636   				mtCOVERAGE_TEST_MARKER();
;;;2637   			}
;;;2638   		}
;;;2639   		#endif /* configUSE_TICK_HOOK */
;;;2640   	}
0001c0  ea000004          B        |L48.472|
                  |L48.452|
;;;2641   	else
;;;2642   	{
;;;2643   		++uxPendedTicks;
0001c4  e59f0094          LDR      r0,|L48.608|
0001c8  e5900000          LDR      r0,[r0,#0]  ; uxPendedTicks
0001cc  e2800001          ADD      r0,r0,#1
0001d0  e59f1088          LDR      r1,|L48.608|
0001d4  e5810000          STR      r0,[r1,#0]  ; uxPendedTicks
                  |L48.472|
;;;2644   
;;;2645   		/* The tick hook gets called at regular intervals, even if the
;;;2646   		scheduler is locked. */
;;;2647   		#if ( configUSE_TICK_HOOK == 1 )
;;;2648   		{
;;;2649   			vApplicationTickHook();
;;;2650   		}
;;;2651   		#endif
;;;2652   	}
;;;2653   
;;;2654   	#if ( configUSE_PREEMPTION == 1 )
;;;2655   	{
;;;2656   		if( xYieldPending != pdFALSE )
0001d8  e59f0084          LDR      r0,|L48.612|
0001dc  e5900000          LDR      r0,[r0,#0]  ; xYieldPending
0001e0  e3500000          CMP      r0,#0
0001e4  0a000000          BEQ      |L48.492|
;;;2657   		{
;;;2658   			xSwitchRequired = pdTRUE;
0001e8  e3a08001          MOV      r8,#1
                  |L48.492|
;;;2659   		}
;;;2660   		else
;;;2661   		{
;;;2662   			mtCOVERAGE_TEST_MARKER();
;;;2663   		}
;;;2664   	}
;;;2665   	#endif /* configUSE_PREEMPTION */
;;;2666   
;;;2667   	return xSwitchRequired;
0001ec  e1a00008          MOV      r0,r8
;;;2668   }
0001f0  e8bd81f0          POP      {r4-r8,pc}
;;;2669   /*-----------------------------------------------------------*/
                          ENDP

                  |L48.500|
                          DCD      uxSchedulerSuspended
                  |L48.504|
                          DCD      xTickCount
                  |L48.508|
                          DCD      pxDelayedTaskList
                  |L48.512|
000200  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
000204  52544f53
000208  5c536f75
00020c  7263655c
000210  7461736b
000214  732e6300
                  |L48.536|
                          DCD      0x000009d9
                  |L48.540|
00021c  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000220  7274696f
000224  6e202220
000228  3f3f3f20
00022c  22206661
000230  696c6564
000234  20617420
000238  6c696e65
00023c  20256420
000240  696e2025
000244  730a00  
000247  00                DCB      0
                  |L48.584|
                          DCD      pxOverflowDelayedTaskList
                  |L48.588|
                          DCD      xNumOfOverflows
                  |L48.592|
                          DCD      xNextTaskUnblockTime
                  |L48.596|
                          DCD      uxTopReadyPriority
                  |L48.600|
                          DCD      pxReadyTasksLists
                  |L48.604|
                          DCD      pxCurrentTCB
                  |L48.608|
                          DCD      uxPendedTicks
                  |L48.612|
                          DCD      xYieldPending

                          AREA ||i.xTaskNotifyStateClear||, CODE, READONLY, ALIGN=2

                  xTaskNotifyStateClear PROC
;;;4661   
;;;4662   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;4663   	{
000004  e1a05000          MOV      r5,r0
;;;4664   	TCB_t *pxTCB;
;;;4665   	BaseType_t xReturn;
;;;4666   
;;;4667   		/* If null is passed in here then it is the calling task that is having
;;;4668   		its notification state cleared. */
;;;4669   		pxTCB = prvGetTCBFromHandle( xTask );
000008  e3550000          CMP      r5,#0
00000c  1a000002          BNE      |L49.28|
000010  e59f003c          LDR      r0,|L49.84|
000014  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000018  ea000000          B        |L49.32|
                  |L49.28|
00001c  e1a00005          MOV      r0,r5
                  |L49.32|
000020  e1a06000          MOV      r6,r0
;;;4670   
;;;4671   		taskENTER_CRITICAL();
000024  ebfffffe          BL       vPortEnterCritical
;;;4672   		{
;;;4673   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
000028  e5d60048          LDRB     r0,[r6,#0x48]
00002c  e3500002          CMP      r0,#2
000030  1a000003          BNE      |L49.68|
;;;4674   			{
;;;4675   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000034  e3a00000          MOV      r0,#0
000038  e5c60048          STRB     r0,[r6,#0x48]
;;;4676   				xReturn = pdPASS;
00003c  e3a04001          MOV      r4,#1
000040  ea000000          B        |L49.72|
                  |L49.68|
;;;4677   			}
;;;4678   			else
;;;4679   			{
;;;4680   				xReturn = pdFAIL;
000044  e3a04000          MOV      r4,#0
                  |L49.72|
;;;4681   			}
;;;4682   		}
;;;4683   		taskEXIT_CRITICAL();
000048  ebfffffe          BL       vPortExitCritical
;;;4684   
;;;4685   		return xReturn;
00004c  e1a00004          MOV      r0,r4
;;;4686   	}
000050  e8bd8070          POP      {r4-r6,pc}
;;;4687   
                          ENDP

                  |L49.84|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4262   
;;;4263   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4264   	{
000004  e1a07000          MOV      r7,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a04002          MOV      r4,r2
000010  e1a05003          MOV      r5,r3
;;;4265   	BaseType_t xReturn;
;;;4266   
;;;4267   		taskENTER_CRITICAL();
000014  ebfffffe          BL       vPortEnterCritical
;;;4268   		{
;;;4269   			/* Only block if a notification is not already pending. */
;;;4270   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000018  e59f00c0          LDR      r0,|L50.224|
00001c  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000020  e5d00048          LDRB     r0,[r0,#0x48]
000024  e3500002          CMP      r0,#2
000028  0a00000f          BEQ      |L50.108|
;;;4271   			{
;;;4272   				/* Clear bits in the task's notification value as bits may get
;;;4273   				set	by the notifying task or interrupt.  This can be used to
;;;4274   				clear the value to zero. */
;;;4275   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00002c  e59f10ac          LDR      r1,|L50.224|
000030  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000034  e2810044          ADD      r0,r1,#0x44
000038  e5911044          LDR      r1,[r1,#0x44]
00003c  e1c11007          BIC      r1,r1,r7
000040  e5801000          STR      r1,[r0,#0]
;;;4276   
;;;4277   				/* Mark this task as waiting for a notification. */
;;;4278   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000044  e3a00001          MOV      r0,#1
000048  e59f1090          LDR      r1,|L50.224|
00004c  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000050  e5c10048          STRB     r0,[r1,#0x48]
;;;4279   
;;;4280   				if( xTicksToWait > ( TickType_t ) 0 )
000054  e3550000          CMP      r5,#0
000058  0a000003          BEQ      |L50.108|
;;;4281   				{
;;;4282   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00005c  e3a01001          MOV      r1,#1
000060  e1a00005          MOV      r0,r5
000064  ebfffffe          BL       prvAddCurrentTaskToDelayedList
;;;4283   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4284   
;;;4285   					/* All ports are written to allow a yield in a critical
;;;4286   					section (some will yield immediately, others wait until the
;;;4287   					critical section exits) - but it is not something that
;;;4288   					application code should ever do. */
;;;4289   					portYIELD_WITHIN_API();
000068  ebfffffe          BL       vPortYield
                  |L50.108|
;;;4290   				}
;;;4291   				else
;;;4292   				{
;;;4293   					mtCOVERAGE_TEST_MARKER();
;;;4294   				}
;;;4295   			}
;;;4296   			else
;;;4297   			{
;;;4298   				mtCOVERAGE_TEST_MARKER();
;;;4299   			}
;;;4300   		}
;;;4301   		taskEXIT_CRITICAL();
00006c  ebfffffe          BL       vPortExitCritical
;;;4302   
;;;4303   		taskENTER_CRITICAL();
000070  ebfffffe          BL       vPortEnterCritical
;;;4304   		{
;;;4305   			traceTASK_NOTIFY_WAIT();
;;;4306   
;;;4307   			if( pulNotificationValue != NULL )
000074  e3540000          CMP      r4,#0
000078  0a000003          BEQ      |L50.140|
;;;4308   			{
;;;4309   				/* Output the current notification value, which may or may not
;;;4310   				have changed. */
;;;4311   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
00007c  e59f005c          LDR      r0,|L50.224|
000080  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000084  e5900044          LDR      r0,[r0,#0x44]
000088  e5840000          STR      r0,[r4,#0]
                  |L50.140|
;;;4312   			}
;;;4313   
;;;4314   			/* If ucNotifyValue is set then either the task never entered the
;;;4315   			blocked state (because a notification was already pending) or the
;;;4316   			task unblocked because of a notification.  Otherwise the task
;;;4317   			unblocked because of a timeout. */
;;;4318   			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
00008c  e59f004c          LDR      r0,|L50.224|
000090  e5900000          LDR      r0,[r0,#0]  ; pxCurrentTCB
000094  e5d00048          LDRB     r0,[r0,#0x48]
000098  e3500001          CMP      r0,#1
00009c  1a000001          BNE      |L50.168|
;;;4319   			{
;;;4320   				/* A notification was not received. */
;;;4321   				xReturn = pdFALSE;
0000a0  e3a06000          MOV      r6,#0
0000a4  ea000006          B        |L50.196|
                  |L50.168|
;;;4322   			}
;;;4323   			else
;;;4324   			{
;;;4325   				/* A notification was already pending or a notification was
;;;4326   				received while the task was waiting. */
;;;4327   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
0000a8  e59f1030          LDR      r1,|L50.224|
0000ac  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
0000b0  e2810044          ADD      r0,r1,#0x44
0000b4  e5911044          LDR      r1,[r1,#0x44]
0000b8  e1c11008          BIC      r1,r1,r8
0000bc  e5801000          STR      r1,[r0,#0]
;;;4328   				xReturn = pdTRUE;
0000c0  e3a06001          MOV      r6,#1
                  |L50.196|
;;;4329   			}
;;;4330   
;;;4331   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
0000c4  e3a00000          MOV      r0,#0
0000c8  e59f1010          LDR      r1,|L50.224|
0000cc  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
0000d0  e5c10048          STRB     r0,[r1,#0x48]
;;;4332   		}
;;;4333   		taskEXIT_CRITICAL();
0000d4  ebfffffe          BL       vPortExitCritical
;;;4334   
;;;4335   		return xReturn;
0000d8  e1a00006          MOV      r0,r6
;;;4336   	}
0000dc  e8bd81f0          POP      {r4-r8,pc}
;;;4337   
                          ENDP

                  |L50.224|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;2893   
;;;2894   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;2895   {
000004  e1a06000          MOV      r6,r0
;;;2896   TCB_t *pxUnblockedTCB;
;;;2897   BaseType_t xReturn;
;;;2898   
;;;2899   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2900   	called from a critical section within an ISR. */
;;;2901   
;;;2902   	/* The event list is sorted in priority order, so the first in the list can
;;;2903   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2904   	the delayed list, and add it to the ready list.
;;;2905   
;;;2906   	If an event is for a queue that is locked then this function will never
;;;2907   	get called - the lock count on the queue will get modified instead.  This
;;;2908   	means exclusive access to the event list is guaranteed here.
;;;2909   
;;;2910   	This function assumes that a check has already been made to ensure that
;;;2911   	pxEventList is not empty. */
;;;2912   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000008  e596000c          LDR      r0,[r6,#0xc]
00000c  e590400c          LDR      r4,[r0,#0xc]
;;;2913   	configASSERT( pxUnblockedTCB );
000010  e3540000          CMP      r4,#0
000014  1a000005          BNE      |L51.48|
000018  e1a00000          MOV      r0,r0
00001c  e28f20ac          ADR      r2,|L51.208|
000020  e59f10c0          LDR      r1,|L51.232|
000024  e28f00c0          ADR      r0,|L51.236|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L51.48|
;;;2914   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000030  e2840018          ADD      r0,r4,#0x18
000034  ebfffffe          BL       uxListRemove
;;;2915   
;;;2916   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000038  e59f00d8          LDR      r0,|L51.280|
00003c  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000040  e3500000          CMP      r0,#0
000044  1a000010          BNE      |L51.140|
;;;2917   	{
;;;2918   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000048  e2840004          ADD      r0,r4,#4
00004c  ebfffffe          BL       uxListRemove
;;;2919   		prvAddTaskToReadyList( pxUnblockedTCB );
000050  e59f10c4          LDR      r1,|L51.284|
000054  e594002c          LDR      r0,[r4,#0x2c]
000058  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
00005c  e1500001          CMP      r0,r1
000060  9a000002          BLS      |L51.112|
000064  e59f10b0          LDR      r1,|L51.284|
000068  e594002c          LDR      r0,[r4,#0x2c]
00006c  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L51.112|
000070  e594102c          LDR      r1,[r4,#0x2c]
000074  e0811101          ADD      r1,r1,r1,LSL #2
000078  e59f20a0          LDR      r2,|L51.288|
00007c  e0820101          ADD      r0,r2,r1,LSL #2
000080  e2841004          ADD      r1,r4,#4
000084  ebfffffe          BL       vListInsertEnd
000088  ea000002          B        |L51.152|
                  |L51.140|
;;;2920   	}
;;;2921   	else
;;;2922   	{
;;;2923   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;2924   		pending until the scheduler is resumed. */
;;;2925   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
00008c  e2841018          ADD      r1,r4,#0x18
000090  e59f008c          LDR      r0,|L51.292|
000094  ebfffffe          BL       vListInsertEnd
                  |L51.152|
;;;2926   	}
;;;2927   
;;;2928   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000098  e59f1088          LDR      r1,|L51.296|
00009c  e594002c          LDR      r0,[r4,#0x2c]
0000a0  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
0000a4  e591102c          LDR      r1,[r1,#0x2c]
0000a8  e1500001          CMP      r0,r1
0000ac  9a000004          BLS      |L51.196|
;;;2929   	{
;;;2930   		/* Return true if the task removed from the event list has a higher
;;;2931   		priority than the calling task.  This allows the calling task to know if
;;;2932   		it should force a context switch now. */
;;;2933   		xReturn = pdTRUE;
0000b0  e3a05001          MOV      r5,#1
;;;2934   
;;;2935   		/* Mark that a yield is pending in case the user is not using the
;;;2936   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2937   		xYieldPending = pdTRUE;
0000b4  e3a00001          MOV      r0,#1
0000b8  e59f106c          LDR      r1,|L51.300|
0000bc  e5810000          STR      r0,[r1,#0]  ; xYieldPending
0000c0  ea000000          B        |L51.200|
                  |L51.196|
;;;2938   	}
;;;2939   	else
;;;2940   	{
;;;2941   		xReturn = pdFALSE;
0000c4  e3a05000          MOV      r5,#0
                  |L51.200|
;;;2942   	}
;;;2943   
;;;2944   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;2945   	{
;;;2946   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;2947   		might be set to the blocked task's time out time.  If the task is
;;;2948   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;2949   		normally left unchanged, because it is automatically reset to a new
;;;2950   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;2951   		tickless idling is used it might be more important to enter sleep mode
;;;2952   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;2953   		ensure it is updated at the earliest possible time. */
;;;2954   		prvResetNextTaskUnblockTime();
;;;2955   	}
;;;2956   	#endif
;;;2957   
;;;2958   	return xReturn;
0000c8  e1a00005          MOV      r0,r5
;;;2959   }
0000cc  e8bd8070          POP      {r4-r6,pc}
;;;2960   /*-----------------------------------------------------------*/
                          ENDP

                  |L51.208|
0000d0  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0000d4  52544f53
0000d8  5c536f75
0000dc  7263655c
0000e0  7461736b
0000e4  732e6300
                  |L51.232|
                          DCD      0x00000b61
                  |L51.236|
0000ec  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000f0  7274696f
0000f4  6e202220
0000f8  3f3f3f20
0000fc  22206661
000100  696c6564
000104  20617420
000108  6c696e65
00010c  20256420
000110  696e2025
000114  730a00  
000117  00                DCB      0
                  |L51.280|
                          DCD      uxSchedulerSuspended
                  |L51.284|
                          DCD      uxTopReadyPriority
                  |L51.288|
                          DCD      pxReadyTasksLists
                  |L51.292|
                          DCD      xPendingReadyList
                  |L51.296|
                          DCD      pxCurrentTCB
                  |L51.300|
                          DCD      xYieldPending

                          AREA ||i.xTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromUnorderedEventList PROC
;;;2961   
;;;2962   BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2963   {
000004  e1a05000          MOV      r5,r0
000008  e1a07001          MOV      r7,r1
;;;2964   TCB_t *pxUnblockedTCB;
;;;2965   BaseType_t xReturn;
;;;2966   
;;;2967   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2968   	the event flags implementation. */
;;;2969   	configASSERT( uxSchedulerSuspended != pdFALSE );
00000c  e59f00e0          LDR      r0,|L52.244|
000010  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000014  e3500000          CMP      r0,#0
000018  0a000001          BEQ      |L52.36|
00001c  e3a00001          MOV      r0,#1
000020  ea000000          B        |L52.40|
                  |L52.36|
000024  e3a00000          MOV      r0,#0
                  |L52.40|
000028  e3500000          CMP      r0,#0
00002c  1a000005          BNE      |L52.72|
000030  e1a00000          MOV      r0,r0
000034  e28f20bc          ADR      r2,|L52.248|
000038  e59f10d0          LDR      r1,|L52.272|
00003c  e28f00d0          ADR      r0,|L52.276|
000040  ebfffffe          BL       sysprintf
000044  e1a00000          MOV      r0,r0
                  |L52.72|
;;;2970   
;;;2971   	/* Store the new item value in the event list. */
;;;2972   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000048  e3870102          ORR      r0,r7,#0x80000000
00004c  e5850000          STR      r0,[r5,#0]
;;;2973   
;;;2974   	/* Remove the event list form the event flag.  Interrupts do not access
;;;2975   	event flags. */
;;;2976   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
000050  e595400c          LDR      r4,[r5,#0xc]
;;;2977   	configASSERT( pxUnblockedTCB );
000054  e3540000          CMP      r4,#0
000058  1a000005          BNE      |L52.116|
00005c  e1a00000          MOV      r0,r0
000060  e28f2090          ADR      r2,|L52.248|
000064  e59f10d4          LDR      r1,|L52.320|
000068  e28f00a4          ADR      r0,|L52.276|
00006c  ebfffffe          BL       sysprintf
000070  e1a00000          MOV      r0,r0
                  |L52.116|
;;;2978   	( void ) uxListRemove( pxEventListItem );
000074  e1a00005          MOV      r0,r5
000078  ebfffffe          BL       uxListRemove
;;;2979   
;;;2980   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;2981   	scheduler is suspended so interrupts will not be accessing the ready
;;;2982   	lists. */
;;;2983   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
00007c  e2840004          ADD      r0,r4,#4
000080  ebfffffe          BL       uxListRemove
;;;2984   	prvAddTaskToReadyList( pxUnblockedTCB );
000084  e59f10b8          LDR      r1,|L52.324|
000088  e594002c          LDR      r0,[r4,#0x2c]
00008c  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
000090  e1500001          CMP      r0,r1
000094  9a000002          BLS      |L52.164|
000098  e59f10a4          LDR      r1,|L52.324|
00009c  e594002c          LDR      r0,[r4,#0x2c]
0000a0  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L52.164|
0000a4  e594102c          LDR      r1,[r4,#0x2c]
0000a8  e0811101          ADD      r1,r1,r1,LSL #2
0000ac  e59f2094          LDR      r2,|L52.328|
0000b0  e0820101          ADD      r0,r2,r1,LSL #2
0000b4  e2841004          ADD      r1,r4,#4
0000b8  ebfffffe          BL       vListInsertEnd
;;;2985   
;;;2986   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
0000bc  e59f1088          LDR      r1,|L52.332|
0000c0  e594002c          LDR      r0,[r4,#0x2c]
0000c4  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
0000c8  e591102c          LDR      r1,[r1,#0x2c]
0000cc  e1500001          CMP      r0,r1
0000d0  9a000004          BLS      |L52.232|
;;;2987   	{
;;;2988   		/* Return true if the task removed from the event list has
;;;2989   		a higher priority than the calling task.  This allows
;;;2990   		the calling task to know if it should force a context
;;;2991   		switch now. */
;;;2992   		xReturn = pdTRUE;
0000d4  e3a06001          MOV      r6,#1
;;;2993   
;;;2994   		/* Mark that a yield is pending in case the user is not using the
;;;2995   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2996   		xYieldPending = pdTRUE;
0000d8  e3a00001          MOV      r0,#1
0000dc  e59f106c          LDR      r1,|L52.336|
0000e0  e5810000          STR      r0,[r1,#0]  ; xYieldPending
0000e4  ea000000          B        |L52.236|
                  |L52.232|
;;;2997   	}
;;;2998   	else
;;;2999   	{
;;;3000   		xReturn = pdFALSE;
0000e8  e3a06000          MOV      r6,#0
                  |L52.236|
;;;3001   	}
;;;3002   
;;;3003   	return xReturn;
0000ec  e1a00006          MOV      r0,r6
;;;3004   }
0000f0  e8bd81f0          POP      {r4-r8,pc}
;;;3005   /*-----------------------------------------------------------*/
                          ENDP

                  |L52.244|
                          DCD      uxSchedulerSuspended
                  |L52.248|
0000f8  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0000fc  52544f53
000100  5c536f75
000104  7263655c
000108  7461736b
00010c  732e6300
                  |L52.272|
                          DCD      0x00000b99
                  |L52.276|
000114  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000118  7274696f
00011c  6e202220
000120  3f3f3f20
000124  22206661
000128  696c6564
00012c  20617420
000130  6c696e65
000134  20256420
000138  696e2025
00013c  730a00  
00013f  00                DCB      0
                  |L52.320|
                          DCD      0x00000ba1
                  |L52.324|
                          DCD      uxTopReadyPriority
                  |L52.328|
                          DCD      pxReadyTasksLists
                  |L52.332|
                          DCD      pxCurrentTCB
                  |L52.336|
                          DCD      xYieldPending

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;2016   
;;;2017   BaseType_t xTaskResumeAll( void )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;2018   {
;;;2019   TCB_t *pxTCB = NULL;
000004  e3a04000          MOV      r4,#0
;;;2020   BaseType_t xAlreadyYielded = pdFALSE;
000008  e3a06000          MOV      r6,#0
;;;2021   
;;;2022   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2023   	previous call to vTaskSuspendAll(). */
;;;2024   	configASSERT( uxSchedulerSuspended );
00000c  e59f016c          LDR      r0,|L53.384|
000010  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000014  e3500000          CMP      r0,#0
000018  1a000005          BNE      |L53.52|
00001c  e1a00000          MOV      r0,r0
000020  e28f2f57          ADR      r2,|L53.388|
000024  e59f1170          LDR      r1,|L53.412|
000028  e28f0e17          ADR      r0,|L53.416|
00002c  ebfffffe          BL       sysprintf
000030  e1a00000          MOV      r0,r0
                  |L53.52|
;;;2025   
;;;2026   	/* It is possible that an ISR caused a task to be removed from an event
;;;2027   	list while the scheduler was suspended.  If this was the case then the
;;;2028   	removed task will have been added to the xPendingReadyList.  Once the
;;;2029   	scheduler has been resumed it is safe to move all the pending ready
;;;2030   	tasks from this list into their appropriate ready list. */
;;;2031   	taskENTER_CRITICAL();
000034  ebfffffe          BL       vPortEnterCritical
;;;2032   	{
;;;2033   		--uxSchedulerSuspended;
000038  e59f0140          LDR      r0,|L53.384|
00003c  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000040  e2400001          SUB      r0,r0,#1
000044  e59f1134          LDR      r1,|L53.384|
000048  e5810000          STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;2034   
;;;2035   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00004c  e2810000          ADD      r0,r1,#0
000050  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000054  e3500000          CMP      r0,#0
000058  1a000045          BNE      |L53.372|
;;;2036   		{
;;;2037   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
00005c  e59f0168          LDR      r0,|L53.460|
000060  e5900000          LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000064  e3500000          CMP      r0,#0
000068  0a000041          BEQ      |L53.372|
;;;2038   			{
;;;2039   				/* Move any readied tasks from the pending list into the
;;;2040   				appropriate ready list. */
;;;2041   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
00006c  ea00001d          B        |L53.232|
                  |L53.112|
;;;2042   				{
;;;2043   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
000070  e59f0158          LDR      r0,|L53.464|
000074  e590000c          LDR      r0,[r0,#0xc]
000078  e590400c          LDR      r4,[r0,#0xc]
;;;2044   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00007c  e2840018          ADD      r0,r4,#0x18
000080  ebfffffe          BL       uxListRemove
;;;2045   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000084  e2840004          ADD      r0,r4,#4
000088  ebfffffe          BL       uxListRemove
;;;2046   					prvAddTaskToReadyList( pxTCB );
00008c  e59f1140          LDR      r1,|L53.468|
000090  e594002c          LDR      r0,[r4,#0x2c]
000094  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
000098  e1500001          CMP      r0,r1
00009c  9a000002          BLS      |L53.172|
0000a0  e59f112c          LDR      r1,|L53.468|
0000a4  e594002c          LDR      r0,[r4,#0x2c]
0000a8  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L53.172|
0000ac  e594102c          LDR      r1,[r4,#0x2c]
0000b0  e0811101          ADD      r1,r1,r1,LSL #2
0000b4  e59f211c          LDR      r2,|L53.472|
0000b8  e0820101          ADD      r0,r2,r1,LSL #2
0000bc  e2841004          ADD      r1,r4,#4
0000c0  ebfffffe          BL       vListInsertEnd
;;;2047   
;;;2048   					/* If the moved task has a priority higher than the current
;;;2049   					task then a yield must be performed. */
;;;2050   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0000c4  e59f1110          LDR      r1,|L53.476|
0000c8  e594002c          LDR      r0,[r4,#0x2c]
0000cc  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
0000d0  e591102c          LDR      r1,[r1,#0x2c]
0000d4  e1500001          CMP      r0,r1
0000d8  3a000002          BCC      |L53.232|
;;;2051   					{
;;;2052   						xYieldPending = pdTRUE;
0000dc  e3a00001          MOV      r0,#1
0000e0  e59f10f8          LDR      r1,|L53.480|
0000e4  e5810000          STR      r0,[r1,#0]  ; xYieldPending
                  |L53.232|
0000e8  e59f00e0          LDR      r0,|L53.464|
0000ec  e5900000          LDR      r0,[r0,#0]            ;2041  ; xPendingReadyList
0000f0  e3500000          CMP      r0,#0                 ;2041
0000f4  1a000001          BNE      |L53.256|
0000f8  e3a00001          MOV      r0,#1                 ;2041
0000fc  ea000000          B        |L53.260|
                  |L53.256|
000100  e3a00000          MOV      r0,#0                 ;2041
                  |L53.260|
000104  e3500000          CMP      r0,#0                 ;2041
000108  0affffd8          BEQ      |L53.112|
;;;2053   					}
;;;2054   					else
;;;2055   					{
;;;2056   						mtCOVERAGE_TEST_MARKER();
;;;2057   					}
;;;2058   				}
;;;2059   
;;;2060   				if( pxTCB != NULL )
00010c  e3540000          CMP      r4,#0
000110  0a000000          BEQ      |L53.280|
;;;2061   				{
;;;2062   					/* A task was unblocked while the scheduler was suspended,
;;;2063   					which may have prevented the next unblock time from being
;;;2064   					re-calculated, in which case re-calculate it now.  Mainly
;;;2065   					important for low power tickless implementations, where
;;;2066   					this can prevent an unnecessary exit from low power
;;;2067   					state. */
;;;2068   					prvResetNextTaskUnblockTime();
000114  ebfffffe          BL       prvResetNextTaskUnblockTime
                  |L53.280|
;;;2069   				}
;;;2070   
;;;2071   				/* If any ticks occurred while the scheduler was suspended then
;;;2072   				they should be processed now.  This ensures the tick count does
;;;2073   				not	slip, and that any delayed tasks are resumed at the correct
;;;2074   				time. */
;;;2075   				{
;;;2076   					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
000118  e59f00c4          LDR      r0,|L53.484|
00011c  e5905000          LDR      r5,[r0,#0]  ; uxPendedTicks
;;;2077   
;;;2078   					if( uxPendedCounts > ( UBaseType_t ) 0U )
000120  e3550000          CMP      r5,#0
000124  0a00000c          BEQ      |L53.348|
;;;2079   					{
;;;2080   						do
000128  e1a00000          MOV      r0,r0
                  |L53.300|
;;;2081   						{
;;;2082   							if( xTaskIncrementTick() != pdFALSE )
00012c  ebfffffe          BL       xTaskIncrementTick
000130  e3500000          CMP      r0,#0
000134  0a000002          BEQ      |L53.324|
;;;2083   							{
;;;2084   								xYieldPending = pdTRUE;
000138  e3a00001          MOV      r0,#1
00013c  e59f109c          LDR      r1,|L53.480|
000140  e5810000          STR      r0,[r1,#0]  ; xYieldPending
                  |L53.324|
;;;2085   							}
;;;2086   							else
;;;2087   							{
;;;2088   								mtCOVERAGE_TEST_MARKER();
;;;2089   							}
;;;2090   							--uxPendedCounts;
000144  e2455001          SUB      r5,r5,#1
;;;2091   						} while( uxPendedCounts > ( UBaseType_t ) 0U );
000148  e3550000          CMP      r5,#0
00014c  1afffff6          BNE      |L53.300|
;;;2092   
;;;2093   						uxPendedTicks = 0;
000150  e3a00000          MOV      r0,#0
000154  e59f1088          LDR      r1,|L53.484|
000158  e5810000          STR      r0,[r1,#0]  ; uxPendedTicks
                  |L53.348|
;;;2094   					}
;;;2095   					else
;;;2096   					{
;;;2097   						mtCOVERAGE_TEST_MARKER();
;;;2098   					}
;;;2099   				}
;;;2100   
;;;2101   				if( xYieldPending != pdFALSE )
00015c  e59f007c          LDR      r0,|L53.480|
000160  e5900000          LDR      r0,[r0,#0]  ; xYieldPending
000164  e3500000          CMP      r0,#0
000168  0a000001          BEQ      |L53.372|
;;;2102   				{
;;;2103   					#if( configUSE_PREEMPTION != 0 )
;;;2104   					{
;;;2105   						xAlreadyYielded = pdTRUE;
00016c  e3a06001          MOV      r6,#1
;;;2106   					}
;;;2107   					#endif
;;;2108   					taskYIELD_IF_USING_PREEMPTION();
000170  ebfffffe          BL       vPortYield
                  |L53.372|
;;;2109   				}
;;;2110   				else
;;;2111   				{
;;;2112   					mtCOVERAGE_TEST_MARKER();
;;;2113   				}
;;;2114   			}
;;;2115   		}
;;;2116   		else
;;;2117   		{
;;;2118   			mtCOVERAGE_TEST_MARKER();
;;;2119   		}
;;;2120   	}
;;;2121   	taskEXIT_CRITICAL();
000174  ebfffffe          BL       vPortExitCritical
;;;2122   
;;;2123   	return xAlreadyYielded;
000178  e1a00006          MOV      r0,r6
;;;2124   }
00017c  e8bd8070          POP      {r4-r6,pc}
;;;2125   /*-----------------------------------------------------------*/
                          ENDP

                  |L53.384|
                          DCD      uxSchedulerSuspended
                  |L53.388|
000184  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
000188  52544f53
00018c  5c536f75
000190  7263655c
000194  7461736b
000198  732e6300
                  |L53.412|
                          DCD      0x000007e8
                  |L53.416|
0001a0  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0001a4  7274696f
0001a8  6e202220
0001ac  3f3f3f20
0001b0  22206661
0001b4  696c6564
0001b8  20617420
0001bc  6c696e65
0001c0  20256420
0001c4  696e2025
0001c8  730a00  
0001cb  00                DCB      0
                  |L53.460|
                          DCD      uxCurrentNumberOfTasks
                  |L53.464|
                          DCD      xPendingReadyList
                  |L53.468|
                          DCD      uxTopReadyPriority
                  |L53.472|
                          DCD      pxReadyTasksLists
                  |L53.476|
                          DCD      pxCurrentTCB
                  |L53.480|
                          DCD      xYieldPending
                  |L53.484|
                          DCD      uxPendedTicks

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1755   
;;;1756   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1757   	{
000004  e1a05000          MOV      r5,r0
;;;1758   	BaseType_t xYieldRequired = pdFALSE;
000008  e3a06000          MOV      r6,#0
;;;1759   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
00000c  e1a04005          MOV      r4,r5
;;;1760   	UBaseType_t uxSavedInterruptStatus;
;;;1761   
;;;1762   		configASSERT( xTaskToResume );
000010  e3550000          CMP      r5,#0
000014  1a000005          BNE      |L54.48|
000018  e1a00000          MOV      r0,r0
00001c  e28f20a4          ADR      r2,|L54.200|
000020  e59f10b8          LDR      r1,|L54.224|
000024  e28f00b8          ADR      r0,|L54.228|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L54.48|
;;;1763   
;;;1764   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1765   		maximum	system call (or maximum API call) interrupt priority.
;;;1766   		Interrupts that are	above the maximum system call priority are keep
;;;1767   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1768   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1769   		is defined in FreeRTOSConfig.h then
;;;1770   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1771   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1772   		been assigned a priority above the configured maximum system call
;;;1773   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1774   		from interrupts	that have been assigned a priority at or (logically)
;;;1775   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1776   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1777   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1778   		provided on the following link:
;;;1779   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1780   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1781   
;;;1782   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000030  e3a07000          MOV      r7,#0
;;;1783   		{
;;;1784   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000034  e1a00004          MOV      r0,r4
000038  ebfffffe          BL       prvTaskIsTaskSuspended
00003c  e3500000          CMP      r0,#0
000040  0a00001e          BEQ      |L54.192|
;;;1785   			{
;;;1786   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1787   
;;;1788   				/* Check the ready lists can be accessed. */
;;;1789   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000044  e59f00c4          LDR      r0,|L54.272|
000048  e5900000          LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00004c  e3500000          CMP      r0,#0
000050  1a000017          BNE      |L54.180|
;;;1790   				{
;;;1791   					/* Ready lists can be accessed so move the task from the
;;;1792   					suspended list to the ready list directly. */
;;;1793   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000054  e59f10b8          LDR      r1,|L54.276|
000058  e594002c          LDR      r0,[r4,#0x2c]
00005c  e5911000          LDR      r1,[r1,#0]  ; pxCurrentTCB
000060  e591102c          LDR      r1,[r1,#0x2c]
000064  e1500001          CMP      r0,r1
000068  3a000000          BCC      |L54.112|
;;;1794   					{
;;;1795   						xYieldRequired = pdTRUE;
00006c  e3a06001          MOV      r6,#1
                  |L54.112|
;;;1796   					}
;;;1797   					else
;;;1798   					{
;;;1799   						mtCOVERAGE_TEST_MARKER();
;;;1800   					}
;;;1801   
;;;1802   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000070  e2840004          ADD      r0,r4,#4
000074  ebfffffe          BL       uxListRemove
;;;1803   					prvAddTaskToReadyList( pxTCB );
000078  e59f1098          LDR      r1,|L54.280|
00007c  e594002c          LDR      r0,[r4,#0x2c]
000080  e5911000          LDR      r1,[r1,#0]  ; uxTopReadyPriority
000084  e1500001          CMP      r0,r1
000088  9a000002          BLS      |L54.152|
00008c  e59f1084          LDR      r1,|L54.280|
000090  e594002c          LDR      r0,[r4,#0x2c]
000094  e5810000          STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L54.152|
000098  e594102c          LDR      r1,[r4,#0x2c]
00009c  e0811101          ADD      r1,r1,r1,LSL #2
0000a0  e59f2074          LDR      r2,|L54.284|
0000a4  e0820101          ADD      r0,r2,r1,LSL #2
0000a8  e2841004          ADD      r1,r4,#4
0000ac  ebfffffe          BL       vListInsertEnd
0000b0  ea000002          B        |L54.192|
                  |L54.180|
;;;1804   				}
;;;1805   				else
;;;1806   				{
;;;1807   					/* The delayed or ready lists cannot be accessed so the task
;;;1808   					is held in the pending ready list until the scheduler is
;;;1809   					unsuspended. */
;;;1810   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0000b4  e2841018          ADD      r1,r4,#0x18
0000b8  e59f0060          LDR      r0,|L54.288|
0000bc  ebfffffe          BL       vListInsertEnd
                  |L54.192|
;;;1811   				}
;;;1812   			}
;;;1813   			else
;;;1814   			{
;;;1815   				mtCOVERAGE_TEST_MARKER();
;;;1816   			}
;;;1817   		}
;;;1818   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1819   
;;;1820   		return xYieldRequired;
0000c0  e1a00006          MOV      r0,r6
;;;1821   	}
0000c4  e8bd81f0          POP      {r4-r8,pc}
;;;1822   
                          ENDP

                  |L54.200|
0000c8  46726565          DCB      "FreeRTOS\\Source\\tasks.c",0
0000cc  52544f53
0000d0  5c536f75
0000d4  7263655c
0000d8  7461736b
0000dc  732e6300
                  |L54.224|
                          DCD      0x000006e2
                  |L54.228|
0000e4  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000e8  7274696f
0000ec  6e202220
0000f0  3f3f3f20
0000f4  22206661
0000f8  696c6564
0000fc  20617420
000100  6c696e65
000104  20256420
000108  696e2025
00010c  730a00  
00010f  00                DCB      0
                  |L54.272|
                          DCD      uxSchedulerSuspended
                  |L54.276|
                          DCD      pxCurrentTCB
                  |L54.280|
                          DCD      uxTopReadyPriority
                  |L54.284|
                          DCD      pxReadyTasksLists
                  |L54.288|
                          DCD      xPendingReadyList

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        640
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
