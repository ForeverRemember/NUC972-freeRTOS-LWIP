; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\pbuf.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pbuf.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\pbuf.crf lwip-1.4.1\src\core\pbuf.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  pbuf_free_ooseq PROC
;;;117    void
;;;118    pbuf_free_ooseq(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;119    {
;;;120      struct tcp_pcb* pcb;
;;;121      SYS_ARCH_DECL_PROTECT(old_level);
;;;122    
;;;123      SYS_ARCH_PROTECT(old_level);
000004  ebfffffe          BL       sys_arch_protect
;;;124      pbuf_free_ooseq_pending = 0;
000008  e59f1254          LDR      r1,|L1.612|
00000c  e3a05000          MOV      r5,#0
000010  e5c15000          STRB     r5,[r1,#0]  ; pbuf_free_ooseq_pending
;;;125      SYS_ARCH_UNPROTECT(old_level);
000014  ebfffffe          BL       sys_arch_unprotect
;;;126    
;;;127      for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
000018  e59f0248          LDR      r0,|L1.616|
00001c  e5904000          LDR      r4,[r0,#0]  ; tcp_active_pcbs
                  |L1.32|
000020  e3540000          CMP      r4,#0
;;;128        if (NULL != pcb->ooseq) {
;;;129          /** Free the ooseq pbufs of one PCB only */
;;;130          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
;;;131          tcp_segs_free(pcb->ooseq);
;;;132          pcb->ooseq = NULL;
;;;133          return;
;;;134        }
;;;135      }
;;;136    }
000024  08bd8070          POPEQ    {r4-r6,pc}
000028  e5940074          LDR      r0,[r4,#0x74]         ;128
00002c  e3500000          CMP      r0,#0                 ;128
000030  0594400c          LDREQ    r4,[r4,#0xc]          ;127
000034  0afffff9          BEQ      |L1.32|
000038  ebfffffe          BL       tcp_segs_free
00003c  e5845074          STR      r5,[r4,#0x74]         ;132
000040  e8bd8070          POP      {r4-r6,pc}
;;;137    
                          ENDP

                  pbuf_free PROC
;;;617    u8_t
;;;618    pbuf_free(struct pbuf *p)
000044  e92d41f0          PUSH     {r4-r8,lr}
;;;619    {
000048  e1b04000          MOVS     r4,r0
00004c  0a000012          BEQ      |L1.156|
;;;620      u16_t type;
;;;621      struct pbuf *q;
;;;622      u8_t count;
;;;623    
;;;624      if (p == NULL) {
;;;625        LWIP_ASSERT("p != NULL", p != NULL);
;;;626        /* if assertions are disabled, proceed with debug output */
;;;627        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;628          ("pbuf_free(p == NULL) was called.\n"));
;;;629        return 0;
;;;630      }
;;;631      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;632    
;;;633      PERF_START;
;;;634    
;;;635      LWIP_ASSERT("pbuf_free: sane type",
000050  e5d4000c          LDRB     r0,[r4,#0xc]
000054  e3500000          CMP      r0,#0
000058  13500001          CMPNE    r0,#1
00005c  0a000007          BEQ      |L1.128|
000060  e3500002          CMP      r0,#2
000064  13500003          CMPNE    r0,#3
000068  0a000004          BEQ      |L1.128|
00006c  e59f2214          LDR      r2,|L1.648|
000070  e28f3f7d          ADR      r3,|L1.620|
000074  e28f1e21          ADR      r1,|L1.652|
000078  e28f0f89          ADR      r0,|L1.676|
00007c  ebfffffe          BL       sysprintf
                  |L1.128|
;;;636        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;637        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;638    
;;;639      count = 0;
000080  e3a06000          MOV      r6,#0
                  |L1.132|
;;;640      /* de-allocate all consecutive pbufs from the head of the chain that
;;;641       * obtain a zero reference count after decrementing*/
;;;642      while (p != NULL) {
;;;643        u16_t ref;
;;;644        SYS_ARCH_DECL_PROTECT(old_level);
;;;645        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;646         * we must protect it. We put the new ref into a local variable to prevent
;;;647         * further protection. */
;;;648        SYS_ARCH_PROTECT(old_level);
000084  ebfffffe          BL       sys_arch_protect
000088  e1a07000          MOV      r7,r0
;;;649        /* all pbufs in a chain are referenced at least once */
;;;650        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
00008c  e1d400be          LDRH     r0,[r4,#0xe]
000090  e3500000          CMP      r0,#0
000094  1a00000c          BNE      |L1.204|
000098  ea000006          B        |L1.184|
                  |L1.156|
00009c  e59f2228          LDR      r2,|L1.716|
0000a0  e28f3f71          ADR      r3,|L1.620|
0000a4  e28f1f89          ADR      r1,|L1.720|
0000a8  e28f0f7d          ADR      r0,|L1.676|
0000ac  ebfffffe          BL       sysprintf
0000b0  e3a00000          MOV      r0,#0                 ;629
;;;651        /* decrease reference count (number of pointers to pbuf) */
;;;652        ref = --(p->ref);
;;;653        SYS_ARCH_UNPROTECT(old_level);
;;;654        /* this pbuf is no longer referenced to? */
;;;655        if (ref == 0) {
;;;656          /* remember next pbuf in chain for next iteration */
;;;657          q = p->next;
;;;658          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;659          type = p->type;
;;;660    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;661          /* is this a custom pbuf? */
;;;662          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
;;;663            struct pbuf_custom *pc = (struct pbuf_custom*)p;
;;;664            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
;;;665            pc->custom_free_function(p);
;;;666          } else
;;;667    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;668          {
;;;669            /* is this a pbuf from the pool? */
;;;670            if (type == PBUF_POOL) {
;;;671              memp_free(MEMP_PBUF_POOL, p);
;;;672            /* is this a ROM or RAM referencing pbuf? */
;;;673            } else if (type == PBUF_ROM || type == PBUF_REF) {
;;;674              memp_free(MEMP_PBUF, p);
;;;675            /* type == PBUF_RAM */
;;;676            } else {
;;;677              mem_free(p);
;;;678            }
;;;679          }
;;;680          count++;
;;;681          /* proceed to next pbuf */
;;;682          p = q;
;;;683        /* p->ref > 0, this pbuf is still referenced to */
;;;684        /* (and so the remaining pbufs in chain as well) */
;;;685        } else {
;;;686          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;687          /* stop walking through the chain */
;;;688          p = NULL;
;;;689        }
;;;690      }
;;;691      PERF_STOP("pbuf_free");
;;;692      /* return number of de-allocated pbufs */
;;;693      return count;
;;;694    }
0000b4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.184|
0000b8  e59f221c          LDR      r2,|L1.732|
0000bc  e28f3f6a          ADR      r3,|L1.620|
0000c0  e28f1f86          ADR      r1,|L1.736|
0000c4  e28f0f76          ADR      r0,|L1.676|
0000c8  ebfffffe          BL       sysprintf
                  |L1.204|
0000cc  e1d400be          LDRH     r0,[r4,#0xe]          ;652
0000d0  e2400001          SUB      r0,r0,#1              ;652
0000d4  e1a05800          LSL      r5,r0,#16             ;652
0000d8  e1a05825          LSR      r5,r5,#16             ;652
0000dc  e1a00007          MOV      r0,r7                 ;653
0000e0  e1c450be          STRH     r5,[r4,#0xe]          ;652
0000e4  ebfffffe          BL       sys_arch_unprotect
0000e8  e3550000          CMP      r5,#0                 ;655
0000ec  1a000010          BNE      |L1.308|
0000f0  e5d4000c          LDRB     r0,[r4,#0xc]          ;659
0000f4  e5945000          LDR      r5,[r4,#0]            ;657
0000f8  e3500003          CMP      r0,#3                 ;670
0000fc  01a01004          MOVEQ    r1,r4                 ;671
000100  03a00007          MOVEQ    r0,#7                 ;671
000104  0a00000c          BEQ      |L1.316|
000108  e3500001          CMP      r0,#1                 ;673
00010c  13500002          CMPNE    r0,#2                 ;673
000110  01a01004          MOVEQ    r1,r4                 ;674
000114  03a00006          MOVEQ    r0,#6                 ;674
000118  0a000007          BEQ      |L1.316|
00011c  e1a00004          MOV      r0,r4                 ;677
000120  ebfffffe          BL       mem_free
                  |L1.292|
000124  e2860001          ADD      r0,r6,#1              ;680
000128  e1b04005          MOVS     r4,r5                 ;682
00012c  e20060ff          AND      r6,r0,#0xff           ;680
000130  1affffd3          BNE      |L1.132|
                  |L1.308|
000134  e1a00006          MOV      r0,r6                 ;693
000138  e8bd81f0          POP      {r4-r8,pc}
                  |L1.316|
00013c  ebfffffe          BL       memp_free
000140  eafffff7          B        |L1.292|
;;;695    
                          ENDP

                  pbuf_alloc PROC
;;;206    struct pbuf *
;;;207    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000144  e92d5ff0          PUSH     {r4-r12,lr}
;;;208    {
;;;209      struct pbuf *p, *q, *r;
;;;210      u16_t offset;
;;;211      s32_t rem_len; /* remaining length */
;;;212      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
;;;213    
;;;214      /* determine header offset */
;;;215      switch (layer) {
000148  e3500000          CMP      r0,#0
00014c  e1a08002          MOV      r8,r2                 ;208
000150  e1a05001          MOV      r5,r1                 ;208
;;;216      case PBUF_TRANSPORT:
;;;217        /* add room for transport (often TCP) layer header */
;;;218        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
000154  03a06038          MOVEQ    r6,#0x38
000158  0a00000e          BEQ      |L1.408|
00015c  e3500001          CMP      r0,#1                 ;215
;;;219        break;
;;;220      case PBUF_IP:
;;;221        /* add room for IP layer header */
;;;222        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
000160  03a06024          MOVEQ    r6,#0x24
000164  0a00000b          BEQ      |L1.408|
000168  e3500002          CMP      r0,#2                 ;215
;;;223        break;
;;;224      case PBUF_LINK:
;;;225        /* add room for link layer header */
;;;226        offset = PBUF_LINK_HLEN;
00016c  03a06010          MOVEQ    r6,#0x10
000170  0a000008          BEQ      |L1.408|
000174  e3500003          CMP      r0,#3                 ;215
;;;227        break;
;;;228      case PBUF_RAW:
;;;229        offset = 0;
;;;230        break;
;;;231      default:
;;;232        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
000178  128f30ec          ADRNE    r3,|L1.620|
00017c  13a020e8          MOVNE    r2,#0xe8
000180  128f1e17          ADRNE    r1,|L1.760|
000184  03a06000          MOVEQ    r6,#0                 ;229
000188  0a000002          BEQ      |L1.408|
                  |L1.396|
00018c  e28f0e11          ADR      r0,|L1.676|
000190  ebfffffe          BL       sysprintf
000194  ea0000d5          B        |L1.1264|
                  |L1.408|
;;;233        return NULL;
;;;234      }
;;;235    
;;;236      switch (type) {
000198  e3580000          CMP      r8,#0
00019c  e3a0b001          MOV      r11,#1                ;208
0001a0  e3a0a000          MOV      r10,#0                ;208
0001a4  0a0000b2          BEQ      |L1.1140|
0001a8  e3580001          CMP      r8,#1
0001ac  13580002          CMPNE    r8,#2
0001b0  0a0000c1          BEQ      |L1.1212|
0001b4  e3580003          CMP      r8,#3
;;;237      case PBUF_POOL:
;;;238        /* allocate head of pbuf chain into p */
;;;239        p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;240        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
;;;241        if (p == NULL) {
;;;242          PBUF_POOL_IS_EMPTY();
;;;243          return NULL;
;;;244        }
;;;245        p->type = type;
;;;246        p->next = NULL;
;;;247    
;;;248        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;249        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;250        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;251                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;252        /* the total length of the pbuf chain is the requested size */
;;;253        p->tot_len = length;
;;;254        /* set the length of the first pbuf in the chain */
;;;255        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;256        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;257                    ((u8_t*)p->payload + p->len <=
;;;258                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;259        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;260          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;261        /* set reference count (needed here in case we fail) */
;;;262        p->ref = 1;
;;;263    
;;;264        /* now allocate the tail of the pbuf chain */
;;;265    
;;;266        /* remember first pbuf for linkage in next iteration */
;;;267        r = p;
;;;268        /* remaining length to be allocated */
;;;269        rem_len = length - p->len;
;;;270        /* any remaining pbufs to be allocated? */
;;;271        while (rem_len > 0) {
;;;272          q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;273          if (q == NULL) {
;;;274            PBUF_POOL_IS_EMPTY();
;;;275            /* free chain so far allocated */
;;;276            pbuf_free(p);
;;;277            /* bail out unsuccesfully */
;;;278            return NULL;
;;;279          }
;;;280          q->type = type;
;;;281          q->flags = 0;
;;;282          q->next = NULL;
;;;283          /* make previous pbuf point to this pbuf */
;;;284          r->next = q;
;;;285          /* set total length of this pbuf and next in chain */
;;;286          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;287          q->tot_len = (u16_t)rem_len;
;;;288          /* this pbuf length is pool size, unless smaller sized tail */
;;;289          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;290          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;291          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;292                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;293          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;294                      ((u8_t*)p->payload + p->len <=
;;;295                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;296          q->ref = 1;
;;;297          /* calculate remaining length to be allocated */
;;;298          rem_len -= q->len;
;;;299          /* remember this pbuf for linkage in next iteration */
;;;300          r = q;
;;;301        }
;;;302        /* end of chain */
;;;303        /*r->next = NULL;*/
;;;304    
;;;305        break;
;;;306      case PBUF_RAM:
;;;307        /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;308        p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;309        if (p == NULL) {
;;;310          return NULL;
;;;311        }
;;;312        /* Set up internal structure of the pbuf. */
;;;313        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;314        p->len = p->tot_len = length;
;;;315        p->next = NULL;
;;;316        p->type = type;
;;;317    
;;;318        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;319               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;320        break;
;;;321      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;322      case PBUF_ROM:
;;;323      /* pbuf references existing (externally allocated) RAM payload? */
;;;324      case PBUF_REF:
;;;325        /* only allocate memory for the pbuf structure */
;;;326        p = (struct pbuf *)memp_malloc(MEMP_PBUF);
;;;327        if (p == NULL) {
;;;328          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;329                      ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;330                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;331          return NULL;
;;;332        }
;;;333        /* caller must set this field properly, afterwards */
;;;334        p->payload = NULL;
;;;335        p->len = p->tot_len = length;
;;;336        p->next = NULL;
;;;337        p->type = type;
;;;338        break;
;;;339      default:
;;;340        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
0001b8  128f30ac          ADRNE    r3,|L1.620|
0001bc  13a02f55          MOVNE    r2,#0x154
0001c0  128f1f53          ADRNE    r1,|L1.788|
0001c4  1afffff0          BNE      |L1.396|
0001c8  e3a00007          MOV      r0,#7                 ;239
0001cc  ebfffffe          BL       memp_malloc
0001d0  e1b04000          MOVS     r4,r0                 ;239
0001d4  0a000070          BEQ      |L1.924|
0001d8  e0840006          ADD      r0,r4,r6              ;249
0001dc  e2800013          ADD      r0,r0,#0x13           ;249
0001e0  e3c01003          BIC      r1,r0,#3              ;249
0001e4  e2860003          ADD      r0,r6,#3              ;255
0001e8  e3c00003          BIC      r0,r0,#3              ;255
0001ec  e2606e42          RSB      r6,r0,#0x420          ;255
0001f0  e5c4800c          STRB     r8,[r4,#0xc]          ;245
0001f4  e1560005          CMP      r6,r5                 ;255
0001f8  e584a000          STR      r10,[r4,#0]           ;246
0001fc  e5841004          STR      r1,[r4,#4]            ;249
000200  d1a00006          MOVLE    r0,r6                 ;255
000204  c1a00005          MOVGT    r0,r5                 ;255
000208  e1c450b8          STRH     r5,[r4,#8]            ;253
00020c  e1c400ba          STRH     r0,[r4,#0xa]          ;255
000210  e0800001          ADD      r0,r0,r1              ;256
000214  e2849e43          ADD      r9,r4,#0x430          ;256
000218  e1500009          CMP      r0,r9                 ;256
00021c  9a000004          BLS      |L1.564|
000220  e28f3044          ADR      r3,|L1.620|
000224  e3a02c01          MOV      r2,#0x100             ;256
000228  e28f1c01          ADR      r1,|L1.816|
00022c  e28f0070          ADR      r0,|L1.676|
000230  ebfffffe          BL       sysprintf
                  |L1.564|
000234  e3560000          CMP      r6,#0                 ;259
000238  ca000004          BGT      |L1.592|
00023c  e59f2120          LDR      r2,|L1.868|
000240  e28f3024          ADR      r3,|L1.620|
000244  e28f1f47          ADR      r1,|L1.872|
000248  e28f0054          ADR      r0,|L1.676|
00024c  ebfffffe          BL       sysprintf
                  |L1.592|
000250  e1c4b0be          STRH     r11,[r4,#0xe]         ;262
000254  e1d400ba          LDRH     r0,[r4,#0xa]          ;269
000258  e1a07004          MOV      r7,r4                 ;267
00025c  e0456000          SUB      r6,r5,r0              ;269
000260  ea00007c          B        |L1.1112|
                  |L1.612|
                          DCD      ||.data||
                  |L1.616|
                          DCD      tcp_active_pcbs
                  |L1.620|
00026c  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
000270  2d312e34
000274  2e315c73
000278  72635c63
00027c  6f72655c
000280  70627566
000284  2e6300  
000287  00                DCB      0
                  |L1.648|
                          DCD      0x0000027b
                  |L1.652|
00028c  70627566          DCB      "pbuf_free: sane type",0
000290  5f667265
000294  653a2073
000298  616e6520
00029c  74797065
0002a0  00      
0002a1  00                DCB      0
0002a2  00                DCB      0
0002a3  00                DCB      0
                  |L1.676|
0002a4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0002a8  7274696f
0002ac  6e202225
0002b0  73222066
0002b4  61696c65
0002b8  64206174
0002bc  206c696e
0002c0  65202564
0002c4  20696e20
0002c8  25730a00
                  |L1.716|
                          DCD      0x00000271
                  |L1.720|
0002d0  7020213d          DCB      "p != NULL",0
0002d4  204e554c
0002d8  4c00    
0002da  00                DCB      0
0002db  00                DCB      0
                  |L1.732|
                          DCD      0x0000028a
                  |L1.736|
0002e0  70627566          DCB      "pbuf_free: p->ref > 0",0
0002e4  5f667265
0002e8  653a2070
0002ec  2d3e7265
0002f0  66203e20
0002f4  3000    
0002f6  00                DCB      0
0002f7  00                DCB      0
                  |L1.760|
0002f8  70627566          DCB      "pbuf_alloc: bad pbuf layer",0
0002fc  5f616c6c
000300  6f633a20
000304  62616420
000308  70627566
00030c  206c6179
000310  657200  
000313  00                DCB      0
                  |L1.788|
000314  70627566          DCB      "pbuf_alloc: erroneous type",0
000318  5f616c6c
00031c  6f633a20
000320  6572726f
000324  6e656f75
000328  73207479
00032c  706500  
00032f  00                DCB      0
                  |L1.816|
000330  63686563          DCB      "check p->payload + p->len does not overflow pbuf",0
000334  6b20702d
000338  3e706179
00033c  6c6f6164
000340  202b2070
000344  2d3e6c65
000348  6e20646f
00034c  6573206e
000350  6f74206f
000354  76657266
000358  6c6f7720
00035c  70627566
000360  00      
000361  00                DCB      0
000362  00                DCB      0
000363  00                DCB      0
                  |L1.868|
                          DCD      0x00000103
                  |L1.872|
000368  50425546          DCB      "PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",0
00036c  5f504f4f
000370  4c5f4255
000374  4653495a
000378  45206d75
00037c  73742062
000380  65206269
000384  67676572
000388  20746861
00038c  6e204d45
000390  4d5f414c
000394  49474e4d
000398  454e5400
                  |L1.924|
00039c  ebfffffe          BL       pbuf_pool_is_empty
0003a0  ea000052          B        |L1.1264|
                  |L1.932|
0003a4  e3a00007          MOV      r0,#7                 ;272
0003a8  ebfffffe          BL       memp_malloc
0003ac  e1b05000          MOVS     r5,r0                 ;272
0003b0  0a00002b          BEQ      |L1.1124|
0003b4  e5c5800c          STRB     r8,[r5,#0xc]          ;280
0003b8  e59f027c          LDR      r0,|L1.1596|
0003bc  e5c5a00d          STRB     r10,[r5,#0xd]         ;281
0003c0  e585a000          STR      r10,[r5,#0]           ;284
0003c4  e1500006          CMP      r0,r6                 ;286
0003c8  e5875000          STR      r5,[r7,#0]            ;286
0003cc  ca000004          BGT      |L1.996|
0003d0  e59f2268          LDR      r2,|L1.1600|
0003d4  e24f3e17          ADR      r3,|L1.620|
0003d8  e28f1f99          ADR      r1,|L1.1604|
0003dc  e24f0d05          ADR      r0,|L1.676|
0003e0  ebfffffe          BL       sysprintf
                  |L1.996|
0003e4  e1a00806          LSL      r0,r6,#16             ;287
0003e8  e1a00820          LSR      r0,r0,#16             ;287
0003ec  e3500e42          CMP      r0,#0x420             ;289
0003f0  e1c500b8          STRH     r0,[r5,#8]            ;287
0003f4  23a00e42          MOVCS    r0,#0x420             ;289
0003f8  e1c500ba          STRH     r0,[r5,#0xa]          ;289
0003fc  e2850010          ADD      r0,r5,#0x10           ;290
000400  e3100003          TST      r0,#3                 ;291
000404  e5850004          STR      r0,[r5,#4]            ;290
000408  0a000004          BEQ      |L1.1056|
00040c  e59f2244          LDR      r2,|L1.1624|
000410  e24f3f6b          ADR      r3,|L1.620|
000414  e28f1d09          ADR      r1,|L1.1628|
000418  e24f0f5f          ADR      r0,|L1.676|
00041c  ebfffffe          BL       sysprintf
                  |L1.1056|
000420  e1d410ba          LDRH     r1,[r4,#0xa]          ;293
000424  e5940004          LDR      r0,[r4,#4]            ;293
000428  e0800001          ADD      r0,r0,r1              ;293
00042c  e1500009          CMP      r0,r9                 ;293
000430  9a000004          BLS      |L1.1096|
000434  e59f2250          LDR      r2,|L1.1676|
000438  e24f3f75          ADR      r3,|L1.620|
00043c  e24f1f45          ADR      r1,|L1.816|
000440  e24f0f69          ADR      r0,|L1.676|
000444  ebfffffe          BL       sysprintf
                  |L1.1096|
000448  e1c5b0be          STRH     r11,[r5,#0xe]         ;296
00044c  e1d500ba          LDRH     r0,[r5,#0xa]          ;298
000450  e1a07005          MOV      r7,r5                 ;300
000454  e0466000          SUB      r6,r6,r0              ;298
                  |L1.1112|
000458  e3560000          CMP      r6,#0                 ;271
00045c  caffffd0          BGT      |L1.932|
000460  ea00001e          B        |L1.1248|
                  |L1.1124|
000464  ebfffffe          BL       pbuf_pool_is_empty
000468  e1a00004          MOV      r0,r4                 ;276
00046c  ebfffffe          BL       pbuf_free
000470  ea00001e          B        |L1.1264|
                  |L1.1140|
000474  e2860013          ADD      r0,r6,#0x13           ;308
000478  e2851003          ADD      r1,r5,#3              ;308
00047c  e3c00003          BIC      r0,r0,#3              ;308
000480  e3c11003          BIC      r1,r1,#3              ;308
000484  e0800001          ADD      r0,r0,r1              ;308
000488  e3c00803          BIC      r0,r0,#0x30000        ;308
00048c  ebfffffe          BL       mem_malloc
000490  e2504000          SUBS     r4,r0,#0              ;308
;;;341        return NULL;
;;;342      }
;;;343      /* set reference count */
;;;344      p->ref = 1;
;;;345      /* set flags */
;;;346      p->flags = 0;
;;;347      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;348      return p;
;;;349    }
000494  08bd9ff0          POPEQ    {r4-r12,pc}
000498  e0840006          ADD      r0,r4,r6              ;313
00049c  e2800013          ADD      r0,r0,#0x13           ;313
0004a0  e3c00003          BIC      r0,r0,#3              ;313
0004a4  e5840004          STR      r0,[r4,#4]            ;313
0004a8  e1c450b8          STRH     r5,[r4,#8]            ;314
0004ac  e1c450ba          STRH     r5,[r4,#0xa]          ;314
0004b0  e584a000          STR      r10,[r4,#0]           ;315
0004b4  e5c4a00c          STRB     r10,[r4,#0xc]         ;316
0004b8  ea000008          B        |L1.1248|
                  |L1.1212|
0004bc  e3a00006          MOV      r0,#6                 ;326
0004c0  ebfffffe          BL       memp_malloc
0004c4  e1b04000          MOVS     r4,r0                 ;326
0004c8  0a000008          BEQ      |L1.1264|
0004cc  e584a004          STR      r10,[r4,#4]           ;334
0004d0  e1c450b8          STRH     r5,[r4,#8]            ;335
0004d4  e1c450ba          STRH     r5,[r4,#0xa]          ;335
0004d8  e584a000          STR      r10,[r4,#0]           ;336
0004dc  e5c4800c          STRB     r8,[r4,#0xc]          ;337
                  |L1.1248|
0004e0  e1c4b0be          STRH     r11,[r4,#0xe]         ;344
0004e4  e1a00004          MOV      r0,r4                 ;348
0004e8  e5c4a00d          STRB     r10,[r4,#0xd]         ;346
0004ec  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.1264|
0004f0  e3a00000          MOV      r0,#0                 ;331
0004f4  e8bd9ff0          POP      {r4-r12,pc}
;;;350    
                          ENDP

                  pbuf_realloc PROC
;;;429    void
;;;430    pbuf_realloc(struct pbuf *p, u16_t new_len)
0004f8  e92d41f0          PUSH     {r4-r8,lr}
;;;431    {
0004fc  e1b04000          MOVS     r4,r0
000500  e1a05001          MOV      r5,r1
000504  1a000004          BNE      |L1.1308|
;;;432      struct pbuf *q;
;;;433      u16_t rem_len; /* remaining length */
;;;434      s32_t grow;
;;;435    
;;;436      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
000508  e24f3fa9          ADR      r3,|L1.620|
00050c  e3a02f6d          MOV      r2,#0x1b4
000510  e28f1f5e          ADR      r1,|L1.1680|
000514  e24f0f9e          ADR      r0,|L1.676|
000518  ebfffffe          BL       sysprintf
                  |L1.1308|
;;;437      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
00051c  e5d4000c          LDRB     r0,[r4,#0xc]
000520  e3500003          CMP      r0,#3
000524  13500001          CMPNE    r0,#1
000528  0a000007          BEQ      |L1.1356|
00052c  e3500000          CMP      r0,#0
000530  13500002          CMPNE    r0,#2
000534  0a000004          BEQ      |L1.1356|
000538  e59f2168          LDR      r2,|L1.1704|
00053c  e24f3fb6          ADR      r3,|L1.620|
000540  e28f1f59          ADR      r1,|L1.1708|
000544  e24f0faa          ADR      r0,|L1.676|
000548  ebfffffe          BL       sysprintf
                  |L1.1356|
;;;438                  p->type == PBUF_ROM ||
;;;439                  p->type == PBUF_RAM ||
;;;440                  p->type == PBUF_REF);
;;;441    
;;;442      /* desired length larger than current length? */
;;;443      if (new_len >= p->tot_len) {
00054c  e1d400b8          LDRH     r0,[r4,#8]
000550  e1500005          CMP      r0,r5
;;;444        /* enlarging not yet supported */
;;;445        return;
;;;446      }
;;;447    
;;;448      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;449       * (which may be negative in case of shrinking) */
;;;450      grow = new_len - p->tot_len;
;;;451    
;;;452      /* first, step over any pbufs that should remain in the chain */
;;;453      rem_len = new_len;
;;;454      q = p;
;;;455      /* should this pbuf be kept? */
;;;456      while (rem_len > q->len) {
;;;457        /* decrease remaining length by pbuf length */
;;;458        rem_len -= q->len;
;;;459        /* decrease total length indicator */
;;;460        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
000554  859f80e0          LDRHI    r8,|L1.1596|
000558  80456000          SUBHI    r6,r5,r0              ;450
;;;461        q->tot_len += (u16_t)grow;
00055c  80067008          ANDHI    r7,r6,r8
;;;462        /* proceed to next pbuf in chain */
;;;463        q = q->next;
;;;464        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
;;;465      }
;;;466      /* we have now reached the new last pbuf (in q) */
;;;467      /* rem_len == desired length for pbuf q */
;;;468    
;;;469      /* shrink allocated memory for PBUF_RAM */
;;;470      /* (other types merely adjust their length fields */
;;;471      if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
;;;472        /* reallocate and adjust the length of the pbuf that will be split */
;;;473        q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
;;;474        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
;;;475      }
;;;476      /* adjust length fields for new last pbuf */
;;;477      q->len = rem_len;
;;;478      q->tot_len = q->len;
;;;479    
;;;480      /* any remaining pbufs in chain? */
;;;481      if (q->next != NULL) {
;;;482        /* free remaining pbufs in chain */
;;;483        pbuf_free(q->next);
;;;484      }
;;;485      /* q is last packet in chain */
;;;486      q->next = NULL;
;;;487    
;;;488    }
000560  98bd81f0          POPLS    {r4-r8,pc}
000564  ea000014          B        |L1.1468|
                  |L1.1384|
000568  e0450000          SUB      r0,r5,r0              ;458
00056c  e1a05800          LSL      r5,r0,#16             ;458
000570  e1560008          CMP      r6,r8                 ;460
000574  e1a05825          LSR      r5,r5,#16             ;458
000578  ba000004          BLT      |L1.1424|
00057c  e24f3fc6          ADR      r3,|L1.620|
000580  e3a02f73          MOV      r2,#0x1cc             ;460
000584  e28f1f4f          ADR      r1,|L1.1736|
000588  e24f0fbb          ADR      r0,|L1.676|
00058c  ebfffffe          BL       sysprintf
                  |L1.1424|
000590  e1d400b8          LDRH     r0,[r4,#8]            ;461
000594  e0800007          ADD      r0,r0,r7              ;461
000598  e1c400b8          STRH     r0,[r4,#8]            ;461
00059c  e5944000          LDR      r4,[r4,#0]            ;463
0005a0  e3540000          CMP      r4,#0                 ;464
0005a4  1a000004          BNE      |L1.1468|
0005a8  e24f3fd1          ADR      r3,|L1.620|
0005ac  e3a02e1d          MOV      r2,#0x1d0             ;464
0005b0  e28f1f49          ADR      r1,|L1.1756|
0005b4  e24f0fc6          ADR      r0,|L1.676|
0005b8  ebfffffe          BL       sysprintf
                  |L1.1468|
0005bc  e1d400ba          LDRH     r0,[r4,#0xa]          ;456
0005c0  e1500005          CMP      r0,r5                 ;456
0005c4  3affffe7          BCC      |L1.1384|
0005c8  e5d4000c          LDRB     r0,[r4,#0xc]          ;471
0005cc  e3500000          CMP      r0,#0                 ;471
0005d0  1a000011          BNE      |L1.1564|
0005d4  e1d400ba          LDRH     r0,[r4,#0xa]          ;471
0005d8  e1500005          CMP      r0,r5                 ;471
0005dc  0a00000e          BEQ      |L1.1564|
0005e0  e1d400b4          LDRH     r0,[r4,#4]            ;473
0005e4  e0400004          SUB      r0,r0,r4              ;473
0005e8  e1a00800          LSL      r0,r0,#16             ;473
0005ec  e1a00820          LSR      r0,r0,#16             ;473
0005f0  e0800005          ADD      r0,r0,r5              ;473
0005f4  e3c01801          BIC      r1,r0,#0x10000        ;473
0005f8  e1a00004          MOV      r0,r4                 ;473
0005fc  ebfffffe          BL       mem_trim
000600  e1b04000          MOVS     r4,r0                 ;473
000604  1a000004          BNE      |L1.1564|
000608  e59f20e4          LDR      r2,|L1.1780|
00060c  e24f3fea          ADR      r3,|L1.620|
000610  e28f10e0          ADR      r1,|L1.1784|
000614  e24f0fde          ADR      r0,|L1.676|
000618  ebfffffe          BL       sysprintf
                  |L1.1564|
00061c  e1c450ba          STRH     r5,[r4,#0xa]          ;477
000620  e1c450b8          STRH     r5,[r4,#8]            ;478
000624  e5940000          LDR      r0,[r4,#0]            ;481
000628  e3500000          CMP      r0,#0                 ;481
00062c  1bfffffe          BLNE     pbuf_free
000630  e3a00000          MOV      r0,#0                 ;486
000634  e5840000          STR      r0,[r4,#0]            ;486
000638  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1596|
                          DCD      0x0000ffff
                  |L1.1600|
                          DCD      0x0000011e
                  |L1.1604|
000644  72656d5f          DCB      "rem_len < max_u16_t",0
000648  6c656e20
00064c  3c206d61
000650  785f7531
000654  365f7400
                  |L1.1624|
                          DCD      0x00000123
                  |L1.1628|
00065c  70627566          DCB      "pbuf_alloc: pbuf q->payload properly aligned",0
000660  5f616c6c
000664  6f633a20
000668  70627566
00066c  20712d3e
000670  7061796c
000674  6f616420
000678  70726f70
00067c  65726c79
000680  20616c69
000684  676e6564
000688  00      
000689  00                DCB      0
00068a  00                DCB      0
00068b  00                DCB      0
                  |L1.1676|
                          DCD      0x00000125
                  |L1.1680|
000690  70627566          DCB      "pbuf_realloc: p != NULL",0
000694  5f726561
000698  6c6c6f63
00069c  3a207020
0006a0  213d204e
0006a4  554c4c00
                  |L1.1704|
                          DCD      0x000001b5
                  |L1.1708|
0006ac  70627566          DCB      "pbuf_realloc: sane p->type",0
0006b0  5f726561
0006b4  6c6c6f63
0006b8  3a207361
0006bc  6e652070
0006c0  2d3e7479
0006c4  706500  
0006c7  00                DCB      0
                  |L1.1736|
0006c8  67726f77          DCB      "grow < max_u16_t",0
0006cc  203c206d
0006d0  61785f75
0006d4  31365f74
0006d8  00      
0006d9  00                DCB      0
0006da  00                DCB      0
0006db  00                DCB      0
                  |L1.1756|
0006dc  70627566          DCB      "pbuf_realloc: q != NULL",0
0006e0  5f726561
0006e4  6c6c6f63
0006e8  3a207120
0006ec  213d204e
0006f0  554c4c00
                  |L1.1780|
                          DCD      0x000001da
                  |L1.1784|
0006f8  6d656d5f          DCB      "mem_trim returned q == NULL",0
0006fc  7472696d
000700  20726574
000704  75726e65
000708  64207120
00070c  3d3d204e
000710  554c4c00
                          ENDP

                  pbuf_header PROC
;;;510    u8_t
;;;511    pbuf_header(struct pbuf *p, s16_t header_size_increment)
000714  e92d4070          PUSH     {r4-r6,lr}
;;;512    {
000718  e1b04000          MOVS     r4,r0
00071c  e1a05001          MOV      r5,r1
000720  1a000004          BNE      |L1.1848|
;;;513      u16_t type;
;;;514      void *payload;
;;;515      u16_t increment_magnitude;
;;;516    
;;;517      LWIP_ASSERT("p != NULL", p != NULL);
000724  e59f3294          LDR      r3,|L1.2496|
000728  e59f2294          LDR      r2,|L1.2500|
00072c  e59f1294          LDR      r1,|L1.2504|
000730  e59f0294          LDR      r0,|L1.2508|
000734  ebfffffe          BL       sysprintf
                  |L1.1848|
;;;518      if ((header_size_increment == 0) || (p == NULL)) {
000738  e3550000          CMP      r5,#0
00073c  13540000          CMPNE    r4,#0
000740  0a00001a          BEQ      |L1.1968|
;;;519        return 0;
;;;520      }
;;;521     
;;;522      if (header_size_increment < 0){
000744  e3550000          CMP      r5,#0
;;;523        increment_magnitude = -header_size_increment;
;;;524        /* Check that we aren't going to move off the end of the pbuf */
;;;525        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
;;;526      } else {
;;;527        increment_magnitude = header_size_increment;
000748  a1a01805          LSLGE    r1,r5,#16
00074c  a1a01821          LSRGE    r1,r1,#16
000750  aa000008          BGE      |L1.1912|
000754  e2650000          RSB      r0,r5,#0              ;523
000758  e1a01800          LSL      r1,r0,#16             ;523
00075c  e1d400ba          LDRH     r0,[r4,#0xa]          ;525
000760  e1a01821          LSR      r1,r1,#16             ;523
000764  e1500001          CMP      r0,r1                 ;525
000768  359f3250          LDRCC    r3,|L1.2496|
00076c  359f225c          LDRCC    r2,|L1.2512|
000770  328f1f97          ADRCC    r1,|L1.2516|
000774  3a00000a          BCC      |L1.1956|
                  |L1.1912|
;;;528    #if 0
;;;529        /* Can't assert these as some callers speculatively call
;;;530             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;531        /* Check that we've got the correct type of pbuf to work with */
;;;532        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
;;;533                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;534        /* Check that we aren't going to move off the beginning of the pbuf */
;;;535        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;536                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;537    #endif
;;;538      }
;;;539    
;;;540      type = p->type;
000778  e5d4000c          LDRB     r0,[r4,#0xc]
;;;541      /* remember current payload pointer */
;;;542      payload = p->payload;
;;;543    
;;;544      /* pbuf types containing payloads? */
;;;545      if (type == PBUF_RAM || type == PBUF_POOL) {
00077c  e5942004          LDR      r2,[r4,#4]
000780  e3500000          CMP      r0,#0
000784  13500003          CMPNE    r0,#3
000788  0a00000a          BEQ      |L1.1976|
;;;546        /* set new payload pointer */
;;;547        p->payload = (u8_t *)p->payload - header_size_increment;
;;;548        /* boundary check fails? */
;;;549        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;550          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;551            ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;552            (void *)p->payload, (void *)(p + 1)));
;;;553          /* restore old payload pointer */
;;;554          p->payload = payload;
;;;555          /* bail out unsuccesfully */
;;;556          return 1;
;;;557        }
;;;558      /* pbuf types refering to external payloads? */
;;;559      } else if (type == PBUF_REF || type == PBUF_ROM) {
00078c  e3500002          CMP      r0,#2
000790  13500001          CMPNE    r0,#1
;;;560        /* hide a header in the payload? */
;;;561        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;562          /* increase payload pointer */
;;;563          p->payload = (u8_t *)p->payload - header_size_increment;
;;;564        } else {
;;;565          /* cannot expand payload to front (yet!)
;;;566           * bail out unsuccesfully */
;;;567          return 1;
;;;568        }
;;;569      } else {
;;;570        /* Unknown type */
;;;571        LWIP_ASSERT("bad pbuf type", 0);
000794  159f3224          LDRNE    r3,|L1.2496|
000798  159f2254          LDRNE    r2,|L1.2548|
00079c  128f1f95          ADRNE    r1,|L1.2552|
0007a0  0a00000b          BEQ      |L1.2004|
                  |L1.1956|
0007a4  e59f0220          LDR      r0,|L1.2508|
0007a8  ebfffffe          BL       sysprintf
0007ac  ea00000f          B        |L1.2032|
                  |L1.1968|
0007b0  e3a00000          MOV      r0,#0                 ;519
;;;572        return 1;
;;;573      }
;;;574      /* modify pbuf length fields */
;;;575      p->len += header_size_increment;
;;;576      p->tot_len += header_size_increment;
;;;577    
;;;578      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;579        (void *)payload, (void *)p->payload, header_size_increment));
;;;580    
;;;581      return 0;
;;;582    }
0007b4  e8bd8070          POP      {r4-r6,pc}
                  |L1.1976|
0007b8  e0420005          SUB      r0,r2,r5              ;547
0007bc  e2841010          ADD      r1,r4,#0x10           ;549
0007c0  e1500001          CMP      r0,r1                 ;549
0007c4  e5840004          STR      r0,[r4,#4]            ;547
0007c8  35842004          STRCC    r2,[r4,#4]            ;554
0007cc  3a000007          BCC      |L1.2032|
0007d0  ea000008          B        |L1.2040|
                  |L1.2004|
0007d4  e3550000          CMP      r5,#0                 ;561
0007d8  aa000004          BGE      |L1.2032|
0007dc  e1d400ba          LDRH     r0,[r4,#0xa]          ;561
0007e0  e1500001          CMP      r0,r1                 ;561
0007e4  20420005          SUBCS    r0,r2,r5              ;563
0007e8  25840004          STRCS    r0,[r4,#4]            ;563
0007ec  2a000001          BCS      |L1.2040|
                  |L1.2032|
0007f0  e3a00001          MOV      r0,#1                 ;567
0007f4  e8bd8070          POP      {r4-r6,pc}
                  |L1.2040|
0007f8  e1d400ba          LDRH     r0,[r4,#0xa]          ;575
0007fc  e0800005          ADD      r0,r0,r5              ;575
000800  e1c400ba          STRH     r0,[r4,#0xa]          ;575
000804  e1d400b8          LDRH     r0,[r4,#8]            ;576
000808  e0800005          ADD      r0,r0,r5              ;576
00080c  e1c400b8          STRH     r0,[r4,#8]            ;576
000810  eaffffe6          B        |L1.1968|
;;;583    
                          ENDP

                  pbuf_clen PROC
;;;703    u8_t
;;;704    pbuf_clen(struct pbuf *p)
000814  e3a01000          MOV      r1,#0
                  |L1.2072|
;;;705    {
;;;706      u8_t len;
;;;707    
;;;708      len = 0;
;;;709      while (p != NULL) {
000818  e3500000          CMP      r0,#0
;;;710        ++len;
;;;711        p = p->next;
00081c  15900000          LDRNE    r0,[r0,#0]
000820  12811001          ADDNE    r1,r1,#1              ;709
000824  120110ff          ANDNE    r1,r1,#0xff           ;710
;;;712      }
;;;713      return len;
000828  01a00001          MOVEQ    r0,r1
00082c  1afffff9          BNE      |L1.2072|
;;;714    }
000830  e12fff1e          BX       lr
;;;715    
                          ENDP

                  pbuf_ref PROC
;;;722    void
;;;723    pbuf_ref(struct pbuf *p)
000834  e92d4010          PUSH     {r4,lr}
;;;724    {
000838  e1b04000          MOVS     r4,r0
;;;725      SYS_ARCH_DECL_PROTECT(old_level);
;;;726      /* pbuf given? */
;;;727      if (p != NULL) {
;;;728        SYS_ARCH_PROTECT(old_level);
;;;729        ++(p->ref);
;;;730        SYS_ARCH_UNPROTECT(old_level);
;;;731      }
;;;732    }
00083c  08bd8010          POPEQ    {r4,pc}
000840  ebfffffe          BL       sys_arch_protect
000844  e1d410be          LDRH     r1,[r4,#0xe]          ;729
000848  e2811001          ADD      r1,r1,#1              ;729
00084c  e1c410be          STRH     r1,[r4,#0xe]          ;729
000850  e8bd4010          POP      {r4,lr}               ;730
000854  eafffffe          B        sys_arch_unprotect
;;;733    
                          ENDP

                  pbuf_cat PROC
;;;744    void
;;;745    pbuf_cat(struct pbuf *h, struct pbuf *t)
000858  e92d4070          PUSH     {r4-r6,lr}
;;;746    {
;;;747      struct pbuf *p;
;;;748    
;;;749      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
00085c  e3500000          CMP      r0,#0
000860  e1a05001          MOV      r5,r1                 ;746
000864  13550000          CMPNE    r5,#0
000868  1a000005          BNE      |L1.2180|
00086c  e8bd4070          POP      {r4-r6,lr}
000870  e59f3148          LDR      r3,|L1.2496|
000874  e59f218c          LDR      r2,|L1.2568|
000878  e59f014c          LDR      r0,|L1.2508|
00087c  e28f1f62          ADR      r1,|L1.2572|
000880  eafffffe          B        sysprintf
                  |L1.2180|
;;;750                 ((h != NULL) && (t != NULL)), return;);
;;;751    
;;;752      /* proceed to last pbuf of chain */
;;;753      for (p = h; p->next != NULL; p = p->next) {
000884  e1a04000          MOV      r4,r0
000888  e5900000          LDR      r0,[r0,#0]
00088c  e3500000          CMP      r0,#0
000890  0a000004          BEQ      |L1.2216|
;;;754        /* add total length of second chain to all totals of first chain */
;;;755        p->tot_len += t->tot_len;
000894  e1d410b8          LDRH     r1,[r4,#8]
000898  e1d520b8          LDRH     r2,[r5,#8]
00089c  e0811002          ADD      r1,r1,r2
0008a0  e1c410b8          STRH     r1,[r4,#8]
0008a4  eafffff6          B        |L1.2180|
                  |L1.2216|
;;;756      }
;;;757      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;758      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
0008a8  e1d400b8          LDRH     r0,[r4,#8]
0008ac  e1d410ba          LDRH     r1,[r4,#0xa]
0008b0  e1500001          CMP      r0,r1
0008b4  0a00000c          BEQ      |L1.2284|
0008b8  e59f3100          LDR      r3,|L1.2496|
0008bc  e59f2180          LDR      r2,|L1.2628|
0008c0  e59f0104          LDR      r0,|L1.2508|
0008c4  e28f1f5f          ADR      r1,|L1.2632|
0008c8  ebfffffe          BL       sysprintf
;;;759      LWIP_ASSERT("p->next == NULL", p->next == NULL);
0008cc  e5940000          LDR      r0,[r4,#0]
0008d0  e3500000          CMP      r0,#0
0008d4  0a000004          BEQ      |L1.2284|
0008d8  e59f30e0          LDR      r3,|L1.2496|
0008dc  e59f2194          LDR      r2,|L1.2680|
0008e0  e59f00e4          LDR      r0,|L1.2508|
0008e4  e28f1e19          ADR      r1,|L1.2684|
0008e8  ebfffffe          BL       sysprintf
                  |L1.2284|
;;;760      /* add total length of second chain to last pbuf total of first chain */
;;;761      p->tot_len += t->tot_len;
0008ec  e1d400b8          LDRH     r0,[r4,#8]
0008f0  e1d510b8          LDRH     r1,[r5,#8]
0008f4  e0800001          ADD      r0,r0,r1
0008f8  e1c400b8          STRH     r0,[r4,#8]
;;;762      /* chain last pbuf of head (p) with first of tail (t) */
;;;763      p->next = t;
0008fc  e5845000          STR      r5,[r4,#0]
;;;764      /* p->next now references t, but the caller will drop its reference to t,
;;;765       * so netto there is no change to the reference count of t.
;;;766       */
;;;767    }
000900  e8bd8070          POP      {r4-r6,pc}
;;;768    
                          ENDP

                  pbuf_chain PROC
;;;785    void
;;;786    pbuf_chain(struct pbuf *h, struct pbuf *t)
000904  e92d4010          PUSH     {r4,lr}
;;;787    {
000908  e1a04001          MOV      r4,r1
;;;788      pbuf_cat(h, t);
00090c  ebfffffe          BL       pbuf_cat
;;;789      /* t is now referenced by h */
;;;790      pbuf_ref(t);
000910  e1a00004          MOV      r0,r4
000914  e8bd4010          POP      {r4,lr}
000918  eafffffe          B        pbuf_ref
;;;791      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
;;;792    }
;;;793    
                          ENDP

                  pbuf_dechain PROC
;;;802    struct pbuf *
;;;803    pbuf_dechain(struct pbuf *p)
00091c  e92d4070          PUSH     {r4-r6,lr}
;;;804    {
;;;805      struct pbuf *q;
;;;806      u8_t tail_gone = 1;
;;;807      /* tail */
;;;808      q = p->next;
000920  e5905000          LDR      r5,[r0,#0]
000924  e1a04000          MOV      r4,r0                 ;804
;;;809      /* pbuf has successor in chain? */
;;;810      if (q != NULL) {
000928  e3550000          CMP      r5,#0
00092c  e3a06001          MOV      r6,#1                 ;806
000930  0a000015          BEQ      |L1.2444|
;;;811        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;812        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
000934  e1d400b8          LDRH     r0,[r4,#8]
000938  e1d410ba          LDRH     r1,[r4,#0xa]
00093c  e0400001          SUB      r0,r0,r1
000940  e1d510b8          LDRH     r1,[r5,#8]
000944  e1500001          CMP      r0,r1
000948  0a000004          BEQ      |L1.2400|
00094c  e59f306c          LDR      r3,|L1.2496|
000950  e59f0074          LDR      r0,|L1.2508|
000954  e3a02fcb          MOV      r2,#0x32c
000958  e28f1f4b          ADR      r1,|L1.2700|
00095c  ebfffffe          BL       sysprintf
                  |L1.2400|
;;;813        /* enforce invariant if assertion is disabled */
;;;814        q->tot_len = p->tot_len - p->len;
000960  e1d400b8          LDRH     r0,[r4,#8]
000964  e1d410ba          LDRH     r1,[r4,#0xa]
000968  e0400001          SUB      r0,r0,r1
00096c  e1c500b8          STRH     r0,[r5,#8]
;;;815        /* decouple pbuf from remainder */
;;;816        p->next = NULL;
000970  e3a00000          MOV      r0,#0
000974  e5840000          STR      r0,[r4,#0]
;;;817        /* total length of pbuf p is its own length only */
;;;818        p->tot_len = p->len;
000978  e1d400ba          LDRH     r0,[r4,#0xa]
00097c  e1c400b8          STRH     r0,[r4,#8]
;;;819        /* q is no longer referenced by p, free it */
;;;820        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
;;;821        tail_gone = pbuf_free(q);
000980  e1a00005          MOV      r0,r5
000984  ebfffffe          BL       pbuf_free
000988  e1a06000          MOV      r6,r0
                  |L1.2444|
;;;822        if (tail_gone > 0) {
;;;823          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
;;;824                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;825        }
;;;826        /* return remaining tail or NULL if deallocated */
;;;827      }
;;;828      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;829      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
00098c  e1d400b8          LDRH     r0,[r4,#8]
000990  e1d410ba          LDRH     r1,[r4,#0xa]
000994  e1500001          CMP      r0,r1
000998  0a000004          BEQ      |L1.2480|
00099c  e59f301c          LDR      r3,|L1.2496|
0009a0  e59f2108          LDR      r2,|L1.2736|
0009a4  e59f0020          LDR      r0,|L1.2508|
0009a8  e28f1f41          ADR      r1,|L1.2740|
0009ac  ebfffffe          BL       sysprintf
                  |L1.2480|
;;;830      return ((tail_gone > 0) ? NULL : q);
0009b0  e3560000          CMP      r6,#0
0009b4  13a00000          MOVNE    r0,#0
0009b8  01a00005          MOVEQ    r0,r5
;;;831    }
0009bc  e8bd8070          POP      {r4-r6,pc}
                  |L1.2496|
                          DCD      ||.text||+0x26c
                  |L1.2500|
                          DCD      0x00000205
                  |L1.2504|
                          DCD      ||.text||+0x2d0
                  |L1.2508|
                          DCD      ||.text||+0x2a4
                  |L1.2512|
                          DCD      0x0000020d
                  |L1.2516|
0009d4  696e6372          DCB      "increment_magnitude <= p->len",0
0009d8  656d656e
0009dc  745f6d61
0009e0  676e6974
0009e4  75646520
0009e8  3c3d2070
0009ec  2d3e6c65
0009f0  6e00    
0009f2  00                DCB      0
0009f3  00                DCB      0
                  |L1.2548|
                          DCD      0x0000023b
                  |L1.2552|
0009f8  62616420          DCB      "bad pbuf type",0
0009fc  70627566
000a00  20747970
000a04  6500    
000a06  00                DCB      0
000a07  00                DCB      0
                  |L1.2568|
                          DCD      0x000002ed
                  |L1.2572|
000a0c  28682021          DCB      "(h != NULL) && (t != NULL) (programmer violates API)",0
000a10  3d204e55
000a14  4c4c2920
000a18  26262028
000a1c  7420213d
000a20  204e554c
000a24  4c292028
000a28  70726f67
000a2c  72616d6d
000a30  65722076
000a34  696f6c61
000a38  74657320
000a3c  41504929
000a40  00      
000a41  00                DCB      0
000a42  00                DCB      0
000a43  00                DCB      0
                  |L1.2628|
                          DCD      0x000002f6
                  |L1.2632|
000a48  702d3e74          DCB      "p->tot_len == p->len (of last pbuf in chain)",0
000a4c  6f745f6c
000a50  656e203d
000a54  3d20702d
000a58  3e6c656e
000a5c  20286f66
000a60  206c6173
000a64  74207062
000a68  75662069
000a6c  6e206368
000a70  61696e29
000a74  00      
000a75  00                DCB      0
000a76  00                DCB      0
000a77  00                DCB      0
                  |L1.2680|
                          DCD      0x000002f7
                  |L1.2684|
000a7c  702d3e6e          DCB      "p->next == NULL",0
000a80  65787420
000a84  3d3d204e
000a88  554c4c00
                  |L1.2700|
000a8c  702d3e74          DCB      "p->tot_len == p->len + q->tot_len",0
000a90  6f745f6c
000a94  656e203d
000a98  3d20702d
000a9c  3e6c656e
000aa0  202b2071
000aa4  2d3e746f
000aa8  745f6c65
000aac  6e00    
000aae  00                DCB      0
000aaf  00                DCB      0
                  |L1.2736|
                          DCD      0x0000033d
                  |L1.2740|
000ab4  702d3e74          DCB      "p->tot_len == p->len",0
000ab8  6f745f6c
000abc  656e203d
000ac0  3d20702d
000ac4  3e6c656e
000ac8  00      
000ac9  00                DCB      0
000aca  00                DCB      0
000acb  00                DCB      0
                          ENDP

                  pbuf_copy PROC
;;;851    err_t
;;;852    pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
000acc  e92d41f0          PUSH     {r4-r8,lr}
;;;853    {
000ad0  e1b05000          MOVS     r5,r0
000ad4  e1a04001          MOV      r4,r1
;;;854      u16_t offset_to=0, offset_from=0, len;
000ad8  e3a07000          MOV      r7,#0
;;;855    
;;;856      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
;;;857        (void*)p_to, (void*)p_from));
;;;858    
;;;859      /* is the target big enough to hold the source? */
;;;860      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
000adc  13540000          CMPNE    r4,#0
000ae0  e1a06007          MOV      r6,r7                 ;854
000ae4  0a000003          BEQ      |L1.2808|
000ae8  e1d500b8          LDRH     r0,[r5,#8]
000aec  e1d410b8          LDRH     r1,[r4,#8]
000af0  e1510000          CMP      r1,r0
000af4  9a000006          BLS      |L1.2836|
                  |L1.2808|
000af8  e51f3140          LDR      r3,|L1.2496|
000afc  e3a02fd7          MOV      r2,#0x35c
000b00  e28f1f8a          ADR      r1,|L1.3376|
                  |L1.2820|
;;;861                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;862    
;;;863      /* iterate through pbuf chain */
;;;864      do
;;;865      {
;;;866        /* copy one part of the original chain */
;;;867        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;868          /* complete current p_from fits into current p_to */
;;;869          len = p_from->len - offset_from;
;;;870        } else {
;;;871          /* current p_from does not fit into current p_to */
;;;872          len = p_to->len - offset_to;
;;;873        }
;;;874        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;875        offset_to += len;
;;;876        offset_from += len;
;;;877        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;878        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;879        if (offset_from >= p_from->len) {
;;;880          /* on to next p_from (if any) */
;;;881          offset_from = 0;
;;;882          p_from = p_from->next;
;;;883        }
;;;884        if (offset_to == p_to->len) {
;;;885          /* on to next p_to (if any) */
;;;886          offset_to = 0;
;;;887          p_to = p_to->next;
;;;888          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
000b04  e51f0140          LDR      r0,|L1.2508|
000b08  ebfffffe          BL       sysprintf
000b0c  e3e0000d          MVN      r0,#0xd
;;;889        }
;;;890    
;;;891        if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;892          /* don't copy more than one packet! */
;;;893          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;894                     (p_from->next == NULL), return ERR_VAL;);
;;;895        }
;;;896        if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;897          /* don't copy more than one packet! */
;;;898          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;899                      (p_to->next == NULL), return ERR_VAL;);
;;;900        }
;;;901      } while (p_from);
;;;902      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;903      return ERR_OK;
;;;904    }
000b10  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2836|
000b14  e1d500ba          LDRH     r0,[r5,#0xa]          ;867
000b18  e1d410ba          LDRH     r1,[r4,#0xa]          ;867
000b1c  e0400007          SUB      r0,r0,r7              ;867
000b20  e0411006          SUB      r1,r1,r6              ;867
000b24  e1500001          CMP      r0,r1                 ;867
000b28  a1a08801          LSLGE    r8,r1,#16             ;869
000b2c  a1a08828          LSRGE    r8,r8,#16             ;869
000b30  b1a08800          LSLLT    r8,r0,#16             ;872
000b34  e5940004          LDR      r0,[r4,#4]            ;874
000b38  b1a08828          LSRLT    r8,r8,#16             ;872
000b3c  e0801006          ADD      r1,r0,r6              ;874
000b40  e5950004          LDR      r0,[r5,#4]            ;874
000b44  e1a02008          MOV      r2,r8                 ;874
000b48  e0800007          ADD      r0,r0,r7              ;874
000b4c  ebfffffe          BL       __aeabi_memcpy
000b50  e0870008          ADD      r0,r7,r8              ;875
000b54  e3c07801          BIC      r7,r0,#0x10000        ;875
000b58  e0860008          ADD      r0,r6,r8              ;876
000b5c  e3c06801          BIC      r6,r0,#0x10000        ;876
000b60  e1d500ba          LDRH     r0,[r5,#0xa]          ;877
000b64  e1500007          CMP      r0,r7                 ;877
000b68  2a000004          BCS      |L1.2944|
000b6c  e51f31b4          LDR      r3,|L1.2496|
000b70  e59f21e8          LDR      r2,|L1.3424|
000b74  e51f01b0          LDR      r0,|L1.2508|
000b78  e28f1f79          ADR      r1,|L1.3428|
000b7c  ebfffffe          BL       sysprintf
                  |L1.2944|
000b80  e1d400ba          LDRH     r0,[r4,#0xa]          ;878
000b84  e1500006          CMP      r0,r6                 ;878
000b88  2a000004          BCS      |L1.2976|
000b8c  e51f31d4          LDR      r3,|L1.2496|
000b90  e59f21e4          LDR      r2,|L1.3452|
000b94  e51f01d0          LDR      r0,|L1.2508|
000b98  e28f1e1e          ADR      r1,|L1.3456|
000b9c  ebfffffe          BL       sysprintf
                  |L1.2976|
000ba0  e1d400ba          LDRH     r0,[r4,#0xa]          ;879
000ba4  e1500006          CMP      r0,r6                 ;879
000ba8  e1d500ba          LDRH     r0,[r5,#0xa]          ;884
000bac  95944000          LDRLS    r4,[r4,#0]            ;882
000bb0  93a06000          MOVLS    r6,#0                 ;881
000bb4  e1500007          CMP      r0,r7                 ;884
000bb8  05955000          LDREQ    r5,[r5,#0]            ;887
000bbc  03a07000          MOVEQ    r7,#0                 ;886
000bc0  03550000          CMPEQ    r5,#0                 ;888
000bc4  0a00000f          BEQ      |L1.3080|
000bc8  e3540000          CMP      r4,#0                 ;891
000bcc  0a000013          BEQ      |L1.3104|
000bd0  e1d400ba          LDRH     r0,[r4,#0xa]          ;891
000bd4  e1d410b8          LDRH     r1,[r4,#8]            ;891
000bd8  e1500001          CMP      r0,r1                 ;891
000bdc  1a00000f          BNE      |L1.3104|
000be0  e5940000          LDR      r0,[r4,#0]            ;893
000be4  e3500000          CMP      r0,#0                 ;893
000be8  151f3230          LDRNE    r3,|L1.2496|
000bec  159f21a8          LDRNE    r2,|L1.3484|
000bf0  0a00000a          BEQ      |L1.3104|
                  |L1.3060|
000bf4  e51f0230          LDR      r0,|L1.2508|
000bf8  e28f1e1a          ADR      r1,|L1.3488|
000bfc  ebfffffe          BL       sysprintf
000c00  e3e00005          MVN      r0,#5                 ;898
000c04  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3080|
000c08  e3540000          CMP      r4,#0                 ;888
000c0c  151f3254          LDRNE    r3,|L1.2496|
000c10  13a02fde          MOVNE    r2,#0x378             ;888
000c14  128f1e1b          ADRNE    r1,|L1.3532|
000c18  1affffb9          BNE      |L1.2820|
000c1c  ea00000c          B        |L1.3156|
                  |L1.3104|
000c20  e3550000          CMP      r5,#0                 ;896
000c24  0a000008          BEQ      |L1.3148|
000c28  e1d500ba          LDRH     r0,[r5,#0xa]          ;896
000c2c  e1d510b8          LDRH     r1,[r5,#8]            ;896
000c30  e1500001          CMP      r0,r1                 ;896
000c34  1a000004          BNE      |L1.3148|
000c38  e5950000          LDR      r0,[r5,#0]            ;898
000c3c  e3500000          CMP      r0,#0                 ;898
000c40  151f3288          LDRNE    r3,|L1.2496|
000c44  159f2190          LDRNE    r2,|L1.3548|
000c48  1affffe9          BNE      |L1.3060|
                  |L1.3148|
000c4c  e3540000          CMP      r4,#0                 ;901
000c50  1affffaf          BNE      |L1.2836|
                  |L1.3156|
000c54  e3a00000          MOV      r0,#0                 ;903
000c58  e8bd81f0          POP      {r4-r8,pc}
;;;905    
                          ENDP

                  pbuf_copy_partial PROC
;;;917    u16_t
;;;918    pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
000c5c  e92d47f0          PUSH     {r4-r10,lr}
;;;919    {
;;;920      struct pbuf *p;
;;;921      u16_t left;
;;;922      u16_t buf_copy_len;
;;;923      u16_t copied_total = 0;
;;;924    
;;;925      LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
000c60  e3500000          CMP      r0,#0
000c64  e1a06002          MOV      r6,r2                 ;919
000c68  051f32b0          LDREQ    r3,|L1.2496|
000c6c  059f216c          LDREQ    r2,|L1.3552|
000c70  e1a09001          MOV      r9,r1                 ;919
000c74  e3a08000          MOV      r8,#0                 ;923
000c78  028f1f59          ADREQ    r1,|L1.3556|
000c7c  0a000006          BEQ      |L1.3228|
;;;926      LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
000c80  e3590000          CMP      r9,#0
000c84  051f32cc          LDREQ    r3,|L1.2496|
000c88  059f2174          LDREQ    r2,|L1.3588|
000c8c  028f1f5d          ADREQ    r1,|L1.3592|
;;;927    
;;;928      left = 0;
000c90  13a07000          MOVNE    r7,#0
;;;929    
;;;930      if((buf == NULL) || (dataptr == NULL)) {
;;;931        return 0;
;;;932      }
;;;933    
;;;934      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;935      for(p = buf; len != 0 && p != NULL; p = p->next) {
000c94  11a04000          MOVNE    r4,r0
000c98  1a00001f          BNE      |L1.3356|
                  |L1.3228|
000c9c  e51f02d8          LDR      r0,|L1.2508|
000ca0  ebfffffe          BL       sysprintf
000ca4  e3a00000          MOV      r0,#0                 ;926
;;;936        if ((offset != 0) && (offset >= p->len)) {
;;;937          /* don't copy from this buffer -> on to the next */
;;;938          offset -= p->len;
;;;939        } else {
;;;940          /* copy from this buffer. maybe only partially. */
;;;941          buf_copy_len = p->len - offset;
;;;942          if (buf_copy_len > len)
;;;943              buf_copy_len = len;
;;;944          /* copy the necessary parts of the buffer */
;;;945          MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;946          copied_total += buf_copy_len;
;;;947          left += buf_copy_len;
;;;948          len -= buf_copy_len;
;;;949          offset = 0;
;;;950        }
;;;951      }
;;;952      return copied_total;
;;;953    }
000ca8  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3244|
000cac  e3530000          CMP      r3,#0                 ;936
000cb0  0a000005          BEQ      |L1.3276|
000cb4  e1d400ba          LDRH     r0,[r4,#0xa]          ;936
000cb8  e1500003          CMP      r0,r3                 ;936
000cbc  90430000          SUBLS    r0,r3,r0              ;938
000cc0  91a03800          LSLLS    r3,r0,#16             ;938
000cc4  91a03823          LSRLS    r3,r3,#16             ;938
000cc8  9a000012          BLS      |L1.3352|
                  |L1.3276|
000ccc  e1d400ba          LDRH     r0,[r4,#0xa]          ;941
000cd0  e0400003          SUB      r0,r0,r3              ;941
000cd4  e1a05800          LSL      r5,r0,#16             ;941
000cd8  e5940004          LDR      r0,[r4,#4]            ;945
000cdc  e1a05825          LSR      r5,r5,#16             ;941
000ce0  e1550006          CMP      r5,r6                 ;942
000ce4  81a05006          MOVHI    r5,r6                 ;943
000ce8  e0801003          ADD      r1,r0,r3              ;945
000cec  e0890007          ADD      r0,r9,r7              ;945
000cf0  e1a02005          MOV      r2,r5                 ;945
000cf4  ebfffffe          BL       __aeabi_memcpy
000cf8  e0880005          ADD      r0,r8,r5              ;946
000cfc  e3c08801          BIC      r8,r0,#0x10000        ;946
000d00  e0870005          ADD      r0,r7,r5              ;947
000d04  e3c07801          BIC      r7,r0,#0x10000        ;947
000d08  e0460005          SUB      r0,r6,r5              ;948
000d0c  e1a06800          LSL      r6,r0,#16             ;948
000d10  e1a06826          LSR      r6,r6,#16             ;948
000d14  e3a03000          MOV      r3,#0                 ;949
                  |L1.3352|
000d18  e5944000          LDR      r4,[r4,#0]            ;935
                  |L1.3356|
000d1c  e3560000          CMP      r6,#0                 ;935
000d20  13540000          CMPNE    r4,#0                 ;935
000d24  01a00008          MOVEQ    r0,r8                 ;952
000d28  1affffdf          BNE      |L1.3244|
000d2c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3376|
000d30  70627566          DCB      "pbuf_copy: target not big enough to hold source",0
000d34  5f636f70
000d38  793a2074
000d3c  61726765
000d40  74206e6f
000d44  74206269
000d48  6720656e
000d4c  6f756768
000d50  20746f20
000d54  686f6c64
000d58  20736f75
000d5c  72636500
                  |L1.3424|
                          DCD      0x0000036d
                  |L1.3428|
000d64  6f666673          DCB      "offset_to <= p_to->len",0
000d68  65745f74
000d6c  6f203c3d
000d70  20705f74
000d74  6f2d3e6c
000d78  656e00  
000d7b  00                DCB      0
                  |L1.3452|
                          DCD      0x0000036e
                  |L1.3456|
000d80  6f666673          DCB      "offset_from <= p_from->len",0
000d84  65745f66
000d88  726f6d20
000d8c  3c3d2070
000d90  5f66726f
000d94  6d2d3e6c
000d98  656e00  
000d9b  00                DCB      0
                  |L1.3484|
                          DCD      0x0000037d
                  |L1.3488|
000da0  70627566          DCB      "pbuf_copy() does not allow packet queues!\n",0
000da4  5f636f70
000da8  79282920
000dac  646f6573
000db0  206e6f74
000db4  20616c6c
000db8  6f772070
000dbc  61636b65
000dc0  74207175
000dc4  65756573
000dc8  210a00  
000dcb  00                DCB      0
                  |L1.3532|
000dcc  705f746f          DCB      "p_to != NULL",0
000dd0  20213d20
000dd4  4e554c4c
000dd8  00      
000dd9  00                DCB      0
000dda  00                DCB      0
000ddb  00                DCB      0
                  |L1.3548|
                          DCD      0x00000382
                  |L1.3552|
                          DCD      0x0000039d
                  |L1.3556|
000de4  70627566          DCB      "pbuf_copy_partial: invalid buf",0
000de8  5f636f70
000dec  795f7061
000df0  72746961
000df4  6c3a2069
000df8  6e76616c
000dfc  69642062
000e00  756600  
000e03  00                DCB      0
                  |L1.3588|
                          DCD      0x0000039e
                  |L1.3592|
000e08  70627566          DCB      "pbuf_copy_partial: invalid dataptr",0
000e0c  5f636f70
000e10  795f7061
000e14  72746961
000e18  6c3a2069
000e1c  6e76616c
000e20  69642064
000e24  61746170
000e28  747200  
000e2b  00                DCB      0
                          ENDP

                  pbuf_take PROC
;;;965    err_t
;;;966    pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
000e2c  e92d47f0          PUSH     {r4-r10,lr}
;;;967    {
;;;968      struct pbuf *p;
;;;969      u16_t buf_copy_len;
;;;970      u16_t total_copy_len = len;
;;;971      u16_t copied_total = 0;
;;;972    
;;;973      LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
000e30  e3500000          CMP      r0,#0
000e34  e1a08002          MOV      r8,r2                 ;967
000e38  e1a06002          MOV      r6,r2                 ;970
000e3c  051f3484          LDREQ    r3,|L1.2496|
000e40  059f223c          LDREQ    r2,|L1.4228|
000e44  e1a09001          MOV      r9,r1                 ;967
000e48  e3a07000          MOV      r7,#0                 ;971
000e4c  028f1f8d          ADREQ    r1,|L1.4232|
000e50  0a00000b          BEQ      |L1.3716|
;;;974      LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
000e54  e3590000          CMP      r9,#0
000e58  051f34a0          LDREQ    r3,|L1.2496|
000e5c  059f223c          LDREQ    r2,|L1.4256|
000e60  028f1f8f          ADREQ    r1,|L1.4260|
000e64  0a000006          BEQ      |L1.3716|
;;;975    
;;;976      if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
000e68  e1d010b8          LDRH     r1,[r0,#8]
000e6c  e1510008          CMP      r1,r8
;;;977        return ERR_ARG;
;;;978      }
;;;979    
;;;980      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;981      for(p = buf; total_copy_len != 0; p = p->next) {
;;;982        LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
000e70  259fa248          LDRCS    r10,|L1.4288|
000e74  33e0000d          MVNCC    r0,#0xd               ;977
000e78  21a04000          MOVCS    r4,r0                 ;981
000e7c  2a000018          BCS      |L1.3812|
;;;983        buf_copy_len = total_copy_len;
;;;984        if (buf_copy_len > p->len) {
;;;985          /* this pbuf cannot hold all remaining data */
;;;986          buf_copy_len = p->len;
;;;987        }
;;;988        /* copy the necessary parts of the buffer */
;;;989        MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
;;;990        total_copy_len -= buf_copy_len;
;;;991        copied_total += buf_copy_len;
;;;992      }
;;;993      LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;994      return ERR_OK;
;;;995    }
000e80  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3716|
000e84  e51f04c0          LDR      r0,|L1.2508|
000e88  ebfffffe          BL       sysprintf
000e8c  ea00001b          B        |L1.3840|
                  |L1.3728|
000e90  e3540000          CMP      r4,#0                 ;982
000e94  1a000004          BNE      |L1.3756|
000e98  e51f34e0          LDR      r3,|L1.2496|
000e9c  e51f04d8          LDR      r0,|L1.2508|
000ea0  e1a0200a          MOV      r2,r10                ;982
000ea4  e28f1f86          ADR      r1,|L1.4292|
000ea8  ebfffffe          BL       sysprintf
                  |L1.3756|
000eac  e1d400ba          LDRH     r0,[r4,#0xa]          ;984
000eb0  e1a05006          MOV      r5,r6                 ;983
000eb4  e0891007          ADD      r1,r9,r7              ;989
000eb8  e1500005          CMP      r0,r5                 ;984
000ebc  31a05000          MOVCC    r5,r0                 ;986
000ec0  e5940004          LDR      r0,[r4,#4]            ;989
000ec4  e1a02005          MOV      r2,r5                 ;989
000ec8  ebfffffe          BL       __aeabi_memcpy
000ecc  e0460005          SUB      r0,r6,r5              ;990
000ed0  e1a06800          LSL      r6,r0,#16             ;990
000ed4  e5944000          LDR      r4,[r4,#0]            ;981
000ed8  e0870005          ADD      r0,r7,r5              ;991
000edc  e1a06826          LSR      r6,r6,#16             ;990
000ee0  e3c07801          BIC      r7,r0,#0x10000        ;991
                  |L1.3812|
000ee4  e3560000          CMP      r6,#0                 ;981
000ee8  1affffe8          BNE      |L1.3728|
000eec  e1570008          CMP      r7,r8                 ;993
000ef0  151f3538          LDRNE    r3,|L1.2496|
000ef4  159f21e0          LDRNE    r2,|L1.4316|
000ef8  128f1e1e          ADRNE    r1,|L1.4320|
000efc  1affffe0          BNE      |L1.3716|
                  |L1.3840|
000f00  e3a00000          MOV      r0,#0                 ;994
000f04  e8bd87f0          POP      {r4-r10,pc}
;;;996    
                          ENDP

                  pbuf_coalesce PROC
;;;1009   struct pbuf*
;;;1010   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
000f08  e92d4070          PUSH     {r4-r6,lr}
;;;1011   {
000f0c  e1a04000          MOV      r4,r0
;;;1012     struct pbuf *q;
;;;1013     err_t err;
;;;1014     if (p->next == NULL) {
000f10  e5900000          LDR      r0,[r0,#0]
000f14  e1a03001          MOV      r3,r1                 ;1011
000f18  e3500000          CMP      r0,#0
000f1c  0a000012          BEQ      |L1.3948|
;;;1015       return p;
;;;1016     }
;;;1017     q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
000f20  e1d410b8          LDRH     r1,[r4,#8]
000f24  e3a02000          MOV      r2,#0
000f28  e1a00003          MOV      r0,r3
000f2c  ebfffffe          BL       pbuf_alloc
000f30  e1b05000          MOVS     r5,r0
;;;1018     if (q == NULL) {
000f34  0a00000c          BEQ      |L1.3948|
;;;1019       /* @todo: what do we do now? */
;;;1020       return p;
;;;1021     }
;;;1022     err = pbuf_copy(q, p);
000f38  e1a01004          MOV      r1,r4
000f3c  ebfffffe          BL       pbuf_copy
;;;1023     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
000f40  e3500000          CMP      r0,#0
000f44  0a000004          BEQ      |L1.3932|
000f48  e51f3590          LDR      r3,|L1.2496|
000f4c  e59f21a4          LDR      r2,|L1.4344|
000f50  e51f058c          LDR      r0,|L1.2508|
000f54  e28f1e1a          ADR      r1,|L1.4348|
000f58  ebfffffe          BL       sysprintf
                  |L1.3932|
;;;1024     pbuf_free(p);
000f5c  e1a00004          MOV      r0,r4
000f60  ebfffffe          BL       pbuf_free
;;;1025     return q;
000f64  e1a00005          MOV      r0,r5
;;;1026   }
000f68  e8bd8070          POP      {r4-r6,pc}
                  |L1.3948|
000f6c  e1a00004          MOV      r0,r4                 ;1020
000f70  e8bd8070          POP      {r4-r6,pc}
;;;1027   
                          ENDP

                  pbuf_get_at PROC
                  |L1.3956|
;;;1076   u8_t
;;;1077   pbuf_get_at(struct pbuf* p, u16_t offset)
000f74  e3500000          CMP      r0,#0
;;;1078   {
;;;1079     u16_t copy_from = offset;
;;;1080     struct pbuf* q = p;
;;;1081   
;;;1082     /* get the correct pbuf */
;;;1083     while ((q != NULL) && (q->len <= copy_from)) {
;;;1084       copy_from -= q->len;
;;;1085       q = q->next;
;;;1086     }
;;;1087     /* return requested data if pbuf is OK */
;;;1088     if ((q != NULL) && (q->len > copy_from)) {
;;;1089       return ((u8_t*)q->payload)[copy_from];
;;;1090     }
;;;1091     return 0;
;;;1092   }
000f78  012fff1e          BXEQ     lr
000f7c  e1d020ba          LDRH     r2,[r0,#0xa]          ;1083
000f80  e1520001          CMP      r2,r1                 ;1083
000f84  95900000          LDRLS    r0,[r0,#0]            ;1085
000f88  85900004          LDRHI    r0,[r0,#4]            ;1089
000f8c  90411002          SUBLS    r1,r1,r2              ;1084
000f90  87d00001          LDRBHI   r0,[r0,r1]            ;1089
000f94  91a01801          LSLLS    r1,r1,#16             ;1084
000f98  91a01821          LSRLS    r1,r1,#16             ;1084
000f9c  9afffff4          BLS      |L1.3956|
000fa0  e12fff1e          BX       lr
;;;1093   
                          ENDP

                  pbuf_memcmp PROC
;;;1103   u16_t
;;;1104   pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
000fa4  e92d4070          PUSH     {r4-r6,lr}
;;;1105   {
000fa8  e1a06002          MOV      r6,r2
000fac  e1a05001          MOV      r5,r1
000fb0  e1a04000          MOV      r4,r0
                  |L1.4020|
;;;1106     u16_t start = offset;
;;;1107     struct pbuf* q = p;
;;;1108   
;;;1109     /* get the correct pbuf */
;;;1110     while ((q != NULL) && (q->len <= start)) {
000fb4  e3540000          CMP      r4,#0
;;;1111       start -= q->len;
;;;1112       q = q->next;
;;;1113     }
;;;1114     /* return requested data if pbuf is OK */
;;;1115     if ((q != NULL) && (q->len > start)) {
;;;1116       u16_t i;
;;;1117       for(i = 0; i < n; i++) {
;;;1118         u8_t a = pbuf_get_at(q, start + i);
;;;1119         u8_t b = ((u8_t*)s2)[i];
;;;1120         if (a != b) {
;;;1121           return i+1;
;;;1122         }
;;;1123       }
;;;1124       return 0;
;;;1125     }
;;;1126     return 0xffff;
000fb8  051f0984          LDREQ    r0,|L1.1596|
;;;1127   }
000fbc  08bd8070          POPEQ    {r4-r6,pc}
000fc0  e1d400ba          LDRH     r0,[r4,#0xa]          ;1110
000fc4  e1500005          CMP      r0,r5                 ;1110
000fc8  90450000          SUBLS    r0,r5,r0              ;1111
000fcc  95944000          LDRLS    r4,[r4,#0]            ;1112
000fd0  91a05800          LSLLS    r5,r0,#16             ;1111
000fd4  91a05825          LSRLS    r5,r5,#16             ;1111
000fd8  83a0c000          MOVHI    r12,#0                ;1117
000fdc  9afffff4          BLS      |L1.4020|
                  |L1.4064|
000fe0  e15c0003          CMP      r12,r3                ;1117
000fe4  23a00000          MOVCS    r0,#0                 ;1124
000fe8  28bd8070          POPCS    {r4-r6,pc}
000fec  e085000c          ADD      r0,r5,r12             ;1118
000ff0  e3c01801          BIC      r1,r0,#0x10000        ;1118
000ff4  e1a00004          MOV      r0,r4                 ;1118
000ff8  ebfffffe          BL       pbuf_get_at
000ffc  e7d6100c          LDRB     r1,[r6,r12]           ;1119
001000  e1500001          CMP      r0,r1                 ;1120
001004  e28c0001          ADD      r0,r12,#1             ;1117
001008  13c00801          BICNE    r0,r0,#0x10000        ;1121
00100c  03c0c801          BICEQ    r12,r0,#0x10000       ;1117
001010  0afffff2          BEQ      |L1.4064|
001014  e8bd8070          POP      {r4-r6,pc}
;;;1128   
                          ENDP

                  pbuf_memfind PROC
;;;1139   u16_t
;;;1140   pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
001018  e92d41f0          PUSH     {r4-r8,lr}
;;;1141   {
00101c  e1a07000          MOV      r7,r0
;;;1142     u16_t i;
;;;1143     u16_t max = p->tot_len - mem_len;
001020  e1d000b8          LDRH     r0,[r0,#8]
001024  e1a06002          MOV      r6,r2                 ;1141
001028  e1a08001          MOV      r8,r1                 ;1141
00102c  e0401006          SUB      r1,r0,r6
001030  e1a05801          LSL      r5,r1,#16
;;;1144     if (p->tot_len >= mem_len + start_offset) {
001034  e0821003          ADD      r1,r2,r3
001038  e1500001          CMP      r0,r1
00103c  e1a05825          LSR      r5,r5,#16             ;1143
;;;1145       for(i = start_offset; i <= max; ) {
001040  21a04003          MOVCS    r4,r3
001044  3a00000c          BCC      |L1.4220|
                  |L1.4168|
001048  e1550004          CMP      r5,r4
00104c  3a00000a          BCC      |L1.4220|
;;;1146         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
001050  e1a03006          MOV      r3,r6
001054  e1a02008          MOV      r2,r8
001058  e1a01004          MOV      r1,r4
00105c  e1a00007          MOV      r0,r7
001060  ebfffffe          BL       pbuf_memcmp
;;;1147         if (plus == 0) {
001064  e3500000          CMP      r0,#0
;;;1148           return i;
001068  01a00004          MOVEQ    r0,r4
;;;1149         } else {
;;;1150           i += plus;
00106c  10800004          ADDNE    r0,r0,r4
001070  13c04801          BICNE    r4,r0,#0x10000
001074  1afffff3          BNE      |L1.4168|
;;;1151         }
;;;1152       }
;;;1153     }
;;;1154     return 0xFFFF;
;;;1155   }
001078  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4220|
00107c  e51f0a48          LDR      r0,|L1.1596|
001080  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4228|
                          DCD      0x000003cd
                  |L1.4232|
001088  70627566          DCB      "pbuf_take: invalid buf",0
00108c  5f74616b
001090  653a2069
001094  6e76616c
001098  69642062
00109c  756600  
00109f  00                DCB      0
                  |L1.4256|
                          DCD      0x000003ce
                  |L1.4260|
0010a4  70627566          DCB      "pbuf_take: invalid dataptr",0
0010a8  5f74616b
0010ac  653a2069
0010b0  6e76616c
0010b4  69642064
0010b8  61746170
0010bc  747200  
0010bf  00                DCB      0
                  |L1.4288|
                          DCD      0x000003d6
                  |L1.4292|
0010c4  70627566          DCB      "pbuf_take: invalid pbuf",0
0010c8  5f74616b
0010cc  653a2069
0010d0  6e76616c
0010d4  69642070
0010d8  62756600
                  |L1.4316|
                          DCD      0x000003e1
                  |L1.4320|
0010e0  64696420          DCB      "did not copy all data",0
0010e4  6e6f7420
0010e8  636f7079
0010ec  20616c6c
0010f0  20646174
0010f4  6100    
0010f6  00                DCB      0
0010f7  00                DCB      0
                  |L1.4344|
                          DCD      0x000003ff
                  |L1.4348|
0010fc  70627566          DCB      "pbuf_copy failed",0
001100  5f636f70
001104  79206661
001108  696c6564
00110c  00      
00110d  00                DCB      0
00110e  00                DCB      0
00110f  00                DCB      0
                          ENDP

                  pbuf_strstr PROC
;;;1167   u16_t
;;;1168   pbuf_strstr(struct pbuf* p, const char* substr)
001110  e92d4070          PUSH     {r4-r6,lr}
;;;1169   {
001114  e1b04001          MOVS     r4,r1
001118  e1a06000          MOV      r6,r0
;;;1170     size_t substr_len;
;;;1171     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
00111c  15d40000          LDRBNE   r0,[r4,#0]
001120  e51f5aec          LDR      r5,|L1.1596|
001124  13500000          CMPNE    r0,#0
001128  11d600b8          LDRHNE   r0,[r6,#8]
00112c  11500005          CMPNE    r0,r5
001130  0a000003          BEQ      |L1.4420|
;;;1172       return 0xFFFF;
;;;1173     }
;;;1174     substr_len = strlen(substr);
001134  e1a00001          MOV      r0,r1
001138  ebfffffe          BL       strlen
;;;1175     if (substr_len >= 0xFFFF) {
00113c  e1550000          CMP      r5,r0
001140  8a000001          BHI      |L1.4428|
                  |L1.4420|
;;;1176       return 0xFFFF;
001144  e1a00005          MOV      r0,r5
;;;1177     }
;;;1178     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1179   }
001148  e8bd8070          POP      {r4-r6,pc}
                  |L1.4428|
00114c  e1a02800          LSL      r2,r0,#16             ;1178
001150  e1a01004          MOV      r1,r4                 ;1178
001154  e1a00006          MOV      r0,r6                 ;1178
001158  e8bd4070          POP      {r4-r6,lr}            ;1178
00115c  e1a02822          LSR      r2,r2,#16             ;1178
001160  e3a03000          MOV      r3,#0                 ;1178
001164  eafffffe          B        pbuf_memfind
                          ENDP

                  pbuf_pool_is_empty PROC
;;;151    static void
;;;152    pbuf_pool_is_empty(void)
001168  e92d4010          PUSH     {r4,lr}
;;;153    {
;;;154    #ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
;;;155      SYS_ARCH_DECL_PROTECT(old_level);
;;;156      SYS_ARCH_PROTECT(old_level);
00116c  ebfffffe          BL       sys_arch_protect
;;;157      pbuf_free_ooseq_pending = 1;
001170  e51f2f14          LDR      r2,|L1.612|
001174  e3a01001          MOV      r1,#1
001178  e5c21000          STRB     r1,[r2,#0]  ; pbuf_free_ooseq_pending
;;;158      SYS_ARCH_UNPROTECT(old_level);
00117c  e8bd4010          POP      {r4,lr}
001180  eafffffe          B        sys_arch_unprotect
;;;159    #else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;160      u8_t queued;
;;;161      SYS_ARCH_DECL_PROTECT(old_level);
;;;162      SYS_ARCH_PROTECT(old_level);
;;;163      queued = pbuf_free_ooseq_pending;
;;;164      pbuf_free_ooseq_pending = 1;
;;;165      SYS_ARCH_UNPROTECT(old_level);
;;;166    
;;;167      if(!queued) {
;;;168        /* queue a call to pbuf_free_ooseq if not already queued */
;;;169        PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
;;;170      }
;;;171    #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;172    }
;;;173    #endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  pbuf_free_ooseq_pending
000000  00                DCB      0x00
