; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\pbuf.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pbuf.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -D__UVISION_VERSION=524 --omf_browse=.\obj\pbuf.crf lwip-1.4.1\src\core\pbuf.c]
                          ARM

                          AREA ||i.pbuf_alloc||, CODE, READONLY, ALIGN=2

                  pbuf_alloc PROC
;;;206    struct pbuf *
;;;207    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;208    {
000004  e1a0b000          MOV      r11,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a09002          MOV      r9,r2
;;;209      struct pbuf *p, *q, *r;
;;;210      u16_t offset;
;;;211      s32_t rem_len; /* remaining length */
;;;212      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
;;;213    
;;;214      /* determine header offset */
;;;215      switch (layer) {
000010  e35b0000          CMP      r11,#0
000014  0a000006          BEQ      |L1.52|
000018  e35b0001          CMP      r11,#1
00001c  0a000007          BEQ      |L1.64|
000020  e35b0002          CMP      r11,#2
000024  0a000008          BEQ      |L1.76|
000028  e35b0003          CMP      r11,#3
00002c  1a00000c          BNE      |L1.100|
000030  ea000008          B        |L1.88|
                  |L1.52|
;;;216      case PBUF_TRANSPORT:
000034  e1a00000          MOV      r0,r0
;;;217        /* add room for transport (often TCP) layer header */
;;;218        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
000038  e3a06038          MOV      r6,#0x38
;;;219        break;
00003c  ea000014          B        |L1.148|
                  |L1.64|
;;;220      case PBUF_IP:
000040  e1a00000          MOV      r0,r0
;;;221        /* add room for IP layer header */
;;;222        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
000044  e3a06024          MOV      r6,#0x24
;;;223        break;
000048  ea000011          B        |L1.148|
                  |L1.76|
;;;224      case PBUF_LINK:
00004c  e1a00000          MOV      r0,r0
;;;225        /* add room for link layer header */
;;;226        offset = PBUF_LINK_HLEN;
000050  e3a06010          MOV      r6,#0x10
;;;227        break;
000054  ea00000e          B        |L1.148|
                  |L1.88|
;;;228      case PBUF_RAW:
000058  e1a00000          MOV      r0,r0
;;;229        offset = 0;
00005c  e3a06000          MOV      r6,#0
;;;230        break;
000060  ea00000b          B        |L1.148|
                  |L1.100|
;;;231      default:
000064  e1a00000          MOV      r0,r0
;;;232        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
000068  e1a00000          MOV      r0,r0
00006c  e1a00000          MOV      r0,r0
000070  e28f3f7f          ADR      r3,|L1.628|
000074  e3a020e8          MOV      r2,#0xe8
000078  e28f1e21          ADR      r1,|L1.656|
00007c  e28f0f8a          ADR      r0,|L1.684|
000080  ebfffffe          BL       sysprintf
000084  e1a00000          MOV      r0,r0
000088  e1a00000          MOV      r0,r0
;;;233        return NULL;
00008c  e3a00000          MOV      r0,#0
                  |L1.144|
;;;234      }
;;;235    
;;;236      switch (type) {
;;;237      case PBUF_POOL:
;;;238        /* allocate head of pbuf chain into p */
;;;239        p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;240        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
;;;241        if (p == NULL) {
;;;242          PBUF_POOL_IS_EMPTY();
;;;243          return NULL;
;;;244        }
;;;245        p->type = type;
;;;246        p->next = NULL;
;;;247    
;;;248        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;249        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;250        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;251                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;252        /* the total length of the pbuf chain is the requested size */
;;;253        p->tot_len = length;
;;;254        /* set the length of the first pbuf in the chain */
;;;255        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;256        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;257                    ((u8_t*)p->payload + p->len <=
;;;258                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;259        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;260          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;261        /* set reference count (needed here in case we fail) */
;;;262        p->ref = 1;
;;;263    
;;;264        /* now allocate the tail of the pbuf chain */
;;;265    
;;;266        /* remember first pbuf for linkage in next iteration */
;;;267        r = p;
;;;268        /* remaining length to be allocated */
;;;269        rem_len = length - p->len;
;;;270        /* any remaining pbufs to be allocated? */
;;;271        while (rem_len > 0) {
;;;272          q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;273          if (q == NULL) {
;;;274            PBUF_POOL_IS_EMPTY();
;;;275            /* free chain so far allocated */
;;;276            pbuf_free(p);
;;;277            /* bail out unsuccesfully */
;;;278            return NULL;
;;;279          }
;;;280          q->type = type;
;;;281          q->flags = 0;
;;;282          q->next = NULL;
;;;283          /* make previous pbuf point to this pbuf */
;;;284          r->next = q;
;;;285          /* set total length of this pbuf and next in chain */
;;;286          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;287          q->tot_len = (u16_t)rem_len;
;;;288          /* this pbuf length is pool size, unless smaller sized tail */
;;;289          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;290          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;291          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;292                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;293          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;294                      ((u8_t*)p->payload + p->len <=
;;;295                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;296          q->ref = 1;
;;;297          /* calculate remaining length to be allocated */
;;;298          rem_len -= q->len;
;;;299          /* remember this pbuf for linkage in next iteration */
;;;300          r = q;
;;;301        }
;;;302        /* end of chain */
;;;303        /*r->next = NULL;*/
;;;304    
;;;305        break;
;;;306      case PBUF_RAM:
;;;307        /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;308        p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;309        if (p == NULL) {
;;;310          return NULL;
;;;311        }
;;;312        /* Set up internal structure of the pbuf. */
;;;313        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;314        p->len = p->tot_len = length;
;;;315        p->next = NULL;
;;;316        p->type = type;
;;;317    
;;;318        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;319               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;320        break;
;;;321      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;322      case PBUF_ROM:
;;;323      /* pbuf references existing (externally allocated) RAM payload? */
;;;324      case PBUF_REF:
;;;325        /* only allocate memory for the pbuf structure */
;;;326        p = (struct pbuf *)memp_malloc(MEMP_PBUF);
;;;327        if (p == NULL) {
;;;328          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;329                      ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;330                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;331          return NULL;
;;;332        }
;;;333        /* caller must set this field properly, afterwards */
;;;334        p->payload = NULL;
;;;335        p->len = p->tot_len = length;
;;;336        p->next = NULL;
;;;337        p->type = type;
;;;338        break;
;;;339      default:
;;;340        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
;;;341        return NULL;
;;;342      }
;;;343      /* set reference count */
;;;344      p->ref = 1;
;;;345      /* set flags */
;;;346      p->flags = 0;
;;;347      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;348      return p;
;;;349    }
000090  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.148|
000094  e1a00000          MOV      r0,r0                 ;219
000098  e3590000          CMP      r9,#0                 ;236
00009c  0a0000e2          BEQ      |L1.1068|
0000a0  e3590001          CMP      r9,#1                 ;236
0000a4  0a000106          BEQ      |L1.1220|
0000a8  e3590002          CMP      r9,#2                 ;236
0000ac  0a000106          BEQ      |L1.1228|
0000b0  e3590003          CMP      r9,#3                 ;236
0000b4  1a000112          BNE      |L1.1284|
0000b8  e3a0000b          MOV      r0,#0xb               ;239
0000bc  ebfffffe          BL       memp_malloc
0000c0  e1a04000          MOV      r4,r0                 ;239
0000c4  e3540000          CMP      r4,#0                 ;241
0000c8  1a000002          BNE      |L1.216|
0000cc  ebfffffe          BL       pbuf_pool_is_empty
0000d0  e3a00000          MOV      r0,#0                 ;243
0000d4  eaffffed          B        |L1.144|
                  |L1.216|
0000d8  e5c4900c          STRB     r9,[r4,#0xc]          ;245
0000dc  e3a00000          MOV      r0,#0                 ;246
0000e0  e5840000          STR      r0,[r4,#0]            ;246
0000e4  e2860010          ADD      r0,r6,#0x10           ;249
0000e8  e0800004          ADD      r0,r0,r4              ;249
0000ec  e2800003          ADD      r0,r0,#3              ;249
0000f0  e3c00003          BIC      r0,r0,#3              ;249
0000f4  e5840004          STR      r0,[r4,#4]            ;249
0000f8  e1a00000          MOV      r0,r0                 ;250
0000fc  e5d40004          LDRB     r0,[r4,#4]            ;250
000100  e2000003          AND      r0,r0,#3              ;250
000104  e3500000          CMP      r0,#0                 ;250
000108  0a000006          BEQ      |L1.296|
00010c  e1a00000          MOV      r0,r0                 ;250
000110  e28f3f57          ADR      r3,|L1.628|
000114  e3a020fa          MOV      r2,#0xfa              ;250
000118  e28f1f6d          ADR      r1,|L1.724|
00011c  e28f0f62          ADR      r0,|L1.684|
000120  ebfffffe          BL       sysprintf
000124  e1a00000          MOV      r0,r0                 ;250
                  |L1.296|
000128  e1a00000          MOV      r0,r0                 ;250
00012c  e1c470b8          STRH     r7,[r4,#8]            ;253
000130  e2860003          ADD      r0,r6,#3              ;255
000134  e3c00003          BIC      r0,r0,#3              ;255
000138  e2600e25          RSB      r0,r0,#0x250          ;255
00013c  e1500007          CMP      r0,r7                 ;255
000140  da000001          BLE      |L1.332|
000144  e1a00007          MOV      r0,r7                 ;255
000148  ea000002          B        |L1.344|
                  |L1.332|
00014c  e2860003          ADD      r0,r6,#3              ;255
000150  e3c00003          BIC      r0,r0,#3              ;255
000154  e2600e25          RSB      r0,r0,#0x250          ;255
                  |L1.344|
000158  e1c400ba          STRH     r0,[r4,#0xa]          ;255
00015c  e1a00000          MOV      r0,r0                 ;256
000160  e5940004          LDR      r0,[r4,#4]            ;256
000164  e1d410ba          LDRH     r1,[r4,#0xa]          ;256
000168  e0800001          ADD      r0,r0,r1              ;256
00016c  e2841e26          ADD      r1,r4,#0x260          ;256
000170  e1500001          CMP      r0,r1                 ;256
000174  9a000006          BLS      |L1.404|
000178  e1a00000          MOV      r0,r0                 ;256
00017c  e28f30f0          ADR      r3,|L1.628|
000180  e3a02c01          MOV      r2,#0x100             ;256
000184  e28f1f5e          ADR      r1,|L1.772|
000188  e28f0f47          ADR      r0,|L1.684|
00018c  ebfffffe          BL       sysprintf
000190  e1a00000          MOV      r0,r0                 ;256
                  |L1.404|
000194  e1a00000          MOV      r0,r0                 ;256
000198  e1a00000          MOV      r0,r0                 ;259
00019c  e2860003          ADD      r0,r6,#3              ;259
0001a0  e3c00003          BIC      r0,r0,#3              ;259
0001a4  e2600e25          RSB      r0,r0,#0x250          ;259
0001a8  e3500000          CMP      r0,#0                 ;259
0001ac  ca000006          BGT      |L1.460|
0001b0  e1a00000          MOV      r0,r0                 ;259
0001b4  e28f30b8          ADR      r3,|L1.628|
0001b8  e59f2178          LDR      r2,|L1.824|
0001bc  e28f1f5e          ADR      r1,|L1.828|
0001c0  e28f00e4          ADR      r0,|L1.684|
0001c4  ebfffffe          BL       sysprintf
0001c8  e1a00000          MOV      r0,r0                 ;259
                  |L1.460|
0001cc  e1a00000          MOV      r0,r0                 ;259
0001d0  e3a00001          MOV      r0,#1                 ;262
0001d4  e1c400be          STRH     r0,[r4,#0xe]          ;262
0001d8  e1a0a004          MOV      r10,r4                ;267
0001dc  e1d400ba          LDRH     r0,[r4,#0xa]          ;269
0001e0  e0478000          SUB      r8,r7,r0              ;269
0001e4  ea00008d          B        |L1.1056|
                  |L1.488|
0001e8  e3a0000b          MOV      r0,#0xb               ;272
0001ec  ebfffffe          BL       memp_malloc
0001f0  e1a05000          MOV      r5,r0                 ;272
0001f4  e3550000          CMP      r5,#0                 ;273
0001f8  1a000004          BNE      |L1.528|
0001fc  ebfffffe          BL       pbuf_pool_is_empty
000200  e1a00004          MOV      r0,r4                 ;276
000204  ebfffffe          BL       pbuf_free
000208  e3a00000          MOV      r0,#0                 ;278
00020c  eaffff9f          B        |L1.144|
                  |L1.528|
000210  e5c5900c          STRB     r9,[r5,#0xc]          ;280
000214  e3a00000          MOV      r0,#0                 ;281
000218  e5c5000d          STRB     r0,[r5,#0xd]          ;281
00021c  e5850000          STR      r0,[r5,#0]            ;282
000220  e58a5000          STR      r5,[r10,#0]           ;284
000224  e1a00000          MOV      r0,r0                 ;286
000228  e59f0140          LDR      r0,|L1.880|
00022c  e1580000          CMP      r8,r0                 ;286
000230  ba000006          BLT      |L1.592|
000234  e1a00000          MOV      r0,r0                 ;286
000238  e28f3034          ADR      r3,|L1.628|
00023c  e59f2130          LDR      r2,|L1.884|
000240  e28f1f4c          ADD      r1,pc,#0x4c, 30 ; #0x130;286
000244  e28f0060          ADR      r0,|L1.684|
000248  ebfffffe          BL       sysprintf
00024c  e1a00000          MOV      r0,r0                 ;286
                  |L1.592|
000250  e1a00000          MOV      r0,r0                 ;286
000254  e1c580b8          STRH     r8,[r5,#8]            ;287
000258  e1a00808          LSL      r0,r8,#16             ;289
00025c  e1a00820          LSR      r0,r0,#16             ;289
000260  e3500e25          CMP      r0,#0x250             ;289
000264  aa000048          BGE      |L1.908|
000268  e1a00808          LSL      r0,r8,#16             ;289
00026c  e1a00820          LSR      r0,r0,#16             ;289
000270  ea000046          B        |L1.912|
                  |L1.628|
000274  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
000278  2d312e34
00027c  2e315c73
000280  72635c63
000284  6f72655c
000288  70627566
00028c  2e6300  
00028f  00                DCB      0
                  |L1.656|
000290  70627566          DCB      "pbuf_alloc: bad pbuf layer",0
000294  5f616c6c
000298  6f633a20
00029c  62616420
0002a0  70627566
0002a4  206c6179
0002a8  657200  
0002ab  00                DCB      0
                  |L1.684|
0002ac  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0002b0  7274696f
0002b4  6e202225
0002b8  73222066
0002bc  61696c65
0002c0  64206174
0002c4  206c696e
0002c8  65202564
0002cc  20696e20
0002d0  25730a00
                  |L1.724|
0002d4  70627566          DCB      "pbuf_alloc: pbuf p->payload properly aligned",0
0002d8  5f616c6c
0002dc  6f633a20
0002e0  70627566
0002e4  20702d3e
0002e8  7061796c
0002ec  6f616420
0002f0  70726f70
0002f4  65726c79
0002f8  20616c69
0002fc  676e6564
000300  00      
000301  00                DCB      0
000302  00                DCB      0
000303  00                DCB      0
                  |L1.772|
000304  63686563          DCB      "check p->payload + p->len does not overflow pbuf",0
000308  6b20702d
00030c  3e706179
000310  6c6f6164
000314  202b2070
000318  2d3e6c65
00031c  6e20646f
000320  6573206e
000324  6f74206f
000328  76657266
00032c  6c6f7720
000330  70627566
000334  00      
000335  00                DCB      0
000336  00                DCB      0
000337  00                DCB      0
                  |L1.824|
                          DCD      0x00000103
                  |L1.828|
00033c  50425546          DCB      "PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",0
000340  5f504f4f
000344  4c5f4255
000348  4653495a
00034c  45206d75
000350  73742062
000354  65206269
000358  67676572
00035c  20746861
000360  6e204d45
000364  4d5f414c
000368  49474e4d
00036c  454e5400
                  |L1.880|
                          DCD      0x0000ffff
                  |L1.884|
                          DCD      0x0000011e
000378  72656d5f          DCB      "rem_len < max_u16_t",0
00037c  6c656e20
000380  3c206d61
000384  785f7531
000388  365f7400
                  |L1.908|
00038c  e3a00e25          MOV      r0,#0x250             ;289
                  |L1.912|
000390  e1c500ba          STRH     r0,[r5,#0xa]          ;289
000394  e2850010          ADD      r0,r5,#0x10           ;290
000398  e5850004          STR      r0,[r5,#4]            ;290
00039c  e1a00000          MOV      r0,r0                 ;291
0003a0  e5d50004          LDRB     r0,[r5,#4]            ;291
0003a4  e2000003          AND      r0,r0,#3              ;291
0003a8  e3500000          CMP      r0,#0                 ;291
0003ac  0a000006          BEQ      |L1.972|
0003b0  e1a00000          MOV      r0,r0                 ;291
0003b4  e24f3f52          ADR      r3,|L1.628|
0003b8  e59f2190          LDR      r2,|L1.1360|
0003bc  e28f1e19          ADR      r1,|L1.1364|
0003c0  e24f0f47          ADR      r0,|L1.684|
0003c4  ebfffffe          BL       sysprintf
0003c8  e1a00000          MOV      r0,r0                 ;291
                  |L1.972|
0003cc  e1a00000          MOV      r0,r0                 ;291
0003d0  e1a00000          MOV      r0,r0                 ;293
0003d4  e5940004          LDR      r0,[r4,#4]            ;293
0003d8  e1d410ba          LDRH     r1,[r4,#0xa]          ;293
0003dc  e0800001          ADD      r0,r0,r1              ;293
0003e0  e2841e26          ADD      r1,r4,#0x260          ;293
0003e4  e1500001          CMP      r0,r1                 ;293
0003e8  9a000006          BLS      |L1.1032|
0003ec  e1a00000          MOV      r0,r0                 ;293
0003f0  e24f3f61          ADR      r3,|L1.628|
0003f4  e59f2188          LDR      r2,|L1.1412|
0003f8  e24f10fc          ADR      r1,|L1.772|
0003fc  e24f0f56          ADR      r0,|L1.684|
000400  ebfffffe          BL       sysprintf
000404  e1a00000          MOV      r0,r0                 ;293
                  |L1.1032|
000408  e1a00000          MOV      r0,r0                 ;293
00040c  e3a00001          MOV      r0,#1                 ;296
000410  e1c500be          STRH     r0,[r5,#0xe]          ;296
000414  e1d500ba          LDRH     r0,[r5,#0xa]          ;298
000418  e0488000          SUB      r8,r8,r0              ;298
00041c  e1a0a005          MOV      r10,r5                ;300
                  |L1.1056|
000420  e3580000          CMP      r8,#0                 ;271
000424  caffff6f          BGT      |L1.488|
000428  ea000041          B        |L1.1332|
                  |L1.1068|
00042c  e1a00000          MOV      r0,r0                 ;306
000430  e2861013          ADD      r1,r6,#0x13           ;308
000434  e3c11003          BIC      r1,r1,#3              ;308
000438  e2872003          ADD      r2,r7,#3              ;308
00043c  e3c22003          BIC      r2,r2,#3              ;308
000440  e0811002          ADD      r1,r1,r2              ;308
000444  e1a00801          LSL      r0,r1,#16             ;308
000448  e1a00820          LSR      r0,r0,#16             ;308
00044c  ebfffffe          BL       mem_malloc
000450  e1a04000          MOV      r4,r0                 ;308
000454  e3540000          CMP      r4,#0                 ;309
000458  1a000001          BNE      |L1.1124|
00045c  e3a00000          MOV      r0,#0                 ;310
000460  eaffff0a          B        |L1.144|
                  |L1.1124|
000464  e2840010          ADD      r0,r4,#0x10           ;313
000468  e0800006          ADD      r0,r0,r6              ;313
00046c  e2800003          ADD      r0,r0,#3              ;313
000470  e3c00003          BIC      r0,r0,#3              ;313
000474  e5840004          STR      r0,[r4,#4]            ;313
000478  e1c470b8          STRH     r7,[r4,#8]            ;314
00047c  e1c470ba          STRH     r7,[r4,#0xa]          ;314
000480  e3a00000          MOV      r0,#0                 ;315
000484  e5840000          STR      r0,[r4,#0]            ;315
000488  e5c4900c          STRB     r9,[r4,#0xc]          ;316
00048c  e1a00000          MOV      r0,r0                 ;318
000490  e5d40004          LDRB     r0,[r4,#4]            ;318
000494  e2000003          AND      r0,r0,#3              ;318
000498  e3500000          CMP      r0,#0                 ;318
00049c  0a000006          BEQ      |L1.1212|
0004a0  e1a00000          MOV      r0,r0                 ;318
0004a4  e24f3f8e          ADR      r3,|L1.628|
0004a8  e59f20d8          LDR      r2,|L1.1416|
0004ac  e28f10d8          ADR      r1,|L1.1420|
0004b0  e24f0f83          ADR      r0,|L1.684|
0004b4  ebfffffe          BL       sysprintf
0004b8  e1a00000          MOV      r0,r0                 ;318
                  |L1.1212|
0004bc  e1a00000          MOV      r0,r0                 ;318
0004c0  ea00001b          B        |L1.1332|
                  |L1.1220|
0004c4  e1a00000          MOV      r0,r0                 ;322
0004c8  e1a00000          MOV      r0,r0                 ;324
                  |L1.1228|
0004cc  e3a0000a          MOV      r0,#0xa               ;326
0004d0  ebfffffe          BL       memp_malloc
0004d4  e1a04000          MOV      r4,r0                 ;326
0004d8  e3540000          CMP      r4,#0                 ;327
0004dc  1a000001          BNE      |L1.1256|
0004e0  e3a00000          MOV      r0,#0                 ;331
0004e4  eafffee9          B        |L1.144|
                  |L1.1256|
0004e8  e3a00000          MOV      r0,#0                 ;334
0004ec  e5840004          STR      r0,[r4,#4]            ;334
0004f0  e1c470b8          STRH     r7,[r4,#8]            ;335
0004f4  e1c470ba          STRH     r7,[r4,#0xa]          ;335
0004f8  e5840000          STR      r0,[r4,#0]            ;336
0004fc  e5c4900c          STRB     r9,[r4,#0xc]          ;337
000500  ea00000b          B        |L1.1332|
                  |L1.1284|
000504  e1a00000          MOV      r0,r0                 ;339
000508  e1a00000          MOV      r0,r0                 ;340
00050c  e1a00000          MOV      r0,r0                 ;340
000510  e24f3fa9          ADR      r3,|L1.628|
000514  e3a02f55          MOV      r2,#0x154             ;340
000518  e28f1098          ADR      r1,|L1.1464|
00051c  e24f0f9e          ADR      r0,|L1.684|
000520  ebfffffe          BL       sysprintf
000524  e1a00000          MOV      r0,r0                 ;340
000528  e1a00000          MOV      r0,r0                 ;340
00052c  e3a00000          MOV      r0,#0                 ;341
000530  eafffed6          B        |L1.144|
                  |L1.1332|
000534  e1a00000          MOV      r0,r0                 ;305
000538  e3a00001          MOV      r0,#1                 ;344
00053c  e1c400be          STRH     r0,[r4,#0xe]          ;344
000540  e3a00000          MOV      r0,#0                 ;346
000544  e5c4000d          STRB     r0,[r4,#0xd]          ;346
000548  e1a00004          MOV      r0,r4                 ;348
00054c  eafffecf          B        |L1.144|
;;;350    
                          ENDP

                  |L1.1360|
                          DCD      0x00000123
                  |L1.1364|
000554  70627566          DCB      "pbuf_alloc: pbuf q->payload properly aligned",0
000558  5f616c6c
00055c  6f633a20
000560  70627566
000564  20712d3e
000568  7061796c
00056c  6f616420
000570  70726f70
000574  65726c79
000578  20616c69
00057c  676e6564
000580  00      
000581  00                DCB      0
000582  00                DCB      0
000583  00                DCB      0
                  |L1.1412|
                          DCD      0x00000125
                  |L1.1416|
                          DCD      0x0000013e
                  |L1.1420|
00058c  70627566          DCB      "pbuf_alloc: pbuf->payload properly aligned",0
000590  5f616c6c
000594  6f633a20
000598  70627566
00059c  2d3e7061
0005a0  796c6f61
0005a4  64207072
0005a8  6f706572
0005ac  6c792061
0005b0  6c69676e
0005b4  656400  
0005b7  00                DCB      0
                  |L1.1464|
0005b8  70627566          DCB      "pbuf_alloc: erroneous type",0
0005bc  5f616c6c
0005c0  6f633a20
0005c4  6572726f
0005c8  6e656f75
0005cc  73207479
0005d0  706500  
0005d3  00                DCB      0

                          AREA ||i.pbuf_cat||, CODE, READONLY, ALIGN=2

                  pbuf_cat PROC
;;;744    void
;;;745    pbuf_cat(struct pbuf *h, struct pbuf *t)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;746    {
000004  e1a06000          MOV      r6,r0
000008  e1a05001          MOV      r5,r1
;;;747      struct pbuf *p;
;;;748    
;;;749      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
00000c  e1a00000          MOV      r0,r0
000010  e3560000          CMP      r6,#0
000014  0a000001          BEQ      |L2.32|
000018  e3550000          CMP      r5,#0
00001c  1a000007          BNE      |L2.64|
                  |L2.32|
000020  e1a00000          MOV      r0,r0
000024  e28f30c8          ADR      r3,|L2.244|
000028  e59f20e0          LDR      r2,|L2.272|
00002c  e28f10e0          ADR      r1,|L2.276|
000030  e28f0f45          ADR      r0,|L2.332|
000034  ebfffffe          BL       sysprintf
000038  e1a00000          MOV      r0,r0
                  |L2.60|
;;;750                 ((h != NULL) && (t != NULL)), return;);
;;;751    
;;;752      /* proceed to last pbuf of chain */
;;;753      for (p = h; p->next != NULL; p = p->next) {
;;;754        /* add total length of second chain to all totals of first chain */
;;;755        p->tot_len += t->tot_len;
;;;756      }
;;;757      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;758      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
;;;759      LWIP_ASSERT("p->next == NULL", p->next == NULL);
;;;760      /* add total length of second chain to last pbuf total of first chain */
;;;761      p->tot_len += t->tot_len;
;;;762      /* chain last pbuf of head (p) with first of tail (t) */
;;;763      p->next = t;
;;;764      /* p->next now references t, but the caller will drop its reference to t,
;;;765       * so netto there is no change to the reference count of t.
;;;766       */
;;;767    }
00003c  e8bd8070          POP      {r4-r6,pc}
                  |L2.64|
000040  e1a00000          MOV      r0,r0                 ;749
000044  e1a04006          MOV      r4,r6                 ;753
000048  ea000005          B        |L2.100|
                  |L2.76|
00004c  e1d400b8          LDRH     r0,[r4,#8]            ;755
000050  e1d510b8          LDRH     r1,[r5,#8]            ;755
000054  e0800001          ADD      r0,r0,r1              ;755
000058  e3c00801          BIC      r0,r0,#0x10000        ;755
00005c  e1c400b8          STRH     r0,[r4,#8]            ;755
000060  e5944000          LDR      r4,[r4,#0]            ;753
                  |L2.100|
000064  e5940000          LDR      r0,[r4,#0]            ;753
000068  e3500000          CMP      r0,#0                 ;753
00006c  1afffff6          BNE      |L2.76|
000070  e1a00000          MOV      r0,r0                 ;758
000074  e1d400b8          LDRH     r0,[r4,#8]            ;758
000078  e1d410ba          LDRH     r1,[r4,#0xa]          ;758
00007c  e1500001          CMP      r0,r1                 ;758
000080  0a000006          BEQ      |L2.160|
000084  e1a00000          MOV      r0,r0                 ;758
000088  e28f3064          ADR      r3,|L2.244|
00008c  e59f20e0          LDR      r2,|L2.372|
000090  e28f10e0          ADR      r1,|L2.376|
000094  e28f00b0          ADR      r0,|L2.332|
000098  ebfffffe          BL       sysprintf
00009c  e1a00000          MOV      r0,r0                 ;758
                  |L2.160|
0000a0  e1a00000          MOV      r0,r0                 ;758
0000a4  e1a00000          MOV      r0,r0                 ;759
0000a8  e5940000          LDR      r0,[r4,#0]            ;759
0000ac  e3500000          CMP      r0,#0                 ;759
0000b0  0a000006          BEQ      |L2.208|
0000b4  e1a00000          MOV      r0,r0                 ;759
0000b8  e28f3034          ADR      r3,|L2.244|
0000bc  e59f20e4          LDR      r2,|L2.424|
0000c0  e28f10e4          ADR      r1,|L2.428|
0000c4  e28f0080          ADR      r0,|L2.332|
0000c8  ebfffffe          BL       sysprintf
0000cc  e1a00000          MOV      r0,r0                 ;759
                  |L2.208|
0000d0  e1a00000          MOV      r0,r0                 ;759
0000d4  e1d400b8          LDRH     r0,[r4,#8]            ;761
0000d8  e1d510b8          LDRH     r1,[r5,#8]            ;761
0000dc  e0800001          ADD      r0,r0,r1              ;761
0000e0  e3c00801          BIC      r0,r0,#0x10000        ;761
0000e4  e1c400b8          STRH     r0,[r4,#8]            ;761
0000e8  e5845000          STR      r5,[r4,#0]            ;763
0000ec  e1a00000          MOV      r0,r0
0000f0  eaffffd1          B        |L2.60|
;;;768    
                          ENDP

                  |L2.244|
0000f4  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
0000f8  2d312e34
0000fc  2e315c73
000100  72635c63
000104  6f72655c
000108  70627566
00010c  2e6300  
00010f  00                DCB      0
                  |L2.272|
                          DCD      0x000002ed
                  |L2.276|
000114  28682021          DCB      "(h != NULL) && (t != NULL) (programmer violates API)",0
000118  3d204e55
00011c  4c4c2920
000120  26262028
000124  7420213d
000128  204e554c
00012c  4c292028
000130  70726f67
000134  72616d6d
000138  65722076
00013c  696f6c61
000140  74657320
000144  41504929
000148  00      
000149  00                DCB      0
00014a  00                DCB      0
00014b  00                DCB      0
                  |L2.332|
00014c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000150  7274696f
000154  6e202225
000158  73222066
00015c  61696c65
000160  64206174
000164  206c696e
000168  65202564
00016c  20696e20
000170  25730a00
                  |L2.372|
                          DCD      0x000002f6
                  |L2.376|
000178  702d3e74          DCB      "p->tot_len == p->len (of last pbuf in chain)",0
00017c  6f745f6c
000180  656e203d
000184  3d20702d
000188  3e6c656e
00018c  20286f66
000190  206c6173
000194  74207062
000198  75662069
00019c  6e206368
0001a0  61696e29
0001a4  00      
0001a5  00                DCB      0
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L2.424|
                          DCD      0x000002f7
                  |L2.428|
0001ac  702d3e6e          DCB      "p->next == NULL",0
0001b0  65787420
0001b4  3d3d204e
0001b8  554c4c00

                          AREA ||i.pbuf_chain||, CODE, READONLY, ALIGN=2

                  pbuf_chain PROC
;;;785    void
;;;786    pbuf_chain(struct pbuf *h, struct pbuf *t)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;787    {
000004  e1a05000          MOV      r5,r0
000008  e1a04001          MOV      r4,r1
;;;788      pbuf_cat(h, t);
00000c  e1a01004          MOV      r1,r4
000010  e1a00005          MOV      r0,r5
000014  ebfffffe          BL       pbuf_cat
;;;789      /* t is now referenced by h */
;;;790      pbuf_ref(t);
000018  e1a00004          MOV      r0,r4
00001c  ebfffffe          BL       pbuf_ref
;;;791      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
;;;792    }
000020  e8bd8070          POP      {r4-r6,pc}
;;;793    
                          ENDP


                          AREA ||i.pbuf_clen||, CODE, READONLY, ALIGN=2

                  pbuf_clen PROC
;;;703    u8_t
;;;704    pbuf_clen(struct pbuf *p)
000000  e1a01000          MOV      r1,r0
;;;705    {
;;;706      u8_t len;
;;;707    
;;;708      len = 0;
000004  e3a00000          MOV      r0,#0
;;;709      while (p != NULL) {
000008  ea000002          B        |L4.24|
                  |L4.12|
;;;710        ++len;
00000c  e2802001          ADD      r2,r0,#1
000010  e20200ff          AND      r0,r2,#0xff
;;;711        p = p->next;
000014  e5911000          LDR      r1,[r1,#0]
                  |L4.24|
000018  e3510000          CMP      r1,#0                 ;709
00001c  1afffffa          BNE      |L4.12|
;;;712      }
;;;713      return len;
;;;714    }
000020  e12fff1e          BX       lr
;;;715    
                          ENDP


                          AREA ||i.pbuf_coalesce||, CODE, READONLY, ALIGN=2

                  pbuf_coalesce PROC
;;;1009   struct pbuf*
;;;1010   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1011   {
000004  e1a04000          MOV      r4,r0
000008  e1a07001          MOV      r7,r1
;;;1012     struct pbuf *q;
;;;1013     err_t err;
;;;1014     if (p->next == NULL) {
00000c  e5940000          LDR      r0,[r4,#0]
000010  e3500000          CMP      r0,#0
000014  1a000001          BNE      |L5.32|
;;;1015       return p;
000018  e1a00004          MOV      r0,r4
                  |L5.28|
;;;1016     }
;;;1017     q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
;;;1018     if (q == NULL) {
;;;1019       /* @todo: what do we do now? */
;;;1020       return p;
;;;1021     }
;;;1022     err = pbuf_copy(q, p);
;;;1023     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
;;;1024     pbuf_free(p);
;;;1025     return q;
;;;1026   }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L5.32|
000020  e1d410b8          LDRH     r1,[r4,#8]            ;1017
000024  e3a02000          MOV      r2,#0                 ;1017
000028  e1a00007          MOV      r0,r7                 ;1017
00002c  ebfffffe          BL       pbuf_alloc
000030  e1a05000          MOV      r5,r0                 ;1017
000034  e3550000          CMP      r5,#0                 ;1018
000038  1a000001          BNE      |L5.68|
00003c  e1a00004          MOV      r0,r4                 ;1020
000040  eafffff5          B        |L5.28|
                  |L5.68|
000044  e1a01004          MOV      r1,r4                 ;1022
000048  e1a00005          MOV      r0,r5                 ;1022
00004c  ebfffffe          BL       pbuf_copy
000050  e1a06000          MOV      r6,r0                 ;1022
000054  e1a00000          MOV      r0,r0                 ;1023
000058  e3560000          CMP      r6,#0                 ;1023
00005c  0a000006          BEQ      |L5.124|
000060  e1a00000          MOV      r0,r0                 ;1023
000064  e28f3024          ADR      r3,|L5.144|
000068  e59f203c          LDR      r2,|L5.172|
00006c  e28f103c          ADR      r1,|L5.176|
000070  e28f004c          ADR      r0,|L5.196|
000074  ebfffffe          BL       sysprintf
000078  e1a00000          MOV      r0,r0                 ;1023
                  |L5.124|
00007c  e1a00000          MOV      r0,r0                 ;1023
000080  e1a00004          MOV      r0,r4                 ;1024
000084  ebfffffe          BL       pbuf_free
000088  e1a00005          MOV      r0,r5                 ;1025
00008c  eaffffe2          B        |L5.28|
;;;1027   
                          ENDP

                  |L5.144|
000090  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
000094  2d312e34
000098  2e315c73
00009c  72635c63
0000a0  6f72655c
0000a4  70627566
0000a8  2e6300  
0000ab  00                DCB      0
                  |L5.172|
                          DCD      0x000003ff
                  |L5.176|
0000b0  70627566          DCB      "pbuf_copy failed",0
0000b4  5f636f70
0000b8  79206661
0000bc  696c6564
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L5.196|
0000c4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000c8  7274696f
0000cc  6e202225
0000d0  73222066
0000d4  61696c65
0000d8  64206174
0000dc  206c696e
0000e0  65202564
0000e4  20696e20
0000e8  25730a00

                          AREA ||i.pbuf_copy||, CODE, READONLY, ALIGN=2

                  pbuf_copy PROC
;;;851    err_t
;;;852    pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;853    {
000004  e1a05000          MOV      r5,r0
000008  e1a04001          MOV      r4,r1
;;;854      u16_t offset_to=0, offset_from=0, len;
00000c  e3a06000          MOV      r6,#0
000010  e3a07000          MOV      r7,#0
;;;855    
;;;856      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
;;;857        (void*)p_to, (void*)p_from));
;;;858    
;;;859      /* is the target big enough to hold the source? */
;;;860      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
000014  e1a00000          MOV      r0,r0
000018  e3550000          CMP      r5,#0
00001c  0a000005          BEQ      |L6.56|
000020  e3540000          CMP      r4,#0
000024  0a000003          BEQ      |L6.56|
000028  e1d500b8          LDRH     r0,[r5,#8]
00002c  e1d410b8          LDRH     r1,[r4,#8]
000030  e1500001          CMP      r0,r1
000034  aa000008          BGE      |L6.92|
                  |L6.56|
000038  e1a00000          MOV      r0,r0
00003c  e28f3c02          ADR      r3,|L6.580|
000040  e3a02fd7          MOV      r2,#0x35c
000044  e28f1f85          ADR      r1,|L6.608|
000048  e28f0d09          ADR      r0,|L6.656|
00004c  ebfffffe          BL       sysprintf
000050  e1a00000          MOV      r0,r0
000054  e3e0000d          MVN      r0,#0xd
                  |L6.88|
;;;861                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;862    
;;;863      /* iterate through pbuf chain */
;;;864      do
;;;865      {
;;;866        /* copy one part of the original chain */
;;;867        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;868          /* complete current p_from fits into current p_to */
;;;869          len = p_from->len - offset_from;
;;;870        } else {
;;;871          /* current p_from does not fit into current p_to */
;;;872          len = p_to->len - offset_to;
;;;873        }
;;;874        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;875        offset_to += len;
;;;876        offset_from += len;
;;;877        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;878        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;879        if (offset_from >= p_from->len) {
;;;880          /* on to next p_from (if any) */
;;;881          offset_from = 0;
;;;882          p_from = p_from->next;
;;;883        }
;;;884        if (offset_to == p_to->len) {
;;;885          /* on to next p_to (if any) */
;;;886          offset_to = 0;
;;;887          p_to = p_to->next;
;;;888          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
;;;889        }
;;;890    
;;;891        if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;892          /* don't copy more than one packet! */
;;;893          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;894                     (p_from->next == NULL), return ERR_VAL;);
;;;895        }
;;;896        if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;897          /* don't copy more than one packet! */
;;;898          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;899                      (p_to->next == NULL), return ERR_VAL;);
;;;900        }
;;;901      } while (p_from);
;;;902      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;903      return ERR_OK;
;;;904    }
000058  e8bd81f0          POP      {r4-r8,pc}
                  |L6.92|
00005c  e1a00000          MOV      r0,r0                 ;860
000060  e1a00000          MOV      r0,r0                 ;864
                  |L6.100|
000064  e1d500ba          LDRH     r0,[r5,#0xa]          ;867
000068  e0400006          SUB      r0,r0,r6              ;867
00006c  e1d410ba          LDRH     r1,[r4,#0xa]          ;867
000070  e0411007          SUB      r1,r1,r7              ;867
000074  e1500001          CMP      r0,r1                 ;867
000078  ba000004          BLT      |L6.144|
00007c  e1d400ba          LDRH     r0,[r4,#0xa]          ;869
000080  e0400007          SUB      r0,r0,r7              ;869
000084  e1a08800          LSL      r8,r0,#16             ;869
000088  e1a08828          LSR      r8,r8,#16             ;869
00008c  ea000003          B        |L6.160|
                  |L6.144|
000090  e1d500ba          LDRH     r0,[r5,#0xa]          ;872
000094  e0400006          SUB      r0,r0,r6              ;872
000098  e1a08800          LSL      r8,r0,#16             ;872
00009c  e1a08828          LSR      r8,r8,#16             ;872
                  |L6.160|
0000a0  e5942004          LDR      r2,[r4,#4]            ;874
0000a4  e0821007          ADD      r1,r2,r7              ;874
0000a8  e5952004          LDR      r2,[r5,#4]            ;874
0000ac  e0820006          ADD      r0,r2,r6              ;874
0000b0  e1a02008          MOV      r2,r8                 ;874
0000b4  ebfffffe          BL       __aeabi_memcpy
0000b8  e0860008          ADD      r0,r6,r8              ;875
0000bc  e1a06800          LSL      r6,r0,#16             ;875
0000c0  e1a06826          LSR      r6,r6,#16             ;875
0000c4  e0870008          ADD      r0,r7,r8              ;876
0000c8  e1a07800          LSL      r7,r0,#16             ;876
0000cc  e1a07827          LSR      r7,r7,#16             ;876
0000d0  e1a00000          MOV      r0,r0                 ;877
0000d4  e1d500ba          LDRH     r0,[r5,#0xa]          ;877
0000d8  e1500006          CMP      r0,r6                 ;877
0000dc  aa000006          BGE      |L6.252|
0000e0  e1a00000          MOV      r0,r0                 ;877
0000e4  e28f3f56          ADR      r3,|L6.580|
0000e8  e59f21c8          LDR      r2,|L6.696|
0000ec  e28f1f72          ADR      r1,|L6.700|
0000f0  e28f0f66          ADR      r0,|L6.656|
0000f4  ebfffffe          BL       sysprintf
0000f8  e1a00000          MOV      r0,r0                 ;877
                  |L6.252|
0000fc  e1a00000          MOV      r0,r0                 ;877
000100  e1a00000          MOV      r0,r0                 ;878
000104  e1d400ba          LDRH     r0,[r4,#0xa]          ;878
000108  e1500007          CMP      r0,r7                 ;878
00010c  aa000006          BGE      |L6.300|
000110  e1a00000          MOV      r0,r0                 ;878
000114  e28f3f4a          ADR      r3,|L6.580|
000118  e59f21b4          LDR      r2,|L6.724|
00011c  e28f1f6d          ADR      r1,|L6.728|
000120  e28f0f5a          ADR      r0,|L6.656|
000124  ebfffffe          BL       sysprintf
000128  e1a00000          MOV      r0,r0                 ;878
                  |L6.300|
00012c  e1a00000          MOV      r0,r0                 ;878
000130  e1d400ba          LDRH     r0,[r4,#0xa]          ;879
000134  e1500007          CMP      r0,r7                 ;879
000138  ca000001          BGT      |L6.324|
00013c  e3a07000          MOV      r7,#0                 ;881
000140  e5944000          LDR      r4,[r4,#0]            ;882
                  |L6.324|
000144  e1d500ba          LDRH     r0,[r5,#0xa]          ;884
000148  e1500006          CMP      r0,r6                 ;884
00014c  1a000010          BNE      |L6.404|
000150  e3a06000          MOV      r6,#0                 ;886
000154  e5955000          LDR      r5,[r5,#0]            ;887
000158  e1a00000          MOV      r0,r0                 ;888
00015c  e3550000          CMP      r5,#0                 ;888
000160  1a00000a          BNE      |L6.400|
000164  e3540000          CMP      r4,#0                 ;888
000168  0a000008          BEQ      |L6.400|
00016c  e1a00000          MOV      r0,r0                 ;888
000170  e28f30cc          ADR      r3,|L6.580|
000174  e3a02fde          MOV      r2,#0x378             ;888
000178  e28f1f5d          ADR      r1,|L6.756|
00017c  e28f0f43          ADR      r0,|L6.656|
000180  ebfffffe          BL       sysprintf
000184  e1a00000          MOV      r0,r0                 ;888
000188  e3e0000d          MVN      r0,#0xd               ;888
00018c  eaffffb1          B        |L6.88|
                  |L6.400|
000190  e1a00000          MOV      r0,r0                 ;888
                  |L6.404|
000194  e3540000          CMP      r4,#0                 ;891
000198  0a000011          BEQ      |L6.484|
00019c  e1d400ba          LDRH     r0,[r4,#0xa]          ;891
0001a0  e1d410b8          LDRH     r1,[r4,#8]            ;891
0001a4  e1500001          CMP      r0,r1                 ;891
0001a8  1a00000d          BNE      |L6.484|
0001ac  e1a00000          MOV      r0,r0                 ;893
0001b0  e5940000          LDR      r0,[r4,#0]            ;893
0001b4  e3500000          CMP      r0,#0                 ;893
0001b8  0a000008          BEQ      |L6.480|
0001bc  e1a00000          MOV      r0,r0                 ;893
0001c0  e28f307c          ADR      r3,|L6.580|
0001c4  e59f2138          LDR      r2,|L6.772|
0001c8  e28f1f4e          ADR      r1,|L6.776|
0001cc  e28f00bc          ADR      r0,|L6.656|
0001d0  ebfffffe          BL       sysprintf
0001d4  e1a00000          MOV      r0,r0                 ;893
0001d8  e3e00005          MVN      r0,#5                 ;893
0001dc  eaffff9d          B        |L6.88|
                  |L6.480|
0001e0  e1a00000          MOV      r0,r0                 ;893
                  |L6.484|
0001e4  e3550000          CMP      r5,#0                 ;896
0001e8  0a000011          BEQ      |L6.564|
0001ec  e1d500ba          LDRH     r0,[r5,#0xa]          ;896
0001f0  e1d510b8          LDRH     r1,[r5,#8]            ;896
0001f4  e1500001          CMP      r0,r1                 ;896
0001f8  1a00000d          BNE      |L6.564|
0001fc  e1a00000          MOV      r0,r0                 ;898
000200  e5950000          LDR      r0,[r5,#0]            ;898
000204  e3500000          CMP      r0,#0                 ;898
000208  0a000008          BEQ      |L6.560|
00020c  e1a00000          MOV      r0,r0                 ;898
000210  e28f302c          ADR      r3,|L6.580|
000214  e59f2118          LDR      r2,|L6.820|
000218  e28f10e8          ADR      r1,|L6.776|
00021c  e28f006c          ADR      r0,|L6.656|
000220  ebfffffe          BL       sysprintf
000224  e1a00000          MOV      r0,r0                 ;898
000228  e3e00005          MVN      r0,#5                 ;898
00022c  eaffff89          B        |L6.88|
                  |L6.560|
000230  e1a00000          MOV      r0,r0                 ;898
                  |L6.564|
000234  e3540000          CMP      r4,#0                 ;901
000238  1affff89          BNE      |L6.100|
00023c  e3a00000          MOV      r0,#0                 ;903
000240  eaffff84          B        |L6.88|
                  |L6.580|
000244  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
000248  2d312e34
00024c  2e315c73
000250  72635c63
000254  6f72655c
000258  70627566
00025c  2e6300  
00025f  00                DCB      0
                  |L6.608|
000260  70627566          DCB      "pbuf_copy: target not big enough to hold source",0
000264  5f636f70
000268  793a2074
00026c  61726765
000270  74206e6f
000274  74206269
000278  6720656e
00027c  6f756768
000280  20746f20
000284  686f6c64
000288  20736f75
00028c  72636500
                  |L6.656|
000290  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000294  7274696f
000298  6e202225
00029c  73222066
0002a0  61696c65
0002a4  64206174
0002a8  206c696e
0002ac  65202564
0002b0  20696e20
0002b4  25730a00
                  |L6.696|
                          DCD      0x0000036d
                  |L6.700|
0002bc  6f666673          DCB      "offset_to <= p_to->len",0
0002c0  65745f74
0002c4  6f203c3d
0002c8  20705f74
0002cc  6f2d3e6c
0002d0  656e00  
0002d3  00                DCB      0
                  |L6.724|
                          DCD      0x0000036e
                  |L6.728|
0002d8  6f666673          DCB      "offset_from <= p_from->len",0
0002dc  65745f66
0002e0  726f6d20
0002e4  3c3d2070
0002e8  5f66726f
0002ec  6d2d3e6c
0002f0  656e00  
0002f3  00                DCB      0
                  |L6.756|
0002f4  705f746f          DCB      "p_to != NULL",0
0002f8  20213d20
0002fc  4e554c4c
000300  00      
000301  00                DCB      0
000302  00                DCB      0
000303  00                DCB      0
                  |L6.772|
                          DCD      0x0000037d
                  |L6.776|
000308  70627566          DCB      "pbuf_copy() does not allow packet queues!\n",0
00030c  5f636f70
000310  79282920
000314  646f6573
000318  206e6f74
00031c  20616c6c
000320  6f772070
000324  61636b65
000328  74207175
00032c  65756573
000330  210a00  
000333  00                DCB      0
                  |L6.820|
                          DCD      0x00000382
                          ENDP


                          AREA ||i.pbuf_copy_partial||, CODE, READONLY, ALIGN=2

                  pbuf_copy_partial PROC
;;;917    u16_t
;;;918    pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;919    {
000004  e1a08000          MOV      r8,r0
000008  e1a09001          MOV      r9,r1
00000c  e1a06002          MOV      r6,r2
000010  e1a05003          MOV      r5,r3
;;;920      struct pbuf *p;
;;;921      u16_t left;
;;;922      u16_t buf_copy_len;
;;;923      u16_t copied_total = 0;
000014  e3a0b000          MOV      r11,#0
;;;924    
;;;925      LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
000018  e1a00000          MOV      r0,r0
00001c  e3580000          CMP      r8,#0
000020  1a000008          BNE      |L7.72|
000024  e1a00000          MOV      r0,r0
000028  e28f3e11          ADR      r3,|L7.320|
00002c  e59f2128          LDR      r2,|L7.348|
000030  e28f1f4a          ADR      r1,|L7.352|
000034  e28f0f51          ADR      r0,|L7.384|
000038  ebfffffe          BL       sysprintf
00003c  e1a00000          MOV      r0,r0
000040  e3a00000          MOV      r0,#0
                  |L7.68|
;;;926      LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
;;;927    
;;;928      left = 0;
;;;929    
;;;930      if((buf == NULL) || (dataptr == NULL)) {
;;;931        return 0;
;;;932      }
;;;933    
;;;934      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;935      for(p = buf; len != 0 && p != NULL; p = p->next) {
;;;936        if ((offset != 0) && (offset >= p->len)) {
;;;937          /* don't copy from this buffer -> on to the next */
;;;938          offset -= p->len;
;;;939        } else {
;;;940          /* copy from this buffer. maybe only partially. */
;;;941          buf_copy_len = p->len - offset;
;;;942          if (buf_copy_len > len)
;;;943              buf_copy_len = len;
;;;944          /* copy the necessary parts of the buffer */
;;;945          MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;946          copied_total += buf_copy_len;
;;;947          left += buf_copy_len;
;;;948          len -= buf_copy_len;
;;;949          offset = 0;
;;;950        }
;;;951      }
;;;952      return copied_total;
;;;953    }
000044  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.72|
000048  e1a00000          MOV      r0,r0                 ;925
00004c  e1a00000          MOV      r0,r0                 ;926
000050  e3590000          CMP      r9,#0                 ;926
000054  1a000008          BNE      |L7.124|
000058  e1a00000          MOV      r0,r0                 ;926
00005c  e28f30dc          ADR      r3,|L7.320|
000060  e59f2140          LDR      r2,|L7.424|
000064  e28f1d05          ADR      r1,|L7.428|
000068  e28f0e11          ADR      r0,|L7.384|
00006c  ebfffffe          BL       sysprintf
000070  e1a00000          MOV      r0,r0                 ;926
000074  e3a00000          MOV      r0,#0                 ;926
000078  eafffff1          B        |L7.68|
                  |L7.124|
00007c  e1a00000          MOV      r0,r0                 ;926
000080  e3a0a000          MOV      r10,#0                ;928
000084  e3580000          CMP      r8,#0                 ;930
000088  0a000001          BEQ      |L7.148|
00008c  e3590000          CMP      r9,#0                 ;930
000090  1a000001          BNE      |L7.156|
                  |L7.148|
000094  e3a00000          MOV      r0,#0                 ;931
000098  eaffffe9          B        |L7.68|
                  |L7.156|
00009c  e1a04008          MOV      r4,r8                 ;935
0000a0  ea000020          B        |L7.296|
                  |L7.164|
0000a4  e3550000          CMP      r5,#0                 ;936
0000a8  0a000007          BEQ      |L7.204|
0000ac  e1d400ba          LDRH     r0,[r4,#0xa]          ;936
0000b0  e1500005          CMP      r0,r5                 ;936
0000b4  ca000004          BGT      |L7.204|
0000b8  e1d400ba          LDRH     r0,[r4,#0xa]          ;938
0000bc  e0450000          SUB      r0,r5,r0              ;938
0000c0  e1a05800          LSL      r5,r0,#16             ;938
0000c4  e1a05825          LSR      r5,r5,#16             ;938
0000c8  ea000015          B        |L7.292|
                  |L7.204|
0000cc  e1d400ba          LDRH     r0,[r4,#0xa]          ;941
0000d0  e0400005          SUB      r0,r0,r5              ;941
0000d4  e1a07800          LSL      r7,r0,#16             ;941
0000d8  e1a07827          LSR      r7,r7,#16             ;941
0000dc  e1570006          CMP      r7,r6                 ;942
0000e0  da000000          BLE      |L7.232|
0000e4  e1a07006          MOV      r7,r6                 ;943
                  |L7.232|
0000e8  e5942004          LDR      r2,[r4,#4]            ;945
0000ec  e0821005          ADD      r1,r2,r5              ;945
0000f0  e089000a          ADD      r0,r9,r10             ;945
0000f4  e1a02007          MOV      r2,r7                 ;945
0000f8  ebfffffe          BL       __aeabi_memcpy
0000fc  e08b0007          ADD      r0,r11,r7             ;946
000100  e1a0b800          LSL      r11,r0,#16            ;946
000104  e1a0b82b          LSR      r11,r11,#16           ;946
000108  e08a0007          ADD      r0,r10,r7             ;947
00010c  e1a0a800          LSL      r10,r0,#16            ;947
000110  e1a0a82a          LSR      r10,r10,#16           ;947
000114  e0460007          SUB      r0,r6,r7              ;948
000118  e1a06800          LSL      r6,r0,#16             ;948
00011c  e1a06826          LSR      r6,r6,#16             ;948
000120  e3a05000          MOV      r5,#0                 ;949
                  |L7.292|
000124  e5944000          LDR      r4,[r4,#0]            ;935
                  |L7.296|
000128  e3560000          CMP      r6,#0                 ;935
00012c  0a000001          BEQ      |L7.312|
000130  e3540000          CMP      r4,#0                 ;935
000134  1affffda          BNE      |L7.164|
                  |L7.312|
000138  e1a0000b          MOV      r0,r11                ;952
00013c  eaffffc0          B        |L7.68|
;;;954    
                          ENDP

                  |L7.320|
000140  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
000144  2d312e34
000148  2e315c73
00014c  72635c63
000150  6f72655c
000154  70627566
000158  2e6300  
00015b  00                DCB      0
                  |L7.348|
                          DCD      0x0000039d
                  |L7.352|
000160  70627566          DCB      "pbuf_copy_partial: invalid buf",0
000164  5f636f70
000168  795f7061
00016c  72746961
000170  6c3a2069
000174  6e76616c
000178  69642062
00017c  756600  
00017f  00                DCB      0
                  |L7.384|
000180  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000184  7274696f
000188  6e202225
00018c  73222066
000190  61696c65
000194  64206174
000198  206c696e
00019c  65202564
0001a0  20696e20
0001a4  25730a00
                  |L7.424|
                          DCD      0x0000039e
                  |L7.428|
0001ac  70627566          DCB      "pbuf_copy_partial: invalid dataptr",0
0001b0  5f636f70
0001b4  795f7061
0001b8  72746961
0001bc  6c3a2069
0001c0  6e76616c
0001c4  69642064
0001c8  61746170
0001cc  747200  
0001cf  00                DCB      0

                          AREA ||i.pbuf_dechain||, CODE, READONLY, ALIGN=2

                  pbuf_dechain PROC
;;;802    struct pbuf *
;;;803    pbuf_dechain(struct pbuf *p)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;804    {
000004  e1a04000          MOV      r4,r0
;;;805      struct pbuf *q;
;;;806      u8_t tail_gone = 1;
000008  e3a06001          MOV      r6,#1
;;;807      /* tail */
;;;808      q = p->next;
00000c  e5945000          LDR      r5,[r4,#0]
;;;809      /* pbuf has successor in chain? */
;;;810      if (q != NULL) {
000010  e3550000          CMP      r5,#0
000014  0a00001a          BEQ      |L8.132|
;;;811        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;812        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
000018  e1a00000          MOV      r0,r0
00001c  e1d400b8          LDRH     r0,[r4,#8]
000020  e1d410ba          LDRH     r1,[r4,#0xa]
000024  e0400001          SUB      r0,r0,r1
000028  e1d510b8          LDRH     r1,[r5,#8]
00002c  e1500001          CMP      r0,r1
000030  0a000006          BEQ      |L8.80|
000034  e1a00000          MOV      r0,r0
000038  e28f3090          ADR      r3,|L8.208|
00003c  e3a02fcb          MOV      r2,#0x32c
000040  e28f10a4          ADR      r1,|L8.236|
000044  e28f00c4          ADR      r0,|L8.272|
000048  ebfffffe          BL       sysprintf
00004c  e1a00000          MOV      r0,r0
                  |L8.80|
000050  e1a00000          MOV      r0,r0
;;;813        /* enforce invariant if assertion is disabled */
;;;814        q->tot_len = p->tot_len - p->len;
000054  e1d400b8          LDRH     r0,[r4,#8]
000058  e1d410ba          LDRH     r1,[r4,#0xa]
00005c  e0400001          SUB      r0,r0,r1
000060  e1c500b8          STRH     r0,[r5,#8]
;;;815        /* decouple pbuf from remainder */
;;;816        p->next = NULL;
000064  e3a00000          MOV      r0,#0
000068  e5840000          STR      r0,[r4,#0]
;;;817        /* total length of pbuf p is its own length only */
;;;818        p->tot_len = p->len;
00006c  e1d400ba          LDRH     r0,[r4,#0xa]
000070  e1c400b8          STRH     r0,[r4,#8]
;;;819        /* q is no longer referenced by p, free it */
;;;820        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
;;;821        tail_gone = pbuf_free(q);
000074  e1a00005          MOV      r0,r5
000078  ebfffffe          BL       pbuf_free
00007c  e1a06000          MOV      r6,r0
;;;822        if (tail_gone > 0) {
000080  e1a00000          MOV      r0,r0
                  |L8.132|
;;;823          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
;;;824                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;825        }
;;;826        /* return remaining tail or NULL if deallocated */
;;;827      }
;;;828      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;829      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
000084  e1a00000          MOV      r0,r0
000088  e1d400b8          LDRH     r0,[r4,#8]
00008c  e1d410ba          LDRH     r1,[r4,#0xa]
000090  e1500001          CMP      r0,r1
000094  0a000006          BEQ      |L8.180|
000098  e1a00000          MOV      r0,r0
00009c  e28f302c          ADR      r3,|L8.208|
0000a0  e59f2090          LDR      r2,|L8.312|
0000a4  e28f1090          ADR      r1,|L8.316|
0000a8  e28f0060          ADR      r0,|L8.272|
0000ac  ebfffffe          BL       sysprintf
0000b0  e1a00000          MOV      r0,r0
                  |L8.180|
0000b4  e1a00000          MOV      r0,r0
;;;830      return ((tail_gone > 0) ? NULL : q);
0000b8  e3560000          CMP      r6,#0
0000bc  da000001          BLE      |L8.200|
0000c0  e3a00000          MOV      r0,#0
                  |L8.196|
;;;831    }
0000c4  e8bd8070          POP      {r4-r6,pc}
                  |L8.200|
0000c8  e1a00005          MOV      r0,r5                 ;830
0000cc  eafffffc          B        |L8.196|
;;;832    
                          ENDP

                  |L8.208|
0000d0  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
0000d4  2d312e34
0000d8  2e315c73
0000dc  72635c63
0000e0  6f72655c
0000e4  70627566
0000e8  2e6300  
0000eb  00                DCB      0
                  |L8.236|
0000ec  702d3e74          DCB      "p->tot_len == p->len + q->tot_len",0
0000f0  6f745f6c
0000f4  656e203d
0000f8  3d20702d
0000fc  3e6c656e
000100  202b2071
000104  2d3e746f
000108  745f6c65
00010c  6e00    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L8.272|
000110  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000114  7274696f
000118  6e202225
00011c  73222066
000120  61696c65
000124  64206174
000128  206c696e
00012c  65202564
000130  20696e20
000134  25730a00
                  |L8.312|
                          DCD      0x0000033d
                  |L8.316|
00013c  702d3e74          DCB      "p->tot_len == p->len",0
000140  6f745f6c
000144  656e203d
000148  3d20702d
00014c  3e6c656e
000150  00      
000151  00                DCB      0
000152  00                DCB      0
000153  00                DCB      0

                          AREA ||i.pbuf_free||, CODE, READONLY, ALIGN=2

                  pbuf_free PROC
;;;617    u8_t
;;;618    pbuf_free(struct pbuf *p)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;619    {
000004  e1a04000          MOV      r4,r0
;;;620      u16_t type;
;;;621      struct pbuf *q;
;;;622      u8_t count;
;;;623    
;;;624      if (p == NULL) {
000008  e3540000          CMP      r4,#0
00000c  1a00000c          BNE      |L9.68|
;;;625        LWIP_ASSERT("p != NULL", p != NULL);
000010  e1a00000          MOV      r0,r0
000014  e3540000          CMP      r4,#0
000018  1a000006          BNE      |L9.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f3f51          ADR      r3,|L9.364|
000024  e59f215c          LDR      r2,|L9.392|
000028  e28f1f57          ADR      r1,|L9.396|
00002c  e28f0f59          ADR      r0,|L9.408|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L9.56|
000038  e1a00000          MOV      r0,r0
;;;626        /* if assertions are disabled, proceed with debug output */
;;;627        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;628          ("pbuf_free(p == NULL) was called.\n"));
;;;629        return 0;
00003c  e3a00000          MOV      r0,#0
                  |L9.64|
;;;630      }
;;;631      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;632    
;;;633      PERF_START;
;;;634    
;;;635      LWIP_ASSERT("pbuf_free: sane type",
;;;636        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;637        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;638    
;;;639      count = 0;
;;;640      /* de-allocate all consecutive pbufs from the head of the chain that
;;;641       * obtain a zero reference count after decrementing*/
;;;642      while (p != NULL) {
;;;643        u16_t ref;
;;;644        SYS_ARCH_DECL_PROTECT(old_level);
;;;645        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;646         * we must protect it. We put the new ref into a local variable to prevent
;;;647         * further protection. */
;;;648        SYS_ARCH_PROTECT(old_level);
;;;649        /* all pbufs in a chain are referenced at least once */
;;;650        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
;;;651        /* decrease reference count (number of pointers to pbuf) */
;;;652        ref = --(p->ref);
;;;653        SYS_ARCH_UNPROTECT(old_level);
;;;654        /* this pbuf is no longer referenced to? */
;;;655        if (ref == 0) {
;;;656          /* remember next pbuf in chain for next iteration */
;;;657          q = p->next;
;;;658          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;659          type = p->type;
;;;660    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;661          /* is this a custom pbuf? */
;;;662          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
;;;663            struct pbuf_custom *pc = (struct pbuf_custom*)p;
;;;664            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
;;;665            pc->custom_free_function(p);
;;;666          } else
;;;667    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;668          {
;;;669            /* is this a pbuf from the pool? */
;;;670            if (type == PBUF_POOL) {
;;;671              memp_free(MEMP_PBUF_POOL, p);
;;;672            /* is this a ROM or RAM referencing pbuf? */
;;;673            } else if (type == PBUF_ROM || type == PBUF_REF) {
;;;674              memp_free(MEMP_PBUF, p);
;;;675            /* type == PBUF_RAM */
;;;676            } else {
;;;677              mem_free(p);
;;;678            }
;;;679          }
;;;680          count++;
;;;681          /* proceed to next pbuf */
;;;682          p = q;
;;;683        /* p->ref > 0, this pbuf is still referenced to */
;;;684        /* (and so the remaining pbufs in chain as well) */
;;;685        } else {
;;;686          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;687          /* stop walking through the chain */
;;;688          p = NULL;
;;;689        }
;;;690      }
;;;691      PERF_STOP("pbuf_free");
;;;692      /* return number of de-allocated pbufs */
;;;693      return count;
;;;694    }
000040  e8bd87f0          POP      {r4-r10,pc}
                  |L9.68|
000044  e1a00000          MOV      r0,r0                 ;635
000048  e5d4000c          LDRB     r0,[r4,#0xc]          ;635
00004c  e3500000          CMP      r0,#0                 ;635
000050  0a00000f          BEQ      |L9.148|
000054  e5d4000c          LDRB     r0,[r4,#0xc]          ;635
000058  e3500001          CMP      r0,#1                 ;635
00005c  0a00000c          BEQ      |L9.148|
000060  e5d4000c          LDRB     r0,[r4,#0xc]          ;635
000064  e3500002          CMP      r0,#2                 ;635
000068  0a000009          BEQ      |L9.148|
00006c  e5d4000c          LDRB     r0,[r4,#0xc]          ;635
000070  e3500003          CMP      r0,#3                 ;635
000074  0a000006          BEQ      |L9.148|
000078  e1a00000          MOV      r0,r0                 ;635
00007c  e28f30e8          ADR      r3,|L9.364|
000080  e59f2138          LDR      r2,|L9.448|
000084  e28f1f4e          ADR      r1,|L9.452|
000088  e28f0f42          ADR      r0,|L9.408|
00008c  ebfffffe          BL       sysprintf
000090  e1a00000          MOV      r0,r0                 ;635
                  |L9.148|
000094  e1a00000          MOV      r0,r0                 ;635
000098  e3a06000          MOV      r6,#0                 ;639
00009c  ea00002e          B        |L9.348|
                  |L9.160|
0000a0  ebfffffe          BL       sys_arch_protect
0000a4  e1a09000          MOV      r9,r0                 ;648
0000a8  e1a00000          MOV      r0,r0                 ;650
0000ac  e1d400be          LDRH     r0,[r4,#0xe]          ;650
0000b0  e3500000          CMP      r0,#0                 ;650
0000b4  ca000006          BGT      |L9.212|
0000b8  e1a00000          MOV      r0,r0                 ;650
0000bc  e28f30a8          ADR      r3,|L9.364|
0000c0  e59f2114          LDR      r2,|L9.476|
0000c4  e28f1f45          ADR      r1,|L9.480|
0000c8  e28f00c8          ADR      r0,|L9.408|
0000cc  ebfffffe          BL       sysprintf
0000d0  e1a00000          MOV      r0,r0                 ;650
                  |L9.212|
0000d4  e1a00000          MOV      r0,r0                 ;650
0000d8  e1d400be          LDRH     r0,[r4,#0xe]          ;652
0000dc  e2400001          SUB      r0,r0,#1              ;652
0000e0  e1a08800          LSL      r8,r0,#16             ;652
0000e4  e1a08828          LSR      r8,r8,#16             ;652
0000e8  e1c480be          STRH     r8,[r4,#0xe]          ;652
0000ec  e1a00009          MOV      r0,r9                 ;653
0000f0  ebfffffe          BL       sys_arch_unprotect
0000f4  e3580000          CMP      r8,#0                 ;655
0000f8  1a000015          BNE      |L9.340|
0000fc  e5947000          LDR      r7,[r4,#0]            ;657
000100  e5d4500c          LDRB     r5,[r4,#0xc]          ;659
000104  e3550003          CMP      r5,#3                 ;670
000108  1a000003          BNE      |L9.284|
00010c  e1a01004          MOV      r1,r4                 ;671
000110  e3a0000b          MOV      r0,#0xb               ;671
000114  ebfffffe          BL       memp_free
000118  ea000009          B        |L9.324|
                  |L9.284|
00011c  e3550001          CMP      r5,#1                 ;673
000120  0a000001          BEQ      |L9.300|
000124  e3550002          CMP      r5,#2                 ;673
000128  1a000003          BNE      |L9.316|
                  |L9.300|
00012c  e1a01004          MOV      r1,r4                 ;674
000130  e3a0000a          MOV      r0,#0xa               ;674
000134  ebfffffe          BL       memp_free
000138  ea000001          B        |L9.324|
                  |L9.316|
00013c  e1a00004          MOV      r0,r4                 ;677
000140  ebfffffe          BL       mem_free
                  |L9.324|
000144  e2860001          ADD      r0,r6,#1              ;680
000148  e20060ff          AND      r6,r0,#0xff           ;680
00014c  e1a04007          MOV      r4,r7                 ;682
000150  ea000000          B        |L9.344|
                  |L9.340|
000154  e3a04000          MOV      r4,#0                 ;688
                  |L9.344|
000158  e1a00000          MOV      r0,r0                 ;690
                  |L9.348|
00015c  e3540000          CMP      r4,#0                 ;642
000160  1affffce          BNE      |L9.160|
000164  e1a00006          MOV      r0,r6                 ;693
000168  eaffffb4          B        |L9.64|
;;;695    
                          ENDP

                  |L9.364|
00016c  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
000170  2d312e34
000174  2e315c73
000178  72635c63
00017c  6f72655c
000180  70627566
000184  2e6300  
000187  00                DCB      0
                  |L9.392|
                          DCD      0x00000271
                  |L9.396|
00018c  7020213d          DCB      "p != NULL",0
000190  204e554c
000194  4c00    
000196  00                DCB      0
000197  00                DCB      0
                  |L9.408|
000198  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00019c  7274696f
0001a0  6e202225
0001a4  73222066
0001a8  61696c65
0001ac  64206174
0001b0  206c696e
0001b4  65202564
0001b8  20696e20
0001bc  25730a00
                  |L9.448|
                          DCD      0x0000027b
                  |L9.452|
0001c4  70627566          DCB      "pbuf_free: sane type",0
0001c8  5f667265
0001cc  653a2073
0001d0  616e6520
0001d4  74797065
0001d8  00      
0001d9  00                DCB      0
0001da  00                DCB      0
0001db  00                DCB      0
                  |L9.476|
                          DCD      0x0000028a
                  |L9.480|
0001e0  70627566          DCB      "pbuf_free: p->ref > 0",0
0001e4  5f667265
0001e8  653a2070
0001ec  2d3e7265
0001f0  66203e20
0001f4  3000    
0001f6  00                DCB      0
0001f7  00                DCB      0

                          AREA ||i.pbuf_free_ooseq||, CODE, READONLY, ALIGN=2

                  pbuf_free_ooseq PROC
;;;117    void
;;;118    pbuf_free_ooseq(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;119    {
;;;120      struct tcp_pcb* pcb;
;;;121      SYS_ARCH_DECL_PROTECT(old_level);
;;;122    
;;;123      SYS_ARCH_PROTECT(old_level);
000004  ebfffffe          BL       sys_arch_protect
000008  e1a05000          MOV      r5,r0
;;;124      pbuf_free_ooseq_pending = 0;
00000c  e3a00000          MOV      r0,#0
000010  e59f1048          LDR      r1,|L10.96|
000014  e5c10000          STRB     r0,[r1,#0]  ; pbuf_free_ooseq_pending
;;;125      SYS_ARCH_UNPROTECT(old_level);
000018  e1a00005          MOV      r0,r5
00001c  ebfffffe          BL       sys_arch_unprotect
;;;126    
;;;127      for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
000020  e59f003c          LDR      r0,|L10.100|
000024  e5904000          LDR      r4,[r0,#0]  ; tcp_active_pcbs
000028  ea000008          B        |L10.80|
                  |L10.44|
;;;128        if (NULL != pcb->ooseq) {
00002c  e5940074          LDR      r0,[r4,#0x74]
000030  e3500000          CMP      r0,#0
000034  0a000004          BEQ      |L10.76|
;;;129          /** Free the ooseq pbufs of one PCB only */
;;;130          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
;;;131          tcp_segs_free(pcb->ooseq);
000038  e5940074          LDR      r0,[r4,#0x74]
00003c  ebfffffe          BL       tcp_segs_free
;;;132          pcb->ooseq = NULL;
000040  e3a00000          MOV      r0,#0
000044  e5840074          STR      r0,[r4,#0x74]
                  |L10.72|
;;;133          return;
;;;134        }
;;;135      }
;;;136    }
000048  e8bd8070          POP      {r4-r6,pc}
                  |L10.76|
00004c  e594400c          LDR      r4,[r4,#0xc]          ;127
                  |L10.80|
000050  e3540000          CMP      r4,#0                 ;127
000054  1afffff4          BNE      |L10.44|
000058  e1a00000          MOV      r0,r0
00005c  eafffff9          B        |L10.72|
;;;137    
                          ENDP

                  |L10.96|
                          DCD      pbuf_free_ooseq_pending
                  |L10.100|
                          DCD      tcp_active_pcbs

                          AREA ||i.pbuf_free_ooseq_callback||, CODE, READONLY, ALIGN=2

                  pbuf_free_ooseq_callback PROC
;;;142    static void
;;;143    pbuf_free_ooseq_callback(void *arg)
000000  e92d4010          PUSH     {r4,lr}
;;;144    {
000004  e1a04000          MOV      r4,r0
;;;145      LWIP_UNUSED_ARG(arg);
;;;146      pbuf_free_ooseq();
000008  ebfffffe          BL       pbuf_free_ooseq
;;;147    }
00000c  e8bd8010          POP      {r4,pc}
;;;148    #endif /* !NO_SYS */
                          ENDP


                          AREA ||i.pbuf_get_at||, CODE, READONLY, ALIGN=2

                  pbuf_get_at PROC
;;;1076   u8_t
;;;1077   pbuf_get_at(struct pbuf* p, u16_t offset)
000000  e1a03000          MOV      r3,r0
;;;1078   {
000004  e1a0c001          MOV      r12,r1
;;;1079     u16_t copy_from = offset;
000008  e1a0200c          MOV      r2,r12
;;;1080     struct pbuf* q = p;
00000c  e1a01003          MOV      r1,r3
;;;1081   
;;;1082     /* get the correct pbuf */
;;;1083     while ((q != NULL) && (q->len <= copy_from)) {
000010  ea000004          B        |L12.40|
                  |L12.20|
;;;1084       copy_from -= q->len;
000014  e1d100ba          LDRH     r0,[r1,#0xa]
000018  e0420000          SUB      r0,r2,r0
00001c  e1a02800          LSL      r2,r0,#16
000020  e1a02822          LSR      r2,r2,#16
;;;1085       q = q->next;
000024  e5911000          LDR      r1,[r1,#0]
                  |L12.40|
000028  e3510000          CMP      r1,#0                 ;1083
00002c  0a000002          BEQ      |L12.60|
000030  e1d100ba          LDRH     r0,[r1,#0xa]          ;1083
000034  e1500002          CMP      r0,r2                 ;1083
000038  dafffff5          BLE      |L12.20|
                  |L12.60|
;;;1086     }
;;;1087     /* return requested data if pbuf is OK */
;;;1088     if ((q != NULL) && (q->len > copy_from)) {
00003c  e3510000          CMP      r1,#0
000040  0a000005          BEQ      |L12.92|
000044  e1d100ba          LDRH     r0,[r1,#0xa]
000048  e1500002          CMP      r0,r2
00004c  da000002          BLE      |L12.92|
;;;1089       return ((u8_t*)q->payload)[copy_from];
000050  e5910004          LDR      r0,[r1,#4]
000054  e7d00002          LDRB     r0,[r0,r2]
                  |L12.88|
;;;1090     }
;;;1091     return 0;
;;;1092   }
000058  e12fff1e          BX       lr
                  |L12.92|
00005c  e3a00000          MOV      r0,#0                 ;1091
000060  eafffffc          B        |L12.88|
;;;1093   
                          ENDP


                          AREA ||i.pbuf_header||, CODE, READONLY, ALIGN=2

                  pbuf_header PROC
;;;510    u8_t
;;;511    pbuf_header(struct pbuf *p, s16_t header_size_increment)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;512    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;513      u16_t type;
;;;514      void *payload;
;;;515      u16_t increment_magnitude;
;;;516    
;;;517      LWIP_ASSERT("p != NULL", p != NULL);
00000c  e1a00000          MOV      r0,r0
000010  e3540000          CMP      r4,#0
000014  1a000006          BNE      |L13.52|
000018  e1a00000          MOV      r0,r0
00001c  e28f3f52          ADR      r3,|L13.364|
000020  e59f2160          LDR      r2,|L13.392|
000024  e28f1e16          ADR      r1,|L13.396|
000028  e28f0f5a          ADR      r0,|L13.408|
00002c  ebfffffe          BL       sysprintf
000030  e1a00000          MOV      r0,r0
                  |L13.52|
000034  e1a00000          MOV      r0,r0
;;;518      if ((header_size_increment == 0) || (p == NULL)) {
000038  e3550000          CMP      r5,#0
00003c  0a000001          BEQ      |L13.72|
000040  e3540000          CMP      r4,#0
000044  1a000001          BNE      |L13.80|
                  |L13.72|
;;;519        return 0;
000048  e3a00000          MOV      r0,#0
                  |L13.76|
;;;520      }
;;;521     
;;;522      if (header_size_increment < 0){
;;;523        increment_magnitude = -header_size_increment;
;;;524        /* Check that we aren't going to move off the end of the pbuf */
;;;525        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
;;;526      } else {
;;;527        increment_magnitude = header_size_increment;
;;;528    #if 0
;;;529        /* Can't assert these as some callers speculatively call
;;;530             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;531        /* Check that we've got the correct type of pbuf to work with */
;;;532        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
;;;533                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;534        /* Check that we aren't going to move off the beginning of the pbuf */
;;;535        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;536                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;537    #endif
;;;538      }
;;;539    
;;;540      type = p->type;
;;;541      /* remember current payload pointer */
;;;542      payload = p->payload;
;;;543    
;;;544      /* pbuf types containing payloads? */
;;;545      if (type == PBUF_RAM || type == PBUF_POOL) {
;;;546        /* set new payload pointer */
;;;547        p->payload = (u8_t *)p->payload - header_size_increment;
;;;548        /* boundary check fails? */
;;;549        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;550          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;551            ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;552            (void *)p->payload, (void *)(p + 1)));
;;;553          /* restore old payload pointer */
;;;554          p->payload = payload;
;;;555          /* bail out unsuccesfully */
;;;556          return 1;
;;;557        }
;;;558      /* pbuf types refering to external payloads? */
;;;559      } else if (type == PBUF_REF || type == PBUF_ROM) {
;;;560        /* hide a header in the payload? */
;;;561        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;562          /* increase payload pointer */
;;;563          p->payload = (u8_t *)p->payload - header_size_increment;
;;;564        } else {
;;;565          /* cannot expand payload to front (yet!)
;;;566           * bail out unsuccesfully */
;;;567          return 1;
;;;568        }
;;;569      } else {
;;;570        /* Unknown type */
;;;571        LWIP_ASSERT("bad pbuf type", 0);
;;;572        return 1;
;;;573      }
;;;574      /* modify pbuf length fields */
;;;575      p->len += header_size_increment;
;;;576      p->tot_len += header_size_increment;
;;;577    
;;;578      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;579        (void *)payload, (void *)p->payload, header_size_increment));
;;;580    
;;;581      return 0;
;;;582    }
00004c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.80|
000050  e3550000          CMP      r5,#0                 ;522
000054  aa000010          BGE      |L13.156|
000058  e2650000          RSB      r0,r5,#0              ;523
00005c  e1a07800          LSL      r7,r0,#16             ;523
000060  e1a07827          LSR      r7,r7,#16             ;523
000064  e1a00000          MOV      r0,r0                 ;525
000068  e1d400ba          LDRH     r0,[r4,#0xa]          ;525
00006c  e1500007          CMP      r0,r7                 ;525
000070  aa000008          BGE      |L13.152|
000074  e1a00000          MOV      r0,r0                 ;525
000078  e28f30ec          ADR      r3,|L13.364|
00007c  e59f213c          LDR      r2,|L13.448|
000080  e28f1f4f          ADR      r1,|L13.452|
000084  e28f0f43          ADR      r0,|L13.408|
000088  ebfffffe          BL       sysprintf
00008c  e1a00000          MOV      r0,r0                 ;525
000090  e3a00001          MOV      r0,#1                 ;525
000094  eaffffec          B        |L13.76|
                  |L13.152|
000098  ea000001          B        |L13.164|
                  |L13.156|
00009c  e1a07805          LSL      r7,r5,#16             ;527
0000a0  e1a07827          LSR      r7,r7,#16             ;527
                  |L13.164|
0000a4  e5d4600c          LDRB     r6,[r4,#0xc]          ;540
0000a8  e5948004          LDR      r8,[r4,#4]            ;542
0000ac  e3560000          CMP      r6,#0                 ;545
0000b0  0a000001          BEQ      |L13.188|
0000b4  e3560003          CMP      r6,#3                 ;545
0000b8  1a000009          BNE      |L13.228|
                  |L13.188|
0000bc  e5940004          LDR      r0,[r4,#4]            ;547
0000c0  e0400005          SUB      r0,r0,r5              ;547
0000c4  e5840004          STR      r0,[r4,#4]            ;547
0000c8  e5940004          LDR      r0,[r4,#4]            ;549
0000cc  e2841010          ADD      r1,r4,#0x10           ;549
0000d0  e1500001          CMP      r0,r1                 ;549
0000d4  2a00001c          BCS      |L13.332|
0000d8  e5848004          STR      r8,[r4,#4]            ;554
0000dc  e3a00001          MOV      r0,#1                 ;556
0000e0  eaffffd9          B        |L13.76|
                  |L13.228|
0000e4  e3560002          CMP      r6,#2                 ;559
0000e8  0a000001          BEQ      |L13.244|
0000ec  e3560001          CMP      r6,#1                 ;559
0000f0  1a00000a          BNE      |L13.288|
                  |L13.244|
0000f4  e3550000          CMP      r5,#0                 ;561
0000f8  aa000006          BGE      |L13.280|
0000fc  e1d400ba          LDRH     r0,[r4,#0xa]          ;561
000100  e1500007          CMP      r0,r7                 ;561
000104  ba000003          BLT      |L13.280|
000108  e5940004          LDR      r0,[r4,#4]            ;563
00010c  e0400005          SUB      r0,r0,r5              ;563
000110  e5840004          STR      r0,[r4,#4]            ;563
000114  ea00000c          B        |L13.332|
                  |L13.280|
000118  e3a00001          MOV      r0,#1                 ;567
00011c  eaffffca          B        |L13.76|
                  |L13.288|
000120  e1a00000          MOV      r0,r0                 ;571
000124  e1a00000          MOV      r0,r0                 ;571
000128  e28f303c          ADR      r3,|L13.364|
00012c  e59f20b0          LDR      r2,|L13.484|
000130  e28f10b0          ADR      r1,|L13.488|
000134  e28f005c          ADR      r0,|L13.408|
000138  ebfffffe          BL       sysprintf
00013c  e1a00000          MOV      r0,r0                 ;571
000140  e1a00000          MOV      r0,r0                 ;571
000144  e3a00001          MOV      r0,#1                 ;572
000148  eaffffbf          B        |L13.76|
                  |L13.332|
00014c  e1d400ba          LDRH     r0,[r4,#0xa]          ;575
000150  e0800005          ADD      r0,r0,r5              ;575
000154  e1c400ba          STRH     r0,[r4,#0xa]          ;575
000158  e1d400b8          LDRH     r0,[r4,#8]            ;576
00015c  e0800005          ADD      r0,r0,r5              ;576
000160  e1c400b8          STRH     r0,[r4,#8]            ;576
000164  e3a00000          MOV      r0,#0                 ;581
000168  eaffffb7          B        |L13.76|
;;;583    
                          ENDP

                  |L13.364|
00016c  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
000170  2d312e34
000174  2e315c73
000178  72635c63
00017c  6f72655c
000180  70627566
000184  2e6300  
000187  00                DCB      0
                  |L13.392|
                          DCD      0x00000205
                  |L13.396|
00018c  7020213d          DCB      "p != NULL",0
000190  204e554c
000194  4c00    
000196  00                DCB      0
000197  00                DCB      0
                  |L13.408|
000198  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00019c  7274696f
0001a0  6e202225
0001a4  73222066
0001a8  61696c65
0001ac  64206174
0001b0  206c696e
0001b4  65202564
0001b8  20696e20
0001bc  25730a00
                  |L13.448|
                          DCD      0x0000020d
                  |L13.452|
0001c4  696e6372          DCB      "increment_magnitude <= p->len",0
0001c8  656d656e
0001cc  745f6d61
0001d0  676e6974
0001d4  75646520
0001d8  3c3d2070
0001dc  2d3e6c65
0001e0  6e00    
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L13.484|
                          DCD      0x0000023b
                  |L13.488|
0001e8  62616420          DCB      "bad pbuf type",0
0001ec  70627566
0001f0  20747970
0001f4  6500    
0001f6  00                DCB      0
0001f7  00                DCB      0

                          AREA ||i.pbuf_memcmp||, CODE, READONLY, ALIGN=2

                  pbuf_memcmp PROC
;;;1103   u16_t
;;;1104   pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1105   {
000004  e1a07000          MOV      r7,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a09002          MOV      r9,r2
000010  e1a0a003          MOV      r10,r3
;;;1106     u16_t start = offset;
000014  e1a06008          MOV      r6,r8
;;;1107     struct pbuf* q = p;
000018  e1a04007          MOV      r4,r7
;;;1108   
;;;1109     /* get the correct pbuf */
;;;1110     while ((q != NULL) && (q->len <= start)) {
00001c  ea000004          B        |L14.52|
                  |L14.32|
;;;1111       start -= q->len;
000020  e1d400ba          LDRH     r0,[r4,#0xa]
000024  e0460000          SUB      r0,r6,r0
000028  e1a06800          LSL      r6,r0,#16
00002c  e1a06826          LSR      r6,r6,#16
;;;1112       q = q->next;
000030  e5944000          LDR      r4,[r4,#0]
                  |L14.52|
000034  e3540000          CMP      r4,#0                 ;1110
000038  0a000002          BEQ      |L14.72|
00003c  e1d400ba          LDRH     r0,[r4,#0xa]          ;1110
000040  e1500006          CMP      r0,r6                 ;1110
000044  dafffff5          BLE      |L14.32|
                  |L14.72|
;;;1113     }
;;;1114     /* return requested data if pbuf is OK */
;;;1115     if ((q != NULL) && (q->len > start)) {
000048  e3540000          CMP      r4,#0
00004c  0a00001a          BEQ      |L14.188|
000050  e1d400ba          LDRH     r0,[r4,#0xa]
000054  e1500006          CMP      r0,r6
000058  da000017          BLE      |L14.188|
;;;1116       u16_t i;
;;;1117       for(i = 0; i < n; i++) {
00005c  e3a05000          MOV      r5,#0
000060  ea000011          B        |L14.172|
                  |L14.100|
;;;1118         u8_t a = pbuf_get_at(q, start + i);
000064  e0860005          ADD      r0,r6,r5
000068  e1a01800          LSL      r1,r0,#16
00006c  e1a01821          LSR      r1,r1,#16
000070  e1a00004          MOV      r0,r4
000074  ebfffffe          BL       pbuf_get_at
000078  e1a0b000          MOV      r11,r0
;;;1119         u8_t b = ((u8_t*)s2)[i];
00007c  e7d90005          LDRB     r0,[r9,r5]
000080  e58d0000          STR      r0,[sp,#0]
;;;1120         if (a != b) {
000084  e59d0000          LDR      r0,[sp,#0]
000088  e15b0000          CMP      r11,r0
00008c  0a000003          BEQ      |L14.160|
;;;1121           return i+1;
000090  e2850001          ADD      r0,r5,#1
000094  e1a00800          LSL      r0,r0,#16
000098  e1a00820          LSR      r0,r0,#16
                  |L14.156|
;;;1122         }
;;;1123       }
;;;1124       return 0;
;;;1125     }
;;;1126     return 0xffff;
;;;1127   }
00009c  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.160|
0000a0  e2850001          ADD      r0,r5,#1              ;1117
0000a4  e1a05800          LSL      r5,r0,#16             ;1117
0000a8  e1a05825          LSR      r5,r5,#16             ;1117
                  |L14.172|
0000ac  e155000a          CMP      r5,r10                ;1117
0000b0  baffffeb          BLT      |L14.100|
0000b4  e3a00000          MOV      r0,#0                 ;1124
0000b8  eafffff7          B        |L14.156|
                  |L14.188|
0000bc  e1a00000          MOV      r0,r0                 ;1125
0000c0  e59f0000          LDR      r0,|L14.200|
0000c4  eafffff4          B        |L14.156|
;;;1128   
                          ENDP

                  |L14.200|
                          DCD      0x0000ffff

                          AREA ||i.pbuf_memfind||, CODE, READONLY, ALIGN=2

                  pbuf_memfind PROC
;;;1139   u16_t
;;;1140   pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1141   {
000004  e1a06000          MOV      r6,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a05002          MOV      r5,r2
000010  e1a07003          MOV      r7,r3
;;;1142     u16_t i;
;;;1143     u16_t max = p->tot_len - mem_len;
000014  e1d600b8          LDRH     r0,[r6,#8]
000018  e0400005          SUB      r0,r0,r5
00001c  e1a0a800          LSL      r10,r0,#16
000020  e1a0a82a          LSR      r10,r10,#16
;;;1144     if (p->tot_len >= mem_len + start_offset) {
000024  e1d600b8          LDRH     r0,[r6,#8]
000028  e0851007          ADD      r1,r5,r7
00002c  e1500001          CMP      r0,r1
000030  ba000011          BLT      |L15.124|
;;;1145       for(i = start_offset; i <= max; ) {
000034  e1a04007          MOV      r4,r7
000038  ea00000d          B        |L15.116|
                  |L15.60|
;;;1146         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
00003c  e1a03005          MOV      r3,r5
000040  e1a02008          MOV      r2,r8
000044  e1a01004          MOV      r1,r4
000048  e1a00006          MOV      r0,r6
00004c  ebfffffe          BL       pbuf_memcmp
000050  e1a09000          MOV      r9,r0
;;;1147         if (plus == 0) {
000054  e3590000          CMP      r9,#0
000058  1a000001          BNE      |L15.100|
;;;1148           return i;
00005c  e1a00004          MOV      r0,r4
                  |L15.96|
;;;1149         } else {
;;;1150           i += plus;
;;;1151         }
;;;1152       }
;;;1153     }
;;;1154     return 0xFFFF;
;;;1155   }
000060  e8bd87f0          POP      {r4-r10,pc}
                  |L15.100|
000064  e0840009          ADD      r0,r4,r9              ;1150
000068  e1a04800          LSL      r4,r0,#16             ;1150
00006c  e1a04824          LSR      r4,r4,#16             ;1150
000070  e1a00000          MOV      r0,r0                 ;1152
                  |L15.116|
000074  e154000a          CMP      r4,r10                ;1145
000078  daffffef          BLE      |L15.60|
                  |L15.124|
00007c  e59f0000          LDR      r0,|L15.132|
000080  eafffff6          B        |L15.96|
;;;1156   
                          ENDP

                  |L15.132|
                          DCD      0x0000ffff

                          AREA ||i.pbuf_pool_is_empty||, CODE, READONLY, ALIGN=2

                  pbuf_pool_is_empty PROC
;;;151    static void
;;;152    pbuf_pool_is_empty(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;153    {
;;;154    #ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
;;;155      SYS_ARCH_DECL_PROTECT(old_level);
;;;156      SYS_ARCH_PROTECT(old_level);
;;;157      pbuf_free_ooseq_pending = 1;
;;;158      SYS_ARCH_UNPROTECT(old_level);
;;;159    #else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;160      u8_t queued;
;;;161      SYS_ARCH_DECL_PROTECT(old_level);
;;;162      SYS_ARCH_PROTECT(old_level);
000004  ebfffffe          BL       sys_arch_protect
000008  e1a05000          MOV      r5,r0
;;;163      queued = pbuf_free_ooseq_pending;
00000c  e59f005c          LDR      r0,|L16.112|
000010  e5d04000          LDRB     r4,[r0,#0]  ; pbuf_free_ooseq_pending
;;;164      pbuf_free_ooseq_pending = 1;
000014  e3a00001          MOV      r0,#1
000018  e59f1050          LDR      r1,|L16.112|
00001c  e5c10000          STRB     r0,[r1,#0]  ; pbuf_free_ooseq_pending
;;;165      SYS_ARCH_UNPROTECT(old_level);
000020  e1a00005          MOV      r0,r5
000024  ebfffffe          BL       sys_arch_unprotect
;;;166    
;;;167      if(!queued) {
000028  e3540000          CMP      r4,#0
00002c  1a00000e          BNE      |L16.108|
;;;168        /* queue a call to pbuf_free_ooseq if not already queued */
;;;169        PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
000030  e1a00000          MOV      r0,r0
000034  e3a02000          MOV      r2,#0
000038  e1a01002          MOV      r1,r2
00003c  e59f0030          LDR      r0,|L16.116|
000040  ebfffffe          BL       tcpip_callback_with_block
000044  e3500000          CMP      r0,#0
000048  0a000006          BEQ      |L16.104|
00004c  ebfffffe          BL       sys_arch_protect
000050  e1a05000          MOV      r5,r0
000054  e3a00000          MOV      r0,#0
000058  e59f1010          LDR      r1,|L16.112|
00005c  e5c10000          STRB     r0,[r1,#0]  ; pbuf_free_ooseq_pending
000060  e1a00005          MOV      r0,r5
000064  ebfffffe          BL       sys_arch_unprotect
                  |L16.104|
000068  e1a00000          MOV      r0,r0
                  |L16.108|
;;;170      }
;;;171    #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;172    }
00006c  e8bd8070          POP      {r4-r6,pc}
;;;173    #endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
                          ENDP

                  |L16.112|
                          DCD      pbuf_free_ooseq_pending
                  |L16.116|
                          DCD      pbuf_free_ooseq_callback

                          AREA ||i.pbuf_realloc||, CODE, READONLY, ALIGN=2

                  pbuf_realloc PROC
;;;429    void
;;;430    pbuf_realloc(struct pbuf *p, u16_t new_len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;431    {
000004  e1a05000          MOV      r5,r0
000008  e1a07001          MOV      r7,r1
;;;432      struct pbuf *q;
;;;433      u16_t rem_len; /* remaining length */
;;;434      s32_t grow;
;;;435    
;;;436      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
00000c  e1a00000          MOV      r0,r0
000010  e3550000          CMP      r5,#0
000014  1a000006          BNE      |L17.52|
000018  e1a00000          MOV      r0,r0
00001c  e28f3f6a          ADR      r3,|L17.460|
000020  e3a02f6d          MOV      r2,#0x1b4
000024  e28f1f6f          ADR      r1,|L17.488|
000028  e28f0e1d          ADR      r0,|L17.512|
00002c  ebfffffe          BL       sysprintf
000030  e1a00000          MOV      r0,r0
                  |L17.52|
000034  e1a00000          MOV      r0,r0
;;;437      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
000038  e1a00000          MOV      r0,r0
00003c  e5d5000c          LDRB     r0,[r5,#0xc]
000040  e3500003          CMP      r0,#3
000044  0a00000f          BEQ      |L17.136|
000048  e5d5000c          LDRB     r0,[r5,#0xc]
00004c  e3500001          CMP      r0,#1
000050  0a00000c          BEQ      |L17.136|
000054  e5d5000c          LDRB     r0,[r5,#0xc]
000058  e3500000          CMP      r0,#0
00005c  0a000009          BEQ      |L17.136|
000060  e5d5000c          LDRB     r0,[r5,#0xc]
000064  e3500002          CMP      r0,#2
000068  0a000006          BEQ      |L17.136|
00006c  e1a00000          MOV      r0,r0
000070  e28f3f55          ADR      r3,|L17.460|
000074  e59f21ac          LDR      r2,|L17.552|
000078  e28f1f6b          ADR      r1,|L17.556|
00007c  e28f0f5f          ADR      r0,|L17.512|
000080  ebfffffe          BL       sysprintf
000084  e1a00000          MOV      r0,r0
                  |L17.136|
000088  e1a00000          MOV      r0,r0
;;;438                  p->type == PBUF_ROM ||
;;;439                  p->type == PBUF_RAM ||
;;;440                  p->type == PBUF_REF);
;;;441    
;;;442      /* desired length larger than current length? */
;;;443      if (new_len >= p->tot_len) {
00008c  e1d500b8          LDRH     r0,[r5,#8]
000090  e1500007          CMP      r0,r7
000094  ca000000          BGT      |L17.156|
                  |L17.152|
;;;444        /* enlarging not yet supported */
;;;445        return;
;;;446      }
;;;447    
;;;448      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;449       * (which may be negative in case of shrinking) */
;;;450      grow = new_len - p->tot_len;
;;;451    
;;;452      /* first, step over any pbufs that should remain in the chain */
;;;453      rem_len = new_len;
;;;454      q = p;
;;;455      /* should this pbuf be kept? */
;;;456      while (rem_len > q->len) {
;;;457        /* decrease remaining length by pbuf length */
;;;458        rem_len -= q->len;
;;;459        /* decrease total length indicator */
;;;460        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
;;;461        q->tot_len += (u16_t)grow;
;;;462        /* proceed to next pbuf in chain */
;;;463        q = q->next;
;;;464        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
;;;465      }
;;;466      /* we have now reached the new last pbuf (in q) */
;;;467      /* rem_len == desired length for pbuf q */
;;;468    
;;;469      /* shrink allocated memory for PBUF_RAM */
;;;470      /* (other types merely adjust their length fields */
;;;471      if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
;;;472        /* reallocate and adjust the length of the pbuf that will be split */
;;;473        q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
;;;474        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
;;;475      }
;;;476      /* adjust length fields for new last pbuf */
;;;477      q->len = rem_len;
;;;478      q->tot_len = q->len;
;;;479    
;;;480      /* any remaining pbufs in chain? */
;;;481      if (q->next != NULL) {
;;;482        /* free remaining pbufs in chain */
;;;483        pbuf_free(q->next);
;;;484      }
;;;485      /* q is last packet in chain */
;;;486      q->next = NULL;
;;;487    
;;;488    }
000098  e8bd81f0          POP      {r4-r8,pc}
                  |L17.156|
00009c  e1d500b8          LDRH     r0,[r5,#8]            ;450
0000a0  e0478000          SUB      r8,r7,r0              ;450
0000a4  e1a06007          MOV      r6,r7                 ;453
0000a8  e1a04005          MOV      r4,r5                 ;454
0000ac  ea00001e          B        |L17.300|
                  |L17.176|
0000b0  e1d400ba          LDRH     r0,[r4,#0xa]          ;458
0000b4  e0460000          SUB      r0,r6,r0              ;458
0000b8  e1a06800          LSL      r6,r0,#16             ;458
0000bc  e1a06826          LSR      r6,r6,#16             ;458
0000c0  e1a00000          MOV      r0,r0                 ;460
0000c4  e59f017c          LDR      r0,|L17.584|
0000c8  e1580000          CMP      r8,r0                 ;460
0000cc  ba000006          BLT      |L17.236|
0000d0  e1a00000          MOV      r0,r0                 ;460
0000d4  e28f30f0          ADR      r3,|L17.460|
0000d8  e3a02f73          MOV      r2,#0x1cc             ;460
0000dc  e28f1f5a          ADR      r1,|L17.588|
0000e0  e28f0f46          ADR      r0,|L17.512|
0000e4  ebfffffe          BL       sysprintf
0000e8  e1a00000          MOV      r0,r0                 ;460
                  |L17.236|
0000ec  e1a00000          MOV      r0,r0                 ;460
0000f0  e1d400b8          LDRH     r0,[r4,#8]            ;461
0000f4  e0800008          ADD      r0,r0,r8              ;461
0000f8  e1c400b8          STRH     r0,[r4,#8]            ;461
0000fc  e5944000          LDR      r4,[r4,#0]            ;463
000100  e1a00000          MOV      r0,r0                 ;464
000104  e3540000          CMP      r4,#0                 ;464
000108  1a000006          BNE      |L17.296|
00010c  e1a00000          MOV      r0,r0                 ;464
000110  e28f30b4          ADR      r3,|L17.460|
000114  e3a02e1d          MOV      r2,#0x1d0             ;464
000118  e28f1d05          ADR      r1,|L17.608|
00011c  e28f00dc          ADR      r0,|L17.512|
000120  ebfffffe          BL       sysprintf
000124  e1a00000          MOV      r0,r0                 ;464
                  |L17.296|
000128  e1a00000          MOV      r0,r0                 ;464
                  |L17.300|
00012c  e1d400ba          LDRH     r0,[r4,#0xa]          ;456
000130  e1500006          CMP      r0,r6                 ;456
000134  baffffdd          BLT      |L17.176|
000138  e5d4000c          LDRB     r0,[r4,#0xc]          ;471
00013c  e3500000          CMP      r0,#0                 ;471
000140  1a000015          BNE      |L17.412|
000144  e1d400ba          LDRH     r0,[r4,#0xa]          ;471
000148  e1500006          CMP      r0,r6                 ;471
00014c  0a000012          BEQ      |L17.412|
000150  e1d400b4          LDRH     r0,[r4,#4]            ;473
000154  e0400004          SUB      r0,r0,r4              ;473
000158  e0800006          ADD      r0,r0,r6              ;473
00015c  e1a01800          LSL      r1,r0,#16             ;473
000160  e1a01821          LSR      r1,r1,#16             ;473
000164  e1a00004          MOV      r0,r4                 ;473
000168  ebfffffe          BL       mem_trim
00016c  e1a04000          MOV      r4,r0                 ;473
000170  e1a00000          MOV      r0,r0                 ;474
000174  e3540000          CMP      r4,#0                 ;474
000178  1a000006          BNE      |L17.408|
00017c  e1a00000          MOV      r0,r0                 ;474
000180  e28f3044          ADR      r3,|L17.460|
000184  e59f20ec          LDR      r2,|L17.632|
000188  e28f10ec          ADR      r1,|L17.636|
00018c  e28f006c          ADR      r0,|L17.512|
000190  ebfffffe          BL       sysprintf
000194  e1a00000          MOV      r0,r0                 ;474
                  |L17.408|
000198  e1a00000          MOV      r0,r0                 ;474
                  |L17.412|
00019c  e1c460ba          STRH     r6,[r4,#0xa]          ;477
0001a0  e1d400ba          LDRH     r0,[r4,#0xa]          ;478
0001a4  e1c400b8          STRH     r0,[r4,#8]            ;478
0001a8  e5940000          LDR      r0,[r4,#0]            ;481
0001ac  e3500000          CMP      r0,#0                 ;481
0001b0  0a000001          BEQ      |L17.444|
0001b4  e5940000          LDR      r0,[r4,#0]            ;483
0001b8  ebfffffe          BL       pbuf_free
                  |L17.444|
0001bc  e3a00000          MOV      r0,#0                 ;486
0001c0  e5840000          STR      r0,[r4,#0]            ;486
0001c4  e1a00000          MOV      r0,r0
0001c8  eaffffb2          B        |L17.152|
;;;489    
                          ENDP

                  |L17.460|
0001cc  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
0001d0  2d312e34
0001d4  2e315c73
0001d8  72635c63
0001dc  6f72655c
0001e0  70627566
0001e4  2e6300  
0001e7  00                DCB      0
                  |L17.488|
0001e8  70627566          DCB      "pbuf_realloc: p != NULL",0
0001ec  5f726561
0001f0  6c6c6f63
0001f4  3a207020
0001f8  213d204e
0001fc  554c4c00
                  |L17.512|
000200  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000204  7274696f
000208  6e202225
00020c  73222066
000210  61696c65
000214  64206174
000218  206c696e
00021c  65202564
000220  20696e20
000224  25730a00
                  |L17.552|
                          DCD      0x000001b5
                  |L17.556|
00022c  70627566          DCB      "pbuf_realloc: sane p->type",0
000230  5f726561
000234  6c6c6f63
000238  3a207361
00023c  6e652070
000240  2d3e7479
000244  706500  
000247  00                DCB      0
                  |L17.584|
                          DCD      0x0000ffff
                  |L17.588|
00024c  67726f77          DCB      "grow < max_u16_t",0
000250  203c206d
000254  61785f75
000258  31365f74
00025c  00      
00025d  00                DCB      0
00025e  00                DCB      0
00025f  00                DCB      0
                  |L17.608|
000260  70627566          DCB      "pbuf_realloc: q != NULL",0
000264  5f726561
000268  6c6c6f63
00026c  3a207120
000270  213d204e
000274  554c4c00
                  |L17.632|
                          DCD      0x000001da
                  |L17.636|
00027c  6d656d5f          DCB      "mem_trim returned q == NULL",0
000280  7472696d
000284  20726574
000288  75726e65
00028c  64207120
000290  3d3d204e
000294  554c4c00

                          AREA ||i.pbuf_ref||, CODE, READONLY, ALIGN=2

                  pbuf_ref PROC
;;;722    void
;;;723    pbuf_ref(struct pbuf *p)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;724    {
000004  e1a04000          MOV      r4,r0
;;;725      SYS_ARCH_DECL_PROTECT(old_level);
;;;726      /* pbuf given? */
;;;727      if (p != NULL) {
000008  e3540000          CMP      r4,#0
00000c  0a000007          BEQ      |L18.48|
;;;728        SYS_ARCH_PROTECT(old_level);
000010  ebfffffe          BL       sys_arch_protect
000014  e1a05000          MOV      r5,r0
;;;729        ++(p->ref);
000018  e1d400be          LDRH     r0,[r4,#0xe]
00001c  e2800001          ADD      r0,r0,#1
000020  e3c00801          BIC      r0,r0,#0x10000
000024  e1c400be          STRH     r0,[r4,#0xe]
;;;730        SYS_ARCH_UNPROTECT(old_level);
000028  e1a00005          MOV      r0,r5
00002c  ebfffffe          BL       sys_arch_unprotect
                  |L18.48|
;;;731      }
;;;732    }
000030  e8bd8070          POP      {r4-r6,pc}
;;;733    
                          ENDP


                          AREA ||i.pbuf_strstr||, CODE, READONLY, ALIGN=2

                  pbuf_strstr PROC
;;;1167   u16_t
;;;1168   pbuf_strstr(struct pbuf* p, const char* substr)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1169   {
000004  e1a06000          MOV      r6,r0
000008  e1a04001          MOV      r4,r1
;;;1170     size_t substr_len;
;;;1171     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
00000c  e3540000          CMP      r4,#0
000010  0a000006          BEQ      |L19.48|
000014  e5d40000          LDRB     r0,[r4,#0]
000018  e3500000          CMP      r0,#0
00001c  0a000003          BEQ      |L19.48|
000020  e1d600b8          LDRH     r0,[r6,#8]
000024  e59f1044          LDR      r1,|L19.112|
000028  e1500001          CMP      r0,r1
00002c  1a000001          BNE      |L19.56|
                  |L19.48|
;;;1172       return 0xFFFF;
000030  e59f0038          LDR      r0,|L19.112|
                  |L19.52|
;;;1173     }
;;;1174     substr_len = strlen(substr);
;;;1175     if (substr_len >= 0xFFFF) {
;;;1176       return 0xFFFF;
;;;1177     }
;;;1178     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1179   }
000034  e8bd8070          POP      {r4-r6,pc}
                  |L19.56|
000038  e1a00004          MOV      r0,r4                 ;1174
00003c  ebfffffe          BL       strlen
000040  e1a05000          MOV      r5,r0                 ;1174
000044  e59f0024          LDR      r0,|L19.112|
000048  e1550000          CMP      r5,r0                 ;1175
00004c  3a000000          BCC      |L19.84|
000050  eafffff7          B        |L19.52|
                  |L19.84|
000054  e1a02805          LSL      r2,r5,#16             ;1178
000058  e1a02822          LSR      r2,r2,#16             ;1178
00005c  e3a03000          MOV      r3,#0                 ;1178
000060  e1a01004          MOV      r1,r4                 ;1178
000064  e1a00006          MOV      r0,r6                 ;1178
000068  ebfffffe          BL       pbuf_memfind
00006c  eafffff0          B        |L19.52|
                          ENDP

                  |L19.112|
                          DCD      0x0000ffff

                          AREA ||i.pbuf_take||, CODE, READONLY, ALIGN=2

                  pbuf_take PROC
;;;965    err_t
;;;966    pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;967    {
000004  e1a05000          MOV      r5,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a08002          MOV      r8,r2
;;;968      struct pbuf *p;
;;;969      u16_t buf_copy_len;
;;;970      u16_t total_copy_len = len;
000010  e1a06008          MOV      r6,r8
;;;971      u16_t copied_total = 0;
000014  e3a0a000          MOV      r10,#0
;;;972    
;;;973      LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
000018  e1a00000          MOV      r0,r0
00001c  e3550000          CMP      r5,#0
000020  1a000008          BNE      |L20.72|
000024  e1a00000          MOV      r0,r0
000028  e28f3f4b          ADR      r3,|L20.348|
00002c  e59f2144          LDR      r2,|L20.376|
000030  e28f1f51          ADR      r1,|L20.380|
000034  e28f0f56          ADR      r0,|L20.404|
000038  ebfffffe          BL       sysprintf
00003c  e1a00000          MOV      r0,r0
000040  e3a00000          MOV      r0,#0
                  |L20.68|
;;;974      LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
;;;975    
;;;976      if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
;;;977        return ERR_ARG;
;;;978      }
;;;979    
;;;980      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;981      for(p = buf; total_copy_len != 0; p = p->next) {
;;;982        LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
;;;983        buf_copy_len = total_copy_len;
;;;984        if (buf_copy_len > p->len) {
;;;985          /* this pbuf cannot hold all remaining data */
;;;986          buf_copy_len = p->len;
;;;987        }
;;;988        /* copy the necessary parts of the buffer */
;;;989        MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
;;;990        total_copy_len -= buf_copy_len;
;;;991        copied_total += buf_copy_len;
;;;992      }
;;;993      LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;994      return ERR_OK;
;;;995    }
000044  e8bd87f0          POP      {r4-r10,pc}
                  |L20.72|
000048  e1a00000          MOV      r0,r0                 ;973
00004c  e1a00000          MOV      r0,r0                 ;974
000050  e3570000          CMP      r7,#0                 ;974
000054  1a000008          BNE      |L20.124|
000058  e1a00000          MOV      r0,r0                 ;974
00005c  e28f30f8          ADR      r3,|L20.348|
000060  e59f2154          LDR      r2,|L20.444|
000064  e28f1f55          ADR      r1,|L20.448|
000068  e28f0f49          ADR      r0,|L20.404|
00006c  ebfffffe          BL       sysprintf
000070  e1a00000          MOV      r0,r0                 ;974
000074  e3a00000          MOV      r0,#0                 ;974
000078  eafffff1          B        |L20.68|
                  |L20.124|
00007c  e1a00000          MOV      r0,r0                 ;974
000080  e3550000          CMP      r5,#0                 ;976
000084  0a000004          BEQ      |L20.156|
000088  e3570000          CMP      r7,#0                 ;976
00008c  0a000002          BEQ      |L20.156|
000090  e1d500b8          LDRH     r0,[r5,#8]            ;976
000094  e1500008          CMP      r0,r8                 ;976
000098  aa000001          BGE      |L20.164|
                  |L20.156|
00009c  e3e0000d          MVN      r0,#0xd               ;977
0000a0  eaffffe7          B        |L20.68|
                  |L20.164|
0000a4  e1a04005          MOV      r4,r5                 ;981
0000a8  ea00001a          B        |L20.280|
                  |L20.172|
0000ac  e1a00000          MOV      r0,r0                 ;982
0000b0  e3540000          CMP      r4,#0                 ;982
0000b4  1a000006          BNE      |L20.212|
0000b8  e1a00000          MOV      r0,r0                 ;982
0000bc  e28f3098          ADR      r3,|L20.348|
0000c0  e59f2114          LDR      r2,|L20.476|
0000c4  e28f1f45          ADR      r1,|L20.480|
0000c8  e28f00c4          ADR      r0,|L20.404|
0000cc  ebfffffe          BL       sysprintf
0000d0  e1a00000          MOV      r0,r0                 ;982
                  |L20.212|
0000d4  e1a00000          MOV      r0,r0                 ;982
0000d8  e1a09006          MOV      r9,r6                 ;983
0000dc  e1d400ba          LDRH     r0,[r4,#0xa]          ;984
0000e0  e1500009          CMP      r0,r9                 ;984
0000e4  aa000000          BGE      |L20.236|
0000e8  e1d490ba          LDRH     r9,[r4,#0xa]          ;986
                  |L20.236|
0000ec  e087100a          ADD      r1,r7,r10             ;989
0000f0  e1a02009          MOV      r2,r9                 ;989
0000f4  e5940004          LDR      r0,[r4,#4]            ;989
0000f8  ebfffffe          BL       __aeabi_memcpy
0000fc  e0460009          SUB      r0,r6,r9              ;990
000100  e1a06800          LSL      r6,r0,#16             ;990
000104  e1a06826          LSR      r6,r6,#16             ;990
000108  e08a0009          ADD      r0,r10,r9             ;991
00010c  e1a0a800          LSL      r10,r0,#16            ;991
000110  e1a0a82a          LSR      r10,r10,#16           ;991
000114  e5944000          LDR      r4,[r4,#0]            ;981
                  |L20.280|
000118  e3560000          CMP      r6,#0                 ;981
00011c  1affffe2          BNE      |L20.172|
000120  e1a00000          MOV      r0,r0                 ;993
000124  e3560000          CMP      r6,#0                 ;993
000128  1a000001          BNE      |L20.308|
00012c  e15a0008          CMP      r10,r8                ;993
000130  0a000006          BEQ      |L20.336|
                  |L20.308|
000134  e1a00000          MOV      r0,r0                 ;993
000138  e28f301c          ADR      r3,|L20.348|
00013c  e59f20b4          LDR      r2,|L20.504|
000140  e28f10b4          ADR      r1,|L20.508|
000144  e28f0048          ADR      r0,|L20.404|
000148  ebfffffe          BL       sysprintf
00014c  e1a00000          MOV      r0,r0                 ;993
                  |L20.336|
000150  e1a00000          MOV      r0,r0                 ;993
000154  e3a00000          MOV      r0,#0                 ;994
000158  eaffffb9          B        |L20.68|
;;;996    
                          ENDP

                  |L20.348|
00015c  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
000160  2d312e34
000164  2e315c73
000168  72635c63
00016c  6f72655c
000170  70627566
000174  2e6300  
000177  00                DCB      0
                  |L20.376|
                          DCD      0x000003cd
                  |L20.380|
00017c  70627566          DCB      "pbuf_take: invalid buf",0
000180  5f74616b
000184  653a2069
000188  6e76616c
00018c  69642062
000190  756600  
000193  00                DCB      0
                  |L20.404|
000194  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000198  7274696f
00019c  6e202225
0001a0  73222066
0001a4  61696c65
0001a8  64206174
0001ac  206c696e
0001b0  65202564
0001b4  20696e20
0001b8  25730a00
                  |L20.444|
                          DCD      0x000003ce
                  |L20.448|
0001c0  70627566          DCB      "pbuf_take: invalid dataptr",0
0001c4  5f74616b
0001c8  653a2069
0001cc  6e76616c
0001d0  69642064
0001d4  61746170
0001d8  747200  
0001db  00                DCB      0
                  |L20.476|
                          DCD      0x000003d6
                  |L20.480|
0001e0  70627566          DCB      "pbuf_take: invalid pbuf",0
0001e4  5f74616b
0001e8  653a2069
0001ec  6e76616c
0001f0  69642070
0001f4  62756600
                  |L20.504|
                          DCD      0x000003e1
                  |L20.508|
0001fc  64696420          DCB      "did not copy all data",0
000200  6e6f7420
000204  636f7079
000208  20616c6c
00020c  20646174
000210  6100    
000212  00                DCB      0
000213  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=0

                  pbuf_free_ooseq_pending
000000  00                DCB      0x00
