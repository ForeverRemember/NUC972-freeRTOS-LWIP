; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\pbuf.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pbuf.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\pbuf.crf lwip-1.4.1\src\core\pbuf.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  pbuf_free_ooseq_callback PROC
;;;142    static void
;;;143    pbuf_free_ooseq_callback(void *arg)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;144    {
000004  ebfffffe          BL       sys_arch_protect
000008  e59f12a4          LDR      r1,|L1.692|
00000c  e3a05000          MOV      r5,#0
000010  e5c15000          STRB     r5,[r1,#0]  ; pbuf_free_ooseq_pending
000014  ebfffffe          BL       sys_arch_unprotect
000018  e59f0298          LDR      r0,|L1.696|
00001c  e5904000          LDR      r4,[r0,#0]  ; tcp_active_pcbs
                  |L1.32|
000020  e3540000          CMP      r4,#0
;;;145      LWIP_UNUSED_ARG(arg);
;;;146      pbuf_free_ooseq();
;;;147    }
000024  08bd8070          POPEQ    {r4-r6,pc}
000028  e5940074          LDR      r0,[r4,#0x74]
00002c  e3500000          CMP      r0,#0
000030  0594400c          LDREQ    r4,[r4,#0xc]
000034  0afffff9          BEQ      |L1.32|
000038  ebfffffe          BL       tcp_segs_free
00003c  e5845074          STR      r5,[r4,#0x74]
000040  e8bd8070          POP      {r4-r6,pc}
;;;148    #endif /* !NO_SYS */
                          ENDP

                  pbuf_pool_is_empty PROC
;;;151    static void
;;;152    pbuf_pool_is_empty(void)
000044  e92d4070          PUSH     {r4-r6,lr}
;;;153    {
;;;154    #ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
;;;155      SYS_ARCH_DECL_PROTECT(old_level);
;;;156      SYS_ARCH_PROTECT(old_level);
;;;157      pbuf_free_ooseq_pending = 1;
;;;158      SYS_ARCH_UNPROTECT(old_level);
;;;159    #else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;160      u8_t queued;
;;;161      SYS_ARCH_DECL_PROTECT(old_level);
;;;162      SYS_ARCH_PROTECT(old_level);
000048  ebfffffe          BL       sys_arch_protect
;;;163      queued = pbuf_free_ooseq_pending;
00004c  e59f5260          LDR      r5,|L1.692|
000050  e5d54000          LDRB     r4,[r5,#0]  ; pbuf_free_ooseq_pending
;;;164      pbuf_free_ooseq_pending = 1;
000054  e3a01001          MOV      r1,#1
000058  e5c51000          STRB     r1,[r5,#0]  ; pbuf_free_ooseq_pending
;;;165      SYS_ARCH_UNPROTECT(old_level);
00005c  ebfffffe          BL       sys_arch_unprotect
;;;166    
;;;167      if(!queued) {
000060  e3540000          CMP      r4,#0
;;;168        /* queue a call to pbuf_free_ooseq if not already queued */
;;;169        PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
;;;170      }
;;;171    #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;172    }
000064  18bd8070          POPNE    {r4-r6,pc}
000068  e3a02000          MOV      r2,#0                 ;169
00006c  e59f0248          LDR      r0,|L1.700|
000070  e1a01002          MOV      r1,r2                 ;169
000074  ebfffffe          BL       tcpip_callback_with_block
000078  e3500000          CMP      r0,#0                 ;169
00007c  08bd8070          POPEQ    {r4-r6,pc}
000080  ebfffffe          BL       sys_arch_protect
000084  e3a01000          MOV      r1,#0                 ;169
000088  e5c51000          STRB     r1,[r5,#0]            ;169  ; pbuf_free_ooseq_pending
00008c  e8bd4070          POP      {r4-r6,lr}            ;169
000090  eafffffe          B        sys_arch_unprotect
;;;173    #endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
                          ENDP

                  pbuf_free PROC
;;;617    u8_t
;;;618    pbuf_free(struct pbuf *p)
000094  e92d41f0          PUSH     {r4-r8,lr}
;;;619    {
000098  e1b04000          MOVS     r4,r0
00009c  0a000012          BEQ      |L1.236|
;;;620      u16_t type;
;;;621      struct pbuf *q;
;;;622      u8_t count;
;;;623    
;;;624      if (p == NULL) {
;;;625        LWIP_ASSERT("p != NULL", p != NULL);
;;;626        /* if assertions are disabled, proceed with debug output */
;;;627        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;628          ("pbuf_free(p == NULL) was called.\n"));
;;;629        return 0;
;;;630      }
;;;631      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;632    
;;;633      PERF_START;
;;;634    
;;;635      LWIP_ASSERT("pbuf_free: sane type",
0000a0  e5d4000c          LDRB     r0,[r4,#0xc]
0000a4  e3500000          CMP      r0,#0
0000a8  13500001          CMPNE    r0,#1
0000ac  0a000007          BEQ      |L1.208|
0000b0  e3500002          CMP      r0,#2
0000b4  13500003          CMPNE    r0,#3
0000b8  0a000004          BEQ      |L1.208|
0000bc  e59f2218          LDR      r2,|L1.732|
0000c0  e28f3f7e          ADR      r3,|L1.704|
0000c4  e28f1f85          ADR      r1,|L1.736|
0000c8  e28f0f8a          ADR      r0,|L1.760|
0000cc  ebfffffe          BL       sysprintf
                  |L1.208|
;;;636        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;637        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;638    
;;;639      count = 0;
0000d0  e3a06000          MOV      r6,#0
                  |L1.212|
;;;640      /* de-allocate all consecutive pbufs from the head of the chain that
;;;641       * obtain a zero reference count after decrementing*/
;;;642      while (p != NULL) {
;;;643        u16_t ref;
;;;644        SYS_ARCH_DECL_PROTECT(old_level);
;;;645        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;646         * we must protect it. We put the new ref into a local variable to prevent
;;;647         * further protection. */
;;;648        SYS_ARCH_PROTECT(old_level);
0000d4  ebfffffe          BL       sys_arch_protect
0000d8  e1a07000          MOV      r7,r0
;;;649        /* all pbufs in a chain are referenced at least once */
;;;650        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
0000dc  e1d400be          LDRH     r0,[r4,#0xe]
0000e0  e3500000          CMP      r0,#0
0000e4  1a00000c          BNE      |L1.284|
0000e8  ea000006          B        |L1.264|
                  |L1.236|
0000ec  e59f222c          LDR      r2,|L1.800|
0000f0  e28f3f72          ADR      r3,|L1.704|
0000f4  e28f1f8a          ADR      r1,|L1.804|
0000f8  e28f0f7e          ADR      r0,|L1.760|
0000fc  ebfffffe          BL       sysprintf
000100  e3a00000          MOV      r0,#0                 ;629
;;;651        /* decrease reference count (number of pointers to pbuf) */
;;;652        ref = --(p->ref);
;;;653        SYS_ARCH_UNPROTECT(old_level);
;;;654        /* this pbuf is no longer referenced to? */
;;;655        if (ref == 0) {
;;;656          /* remember next pbuf in chain for next iteration */
;;;657          q = p->next;
;;;658          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;659          type = p->type;
;;;660    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;661          /* is this a custom pbuf? */
;;;662          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
;;;663            struct pbuf_custom *pc = (struct pbuf_custom*)p;
;;;664            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
;;;665            pc->custom_free_function(p);
;;;666          } else
;;;667    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;668          {
;;;669            /* is this a pbuf from the pool? */
;;;670            if (type == PBUF_POOL) {
;;;671              memp_free(MEMP_PBUF_POOL, p);
;;;672            /* is this a ROM or RAM referencing pbuf? */
;;;673            } else if (type == PBUF_ROM || type == PBUF_REF) {
;;;674              memp_free(MEMP_PBUF, p);
;;;675            /* type == PBUF_RAM */
;;;676            } else {
;;;677              mem_free(p);
;;;678            }
;;;679          }
;;;680          count++;
;;;681          /* proceed to next pbuf */
;;;682          p = q;
;;;683        /* p->ref > 0, this pbuf is still referenced to */
;;;684        /* (and so the remaining pbufs in chain as well) */
;;;685        } else {
;;;686          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;687          /* stop walking through the chain */
;;;688          p = NULL;
;;;689        }
;;;690      }
;;;691      PERF_STOP("pbuf_free");
;;;692      /* return number of de-allocated pbufs */
;;;693      return count;
;;;694    }
000104  e8bd81f0          POP      {r4-r8,pc}
                  |L1.264|
000108  e59f2220          LDR      r2,|L1.816|
00010c  e28f3f6b          ADR      r3,|L1.704|
000110  e28f1f87          ADR      r1,|L1.820|
000114  e28f0f77          ADR      r0,|L1.760|
000118  ebfffffe          BL       sysprintf
                  |L1.284|
00011c  e1d400be          LDRH     r0,[r4,#0xe]          ;652
000120  e2400001          SUB      r0,r0,#1              ;652
000124  e1a05800          LSL      r5,r0,#16             ;652
000128  e1a05825          LSR      r5,r5,#16             ;652
00012c  e1a00007          MOV      r0,r7                 ;653
000130  e1c450be          STRH     r5,[r4,#0xe]          ;652
000134  ebfffffe          BL       sys_arch_unprotect
000138  e3550000          CMP      r5,#0                 ;655
00013c  1a000010          BNE      |L1.388|
000140  e5d4000c          LDRB     r0,[r4,#0xc]          ;659
000144  e5945000          LDR      r5,[r4,#0]            ;657
000148  e3500003          CMP      r0,#3                 ;670
00014c  01a01004          MOVEQ    r1,r4                 ;671
000150  03a00009          MOVEQ    r0,#9                 ;671
000154  0a00000c          BEQ      |L1.396|
000158  e3500001          CMP      r0,#1                 ;673
00015c  13500002          CMPNE    r0,#2                 ;673
000160  01a01004          MOVEQ    r1,r4                 ;674
000164  03a00008          MOVEQ    r0,#8                 ;674
000168  0a000007          BEQ      |L1.396|
00016c  e1a00004          MOV      r0,r4                 ;677
000170  ebfffffe          BL       mem_free
                  |L1.372|
000174  e2860001          ADD      r0,r6,#1              ;680
000178  e1b04005          MOVS     r4,r5                 ;682
00017c  e20060ff          AND      r6,r0,#0xff           ;680
000180  1affffd3          BNE      |L1.212|
                  |L1.388|
000184  e1a00006          MOV      r0,r6                 ;693
000188  e8bd81f0          POP      {r4-r8,pc}
                  |L1.396|
00018c  ebfffffe          BL       memp_free
000190  eafffff7          B        |L1.372|
;;;695    
                          ENDP

                  pbuf_alloc PROC
;;;206    struct pbuf *
;;;207    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000194  e92d5ff0          PUSH     {r4-r12,lr}
;;;208    {
;;;209      struct pbuf *p, *q, *r;
;;;210      u16_t offset;
;;;211      s32_t rem_len; /* remaining length */
;;;212      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
;;;213    
;;;214      /* determine header offset */
;;;215      switch (layer) {
000198  e3500000          CMP      r0,#0
00019c  e1a08002          MOV      r8,r2                 ;208
0001a0  e1a05001          MOV      r5,r1                 ;208
;;;216      case PBUF_TRANSPORT:
;;;217        /* add room for transport (often TCP) layer header */
;;;218        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
0001a4  03a06038          MOVEQ    r6,#0x38
0001a8  0a00000e          BEQ      |L1.488|
0001ac  e3500001          CMP      r0,#1                 ;215
;;;219        break;
;;;220      case PBUF_IP:
;;;221        /* add room for IP layer header */
;;;222        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
0001b0  03a06024          MOVEQ    r6,#0x24
0001b4  0a00000b          BEQ      |L1.488|
0001b8  e3500002          CMP      r0,#2                 ;215
;;;223        break;
;;;224      case PBUF_LINK:
;;;225        /* add room for link layer header */
;;;226        offset = PBUF_LINK_HLEN;
0001bc  03a06010          MOVEQ    r6,#0x10
0001c0  0a000008          BEQ      |L1.488|
0001c4  e3500003          CMP      r0,#3                 ;215
;;;227        break;
;;;228      case PBUF_RAW:
;;;229        offset = 0;
;;;230        break;
;;;231      default:
;;;232        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
0001c8  128f30f0          ADRNE    r3,|L1.704|
0001cc  13a020e8          MOVNE    r2,#0xe8
0001d0  128f1f5d          ADRNE    r1,|L1.844|
0001d4  03a06000          MOVEQ    r6,#0                 ;229
0001d8  0a000002          BEQ      |L1.488|
                  |L1.476|
0001dc  e28f0f45          ADR      r0,|L1.760|
0001e0  ebfffffe          BL       sysprintf
0001e4  ea0000d6          B        |L1.1348|
                  |L1.488|
;;;233        return NULL;
;;;234      }
;;;235    
;;;236      switch (type) {
0001e8  e3580000          CMP      r8,#0
0001ec  e3a0b001          MOV      r11,#1                ;208
0001f0  e3a0a000          MOV      r10,#0                ;208
0001f4  0a0000b3          BEQ      |L1.1224|
0001f8  e3580001          CMP      r8,#1
0001fc  13580002          CMPNE    r8,#2
000200  0a0000c2          BEQ      |L1.1296|
000204  e3580003          CMP      r8,#3
;;;237      case PBUF_POOL:
;;;238        /* allocate head of pbuf chain into p */
;;;239        p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;240        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
;;;241        if (p == NULL) {
;;;242          PBUF_POOL_IS_EMPTY();
;;;243          return NULL;
;;;244        }
;;;245        p->type = type;
;;;246        p->next = NULL;
;;;247    
;;;248        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;249        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;250        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;251                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;252        /* the total length of the pbuf chain is the requested size */
;;;253        p->tot_len = length;
;;;254        /* set the length of the first pbuf in the chain */
;;;255        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;256        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;257                    ((u8_t*)p->payload + p->len <=
;;;258                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;259        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;260          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;261        /* set reference count (needed here in case we fail) */
;;;262        p->ref = 1;
;;;263    
;;;264        /* now allocate the tail of the pbuf chain */
;;;265    
;;;266        /* remember first pbuf for linkage in next iteration */
;;;267        r = p;
;;;268        /* remaining length to be allocated */
;;;269        rem_len = length - p->len;
;;;270        /* any remaining pbufs to be allocated? */
;;;271        while (rem_len > 0) {
;;;272          q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;273          if (q == NULL) {
;;;274            PBUF_POOL_IS_EMPTY();
;;;275            /* free chain so far allocated */
;;;276            pbuf_free(p);
;;;277            /* bail out unsuccesfully */
;;;278            return NULL;
;;;279          }
;;;280          q->type = type;
;;;281          q->flags = 0;
;;;282          q->next = NULL;
;;;283          /* make previous pbuf point to this pbuf */
;;;284          r->next = q;
;;;285          /* set total length of this pbuf and next in chain */
;;;286          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;287          q->tot_len = (u16_t)rem_len;
;;;288          /* this pbuf length is pool size, unless smaller sized tail */
;;;289          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;290          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;291          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;292                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;293          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;294                      ((u8_t*)p->payload + p->len <=
;;;295                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;296          q->ref = 1;
;;;297          /* calculate remaining length to be allocated */
;;;298          rem_len -= q->len;
;;;299          /* remember this pbuf for linkage in next iteration */
;;;300          r = q;
;;;301        }
;;;302        /* end of chain */
;;;303        /*r->next = NULL;*/
;;;304    
;;;305        break;
;;;306      case PBUF_RAM:
;;;307        /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;308        p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;309        if (p == NULL) {
;;;310          return NULL;
;;;311        }
;;;312        /* Set up internal structure of the pbuf. */
;;;313        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;314        p->len = p->tot_len = length;
;;;315        p->next = NULL;
;;;316        p->type = type;
;;;317    
;;;318        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;319               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;320        break;
;;;321      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;322      case PBUF_ROM:
;;;323      /* pbuf references existing (externally allocated) RAM payload? */
;;;324      case PBUF_REF:
;;;325        /* only allocate memory for the pbuf structure */
;;;326        p = (struct pbuf *)memp_malloc(MEMP_PBUF);
;;;327        if (p == NULL) {
;;;328          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;329                      ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;330                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;331          return NULL;
;;;332        }
;;;333        /* caller must set this field properly, afterwards */
;;;334        p->payload = NULL;
;;;335        p->len = p->tot_len = length;
;;;336        p->next = NULL;
;;;337        p->type = type;
;;;338        break;
;;;339      default:
;;;340        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
000208  128f30b0          ADRNE    r3,|L1.704|
00020c  13a02f55          MOVNE    r2,#0x154
000210  128f1e15          ADRNE    r1,|L1.872|
000214  1afffff0          BNE      |L1.476|
000218  e3a00009          MOV      r0,#9                 ;239
00021c  ebfffffe          BL       memp_malloc
000220  e1b04000          MOVS     r4,r0                 ;239
000224  0a000071          BEQ      |L1.1008|
000228  e0840006          ADD      r0,r4,r6              ;249
00022c  e2800013          ADD      r0,r0,#0x13           ;249
000230  e3c01003          BIC      r1,r0,#3              ;249
000234  e2860003          ADD      r0,r6,#3              ;255
000238  e3c00003          BIC      r0,r0,#3              ;255
00023c  e2606e42          RSB      r6,r0,#0x420          ;255
000240  e5c4800c          STRB     r8,[r4,#0xc]          ;245
000244  e1560005          CMP      r6,r5                 ;255
000248  e584a000          STR      r10,[r4,#0]           ;246
00024c  e5841004          STR      r1,[r4,#4]            ;249
000250  d1a00006          MOVLE    r0,r6                 ;255
000254  c1a00005          MOVGT    r0,r5                 ;255
000258  e1c450b8          STRH     r5,[r4,#8]            ;253
00025c  e1c400ba          STRH     r0,[r4,#0xa]          ;255
000260  e0800001          ADD      r0,r0,r1              ;256
000264  e2849e43          ADD      r9,r4,#0x430          ;256
000268  e1500009          CMP      r0,r9                 ;256
00026c  9a000004          BLS      |L1.644|
000270  e28f3048          ADR      r3,|L1.704|
000274  e3a02c01          MOV      r2,#0x100             ;256
000278  e28f1f41          ADR      r1,|L1.900|
00027c  e28f0074          ADR      r0,|L1.760|
000280  ebfffffe          BL       sysprintf
                  |L1.644|
000284  e3560000          CMP      r6,#0                 ;259
000288  ca000004          BGT      |L1.672|
00028c  e59f2124          LDR      r2,|L1.952|
000290  e28f3028          ADR      r3,|L1.704|
000294  e28f1f48          ADD      r1,pc,#0x48, 30 ; #0x120;259
000298  e28f0058          ADR      r0,|L1.760|
00029c  ebfffffe          BL       sysprintf
                  |L1.672|
0002a0  e1c4b0be          STRH     r11,[r4,#0xe]         ;262
0002a4  e1d400ba          LDRH     r0,[r4,#0xa]          ;269
0002a8  e1a07004          MOV      r7,r4                 ;267
0002ac  e0456000          SUB      r6,r5,r0              ;269
0002b0  ea00007d          B        |L1.1196|
                  |L1.692|
                          DCD      ||.data||
                  |L1.696|
                          DCD      tcp_active_pcbs
                  |L1.700|
                          DCD      pbuf_free_ooseq_callback
                  |L1.704|
0002c0  6c776970          DCB      "lwip-1.4.1\\src\\core\\pbuf.c",0
0002c4  2d312e34
0002c8  2e315c73
0002cc  72635c63
0002d0  6f72655c
0002d4  70627566
0002d8  2e6300  
0002db  00                DCB      0
                  |L1.732|
                          DCD      0x0000027b
                  |L1.736|
0002e0  70627566          DCB      "pbuf_free: sane type",0
0002e4  5f667265
0002e8  653a2073
0002ec  616e6520
0002f0  74797065
0002f4  00      
0002f5  00                DCB      0
0002f6  00                DCB      0
0002f7  00                DCB      0
                  |L1.760|
0002f8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0002fc  7274696f
000300  6e202225
000304  73222066
000308  61696c65
00030c  64206174
000310  206c696e
000314  65202564
000318  20696e20
00031c  25730a00
                  |L1.800|
                          DCD      0x00000271
                  |L1.804|
000324  7020213d          DCB      "p != NULL",0
000328  204e554c
00032c  4c00    
00032e  00                DCB      0
00032f  00                DCB      0
                  |L1.816|
                          DCD      0x0000028a
                  |L1.820|
000334  70627566          DCB      "pbuf_free: p->ref > 0",0
000338  5f667265
00033c  653a2070
000340  2d3e7265
000344  66203e20
000348  3000    
00034a  00                DCB      0
00034b  00                DCB      0
                  |L1.844|
00034c  70627566          DCB      "pbuf_alloc: bad pbuf layer",0
000350  5f616c6c
000354  6f633a20
000358  62616420
00035c  70627566
000360  206c6179
000364  657200  
000367  00                DCB      0
                  |L1.872|
000368  70627566          DCB      "pbuf_alloc: erroneous type",0
00036c  5f616c6c
000370  6f633a20
000374  6572726f
000378  6e656f75
00037c  73207479
000380  706500  
000383  00                DCB      0
                  |L1.900|
000384  63686563          DCB      "check p->payload + p->len does not overflow pbuf",0
000388  6b20702d
00038c  3e706179
000390  6c6f6164
000394  202b2070
000398  2d3e6c65
00039c  6e20646f
0003a0  6573206e
0003a4  6f74206f
0003a8  76657266
0003ac  6c6f7720
0003b0  70627566
0003b4  00      
0003b5  00                DCB      0
0003b6  00                DCB      0
0003b7  00                DCB      0
                  |L1.952|
                          DCD      0x00000103
0003bc  50425546          DCB      "PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",0
0003c0  5f504f4f
0003c4  4c5f4255
0003c8  4653495a
0003cc  45206d75
0003d0  73742062
0003d4  65206269
0003d8  67676572
0003dc  20746861
0003e0  6e204d45
0003e4  4d5f414c
0003e8  49474e4d
0003ec  454e5400
                  |L1.1008|
0003f0  ebfffffe          BL       pbuf_pool_is_empty
0003f4  ea000052          B        |L1.1348|
                  |L1.1016|
0003f8  e3a00009          MOV      r0,#9                 ;272
0003fc  ebfffffe          BL       memp_malloc
000400  e1b05000          MOVS     r5,r0                 ;272
000404  0a00002b          BEQ      |L1.1208|
000408  e5c5800c          STRB     r8,[r5,#0xc]          ;280
00040c  e59f027c          LDR      r0,|L1.1680|
000410  e5c5a00d          STRB     r10,[r5,#0xd]         ;281
000414  e585a000          STR      r10,[r5,#0]           ;284
000418  e1500006          CMP      r0,r6                 ;286
00041c  e5875000          STR      r5,[r7,#0]            ;286
000420  ca000004          BGT      |L1.1080|
000424  e59f2268          LDR      r2,|L1.1684|
000428  e24f3e17          ADR      r3,|L1.704|
00042c  e28f1f99          ADR      r1,|L1.1688|
000430  e24f0d05          ADR      r0,|L1.760|
000434  ebfffffe          BL       sysprintf
                  |L1.1080|
000438  e1a00806          LSL      r0,r6,#16             ;287
00043c  e1a00820          LSR      r0,r0,#16             ;287
000440  e3500e42          CMP      r0,#0x420             ;289
000444  e1c500b8          STRH     r0,[r5,#8]            ;287
000448  23a00e42          MOVCS    r0,#0x420             ;289
00044c  e1c500ba          STRH     r0,[r5,#0xa]          ;289
000450  e2850010          ADD      r0,r5,#0x10           ;290
000454  e3100003          TST      r0,#3                 ;291
000458  e5850004          STR      r0,[r5,#4]            ;290
00045c  0a000004          BEQ      |L1.1140|
000460  e59f2244          LDR      r2,|L1.1708|
000464  e24f3f6b          ADR      r3,|L1.704|
000468  e28f1d09          ADR      r1,|L1.1712|
00046c  e24f0f5f          ADR      r0,|L1.760|
000470  ebfffffe          BL       sysprintf
                  |L1.1140|
000474  e1d410ba          LDRH     r1,[r4,#0xa]          ;293
000478  e5940004          LDR      r0,[r4,#4]            ;293
00047c  e0800001          ADD      r0,r0,r1              ;293
000480  e1500009          CMP      r0,r9                 ;293
000484  9a000004          BLS      |L1.1180|
000488  e59f2250          LDR      r2,|L1.1760|
00048c  e24f3f75          ADR      r3,|L1.704|
000490  e24f1f45          ADR      r1,|L1.900|
000494  e24f0f69          ADR      r0,|L1.760|
000498  ebfffffe          BL       sysprintf
                  |L1.1180|
00049c  e1c5b0be          STRH     r11,[r5,#0xe]         ;296
0004a0  e1d500ba          LDRH     r0,[r5,#0xa]          ;298
0004a4  e1a07005          MOV      r7,r5                 ;300
0004a8  e0466000          SUB      r6,r6,r0              ;298
                  |L1.1196|
0004ac  e3560000          CMP      r6,#0                 ;271
0004b0  caffffd0          BGT      |L1.1016|
0004b4  ea00001e          B        |L1.1332|
                  |L1.1208|
0004b8  ebfffffe          BL       pbuf_pool_is_empty
0004bc  e1a00004          MOV      r0,r4                 ;276
0004c0  ebfffffe          BL       pbuf_free
0004c4  ea00001e          B        |L1.1348|
                  |L1.1224|
0004c8  e2860013          ADD      r0,r6,#0x13           ;308
0004cc  e2851003          ADD      r1,r5,#3              ;308
0004d0  e3c00003          BIC      r0,r0,#3              ;308
0004d4  e3c11003          BIC      r1,r1,#3              ;308
0004d8  e0800001          ADD      r0,r0,r1              ;308
0004dc  e3c00803          BIC      r0,r0,#0x30000        ;308
0004e0  ebfffffe          BL       mem_malloc
0004e4  e2504000          SUBS     r4,r0,#0              ;308
;;;341        return NULL;
;;;342      }
;;;343      /* set reference count */
;;;344      p->ref = 1;
;;;345      /* set flags */
;;;346      p->flags = 0;
;;;347      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;348      return p;
;;;349    }
0004e8  08bd9ff0          POPEQ    {r4-r12,pc}
0004ec  e0840006          ADD      r0,r4,r6              ;313
0004f0  e2800013          ADD      r0,r0,#0x13           ;313
0004f4  e3c00003          BIC      r0,r0,#3              ;313
0004f8  e5840004          STR      r0,[r4,#4]            ;313
0004fc  e1c450b8          STRH     r5,[r4,#8]            ;314
000500  e1c450ba          STRH     r5,[r4,#0xa]          ;314
000504  e584a000          STR      r10,[r4,#0]           ;315
000508  e5c4a00c          STRB     r10,[r4,#0xc]         ;316
00050c  ea000008          B        |L1.1332|
                  |L1.1296|
000510  e3a00008          MOV      r0,#8                 ;326
000514  ebfffffe          BL       memp_malloc
000518  e1b04000          MOVS     r4,r0                 ;326
00051c  0a000008          BEQ      |L1.1348|
000520  e584a004          STR      r10,[r4,#4]           ;334
000524  e1c450b8          STRH     r5,[r4,#8]            ;335
000528  e1c450ba          STRH     r5,[r4,#0xa]          ;335
00052c  e584a000          STR      r10,[r4,#0]           ;336
000530  e5c4800c          STRB     r8,[r4,#0xc]          ;337
                  |L1.1332|
000534  e1c4b0be          STRH     r11,[r4,#0xe]         ;344
000538  e1a00004          MOV      r0,r4                 ;348
00053c  e5c4a00d          STRB     r10,[r4,#0xd]         ;346
000540  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.1348|
000544  e3a00000          MOV      r0,#0                 ;331
000548  e8bd9ff0          POP      {r4-r12,pc}
;;;350    
                          ENDP

                  pbuf_realloc PROC
;;;429    void
;;;430    pbuf_realloc(struct pbuf *p, u16_t new_len)
00054c  e92d41f0          PUSH     {r4-r8,lr}
;;;431    {
000550  e1b04000          MOVS     r4,r0
000554  e1a05001          MOV      r5,r1
000558  1a000004          BNE      |L1.1392|
;;;432      struct pbuf *q;
;;;433      u16_t rem_len; /* remaining length */
;;;434      s32_t grow;
;;;435    
;;;436      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
00055c  e24f3fa9          ADR      r3,|L1.704|
000560  e3a02f6d          MOV      r2,#0x1b4
000564  e28f1f5e          ADR      r1,|L1.1764|
000568  e24f0f9e          ADR      r0,|L1.760|
00056c  ebfffffe          BL       sysprintf
                  |L1.1392|
;;;437      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
000570  e5d4000c          LDRB     r0,[r4,#0xc]
000574  e3500003          CMP      r0,#3
000578  13500001          CMPNE    r0,#1
00057c  0a000007          BEQ      |L1.1440|
000580  e3500000          CMP      r0,#0
000584  13500002          CMPNE    r0,#2
000588  0a000004          BEQ      |L1.1440|
00058c  e59f2168          LDR      r2,|L1.1788|
000590  e24f3fb6          ADR      r3,|L1.704|
000594  e28f1f59          ADR      r1,|L1.1792|
000598  e24f0faa          ADR      r0,|L1.760|
00059c  ebfffffe          BL       sysprintf
                  |L1.1440|
;;;438                  p->type == PBUF_ROM ||
;;;439                  p->type == PBUF_RAM ||
;;;440                  p->type == PBUF_REF);
;;;441    
;;;442      /* desired length larger than current length? */
;;;443      if (new_len >= p->tot_len) {
0005a0  e1d400b8          LDRH     r0,[r4,#8]
0005a4  e1500005          CMP      r0,r5
;;;444        /* enlarging not yet supported */
;;;445        return;
;;;446      }
;;;447    
;;;448      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;449       * (which may be negative in case of shrinking) */
;;;450      grow = new_len - p->tot_len;
;;;451    
;;;452      /* first, step over any pbufs that should remain in the chain */
;;;453      rem_len = new_len;
;;;454      q = p;
;;;455      /* should this pbuf be kept? */
;;;456      while (rem_len > q->len) {
;;;457        /* decrease remaining length by pbuf length */
;;;458        rem_len -= q->len;
;;;459        /* decrease total length indicator */
;;;460        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
0005a8  859f80e0          LDRHI    r8,|L1.1680|
0005ac  80456000          SUBHI    r6,r5,r0              ;450
;;;461        q->tot_len += (u16_t)grow;
0005b0  80067008          ANDHI    r7,r6,r8
;;;462        /* proceed to next pbuf in chain */
;;;463        q = q->next;
;;;464        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
;;;465      }
;;;466      /* we have now reached the new last pbuf (in q) */
;;;467      /* rem_len == desired length for pbuf q */
;;;468    
;;;469      /* shrink allocated memory for PBUF_RAM */
;;;470      /* (other types merely adjust their length fields */
;;;471      if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
;;;472        /* reallocate and adjust the length of the pbuf that will be split */
;;;473        q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
;;;474        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
;;;475      }
;;;476      /* adjust length fields for new last pbuf */
;;;477      q->len = rem_len;
;;;478      q->tot_len = q->len;
;;;479    
;;;480      /* any remaining pbufs in chain? */
;;;481      if (q->next != NULL) {
;;;482        /* free remaining pbufs in chain */
;;;483        pbuf_free(q->next);
;;;484      }
;;;485      /* q is last packet in chain */
;;;486      q->next = NULL;
;;;487    
;;;488    }
0005b4  98bd81f0          POPLS    {r4-r8,pc}
0005b8  ea000014          B        |L1.1552|
                  |L1.1468|
0005bc  e0450000          SUB      r0,r5,r0              ;458
0005c0  e1a05800          LSL      r5,r0,#16             ;458
0005c4  e1560008          CMP      r6,r8                 ;460
0005c8  e1a05825          LSR      r5,r5,#16             ;458
0005cc  ba000004          BLT      |L1.1508|
0005d0  e24f3fc6          ADR      r3,|L1.704|
0005d4  e3a02f73          MOV      r2,#0x1cc             ;460
0005d8  e28f1f4f          ADR      r1,|L1.1820|
0005dc  e24f0fbb          ADR      r0,|L1.760|
0005e0  ebfffffe          BL       sysprintf
                  |L1.1508|
0005e4  e1d400b8          LDRH     r0,[r4,#8]            ;461
0005e8  e0800007          ADD      r0,r0,r7              ;461
0005ec  e1c400b8          STRH     r0,[r4,#8]            ;461
0005f0  e5944000          LDR      r4,[r4,#0]            ;463
0005f4  e3540000          CMP      r4,#0                 ;464
0005f8  1a000004          BNE      |L1.1552|
0005fc  e24f3fd1          ADR      r3,|L1.704|
000600  e3a02e1d          MOV      r2,#0x1d0             ;464
000604  e28f1f49          ADR      r1,|L1.1840|
000608  e24f0fc6          ADR      r0,|L1.760|
00060c  ebfffffe          BL       sysprintf
                  |L1.1552|
000610  e1d400ba          LDRH     r0,[r4,#0xa]          ;456
000614  e1500005          CMP      r0,r5                 ;456
000618  3affffe7          BCC      |L1.1468|
00061c  e5d4000c          LDRB     r0,[r4,#0xc]          ;471
000620  e3500000          CMP      r0,#0                 ;471
000624  1a000011          BNE      |L1.1648|
000628  e1d400ba          LDRH     r0,[r4,#0xa]          ;471
00062c  e1500005          CMP      r0,r5                 ;471
000630  0a00000e          BEQ      |L1.1648|
000634  e1d400b4          LDRH     r0,[r4,#4]            ;473
000638  e0400004          SUB      r0,r0,r4              ;473
00063c  e1a00800          LSL      r0,r0,#16             ;473
000640  e1a00820          LSR      r0,r0,#16             ;473
000644  e0800005          ADD      r0,r0,r5              ;473
000648  e3c01801          BIC      r1,r0,#0x10000        ;473
00064c  e1a00004          MOV      r0,r4                 ;473
000650  ebfffffe          BL       mem_trim
000654  e1b04000          MOVS     r4,r0                 ;473
000658  1a000004          BNE      |L1.1648|
00065c  e59f20e4          LDR      r2,|L1.1864|
000660  e24f3fea          ADR      r3,|L1.704|
000664  e28f10e0          ADR      r1,|L1.1868|
000668  e24f0fde          ADR      r0,|L1.760|
00066c  ebfffffe          BL       sysprintf
                  |L1.1648|
000670  e1c450ba          STRH     r5,[r4,#0xa]          ;477
000674  e1c450b8          STRH     r5,[r4,#8]            ;478
000678  e5940000          LDR      r0,[r4,#0]            ;481
00067c  e3500000          CMP      r0,#0                 ;481
000680  1bfffffe          BLNE     pbuf_free
000684  e3a00000          MOV      r0,#0                 ;486
000688  e5840000          STR      r0,[r4,#0]            ;486
00068c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1680|
                          DCD      0x0000ffff
                  |L1.1684|
                          DCD      0x0000011e
                  |L1.1688|
000698  72656d5f          DCB      "rem_len < max_u16_t",0
00069c  6c656e20
0006a0  3c206d61
0006a4  785f7531
0006a8  365f7400
                  |L1.1708|
                          DCD      0x00000123
                  |L1.1712|
0006b0  70627566          DCB      "pbuf_alloc: pbuf q->payload properly aligned",0
0006b4  5f616c6c
0006b8  6f633a20
0006bc  70627566
0006c0  20712d3e
0006c4  7061796c
0006c8  6f616420
0006cc  70726f70
0006d0  65726c79
0006d4  20616c69
0006d8  676e6564
0006dc  00      
0006dd  00                DCB      0
0006de  00                DCB      0
0006df  00                DCB      0
                  |L1.1760|
                          DCD      0x00000125
                  |L1.1764|
0006e4  70627566          DCB      "pbuf_realloc: p != NULL",0
0006e8  5f726561
0006ec  6c6c6f63
0006f0  3a207020
0006f4  213d204e
0006f8  554c4c00
                  |L1.1788|
                          DCD      0x000001b5
                  |L1.1792|
000700  70627566          DCB      "pbuf_realloc: sane p->type",0
000704  5f726561
000708  6c6c6f63
00070c  3a207361
000710  6e652070
000714  2d3e7479
000718  706500  
00071b  00                DCB      0
                  |L1.1820|
00071c  67726f77          DCB      "grow < max_u16_t",0
000720  203c206d
000724  61785f75
000728  31365f74
00072c  00      
00072d  00                DCB      0
00072e  00                DCB      0
00072f  00                DCB      0
                  |L1.1840|
000730  70627566          DCB      "pbuf_realloc: q != NULL",0
000734  5f726561
000738  6c6c6f63
00073c  3a207120
000740  213d204e
000744  554c4c00
                  |L1.1864|
                          DCD      0x000001da
                  |L1.1868|
00074c  6d656d5f          DCB      "mem_trim returned q == NULL",0
000750  7472696d
000754  20726574
000758  75726e65
00075c  64207120
000760  3d3d204e
000764  554c4c00
                          ENDP

                  pbuf_header PROC
;;;510    u8_t
;;;511    pbuf_header(struct pbuf *p, s16_t header_size_increment)
000768  e92d4070          PUSH     {r4-r6,lr}
;;;512    {
00076c  e1b04000          MOVS     r4,r0
000770  e1a05001          MOV      r5,r1
000774  1a000004          BNE      |L1.1932|
;;;513      u16_t type;
;;;514      void *payload;
;;;515      u16_t increment_magnitude;
;;;516    
;;;517      LWIP_ASSERT("p != NULL", p != NULL);
000778  e59f3294          LDR      r3,|L1.2580|
00077c  e59f2294          LDR      r2,|L1.2584|
000780  e59f1294          LDR      r1,|L1.2588|
000784  e59f0294          LDR      r0,|L1.2592|
000788  ebfffffe          BL       sysprintf
                  |L1.1932|
;;;518      if ((header_size_increment == 0) || (p == NULL)) {
00078c  e3550000          CMP      r5,#0
000790  13540000          CMPNE    r4,#0
000794  0a00001a          BEQ      |L1.2052|
;;;519        return 0;
;;;520      }
;;;521     
;;;522      if (header_size_increment < 0){
000798  e3550000          CMP      r5,#0
;;;523        increment_magnitude = -header_size_increment;
;;;524        /* Check that we aren't going to move off the end of the pbuf */
;;;525        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
;;;526      } else {
;;;527        increment_magnitude = header_size_increment;
00079c  a1a01805          LSLGE    r1,r5,#16
0007a0  a1a01821          LSRGE    r1,r1,#16
0007a4  aa000008          BGE      |L1.1996|
0007a8  e2650000          RSB      r0,r5,#0              ;523
0007ac  e1a01800          LSL      r1,r0,#16             ;523
0007b0  e1d400ba          LDRH     r0,[r4,#0xa]          ;525
0007b4  e1a01821          LSR      r1,r1,#16             ;523
0007b8  e1500001          CMP      r0,r1                 ;525
0007bc  359f3250          LDRCC    r3,|L1.2580|
0007c0  359f225c          LDRCC    r2,|L1.2596|
0007c4  328f1f97          ADRCC    r1,|L1.2600|
0007c8  3a00000a          BCC      |L1.2040|
                  |L1.1996|
;;;528    #if 0
;;;529        /* Can't assert these as some callers speculatively call
;;;530             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;531        /* Check that we've got the correct type of pbuf to work with */
;;;532        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
;;;533                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;534        /* Check that we aren't going to move off the beginning of the pbuf */
;;;535        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;536                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;537    #endif
;;;538      }
;;;539    
;;;540      type = p->type;
0007cc  e5d4000c          LDRB     r0,[r4,#0xc]
;;;541      /* remember current payload pointer */
;;;542      payload = p->payload;
;;;543    
;;;544      /* pbuf types containing payloads? */
;;;545      if (type == PBUF_RAM || type == PBUF_POOL) {
0007d0  e5942004          LDR      r2,[r4,#4]
0007d4  e3500000          CMP      r0,#0
0007d8  13500003          CMPNE    r0,#3
0007dc  0a00000a          BEQ      |L1.2060|
;;;546        /* set new payload pointer */
;;;547        p->payload = (u8_t *)p->payload - header_size_increment;
;;;548        /* boundary check fails? */
;;;549        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;550          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;551            ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;552            (void *)p->payload, (void *)(p + 1)));
;;;553          /* restore old payload pointer */
;;;554          p->payload = payload;
;;;555          /* bail out unsuccesfully */
;;;556          return 1;
;;;557        }
;;;558      /* pbuf types refering to external payloads? */
;;;559      } else if (type == PBUF_REF || type == PBUF_ROM) {
0007e0  e3500002          CMP      r0,#2
0007e4  13500001          CMPNE    r0,#1
;;;560        /* hide a header in the payload? */
;;;561        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;562          /* increase payload pointer */
;;;563          p->payload = (u8_t *)p->payload - header_size_increment;
;;;564        } else {
;;;565          /* cannot expand payload to front (yet!)
;;;566           * bail out unsuccesfully */
;;;567          return 1;
;;;568        }
;;;569      } else {
;;;570        /* Unknown type */
;;;571        LWIP_ASSERT("bad pbuf type", 0);
0007e8  159f3224          LDRNE    r3,|L1.2580|
0007ec  159f2254          LDRNE    r2,|L1.2632|
0007f0  128f1f95          ADRNE    r1,|L1.2636|
0007f4  0a00000b          BEQ      |L1.2088|
                  |L1.2040|
0007f8  e59f0220          LDR      r0,|L1.2592|
0007fc  ebfffffe          BL       sysprintf
000800  ea00000f          B        |L1.2116|
                  |L1.2052|
000804  e3a00000          MOV      r0,#0                 ;519
;;;572        return 1;
;;;573      }
;;;574      /* modify pbuf length fields */
;;;575      p->len += header_size_increment;
;;;576      p->tot_len += header_size_increment;
;;;577    
;;;578      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;579        (void *)payload, (void *)p->payload, header_size_increment));
;;;580    
;;;581      return 0;
;;;582    }
000808  e8bd8070          POP      {r4-r6,pc}
                  |L1.2060|
00080c  e0420005          SUB      r0,r2,r5              ;547
000810  e2841010          ADD      r1,r4,#0x10           ;549
000814  e1500001          CMP      r0,r1                 ;549
000818  e5840004          STR      r0,[r4,#4]            ;547
00081c  35842004          STRCC    r2,[r4,#4]            ;554
000820  3a000007          BCC      |L1.2116|
000824  ea000008          B        |L1.2124|
                  |L1.2088|
000828  e3550000          CMP      r5,#0                 ;561
00082c  aa000004          BGE      |L1.2116|
000830  e1d400ba          LDRH     r0,[r4,#0xa]          ;561
000834  e1500001          CMP      r0,r1                 ;561
000838  20420005          SUBCS    r0,r2,r5              ;563
00083c  25840004          STRCS    r0,[r4,#4]            ;563
000840  2a000001          BCS      |L1.2124|
                  |L1.2116|
000844  e3a00001          MOV      r0,#1                 ;567
000848  e8bd8070          POP      {r4-r6,pc}
                  |L1.2124|
00084c  e1d400ba          LDRH     r0,[r4,#0xa]          ;575
000850  e0800005          ADD      r0,r0,r5              ;575
000854  e1c400ba          STRH     r0,[r4,#0xa]          ;575
000858  e1d400b8          LDRH     r0,[r4,#8]            ;576
00085c  e0800005          ADD      r0,r0,r5              ;576
000860  e1c400b8          STRH     r0,[r4,#8]            ;576
000864  eaffffe6          B        |L1.2052|
;;;583    
                          ENDP

                  pbuf_clen PROC
;;;703    u8_t
;;;704    pbuf_clen(struct pbuf *p)
000868  e3a01000          MOV      r1,#0
                  |L1.2156|
;;;705    {
;;;706      u8_t len;
;;;707    
;;;708      len = 0;
;;;709      while (p != NULL) {
00086c  e3500000          CMP      r0,#0
;;;710        ++len;
;;;711        p = p->next;
000870  15900000          LDRNE    r0,[r0,#0]
000874  12811001          ADDNE    r1,r1,#1              ;709
000878  120110ff          ANDNE    r1,r1,#0xff           ;710
;;;712      }
;;;713      return len;
00087c  01a00001          MOVEQ    r0,r1
000880  1afffff9          BNE      |L1.2156|
;;;714    }
000884  e12fff1e          BX       lr
;;;715    
                          ENDP

                  pbuf_ref PROC
;;;722    void
;;;723    pbuf_ref(struct pbuf *p)
000888  e92d4010          PUSH     {r4,lr}
;;;724    {
00088c  e1b04000          MOVS     r4,r0
;;;725      SYS_ARCH_DECL_PROTECT(old_level);
;;;726      /* pbuf given? */
;;;727      if (p != NULL) {
;;;728        SYS_ARCH_PROTECT(old_level);
;;;729        ++(p->ref);
;;;730        SYS_ARCH_UNPROTECT(old_level);
;;;731      }
;;;732    }
000890  08bd8010          POPEQ    {r4,pc}
000894  ebfffffe          BL       sys_arch_protect
000898  e1d410be          LDRH     r1,[r4,#0xe]          ;729
00089c  e2811001          ADD      r1,r1,#1              ;729
0008a0  e1c410be          STRH     r1,[r4,#0xe]          ;729
0008a4  e8bd4010          POP      {r4,lr}               ;730
0008a8  eafffffe          B        sys_arch_unprotect
;;;733    
                          ENDP

                  pbuf_cat PROC
;;;744    void
;;;745    pbuf_cat(struct pbuf *h, struct pbuf *t)
0008ac  e92d4070          PUSH     {r4-r6,lr}
;;;746    {
;;;747      struct pbuf *p;
;;;748    
;;;749      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
0008b0  e3500000          CMP      r0,#0
0008b4  e1a05001          MOV      r5,r1                 ;746
0008b8  13550000          CMPNE    r5,#0
0008bc  1a000005          BNE      |L1.2264|
0008c0  e8bd4070          POP      {r4-r6,lr}
0008c4  e59f3148          LDR      r3,|L1.2580|
0008c8  e59f218c          LDR      r2,|L1.2652|
0008cc  e59f014c          LDR      r0,|L1.2592|
0008d0  e28f1f62          ADR      r1,|L1.2656|
0008d4  eafffffe          B        sysprintf
                  |L1.2264|
;;;750                 ((h != NULL) && (t != NULL)), return;);
;;;751    
;;;752      /* proceed to last pbuf of chain */
;;;753      for (p = h; p->next != NULL; p = p->next) {
0008d8  e1a04000          MOV      r4,r0
0008dc  e5900000          LDR      r0,[r0,#0]
0008e0  e3500000          CMP      r0,#0
0008e4  0a000004          BEQ      |L1.2300|
;;;754        /* add total length of second chain to all totals of first chain */
;;;755        p->tot_len += t->tot_len;
0008e8  e1d410b8          LDRH     r1,[r4,#8]
0008ec  e1d520b8          LDRH     r2,[r5,#8]
0008f0  e0811002          ADD      r1,r1,r2
0008f4  e1c410b8          STRH     r1,[r4,#8]
0008f8  eafffff6          B        |L1.2264|
                  |L1.2300|
;;;756      }
;;;757      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;758      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
0008fc  e1d400b8          LDRH     r0,[r4,#8]
000900  e1d410ba          LDRH     r1,[r4,#0xa]
000904  e1500001          CMP      r0,r1
000908  0a00000c          BEQ      |L1.2368|
00090c  e59f3100          LDR      r3,|L1.2580|
000910  e59f2180          LDR      r2,|L1.2712|
000914  e59f0104          LDR      r0,|L1.2592|
000918  e28f1f5f          ADR      r1,|L1.2716|
00091c  ebfffffe          BL       sysprintf
;;;759      LWIP_ASSERT("p->next == NULL", p->next == NULL);
000920  e5940000          LDR      r0,[r4,#0]
000924  e3500000          CMP      r0,#0
000928  0a000004          BEQ      |L1.2368|
00092c  e59f30e0          LDR      r3,|L1.2580|
000930  e59f2194          LDR      r2,|L1.2764|
000934  e59f00e4          LDR      r0,|L1.2592|
000938  e28f1e19          ADR      r1,|L1.2768|
00093c  ebfffffe          BL       sysprintf
                  |L1.2368|
;;;760      /* add total length of second chain to last pbuf total of first chain */
;;;761      p->tot_len += t->tot_len;
000940  e1d400b8          LDRH     r0,[r4,#8]
000944  e1d510b8          LDRH     r1,[r5,#8]
000948  e0800001          ADD      r0,r0,r1
00094c  e1c400b8          STRH     r0,[r4,#8]
;;;762      /* chain last pbuf of head (p) with first of tail (t) */
;;;763      p->next = t;
000950  e5845000          STR      r5,[r4,#0]
;;;764      /* p->next now references t, but the caller will drop its reference to t,
;;;765       * so netto there is no change to the reference count of t.
;;;766       */
;;;767    }
000954  e8bd8070          POP      {r4-r6,pc}
;;;768    
                          ENDP

                  pbuf_chain PROC
;;;785    void
;;;786    pbuf_chain(struct pbuf *h, struct pbuf *t)
000958  e92d4010          PUSH     {r4,lr}
;;;787    {
00095c  e1a04001          MOV      r4,r1
;;;788      pbuf_cat(h, t);
000960  ebfffffe          BL       pbuf_cat
;;;789      /* t is now referenced by h */
;;;790      pbuf_ref(t);
000964  e1a00004          MOV      r0,r4
000968  e8bd4010          POP      {r4,lr}
00096c  eafffffe          B        pbuf_ref
;;;791      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
;;;792    }
;;;793    
                          ENDP

                  pbuf_dechain PROC
;;;802    struct pbuf *
;;;803    pbuf_dechain(struct pbuf *p)
000970  e92d4070          PUSH     {r4-r6,lr}
;;;804    {
;;;805      struct pbuf *q;
;;;806      u8_t tail_gone = 1;
;;;807      /* tail */
;;;808      q = p->next;
000974  e5905000          LDR      r5,[r0,#0]
000978  e1a04000          MOV      r4,r0                 ;804
;;;809      /* pbuf has successor in chain? */
;;;810      if (q != NULL) {
00097c  e3550000          CMP      r5,#0
000980  e3a06001          MOV      r6,#1                 ;806
000984  0a000015          BEQ      |L1.2528|
;;;811        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;812        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
000988  e1d400b8          LDRH     r0,[r4,#8]
00098c  e1d410ba          LDRH     r1,[r4,#0xa]
000990  e0400001          SUB      r0,r0,r1
000994  e1d510b8          LDRH     r1,[r5,#8]
000998  e1500001          CMP      r0,r1
00099c  0a000004          BEQ      |L1.2484|
0009a0  e59f306c          LDR      r3,|L1.2580|
0009a4  e59f0074          LDR      r0,|L1.2592|
0009a8  e3a02fcb          MOV      r2,#0x32c
0009ac  e28f1f4b          ADR      r1,|L1.2784|
0009b0  ebfffffe          BL       sysprintf
                  |L1.2484|
;;;813        /* enforce invariant if assertion is disabled */
;;;814        q->tot_len = p->tot_len - p->len;
0009b4  e1d400b8          LDRH     r0,[r4,#8]
0009b8  e1d410ba          LDRH     r1,[r4,#0xa]
0009bc  e0400001          SUB      r0,r0,r1
0009c0  e1c500b8          STRH     r0,[r5,#8]
;;;815        /* decouple pbuf from remainder */
;;;816        p->next = NULL;
0009c4  e3a00000          MOV      r0,#0
0009c8  e5840000          STR      r0,[r4,#0]
;;;817        /* total length of pbuf p is its own length only */
;;;818        p->tot_len = p->len;
0009cc  e1d400ba          LDRH     r0,[r4,#0xa]
0009d0  e1c400b8          STRH     r0,[r4,#8]
;;;819        /* q is no longer referenced by p, free it */
;;;820        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
;;;821        tail_gone = pbuf_free(q);
0009d4  e1a00005          MOV      r0,r5
0009d8  ebfffffe          BL       pbuf_free
0009dc  e1a06000          MOV      r6,r0
                  |L1.2528|
;;;822        if (tail_gone > 0) {
;;;823          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
;;;824                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;825        }
;;;826        /* return remaining tail or NULL if deallocated */
;;;827      }
;;;828      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;829      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
0009e0  e1d400b8          LDRH     r0,[r4,#8]
0009e4  e1d410ba          LDRH     r1,[r4,#0xa]
0009e8  e1500001          CMP      r0,r1
0009ec  0a000004          BEQ      |L1.2564|
0009f0  e59f301c          LDR      r3,|L1.2580|
0009f4  e59f2108          LDR      r2,|L1.2820|
0009f8  e59f0020          LDR      r0,|L1.2592|
0009fc  e28f1f41          ADR      r1,|L1.2824|
000a00  ebfffffe          BL       sysprintf
                  |L1.2564|
;;;830      return ((tail_gone > 0) ? NULL : q);
000a04  e3560000          CMP      r6,#0
000a08  13a00000          MOVNE    r0,#0
000a0c  01a00005          MOVEQ    r0,r5
;;;831    }
000a10  e8bd8070          POP      {r4-r6,pc}
                  |L1.2580|
                          DCD      ||.text||+0x2c0
                  |L1.2584|
                          DCD      0x00000205
                  |L1.2588|
                          DCD      ||.text||+0x324
                  |L1.2592|
                          DCD      ||.text||+0x2f8
                  |L1.2596|
                          DCD      0x0000020d
                  |L1.2600|
000a28  696e6372          DCB      "increment_magnitude <= p->len",0
000a2c  656d656e
000a30  745f6d61
000a34  676e6974
000a38  75646520
000a3c  3c3d2070
000a40  2d3e6c65
000a44  6e00    
000a46  00                DCB      0
000a47  00                DCB      0
                  |L1.2632|
                          DCD      0x0000023b
                  |L1.2636|
000a4c  62616420          DCB      "bad pbuf type",0
000a50  70627566
000a54  20747970
000a58  6500    
000a5a  00                DCB      0
000a5b  00                DCB      0
                  |L1.2652|
                          DCD      0x000002ed
                  |L1.2656|
000a60  28682021          DCB      "(h != NULL) && (t != NULL) (programmer violates API)",0
000a64  3d204e55
000a68  4c4c2920
000a6c  26262028
000a70  7420213d
000a74  204e554c
000a78  4c292028
000a7c  70726f67
000a80  72616d6d
000a84  65722076
000a88  696f6c61
000a8c  74657320
000a90  41504929
000a94  00      
000a95  00                DCB      0
000a96  00                DCB      0
000a97  00                DCB      0
                  |L1.2712|
                          DCD      0x000002f6
                  |L1.2716|
000a9c  702d3e74          DCB      "p->tot_len == p->len (of last pbuf in chain)",0
000aa0  6f745f6c
000aa4  656e203d
000aa8  3d20702d
000aac  3e6c656e
000ab0  20286f66
000ab4  206c6173
000ab8  74207062
000abc  75662069
000ac0  6e206368
000ac4  61696e29
000ac8  00      
000ac9  00                DCB      0
000aca  00                DCB      0
000acb  00                DCB      0
                  |L1.2764|
                          DCD      0x000002f7
                  |L1.2768|
000ad0  702d3e6e          DCB      "p->next == NULL",0
000ad4  65787420
000ad8  3d3d204e
000adc  554c4c00
                  |L1.2784|
000ae0  702d3e74          DCB      "p->tot_len == p->len + q->tot_len",0
000ae4  6f745f6c
000ae8  656e203d
000aec  3d20702d
000af0  3e6c656e
000af4  202b2071
000af8  2d3e746f
000afc  745f6c65
000b00  6e00    
000b02  00                DCB      0
000b03  00                DCB      0
                  |L1.2820|
                          DCD      0x0000033d
                  |L1.2824|
000b08  702d3e74          DCB      "p->tot_len == p->len",0
000b0c  6f745f6c
000b10  656e203d
000b14  3d20702d
000b18  3e6c656e
000b1c  00      
000b1d  00                DCB      0
000b1e  00                DCB      0
000b1f  00                DCB      0
                          ENDP

                  pbuf_copy PROC
;;;851    err_t
;;;852    pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
000b20  e92d41f0          PUSH     {r4-r8,lr}
;;;853    {
000b24  e1b05000          MOVS     r5,r0
000b28  e1a04001          MOV      r4,r1
;;;854      u16_t offset_to=0, offset_from=0, len;
000b2c  e3a07000          MOV      r7,#0
;;;855    
;;;856      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
;;;857        (void*)p_to, (void*)p_from));
;;;858    
;;;859      /* is the target big enough to hold the source? */
;;;860      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
000b30  13540000          CMPNE    r4,#0
000b34  e1a06007          MOV      r6,r7                 ;854
000b38  0a000003          BEQ      |L1.2892|
000b3c  e1d500b8          LDRH     r0,[r5,#8]
000b40  e1d410b8          LDRH     r1,[r4,#8]
000b44  e1510000          CMP      r1,r0
000b48  9a000006          BLS      |L1.2920|
                  |L1.2892|
000b4c  e51f3140          LDR      r3,|L1.2580|
000b50  e3a02fd7          MOV      r2,#0x35c
000b54  e28f1f8a          ADR      r1,|L1.3460|
                  |L1.2904|
;;;861                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;862    
;;;863      /* iterate through pbuf chain */
;;;864      do
;;;865      {
;;;866        /* copy one part of the original chain */
;;;867        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;868          /* complete current p_from fits into current p_to */
;;;869          len = p_from->len - offset_from;
;;;870        } else {
;;;871          /* current p_from does not fit into current p_to */
;;;872          len = p_to->len - offset_to;
;;;873        }
;;;874        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;875        offset_to += len;
;;;876        offset_from += len;
;;;877        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;878        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;879        if (offset_from >= p_from->len) {
;;;880          /* on to next p_from (if any) */
;;;881          offset_from = 0;
;;;882          p_from = p_from->next;
;;;883        }
;;;884        if (offset_to == p_to->len) {
;;;885          /* on to next p_to (if any) */
;;;886          offset_to = 0;
;;;887          p_to = p_to->next;
;;;888          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
000b58  e51f0140          LDR      r0,|L1.2592|
000b5c  ebfffffe          BL       sysprintf
000b60  e3e0000d          MVN      r0,#0xd
;;;889        }
;;;890    
;;;891        if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;892          /* don't copy more than one packet! */
;;;893          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;894                     (p_from->next == NULL), return ERR_VAL;);
;;;895        }
;;;896        if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;897          /* don't copy more than one packet! */
;;;898          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;899                      (p_to->next == NULL), return ERR_VAL;);
;;;900        }
;;;901      } while (p_from);
;;;902      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;903      return ERR_OK;
;;;904    }
000b64  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2920|
000b68  e1d500ba          LDRH     r0,[r5,#0xa]          ;867
000b6c  e1d410ba          LDRH     r1,[r4,#0xa]          ;867
000b70  e0400007          SUB      r0,r0,r7              ;867
000b74  e0411006          SUB      r1,r1,r6              ;867
000b78  e1500001          CMP      r0,r1                 ;867
000b7c  a1a08801          LSLGE    r8,r1,#16             ;869
000b80  a1a08828          LSRGE    r8,r8,#16             ;869
000b84  b1a08800          LSLLT    r8,r0,#16             ;872
000b88  e5940004          LDR      r0,[r4,#4]            ;874
000b8c  b1a08828          LSRLT    r8,r8,#16             ;872
000b90  e0801006          ADD      r1,r0,r6              ;874
000b94  e5950004          LDR      r0,[r5,#4]            ;874
000b98  e1a02008          MOV      r2,r8                 ;874
000b9c  e0800007          ADD      r0,r0,r7              ;874
000ba0  ebfffffe          BL       __aeabi_memcpy
000ba4  e0870008          ADD      r0,r7,r8              ;875
000ba8  e3c07801          BIC      r7,r0,#0x10000        ;875
000bac  e0860008          ADD      r0,r6,r8              ;876
000bb0  e3c06801          BIC      r6,r0,#0x10000        ;876
000bb4  e1d500ba          LDRH     r0,[r5,#0xa]          ;877
000bb8  e1500007          CMP      r0,r7                 ;877
000bbc  2a000004          BCS      |L1.3028|
000bc0  e51f31b4          LDR      r3,|L1.2580|
000bc4  e59f21e8          LDR      r2,|L1.3508|
000bc8  e51f01b0          LDR      r0,|L1.2592|
000bcc  e28f1f79          ADR      r1,|L1.3512|
000bd0  ebfffffe          BL       sysprintf
                  |L1.3028|
000bd4  e1d400ba          LDRH     r0,[r4,#0xa]          ;878
000bd8  e1500006          CMP      r0,r6                 ;878
000bdc  2a000004          BCS      |L1.3060|
000be0  e51f31d4          LDR      r3,|L1.2580|
000be4  e59f21e4          LDR      r2,|L1.3536|
000be8  e51f01d0          LDR      r0,|L1.2592|
000bec  e28f1e1e          ADR      r1,|L1.3540|
000bf0  ebfffffe          BL       sysprintf
                  |L1.3060|
000bf4  e1d400ba          LDRH     r0,[r4,#0xa]          ;879
000bf8  e1500006          CMP      r0,r6                 ;879
000bfc  e1d500ba          LDRH     r0,[r5,#0xa]          ;884
000c00  95944000          LDRLS    r4,[r4,#0]            ;882
000c04  93a06000          MOVLS    r6,#0                 ;881
000c08  e1500007          CMP      r0,r7                 ;884
000c0c  05955000          LDREQ    r5,[r5,#0]            ;887
000c10  03a07000          MOVEQ    r7,#0                 ;886
000c14  03550000          CMPEQ    r5,#0                 ;888
000c18  0a00000f          BEQ      |L1.3164|
000c1c  e3540000          CMP      r4,#0                 ;891
000c20  0a000013          BEQ      |L1.3188|
000c24  e1d400ba          LDRH     r0,[r4,#0xa]          ;891
000c28  e1d410b8          LDRH     r1,[r4,#8]            ;891
000c2c  e1500001          CMP      r0,r1                 ;891
000c30  1a00000f          BNE      |L1.3188|
000c34  e5940000          LDR      r0,[r4,#0]            ;893
000c38  e3500000          CMP      r0,#0                 ;893
000c3c  151f3230          LDRNE    r3,|L1.2580|
000c40  159f21a8          LDRNE    r2,|L1.3568|
000c44  0a00000a          BEQ      |L1.3188|
                  |L1.3144|
000c48  e51f0230          LDR      r0,|L1.2592|
000c4c  e28f1e1a          ADR      r1,|L1.3572|
000c50  ebfffffe          BL       sysprintf
000c54  e3e00005          MVN      r0,#5                 ;898
000c58  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3164|
000c5c  e3540000          CMP      r4,#0                 ;888
000c60  151f3254          LDRNE    r3,|L1.2580|
000c64  13a02fde          MOVNE    r2,#0x378             ;888
000c68  128f1e1b          ADRNE    r1,|L1.3616|
000c6c  1affffb9          BNE      |L1.2904|
000c70  ea00000c          B        |L1.3240|
                  |L1.3188|
000c74  e3550000          CMP      r5,#0                 ;896
000c78  0a000008          BEQ      |L1.3232|
000c7c  e1d500ba          LDRH     r0,[r5,#0xa]          ;896
000c80  e1d510b8          LDRH     r1,[r5,#8]            ;896
000c84  e1500001          CMP      r0,r1                 ;896
000c88  1a000004          BNE      |L1.3232|
000c8c  e5950000          LDR      r0,[r5,#0]            ;898
000c90  e3500000          CMP      r0,#0                 ;898
000c94  151f3288          LDRNE    r3,|L1.2580|
000c98  159f2190          LDRNE    r2,|L1.3632|
000c9c  1affffe9          BNE      |L1.3144|
                  |L1.3232|
000ca0  e3540000          CMP      r4,#0                 ;901
000ca4  1affffaf          BNE      |L1.2920|
                  |L1.3240|
000ca8  e3a00000          MOV      r0,#0                 ;903
000cac  e8bd81f0          POP      {r4-r8,pc}
;;;905    
                          ENDP

                  pbuf_copy_partial PROC
;;;917    u16_t
;;;918    pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
000cb0  e92d47f0          PUSH     {r4-r10,lr}
;;;919    {
;;;920      struct pbuf *p;
;;;921      u16_t left;
;;;922      u16_t buf_copy_len;
;;;923      u16_t copied_total = 0;
;;;924    
;;;925      LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
000cb4  e3500000          CMP      r0,#0
000cb8  e1a06002          MOV      r6,r2                 ;919
000cbc  051f32b0          LDREQ    r3,|L1.2580|
000cc0  059f216c          LDREQ    r2,|L1.3636|
000cc4  e1a09001          MOV      r9,r1                 ;919
000cc8  e3a08000          MOV      r8,#0                 ;923
000ccc  028f1f59          ADREQ    r1,|L1.3640|
000cd0  0a000006          BEQ      |L1.3312|
;;;926      LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
000cd4  e3590000          CMP      r9,#0
000cd8  051f32cc          LDREQ    r3,|L1.2580|
000cdc  059f2174          LDREQ    r2,|L1.3672|
000ce0  028f1f5d          ADREQ    r1,|L1.3676|
;;;927    
;;;928      left = 0;
000ce4  13a07000          MOVNE    r7,#0
;;;929    
;;;930      if((buf == NULL) || (dataptr == NULL)) {
;;;931        return 0;
;;;932      }
;;;933    
;;;934      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;935      for(p = buf; len != 0 && p != NULL; p = p->next) {
000ce8  11a04000          MOVNE    r4,r0
000cec  1a00001f          BNE      |L1.3440|
                  |L1.3312|
000cf0  e51f02d8          LDR      r0,|L1.2592|
000cf4  ebfffffe          BL       sysprintf
000cf8  e3a00000          MOV      r0,#0                 ;926
;;;936        if ((offset != 0) && (offset >= p->len)) {
;;;937          /* don't copy from this buffer -> on to the next */
;;;938          offset -= p->len;
;;;939        } else {
;;;940          /* copy from this buffer. maybe only partially. */
;;;941          buf_copy_len = p->len - offset;
;;;942          if (buf_copy_len > len)
;;;943              buf_copy_len = len;
;;;944          /* copy the necessary parts of the buffer */
;;;945          MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;946          copied_total += buf_copy_len;
;;;947          left += buf_copy_len;
;;;948          len -= buf_copy_len;
;;;949          offset = 0;
;;;950        }
;;;951      }
;;;952      return copied_total;
;;;953    }
000cfc  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3328|
000d00  e3530000          CMP      r3,#0                 ;936
000d04  0a000005          BEQ      |L1.3360|
000d08  e1d400ba          LDRH     r0,[r4,#0xa]          ;936
000d0c  e1500003          CMP      r0,r3                 ;936
000d10  90430000          SUBLS    r0,r3,r0              ;938
000d14  91a03800          LSLLS    r3,r0,#16             ;938
000d18  91a03823          LSRLS    r3,r3,#16             ;938
000d1c  9a000012          BLS      |L1.3436|
                  |L1.3360|
000d20  e1d400ba          LDRH     r0,[r4,#0xa]          ;941
000d24  e0400003          SUB      r0,r0,r3              ;941
000d28  e1a05800          LSL      r5,r0,#16             ;941
000d2c  e5940004          LDR      r0,[r4,#4]            ;945
000d30  e1a05825          LSR      r5,r5,#16             ;941
000d34  e1550006          CMP      r5,r6                 ;942
000d38  81a05006          MOVHI    r5,r6                 ;943
000d3c  e0801003          ADD      r1,r0,r3              ;945
000d40  e0890007          ADD      r0,r9,r7              ;945
000d44  e1a02005          MOV      r2,r5                 ;945
000d48  ebfffffe          BL       __aeabi_memcpy
000d4c  e0880005          ADD      r0,r8,r5              ;946
000d50  e3c08801          BIC      r8,r0,#0x10000        ;946
000d54  e0870005          ADD      r0,r7,r5              ;947
000d58  e3c07801          BIC      r7,r0,#0x10000        ;947
000d5c  e0460005          SUB      r0,r6,r5              ;948
000d60  e1a06800          LSL      r6,r0,#16             ;948
000d64  e1a06826          LSR      r6,r6,#16             ;948
000d68  e3a03000          MOV      r3,#0                 ;949
                  |L1.3436|
000d6c  e5944000          LDR      r4,[r4,#0]            ;935
                  |L1.3440|
000d70  e3560000          CMP      r6,#0                 ;935
000d74  13540000          CMPNE    r4,#0                 ;935
000d78  01a00008          MOVEQ    r0,r8                 ;952
000d7c  1affffdf          BNE      |L1.3328|
000d80  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3460|
000d84  70627566          DCB      "pbuf_copy: target not big enough to hold source",0
000d88  5f636f70
000d8c  793a2074
000d90  61726765
000d94  74206e6f
000d98  74206269
000d9c  6720656e
000da0  6f756768
000da4  20746f20
000da8  686f6c64
000dac  20736f75
000db0  72636500
                  |L1.3508|
                          DCD      0x0000036d
                  |L1.3512|
000db8  6f666673          DCB      "offset_to <= p_to->len",0
000dbc  65745f74
000dc0  6f203c3d
000dc4  20705f74
000dc8  6f2d3e6c
000dcc  656e00  
000dcf  00                DCB      0
                  |L1.3536|
                          DCD      0x0000036e
                  |L1.3540|
000dd4  6f666673          DCB      "offset_from <= p_from->len",0
000dd8  65745f66
000ddc  726f6d20
000de0  3c3d2070
000de4  5f66726f
000de8  6d2d3e6c
000dec  656e00  
000def  00                DCB      0
                  |L1.3568|
                          DCD      0x0000037d
                  |L1.3572|
000df4  70627566          DCB      "pbuf_copy() does not allow packet queues!\n",0
000df8  5f636f70
000dfc  79282920
000e00  646f6573
000e04  206e6f74
000e08  20616c6c
000e0c  6f772070
000e10  61636b65
000e14  74207175
000e18  65756573
000e1c  210a00  
000e1f  00                DCB      0
                  |L1.3616|
000e20  705f746f          DCB      "p_to != NULL",0
000e24  20213d20
000e28  4e554c4c
000e2c  00      
000e2d  00                DCB      0
000e2e  00                DCB      0
000e2f  00                DCB      0
                  |L1.3632|
                          DCD      0x00000382
                  |L1.3636|
                          DCD      0x0000039d
                  |L1.3640|
000e38  70627566          DCB      "pbuf_copy_partial: invalid buf",0
000e3c  5f636f70
000e40  795f7061
000e44  72746961
000e48  6c3a2069
000e4c  6e76616c
000e50  69642062
000e54  756600  
000e57  00                DCB      0
                  |L1.3672|
                          DCD      0x0000039e
                  |L1.3676|
000e5c  70627566          DCB      "pbuf_copy_partial: invalid dataptr",0
000e60  5f636f70
000e64  795f7061
000e68  72746961
000e6c  6c3a2069
000e70  6e76616c
000e74  69642064
000e78  61746170
000e7c  747200  
000e7f  00                DCB      0
                          ENDP

                  pbuf_take PROC
;;;965    err_t
;;;966    pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
000e80  e92d47f0          PUSH     {r4-r10,lr}
;;;967    {
;;;968      struct pbuf *p;
;;;969      u16_t buf_copy_len;
;;;970      u16_t total_copy_len = len;
;;;971      u16_t copied_total = 0;
;;;972    
;;;973      LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
000e84  e3500000          CMP      r0,#0
000e88  e1a08002          MOV      r8,r2                 ;967
000e8c  e1a06002          MOV      r6,r2                 ;970
000e90  051f3484          LDREQ    r3,|L1.2580|
000e94  059f223c          LDREQ    r2,|L1.4312|
000e98  e1a09001          MOV      r9,r1                 ;967
000e9c  e3a07000          MOV      r7,#0                 ;971
000ea0  028f1f8d          ADREQ    r1,|L1.4316|
000ea4  0a00000b          BEQ      |L1.3800|
;;;974      LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
000ea8  e3590000          CMP      r9,#0
000eac  051f34a0          LDREQ    r3,|L1.2580|
000eb0  059f223c          LDREQ    r2,|L1.4340|
000eb4  028f1f8f          ADREQ    r1,|L1.4344|
000eb8  0a000006          BEQ      |L1.3800|
;;;975    
;;;976      if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
000ebc  e1d010b8          LDRH     r1,[r0,#8]
000ec0  e1510008          CMP      r1,r8
;;;977        return ERR_ARG;
;;;978      }
;;;979    
;;;980      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;981      for(p = buf; total_copy_len != 0; p = p->next) {
;;;982        LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
000ec4  259fa248          LDRCS    r10,|L1.4372|
000ec8  33e0000d          MVNCC    r0,#0xd               ;977
000ecc  21a04000          MOVCS    r4,r0                 ;981
000ed0  2a000018          BCS      |L1.3896|
;;;983        buf_copy_len = total_copy_len;
;;;984        if (buf_copy_len > p->len) {
;;;985          /* this pbuf cannot hold all remaining data */
;;;986          buf_copy_len = p->len;
;;;987        }
;;;988        /* copy the necessary parts of the buffer */
;;;989        MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
;;;990        total_copy_len -= buf_copy_len;
;;;991        copied_total += buf_copy_len;
;;;992      }
;;;993      LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;994      return ERR_OK;
;;;995    }
000ed4  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3800|
000ed8  e51f04c0          LDR      r0,|L1.2592|
000edc  ebfffffe          BL       sysprintf
000ee0  ea00001b          B        |L1.3924|
                  |L1.3812|
000ee4  e3540000          CMP      r4,#0                 ;982
000ee8  1a000004          BNE      |L1.3840|
000eec  e51f34e0          LDR      r3,|L1.2580|
000ef0  e51f04d8          LDR      r0,|L1.2592|
000ef4  e1a0200a          MOV      r2,r10                ;982
000ef8  e28f1f86          ADR      r1,|L1.4376|
000efc  ebfffffe          BL       sysprintf
                  |L1.3840|
000f00  e1d400ba          LDRH     r0,[r4,#0xa]          ;984
000f04  e1a05006          MOV      r5,r6                 ;983
000f08  e0891007          ADD      r1,r9,r7              ;989
000f0c  e1500005          CMP      r0,r5                 ;984
000f10  31a05000          MOVCC    r5,r0                 ;986
000f14  e5940004          LDR      r0,[r4,#4]            ;989
000f18  e1a02005          MOV      r2,r5                 ;989
000f1c  ebfffffe          BL       __aeabi_memcpy
000f20  e0460005          SUB      r0,r6,r5              ;990
000f24  e1a06800          LSL      r6,r0,#16             ;990
000f28  e5944000          LDR      r4,[r4,#0]            ;981
000f2c  e0870005          ADD      r0,r7,r5              ;991
000f30  e1a06826          LSR      r6,r6,#16             ;990
000f34  e3c07801          BIC      r7,r0,#0x10000        ;991
                  |L1.3896|
000f38  e3560000          CMP      r6,#0                 ;981
000f3c  1affffe8          BNE      |L1.3812|
000f40  e1570008          CMP      r7,r8                 ;993
000f44  151f3538          LDRNE    r3,|L1.2580|
000f48  159f21e0          LDRNE    r2,|L1.4400|
000f4c  128f1e1e          ADRNE    r1,|L1.4404|
000f50  1affffe0          BNE      |L1.3800|
                  |L1.3924|
000f54  e3a00000          MOV      r0,#0                 ;994
000f58  e8bd87f0          POP      {r4-r10,pc}
;;;996    
                          ENDP

                  pbuf_coalesce PROC
;;;1009   struct pbuf*
;;;1010   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
000f5c  e92d4070          PUSH     {r4-r6,lr}
;;;1011   {
000f60  e1a04000          MOV      r4,r0
;;;1012     struct pbuf *q;
;;;1013     err_t err;
;;;1014     if (p->next == NULL) {
000f64  e5900000          LDR      r0,[r0,#0]
000f68  e1a03001          MOV      r3,r1                 ;1011
000f6c  e3500000          CMP      r0,#0
000f70  0a000012          BEQ      |L1.4032|
;;;1015       return p;
;;;1016     }
;;;1017     q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
000f74  e1d410b8          LDRH     r1,[r4,#8]
000f78  e3a02000          MOV      r2,#0
000f7c  e1a00003          MOV      r0,r3
000f80  ebfffffe          BL       pbuf_alloc
000f84  e1b05000          MOVS     r5,r0
;;;1018     if (q == NULL) {
000f88  0a00000c          BEQ      |L1.4032|
;;;1019       /* @todo: what do we do now? */
;;;1020       return p;
;;;1021     }
;;;1022     err = pbuf_copy(q, p);
000f8c  e1a01004          MOV      r1,r4
000f90  ebfffffe          BL       pbuf_copy
;;;1023     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
000f94  e3500000          CMP      r0,#0
000f98  0a000004          BEQ      |L1.4016|
000f9c  e51f3590          LDR      r3,|L1.2580|
000fa0  e59f21a4          LDR      r2,|L1.4428|
000fa4  e51f058c          LDR      r0,|L1.2592|
000fa8  e28f1e1a          ADR      r1,|L1.4432|
000fac  ebfffffe          BL       sysprintf
                  |L1.4016|
;;;1024     pbuf_free(p);
000fb0  e1a00004          MOV      r0,r4
000fb4  ebfffffe          BL       pbuf_free
;;;1025     return q;
000fb8  e1a00005          MOV      r0,r5
;;;1026   }
000fbc  e8bd8070          POP      {r4-r6,pc}
                  |L1.4032|
000fc0  e1a00004          MOV      r0,r4                 ;1020
000fc4  e8bd8070          POP      {r4-r6,pc}
;;;1027   
                          ENDP

                  pbuf_get_at PROC
                  |L1.4040|
;;;1076   u8_t
;;;1077   pbuf_get_at(struct pbuf* p, u16_t offset)
000fc8  e3500000          CMP      r0,#0
;;;1078   {
;;;1079     u16_t copy_from = offset;
;;;1080     struct pbuf* q = p;
;;;1081   
;;;1082     /* get the correct pbuf */
;;;1083     while ((q != NULL) && (q->len <= copy_from)) {
;;;1084       copy_from -= q->len;
;;;1085       q = q->next;
;;;1086     }
;;;1087     /* return requested data if pbuf is OK */
;;;1088     if ((q != NULL) && (q->len > copy_from)) {
;;;1089       return ((u8_t*)q->payload)[copy_from];
;;;1090     }
;;;1091     return 0;
;;;1092   }
000fcc  012fff1e          BXEQ     lr
000fd0  e1d020ba          LDRH     r2,[r0,#0xa]          ;1083
000fd4  e1520001          CMP      r2,r1                 ;1083
000fd8  95900000          LDRLS    r0,[r0,#0]            ;1085
000fdc  85900004          LDRHI    r0,[r0,#4]            ;1089
000fe0  90411002          SUBLS    r1,r1,r2              ;1084
000fe4  87d00001          LDRBHI   r0,[r0,r1]            ;1089
000fe8  91a01801          LSLLS    r1,r1,#16             ;1084
000fec  91a01821          LSRLS    r1,r1,#16             ;1084
000ff0  9afffff4          BLS      |L1.4040|
000ff4  e12fff1e          BX       lr
;;;1093   
                          ENDP

                  pbuf_memcmp PROC
;;;1103   u16_t
;;;1104   pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
000ff8  e92d4070          PUSH     {r4-r6,lr}
;;;1105   {
000ffc  e1a06002          MOV      r6,r2
001000  e1a05001          MOV      r5,r1
001004  e1a04000          MOV      r4,r0
                  |L1.4104|
;;;1106     u16_t start = offset;
;;;1107     struct pbuf* q = p;
;;;1108   
;;;1109     /* get the correct pbuf */
;;;1110     while ((q != NULL) && (q->len <= start)) {
001008  e3540000          CMP      r4,#0
;;;1111       start -= q->len;
;;;1112       q = q->next;
;;;1113     }
;;;1114     /* return requested data if pbuf is OK */
;;;1115     if ((q != NULL) && (q->len > start)) {
;;;1116       u16_t i;
;;;1117       for(i = 0; i < n; i++) {
;;;1118         u8_t a = pbuf_get_at(q, start + i);
;;;1119         u8_t b = ((u8_t*)s2)[i];
;;;1120         if (a != b) {
;;;1121           return i+1;
;;;1122         }
;;;1123       }
;;;1124       return 0;
;;;1125     }
;;;1126     return 0xffff;
00100c  051f0984          LDREQ    r0,|L1.1680|
;;;1127   }
001010  08bd8070          POPEQ    {r4-r6,pc}
001014  e1d400ba          LDRH     r0,[r4,#0xa]          ;1110
001018  e1500005          CMP      r0,r5                 ;1110
00101c  90450000          SUBLS    r0,r5,r0              ;1111
001020  95944000          LDRLS    r4,[r4,#0]            ;1112
001024  91a05800          LSLLS    r5,r0,#16             ;1111
001028  91a05825          LSRLS    r5,r5,#16             ;1111
00102c  83a0c000          MOVHI    r12,#0                ;1117
001030  9afffff4          BLS      |L1.4104|
                  |L1.4148|
001034  e15c0003          CMP      r12,r3                ;1117
001038  23a00000          MOVCS    r0,#0                 ;1124
00103c  28bd8070          POPCS    {r4-r6,pc}
001040  e085000c          ADD      r0,r5,r12             ;1118
001044  e3c01801          BIC      r1,r0,#0x10000        ;1118
001048  e1a00004          MOV      r0,r4                 ;1118
00104c  ebfffffe          BL       pbuf_get_at
001050  e7d6100c          LDRB     r1,[r6,r12]           ;1119
001054  e1500001          CMP      r0,r1                 ;1120
001058  e28c0001          ADD      r0,r12,#1             ;1117
00105c  13c00801          BICNE    r0,r0,#0x10000        ;1121
001060  03c0c801          BICEQ    r12,r0,#0x10000       ;1117
001064  0afffff2          BEQ      |L1.4148|
001068  e8bd8070          POP      {r4-r6,pc}
;;;1128   
                          ENDP

                  pbuf_memfind PROC
;;;1139   u16_t
;;;1140   pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
00106c  e92d41f0          PUSH     {r4-r8,lr}
;;;1141   {
001070  e1a07000          MOV      r7,r0
;;;1142     u16_t i;
;;;1143     u16_t max = p->tot_len - mem_len;
001074  e1d000b8          LDRH     r0,[r0,#8]
001078  e1a06002          MOV      r6,r2                 ;1141
00107c  e1a08001          MOV      r8,r1                 ;1141
001080  e0401006          SUB      r1,r0,r6
001084  e1a05801          LSL      r5,r1,#16
;;;1144     if (p->tot_len >= mem_len + start_offset) {
001088  e0821003          ADD      r1,r2,r3
00108c  e1500001          CMP      r0,r1
001090  e1a05825          LSR      r5,r5,#16             ;1143
;;;1145       for(i = start_offset; i <= max; ) {
001094  21a04003          MOVCS    r4,r3
001098  3a00000c          BCC      |L1.4304|
                  |L1.4252|
00109c  e1550004          CMP      r5,r4
0010a0  3a00000a          BCC      |L1.4304|
;;;1146         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
0010a4  e1a03006          MOV      r3,r6
0010a8  e1a02008          MOV      r2,r8
0010ac  e1a01004          MOV      r1,r4
0010b0  e1a00007          MOV      r0,r7
0010b4  ebfffffe          BL       pbuf_memcmp
;;;1147         if (plus == 0) {
0010b8  e3500000          CMP      r0,#0
;;;1148           return i;
0010bc  01a00004          MOVEQ    r0,r4
;;;1149         } else {
;;;1150           i += plus;
0010c0  10800004          ADDNE    r0,r0,r4
0010c4  13c04801          BICNE    r4,r0,#0x10000
0010c8  1afffff3          BNE      |L1.4252|
;;;1151         }
;;;1152       }
;;;1153     }
;;;1154     return 0xFFFF;
;;;1155   }
0010cc  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4304|
0010d0  e51f0a48          LDR      r0,|L1.1680|
0010d4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4312|
                          DCD      0x000003cd
                  |L1.4316|
0010dc  70627566          DCB      "pbuf_take: invalid buf",0
0010e0  5f74616b
0010e4  653a2069
0010e8  6e76616c
0010ec  69642062
0010f0  756600  
0010f3  00                DCB      0
                  |L1.4340|
                          DCD      0x000003ce
                  |L1.4344|
0010f8  70627566          DCB      "pbuf_take: invalid dataptr",0
0010fc  5f74616b
001100  653a2069
001104  6e76616c
001108  69642064
00110c  61746170
001110  747200  
001113  00                DCB      0
                  |L1.4372|
                          DCD      0x000003d6
                  |L1.4376|
001118  70627566          DCB      "pbuf_take: invalid pbuf",0
00111c  5f74616b
001120  653a2069
001124  6e76616c
001128  69642070
00112c  62756600
                  |L1.4400|
                          DCD      0x000003e1
                  |L1.4404|
001134  64696420          DCB      "did not copy all data",0
001138  6e6f7420
00113c  636f7079
001140  20616c6c
001144  20646174
001148  6100    
00114a  00                DCB      0
00114b  00                DCB      0
                  |L1.4428|
                          DCD      0x000003ff
                  |L1.4432|
001150  70627566          DCB      "pbuf_copy failed",0
001154  5f636f70
001158  79206661
00115c  696c6564
001160  00      
001161  00                DCB      0
001162  00                DCB      0
001163  00                DCB      0
                          ENDP

                  pbuf_strstr PROC
;;;1167   u16_t
;;;1168   pbuf_strstr(struct pbuf* p, const char* substr)
001164  e92d4070          PUSH     {r4-r6,lr}
;;;1169   {
001168  e1b04001          MOVS     r4,r1
00116c  e1a06000          MOV      r6,r0
;;;1170     size_t substr_len;
;;;1171     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
001170  15d40000          LDRBNE   r0,[r4,#0]
001174  e51f5aec          LDR      r5,|L1.1680|
001178  13500000          CMPNE    r0,#0
00117c  11d600b8          LDRHNE   r0,[r6,#8]
001180  11500005          CMPNE    r0,r5
001184  0a000003          BEQ      |L1.4504|
;;;1172       return 0xFFFF;
;;;1173     }
;;;1174     substr_len = strlen(substr);
001188  e1a00001          MOV      r0,r1
00118c  ebfffffe          BL       strlen
;;;1175     if (substr_len >= 0xFFFF) {
001190  e1550000          CMP      r5,r0
001194  8a000001          BHI      |L1.4512|
                  |L1.4504|
;;;1176       return 0xFFFF;
001198  e1a00005          MOV      r0,r5
;;;1177     }
;;;1178     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1179   }
00119c  e8bd8070          POP      {r4-r6,pc}
                  |L1.4512|
0011a0  e1a02800          LSL      r2,r0,#16             ;1178
0011a4  e1a01004          MOV      r1,r4                 ;1178
0011a8  e1a00006          MOV      r0,r6                 ;1178
0011ac  e8bd4070          POP      {r4-r6,lr}            ;1178
0011b0  e1a02822          LSR      r2,r2,#16             ;1178
0011b4  e3a03000          MOV      r3,#0                 ;1178
0011b8  eafffffe          B        pbuf_memfind
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  pbuf_free_ooseq_pending
000000  00                DCB      0x00
