; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\heap_4.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\heap_4.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -D__UVISION_VERSION=524 --omf_browse=.\obj\heap_4.crf FreeRTOS\Source\portable\MemMang\heap_4.c]
                          ARM

                          AREA ||i.prvHeapInit||, CODE, READONLY, ALIGN=2

                  prvHeapInit PROC
;;;370    
;;;371    static void prvHeapInit( void )
000000  e92d4010          PUSH     {r4,lr}
;;;372    {
;;;373    BlockLink_t *pxFirstFreeBlock;
;;;374    uint8_t *pucAlignedHeap;
;;;375    size_t uxAddress;
;;;376    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
000004  e3a03a0a          MOV      r3,#0xa000
;;;377    
;;;378    	/* Ensure the heap starts on a correctly aligned boundary. */
;;;379    	uxAddress = ( size_t ) ucHeap;
000008  e59f00a4          LDR      r0,|L1.180|
;;;380    
;;;381    	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
00000c  e200c007          AND      r12,r0,#7
000010  e35c0000          CMP      r12,#0
000014  0a000004          BEQ      |L1.44|
;;;382    	{
;;;383    		uxAddress += ( portBYTE_ALIGNMENT - 1 );
000018  e2800007          ADD      r0,r0,#7
;;;384    		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
00001c  e3c00007          BIC      r0,r0,#7
;;;385    		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
000020  e59fc08c          LDR      r12,|L1.180|
000024  e040c00c          SUB      r12,r0,r12
000028  e043300c          SUB      r3,r3,r12
                  |L1.44|
;;;386    	}
;;;387    
;;;388    	pucAlignedHeap = ( uint8_t * ) uxAddress;
00002c  e1a02000          MOV      r2,r0
;;;389    
;;;390    	/* xStart is used to hold a pointer to the first item in the list of free
;;;391    	blocks.  The void cast is used to prevent compiler warnings. */
;;;392    	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
000030  e59fc080          LDR      r12,|L1.184|
000034  e58c2000          STR      r2,[r12,#0]  ; xStart
;;;393    	xStart.xBlockSize = ( size_t ) 0;
000038  e3a0c000          MOV      r12,#0
00003c  e59f4074          LDR      r4,|L1.184|
000040  e584c004          STR      r12,[r4,#4]  ; xStart
;;;394    
;;;395    	/* pxEnd is used to mark the end of the list of free blocks and is inserted
;;;396    	at the end of the heap space. */
;;;397    	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
000044  e0820003          ADD      r0,r2,r3
;;;398    	uxAddress -= xHeapStructSize;
000048  e2400008          SUB      r0,r0,#8
;;;399    	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
00004c  e3c00007          BIC      r0,r0,#7
;;;400    	pxEnd = ( void * ) uxAddress;
000050  e59fc064          LDR      r12,|L1.188|
000054  e58c0000          STR      r0,[r12,#0]  ; pxEnd
;;;401    	pxEnd->xBlockSize = 0;
000058  e3a0c000          MOV      r12,#0
00005c  e59f4058          LDR      r4,|L1.188|
000060  e5944000          LDR      r4,[r4,#0]  ; pxEnd
000064  e584c004          STR      r12,[r4,#4]
;;;402    	pxEnd->pxNextFreeBlock = NULL;
000068  e59f404c          LDR      r4,|L1.188|
00006c  e5944000          LDR      r4,[r4,#0]  ; pxEnd
000070  e584c000          STR      r12,[r4,#0]
;;;403    
;;;404    	/* To start with there is a single free block that is sized to take up the
;;;405    	entire heap space, minus the space taken by pxEnd. */
;;;406    	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
000074  e1a01002          MOV      r1,r2
;;;407    	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
000078  e040c001          SUB      r12,r0,r1
00007c  e581c004          STR      r12,[r1,#4]
;;;408    	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
000080  e59fc034          LDR      r12,|L1.188|
000084  e59cc000          LDR      r12,[r12,#0]  ; pxEnd
000088  e581c000          STR      r12,[r1,#0]
;;;409    
;;;410    	/* Only one block exists - and it covers the entire usable heap space. */
;;;411    	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
00008c  e59f402c          LDR      r4,|L1.192|
000090  e591c004          LDR      r12,[r1,#4]
000094  e584c000          STR      r12,[r4,#0]  ; xMinimumEverFreeBytesRemaining
;;;412    	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
000098  e59f4024          LDR      r4,|L1.196|
00009c  e591c004          LDR      r12,[r1,#4]
0000a0  e584c000          STR      r12,[r4,#0]  ; xFreeBytesRemaining
;;;413    
;;;414    	/* Work out the position of the top bit in a size_t variable. */
;;;415    	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
0000a4  e3a0c102          MOV      r12,#0x80000000
0000a8  e59f4018          LDR      r4,|L1.200|
0000ac  e584c000          STR      r12,[r4,#0]  ; xBlockAllocatedBit
;;;416    }
0000b0  e8bd8010          POP      {r4,pc}
;;;417    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.180|
                          DCD      ucHeap
                  |L1.184|
                          DCD      xStart
                  |L1.188|
                          DCD      pxEnd
                  |L1.192|
                          DCD      xMinimumEverFreeBytesRemaining
                  |L1.196|
                          DCD      xFreeBytesRemaining
                  |L1.200|
                          DCD      xBlockAllocatedBit

                          AREA ||i.prvInsertBlockIntoFreeList||, CODE, READONLY, ALIGN=2

                  prvInsertBlockIntoFreeList PROC
;;;418    
;;;419    static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
000000  e1a01000          MOV      r1,r0
;;;420    {
;;;421    BlockLink_t *pxIterator;
;;;422    uint8_t *puc;
;;;423    
;;;424    	/* Iterate through the list until a block is found that has a higher address
;;;425    	than the block being inserted. */
;;;426    	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
000004  e59f00b0          LDR      r0,|L2.188|
000008  ea000000          B        |L2.16|
                  |L2.12|
00000c  e5900000          LDR      r0,[r0,#0]
                  |L2.16|
000010  e5903000          LDR      r3,[r0,#0]
000014  e1530001          CMP      r3,r1
000018  3afffffb          BCC      |L2.12|
;;;427    	{
;;;428    		/* Nothing to do here, just iterate to the right position. */
;;;429    	}
;;;430    
;;;431    	/* Do the block being inserted, and the block it is being inserted after
;;;432    	make a contiguous block of memory? */
;;;433    	puc = ( uint8_t * ) pxIterator;
00001c  e1a02000          MOV      r2,r0
;;;434    	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
000020  e5903004          LDR      r3,[r0,#4]
000024  e0833002          ADD      r3,r3,r2
000028  e1530001          CMP      r3,r1
00002c  1a000004          BNE      |L2.68|
;;;435    	{
;;;436    		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
000030  e5903004          LDR      r3,[r0,#4]
000034  e591c004          LDR      r12,[r1,#4]
000038  e083300c          ADD      r3,r3,r12
00003c  e5803004          STR      r3,[r0,#4]
;;;437    		pxBlockToInsert = pxIterator;
000040  e1a01000          MOV      r1,r0
                  |L2.68|
;;;438    	}
;;;439    	else
;;;440    	{
;;;441    		mtCOVERAGE_TEST_MARKER();
;;;442    	}
;;;443    
;;;444    	/* Do the block being inserted, and the block it is being inserted before
;;;445    	make a contiguous block of memory? */
;;;446    	puc = ( uint8_t * ) pxBlockToInsert;
000044  e1a02001          MOV      r2,r1
;;;447    	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
000048  e5913004          LDR      r3,[r1,#4]
00004c  e0833002          ADD      r3,r3,r2
000050  e590c000          LDR      r12,[r0,#0]
000054  e153000c          CMP      r3,r12
000058  1a000011          BNE      |L2.164|
;;;448    	{
;;;449    		if( pxIterator->pxNextFreeBlock != pxEnd )
00005c  e59fc05c          LDR      r12,|L2.192|
000060  e5903000          LDR      r3,[r0,#0]
000064  e59cc000          LDR      r12,[r12,#0]  ; pxEnd
000068  e153000c          CMP      r3,r12
00006c  0a000008          BEQ      |L2.148|
;;;450    		{
;;;451    			/* Form one big block from the two blocks. */
;;;452    			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
000070  e5913004          LDR      r3,[r1,#4]
000074  e590c000          LDR      r12,[r0,#0]
000078  e59cc004          LDR      r12,[r12,#4]
00007c  e083300c          ADD      r3,r3,r12
000080  e5813004          STR      r3,[r1,#4]
;;;453    			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
000084  e5903000          LDR      r3,[r0,#0]
000088  e5933000          LDR      r3,[r3,#0]
00008c  e5813000          STR      r3,[r1,#0]
000090  ea000005          B        |L2.172|
                  |L2.148|
;;;454    		}
;;;455    		else
;;;456    		{
;;;457    			pxBlockToInsert->pxNextFreeBlock = pxEnd;
000094  e59f3024          LDR      r3,|L2.192|
000098  e5933000          LDR      r3,[r3,#0]  ; pxEnd
00009c  e5813000          STR      r3,[r1,#0]
0000a0  ea000001          B        |L2.172|
                  |L2.164|
;;;458    		}
;;;459    	}
;;;460    	else
;;;461    	{
;;;462    		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
0000a4  e5903000          LDR      r3,[r0,#0]
0000a8  e5813000          STR      r3,[r1,#0]
                  |L2.172|
;;;463    	}
;;;464    
;;;465    	/* If the block being inserted plugged a gab, so was merged with the block
;;;466    	before and the block after, then it's pxNextFreeBlock pointer will have
;;;467    	already been set, and should not be set here as that would make it point
;;;468    	to itself. */
;;;469    	if( pxIterator != pxBlockToInsert )
0000ac  e1500001          CMP      r0,r1
0000b0  0a000000          BEQ      |L2.184|
;;;470    	{
;;;471    		pxIterator->pxNextFreeBlock = pxBlockToInsert;
0000b4  e5801000          STR      r1,[r0,#0]
                  |L2.184|
;;;472    	}
;;;473    	else
;;;474    	{
;;;475    		mtCOVERAGE_TEST_MARKER();
;;;476    	}
;;;477    }
0000b8  e12fff1e          BX       lr
;;;478    
                          ENDP

                  |L2.188|
                          DCD      xStart
                  |L2.192|
                          DCD      pxEnd

                          AREA ||i.pvPortMalloc||, CODE, READONLY, ALIGN=2

                  pvPortMalloc PROC
;;;154    
;;;155    void *pvPortMalloc( size_t xWantedSize )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;156    {
000004  e1a04000          MOV      r4,r0
;;;157    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;158    void *pvReturn = NULL;
000008  e3a08000          MOV      r8,#0
;;;159    
;;;160    	vTaskSuspendAll();
00000c  ebfffffe          BL       vTaskSuspendAll
;;;161    	{
;;;162    		/* If this is the first call to malloc then the heap will require
;;;163    		initialisation to setup the list of free blocks. */
;;;164    		if( pxEnd == NULL )
000010  e59f01e8          LDR      r0,|L3.512|
000014  e5900000          LDR      r0,[r0,#0]  ; pxEnd
000018  e3500000          CMP      r0,#0
00001c  1a000000          BNE      |L3.36|
;;;165    		{
;;;166    			prvHeapInit();
000020  ebfffffe          BL       prvHeapInit
                  |L3.36|
;;;167    		}
;;;168    		else
;;;169    		{
;;;170    			mtCOVERAGE_TEST_MARKER();
;;;171    		}
;;;172    
;;;173    		/* Check the requested block size is not so large that the top bit is
;;;174    		set.  The top bit of the block size member of the BlockLink_t structure
;;;175    		is used to determine who owns the block - the application or the
;;;176    		kernel, so it must be free. */
;;;177    		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
000024  e59f01d8          LDR      r0,|L3.516|
000028  e5900000          LDR      r0,[r0,#0]  ; xBlockAllocatedBit
00002c  e0000004          AND      r0,r0,r4
000030  e3500000          CMP      r0,#0
000034  1a000060          BNE      |L3.444|
;;;178    		{
;;;179    			/* The wanted size is increased so it can contain a BlockLink_t
;;;180    			structure in addition to the requested amount of bytes. */
;;;181    			if( xWantedSize > 0 )
000038  e3540000          CMP      r4,#0
00003c  0a000014          BEQ      |L3.148|
;;;182    			{
;;;183    				xWantedSize += xHeapStructSize;
000040  e2844008          ADD      r4,r4,#8
;;;184    
;;;185    				/* Ensure that blocks are always aligned to the required number
;;;186    				of bytes. */
;;;187    				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
000044  e2040007          AND      r0,r4,#7
000048  e3500000          CMP      r0,#0
00004c  0a000010          BEQ      |L3.148|
;;;188    				{
;;;189    					/* Byte alignment required. */
;;;190    					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
000050  e2040007          AND      r0,r4,#7
000054  e2600008          RSB      r0,r0,#8
000058  e0844000          ADD      r4,r4,r0
;;;191    					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
00005c  e2040007          AND      r0,r4,#7
000060  e3500000          CMP      r0,#0
000064  1a000001          BNE      |L3.112|
000068  e3a00001          MOV      r0,#1
00006c  ea000000          B        |L3.116|
                  |L3.112|
000070  e3a00000          MOV      r0,#0
                  |L3.116|
000074  e3500000          CMP      r0,#0
000078  1a000005          BNE      |L3.148|
00007c  e1a00000          MOV      r0,r0
000080  e28f2d06          ADR      r2,|L3.520|
000084  e3a010bf          MOV      r1,#0xbf
000088  e28f0f69          ADR      r0,|L3.564|
00008c  ebfffffe          BL       sysprintf
000090  e1a00000          MOV      r0,r0
                  |L3.148|
;;;192    				}
;;;193    				else
;;;194    				{
;;;195    					mtCOVERAGE_TEST_MARKER();
;;;196    				}
;;;197    			}
;;;198    			else
;;;199    			{
;;;200    				mtCOVERAGE_TEST_MARKER();
;;;201    			}
;;;202    
;;;203    			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
000094  e3540000          CMP      r4,#0
000098  0a000047          BEQ      |L3.444|
00009c  e59f01bc          LDR      r0,|L3.608|
0000a0  e5900000          LDR      r0,[r0,#0]  ; xFreeBytesRemaining
0000a4  e1540000          CMP      r4,r0
0000a8  8a000043          BHI      |L3.444|
;;;204    			{
;;;205    				/* Traverse the list from the start	(lowest address) block until
;;;206    				one	of adequate size is found. */
;;;207    				pxPreviousBlock = &xStart;
0000ac  e59f61b0          LDR      r6,|L3.612|
;;;208    				pxBlock = xStart.pxNextFreeBlock;
0000b0  e2860000          ADD      r0,r6,#0
0000b4  e5905000          LDR      r5,[r0,#0]  ; xStart
;;;209    				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
0000b8  ea000001          B        |L3.196|
                  |L3.188|
;;;210    				{
;;;211    					pxPreviousBlock = pxBlock;
0000bc  e1a06005          MOV      r6,r5
;;;212    					pxBlock = pxBlock->pxNextFreeBlock;
0000c0  e5955000          LDR      r5,[r5,#0]
                  |L3.196|
0000c4  e5950004          LDR      r0,[r5,#4]            ;209
0000c8  e1500004          CMP      r0,r4                 ;209
0000cc  2a000002          BCS      |L3.220|
0000d0  e5950000          LDR      r0,[r5,#0]            ;209
0000d4  e3500000          CMP      r0,#0                 ;209
0000d8  1afffff7          BNE      |L3.188|
                  |L3.220|
;;;213    				}
;;;214    
;;;215    				/* If the end marker was reached then a block of adequate size
;;;216    				was	not found. */
;;;217    				if( pxBlock != pxEnd )
0000dc  e59f011c          LDR      r0,|L3.512|
0000e0  e5900000          LDR      r0,[r0,#0]  ; pxEnd
0000e4  e1550000          CMP      r5,r0
0000e8  0a000033          BEQ      |L3.444|
;;;218    				{
;;;219    					/* Return the memory space pointed to - jumping over the
;;;220    					BlockLink_t structure at its start. */
;;;221    					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
0000ec  e5960000          LDR      r0,[r6,#0]
0000f0  e2808008          ADD      r8,r0,#8
;;;222    
;;;223    					/* This block is being returned for use so must be taken out
;;;224    					of the list of free blocks. */
;;;225    					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
0000f4  e5950000          LDR      r0,[r5,#0]
0000f8  e5860000          STR      r0,[r6,#0]
;;;226    
;;;227    					/* If the block is larger than required it can be split into
;;;228    					two. */
;;;229    					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
0000fc  e5950004          LDR      r0,[r5,#4]
000100  e0400004          SUB      r0,r0,r4
000104  e3500010          CMP      r0,#0x10
000108  9a000014          BLS      |L3.352|
;;;230    					{
;;;231    						/* This block is to be split into two.  Create a new
;;;232    						block following the number of bytes requested. The void
;;;233    						cast is used to prevent byte alignment warnings from the
;;;234    						compiler. */
;;;235    						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
00010c  e0857004          ADD      r7,r5,r4
;;;236    						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
000110  e2070007          AND      r0,r7,#7
000114  e3500000          CMP      r0,#0
000118  1a000001          BNE      |L3.292|
00011c  e3a00001          MOV      r0,#1
000120  ea000000          B        |L3.296|
                  |L3.292|
000124  e3a00000          MOV      r0,#0
                  |L3.296|
000128  e3500000          CMP      r0,#0
00012c  1a000005          BNE      |L3.328|
000130  e1a00000          MOV      r0,r0
000134  e28f20cc          ADR      r2,|L3.520|
000138  e3a010ec          MOV      r1,#0xec
00013c  e28f00f0          ADR      r0,|L3.564|
000140  ebfffffe          BL       sysprintf
000144  e1a00000          MOV      r0,r0
                  |L3.328|
;;;237    
;;;238    						/* Calculate the sizes of two blocks split from the
;;;239    						single block. */
;;;240    						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
000148  e5950004          LDR      r0,[r5,#4]
00014c  e0400004          SUB      r0,r0,r4
000150  e5870004          STR      r0,[r7,#4]
;;;241    						pxBlock->xBlockSize = xWantedSize;
000154  e5854004          STR      r4,[r5,#4]
;;;242    
;;;243    						/* Insert the new block into the list of free blocks. */
;;;244    						prvInsertBlockIntoFreeList( pxNewBlockLink );
000158  e1a00007          MOV      r0,r7
00015c  ebfffffe          BL       prvInsertBlockIntoFreeList
                  |L3.352|
;;;245    					}
;;;246    					else
;;;247    					{
;;;248    						mtCOVERAGE_TEST_MARKER();
;;;249    					}
;;;250    
;;;251    					xFreeBytesRemaining -= pxBlock->xBlockSize;
000160  e59f10f8          LDR      r1,|L3.608|
000164  e5950004          LDR      r0,[r5,#4]
000168  e5911000          LDR      r1,[r1,#0]  ; xFreeBytesRemaining
00016c  e0410000          SUB      r0,r1,r0
000170  e59f10e8          LDR      r1,|L3.608|
000174  e5810000          STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;252    
;;;253    					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
000178  e2810000          ADD      r0,r1,#0
00017c  e5900000          LDR      r0,[r0,#0]  ; xFreeBytesRemaining
000180  e59f10e0          LDR      r1,|L3.616|
000184  e5911000          LDR      r1,[r1,#0]  ; xMinimumEverFreeBytesRemaining
000188  e1500001          CMP      r0,r1
00018c  2a000003          BCS      |L3.416|
;;;254    					{
;;;255    						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
000190  e59f00c8          LDR      r0,|L3.608|
000194  e5900000          LDR      r0,[r0,#0]  ; xFreeBytesRemaining
000198  e59f10c8          LDR      r1,|L3.616|
00019c  e5810000          STR      r0,[r1,#0]  ; xMinimumEverFreeBytesRemaining
                  |L3.416|
;;;256    					}
;;;257    					else
;;;258    					{
;;;259    						mtCOVERAGE_TEST_MARKER();
;;;260    					}
;;;261    
;;;262    					/* The block is being returned - it is allocated and owned
;;;263    					by the application and has no "next" block. */
;;;264    					pxBlock->xBlockSize |= xBlockAllocatedBit;
0001a0  e59f105c          LDR      r1,|L3.516|
0001a4  e5950004          LDR      r0,[r5,#4]
0001a8  e5911000          LDR      r1,[r1,#0]  ; xBlockAllocatedBit
0001ac  e1800001          ORR      r0,r0,r1
0001b0  e5850004          STR      r0,[r5,#4]
;;;265    					pxBlock->pxNextFreeBlock = NULL;
0001b4  e3a00000          MOV      r0,#0
0001b8  e5850000          STR      r0,[r5,#0]
                  |L3.444|
;;;266    				}
;;;267    				else
;;;268    				{
;;;269    					mtCOVERAGE_TEST_MARKER();
;;;270    				}
;;;271    			}
;;;272    			else
;;;273    			{
;;;274    				mtCOVERAGE_TEST_MARKER();
;;;275    			}
;;;276    		}
;;;277    		else
;;;278    		{
;;;279    			mtCOVERAGE_TEST_MARKER();
;;;280    		}
;;;281    
;;;282    		traceMALLOC( pvReturn, xWantedSize );
;;;283    	}
;;;284    	( void ) xTaskResumeAll();
0001bc  ebfffffe          BL       xTaskResumeAll
;;;285    
;;;286    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;287    	{
;;;288    		if( pvReturn == NULL )
;;;289    		{
;;;290    			extern void vApplicationMallocFailedHook( void );
;;;291    			vApplicationMallocFailedHook();
;;;292    		}
;;;293    		else
;;;294    		{
;;;295    			mtCOVERAGE_TEST_MARKER();
;;;296    		}
;;;297    	}
;;;298    	#endif
;;;299    
;;;300    	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
0001c0  e2080007          AND      r0,r8,#7
0001c4  e3500000          CMP      r0,#0
0001c8  1a000001          BNE      |L3.468|
0001cc  e3a00001          MOV      r0,#1
0001d0  ea000000          B        |L3.472|
                  |L3.468|
0001d4  e3a00000          MOV      r0,#0
                  |L3.472|
0001d8  e3500000          CMP      r0,#0
0001dc  1a000005          BNE      |L3.504|
0001e0  e1a00000          MOV      r0,r0
0001e4  e28f201c          ADR      r2,|L3.520|
0001e8  e3a01f4b          MOV      r1,#0x12c
0001ec  e28f0040          ADR      r0,|L3.564|
0001f0  ebfffffe          BL       sysprintf
0001f4  e1a00000          MOV      r0,r0
                  |L3.504|
;;;301    	return pvReturn;
0001f8  e1a00008          MOV      r0,r8
;;;302    }
0001fc  e8bd81f0          POP      {r4-r8,pc}
;;;303    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.512|
                          DCD      pxEnd
                  |L3.516|
                          DCD      xBlockAllocatedBit
                  |L3.520|
000208  46726565          DCB      "FreeRTOS\\Source\\portable\\MemMang\\heap_4.c",0
00020c  52544f53
000210  5c536f75
000214  7263655c
000218  706f7274
00021c  61626c65
000220  5c4d656d
000224  4d616e67
000228  5c686561
00022c  705f342e
000230  6300    
000232  00                DCB      0
000233  00                DCB      0
                  |L3.564|
000234  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000238  7274696f
00023c  6e202220
000240  3f3f3f20
000244  22206661
000248  696c6564
00024c  20617420
000250  6c696e65
000254  20256420
000258  696e2025
00025c  730a00  
00025f  00                DCB      0
                  |L3.608|
                          DCD      xFreeBytesRemaining
                  |L3.612|
                          DCD      xStart
                  |L3.616|
                          DCD      xMinimumEverFreeBytesRemaining

                          AREA ||i.vPortFree||, CODE, READONLY, ALIGN=2

                  vPortFree PROC
;;;304    
;;;305    void vPortFree( void *pv )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;306    {
000004  e1a06000          MOV      r6,r0
;;;307    uint8_t *puc = ( uint8_t * ) pv;
000008  e1a05006          MOV      r5,r6
;;;308    BlockLink_t *pxLink;
;;;309    
;;;310    	if( pv != NULL )
00000c  e3560000          CMP      r6,#0
000010  0a000038          BEQ      |L4.248|
;;;311    	{
;;;312    		/* The memory being freed will have an BlockLink_t structure immediately
;;;313    		before it. */
;;;314    		puc -= xHeapStructSize;
000014  e2455008          SUB      r5,r5,#8
;;;315    
;;;316    		/* This casting is to keep the compiler from issuing warnings. */
;;;317    		pxLink = ( void * ) puc;
000018  e1a04005          MOV      r4,r5
;;;318    
;;;319    		/* Check the block is actually allocated. */
;;;320    		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
00001c  e59f10d8          LDR      r1,|L4.252|
000020  e5940004          LDR      r0,[r4,#4]
000024  e5911000          LDR      r1,[r1,#0]  ; xBlockAllocatedBit
000028  e0000001          AND      r0,r0,r1
00002c  e3500000          CMP      r0,#0
000030  0a000001          BEQ      |L4.60|
000034  e3a00001          MOV      r0,#1
000038  ea000000          B        |L4.64|
                  |L4.60|
00003c  e3a00000          MOV      r0,#0
                  |L4.64|
000040  e3500000          CMP      r0,#0
000044  1a000005          BNE      |L4.96|
000048  e1a00000          MOV      r0,r0
00004c  e28f20ac          ADR      r2,|L4.256|
000050  e3a01d05          MOV      r1,#0x140
000054  e28f00d0          ADR      r0,|L4.300|
000058  ebfffffe          BL       sysprintf
00005c  e1a00000          MOV      r0,r0
                  |L4.96|
;;;321    		configASSERT( pxLink->pxNextFreeBlock == NULL );
000060  e5940000          LDR      r0,[r4,#0]
000064  e3500000          CMP      r0,#0
000068  1a000001          BNE      |L4.116|
00006c  e3a00001          MOV      r0,#1
000070  ea000000          B        |L4.120|
                  |L4.116|
000074  e3a00000          MOV      r0,#0
                  |L4.120|
000078  e3500000          CMP      r0,#0
00007c  1a000005          BNE      |L4.152|
000080  e1a00000          MOV      r0,r0
000084  e28f2074          ADR      r2,|L4.256|
000088  e59f10c8          LDR      r1,|L4.344|
00008c  e28f0098          ADR      r0,|L4.300|
000090  ebfffffe          BL       sysprintf
000094  e1a00000          MOV      r0,r0
                  |L4.152|
;;;322    
;;;323    		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
000098  e59f105c          LDR      r1,|L4.252|
00009c  e5940004          LDR      r0,[r4,#4]
0000a0  e5911000          LDR      r1,[r1,#0]  ; xBlockAllocatedBit
0000a4  e0000001          AND      r0,r0,r1
0000a8  e3500000          CMP      r0,#0
0000ac  0a000011          BEQ      |L4.248|
;;;324    		{
;;;325    			if( pxLink->pxNextFreeBlock == NULL )
0000b0  e5940000          LDR      r0,[r4,#0]
0000b4  e3500000          CMP      r0,#0
0000b8  1a00000e          BNE      |L4.248|
;;;326    			{
;;;327    				/* The block is being returned to the heap - it is no longer
;;;328    				allocated. */
;;;329    				pxLink->xBlockSize &= ~xBlockAllocatedBit;
0000bc  e59f1038          LDR      r1,|L4.252|
0000c0  e5940004          LDR      r0,[r4,#4]
0000c4  e5911000          LDR      r1,[r1,#0]  ; xBlockAllocatedBit
0000c8  e1c00001          BIC      r0,r0,r1
0000cc  e5840004          STR      r0,[r4,#4]
;;;330    
;;;331    				vTaskSuspendAll();
0000d0  ebfffffe          BL       vTaskSuspendAll
;;;332    				{
;;;333    					/* Add this block to the list of free blocks. */
;;;334    					xFreeBytesRemaining += pxLink->xBlockSize;
0000d4  e59f1080          LDR      r1,|L4.348|
0000d8  e5940004          LDR      r0,[r4,#4]
0000dc  e5911000          LDR      r1,[r1,#0]  ; xFreeBytesRemaining
0000e0  e0800001          ADD      r0,r0,r1
0000e4  e59f1070          LDR      r1,|L4.348|
0000e8  e5810000          STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;335    					traceFREE( pv, pxLink->xBlockSize );
;;;336    					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
0000ec  e1a00004          MOV      r0,r4
0000f0  ebfffffe          BL       prvInsertBlockIntoFreeList
;;;337    				}
;;;338    				( void ) xTaskResumeAll();
0000f4  ebfffffe          BL       xTaskResumeAll
                  |L4.248|
;;;339    			}
;;;340    			else
;;;341    			{
;;;342    				mtCOVERAGE_TEST_MARKER();
;;;343    			}
;;;344    		}
;;;345    		else
;;;346    		{
;;;347    			mtCOVERAGE_TEST_MARKER();
;;;348    		}
;;;349    	}
;;;350    }
0000f8  e8bd8070          POP      {r4-r6,pc}
;;;351    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.252|
                          DCD      xBlockAllocatedBit
                  |L4.256|
000100  46726565          DCB      "FreeRTOS\\Source\\portable\\MemMang\\heap_4.c",0
000104  52544f53
000108  5c536f75
00010c  7263655c
000110  706f7274
000114  61626c65
000118  5c4d656d
00011c  4d616e67
000120  5c686561
000124  705f342e
000128  6300    
00012a  00                DCB      0
00012b  00                DCB      0
                  |L4.300|
00012c  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000130  7274696f
000134  6e202220
000138  3f3f3f20
00013c  22206661
000140  696c6564
000144  20617420
000148  6c696e65
00014c  20256420
000150  696e2025
000154  730a00  
000157  00                DCB      0
                  |L4.344|
                          DCD      0x00000141
                  |L4.348|
                          DCD      xFreeBytesRemaining

                          AREA ||i.vPortInitialiseBlocks||, CODE, READONLY, ALIGN=2

                  vPortInitialiseBlocks PROC
;;;364    
;;;365    void vPortInitialiseBlocks( void )
000000  e12fff1e          BX       lr
;;;366    {
;;;367    	/* This just exists to keep the linker quiet. */
;;;368    }
;;;369    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xPortGetFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetFreeHeapSize PROC
;;;352    
;;;353    size_t xPortGetFreeHeapSize( void )
000000  e59f0004          LDR      r0,|L6.12|
;;;354    {
;;;355    	return xFreeBytesRemaining;
000004  e5900000          LDR      r0,[r0,#0]  ; xFreeBytesRemaining
;;;356    }
000008  e12fff1e          BX       lr
;;;357    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.12|
                          DCD      xFreeBytesRemaining

                          AREA ||i.xPortGetMinimumEverFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetMinimumEverFreeHeapSize PROC
;;;358    
;;;359    size_t xPortGetMinimumEverFreeHeapSize( void )
000000  e59f0004          LDR      r0,|L7.12|
;;;360    {
;;;361    	return xMinimumEverFreeBytesRemaining;
000004  e5900000          LDR      r0,[r0,#0]  ; xMinimumEverFreeBytesRemaining
;;;362    }
000008  e12fff1e          BX       lr
;;;363    /*-----------------------------------------------------------*/
                          ENDP

                  |L7.12|
                          DCD      xMinimumEverFreeBytesRemaining

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        40960

                          AREA ||.data||, DATA, ALIGN=2

                  xStart
                          %        8
                  pxEnd
                          DCD      0x00000000
                  xFreeBytesRemaining
                          DCD      0x00000000
                  xMinimumEverFreeBytesRemaining
                          DCD      0x00000000
                  xBlockAllocatedBit
                          DCD      0x00000000
