; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\sys_arch.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\sys_arch.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\sys_arch.crf lwip-1.4.1\sys_arch.c]
                          ARM

                          AREA ||i.inHandlerMode||, CODE, READONLY, ALIGN=2

                  inHandlerMode PROC
;;;37     /* Determine whether we are in thread mode or handler mode. */
;;;38     int inHandlerMode (void)
000000  e10f1000          MRS      r1,APSR ; formerly CPSR
;;;39     {
;;;40         int ret;
;;;41         __asm
;;;42         {
;;;43             MRS ret, CPSR
;;;44         }
;;;45         ret &= 0x1F;
000004  e201101f          AND      r1,r1,#0x1f
;;;46         if (ret == 0x1F)
000008  e351001f          CMP      r1,#0x1f
00000c  1a000001          BNE      |L1.24|
;;;47             return 0;
000010  e3a00000          MOV      r0,#0
                  |L1.20|
;;;48         else
;;;49             return 1;
;;;50     }
000014  e12fff1e          BX       lr
                  |L1.24|
000018  e3a00001          MOV      r0,#1                 ;49
00001c  eafffffc          B        |L1.20|
;;;51     
                          ENDP


                          AREA ||i.sys_arch_mbox_fetch||, CODE, READONLY, ALIGN=2

                  sys_arch_mbox_fetch PROC
;;;431     */
;;;432    u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;433    {
000004  e1a07000          MOV      r7,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a09002          MOV      r9,r2
;;;434    	portTickType TickStart;
;;;435    	portTickType TickStop;
;;;436    	void *tempoptr;
;;;437    	/* Express the timeout in OS tick. */
;;;438    	portTickType TickElapsed = (portTickType)(timeout / portTICK_RATE_MS);
000010  e1a05009          MOV      r5,r9
;;;439    
;;;440    	/* Sanity check */
;;;441    	if (mbox != NULL) {
000014  e3570000          CMP      r7,#0
000018  0a00002c          BEQ      |L2.208|
;;;442    		if (timeout && !TickElapsed) {
00001c  e3590000          CMP      r9,#0
000020  0a000002          BEQ      |L2.48|
000024  e3550000          CMP      r5,#0
000028  1a000000          BNE      |L2.48|
;;;443    			TickElapsed = 1; /* Wait at least one tick */
00002c  e3a05001          MOV      r5,#1
                  |L2.48|
;;;444    		}
;;;445    
;;;446    		if (msg == NULL) {
000030  e3580000          CMP      r8,#0
000034  1a000000          BNE      |L2.60|
;;;447    			msg = &tempoptr;
000038  e1a0800d          MOV      r8,sp
                  |L2.60|
;;;448    		}
;;;449    
;;;450    		/* NOTE: INCLUDE_xTaskGetSchedulerState must be set to 1 in
;;;451    		 * FreeRTOSConfig.h for xTaskGetTickCount() to be available */
;;;452    		if (0 == TickElapsed) {
00003c  e3550000          CMP      r5,#0
000040  1a00000a          BNE      |L2.112|
;;;453    			TickStart = xTaskGetTickCount();
000044  ebfffffe          BL       xTaskGetTickCount
000048  e1a04000          MOV      r4,r0
;;;454    			/* If "timeout" is 0, the thread should be blocked until
;;;455    			 * a message arrives */
;;;456    			while (pdFALSE == xQueueReceive( *mbox, &(*msg),
00004c  e1a00000          MOV      r0,r0
                  |L2.80|
000050  e3a03000          MOV      r3,#0
000054  e5970000          LDR      r0,[r7,#0]
000058  e59f2078          LDR      r2,|L2.216|
00005c  e1a01008          MOV      r1,r8
000060  ebfffffe          BL       xQueueGenericReceive
000064  e3500000          CMP      r0,#0
000068  0afffff8          BEQ      |L2.80|
00006c  ea00000c          B        |L2.164|
                  |L2.112|
;;;457    					SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
;;;458    			}
;;;459    		} else {
;;;460    			TickStart = xTaskGetTickCount();
000070  ebfffffe          BL       xTaskGetTickCount
000074  e1a04000          MOV      r4,r0
;;;461    			if (pdFALSE == xQueueReceive( *mbox, &(*msg), TickElapsed )) {
000078  e3a03000          MOV      r3,#0
00007c  e1a02005          MOV      r2,r5
000080  e1a01008          MOV      r1,r8
000084  e5970000          LDR      r0,[r7,#0]
000088  ebfffffe          BL       xQueueGenericReceive
00008c  e3500000          CMP      r0,#0
000090  1a000003          BNE      |L2.164|
;;;462    				*msg = NULL;
000094  e3a00000          MOV      r0,#0
000098  e5880000          STR      r0,[r8,#0]
;;;463    				/* if the function times out, it should return
;;;464    				 * SYS_ARCH_TIMEOUT. */
;;;465    				return(SYS_ARCH_TIMEOUT);
00009c  e3e00000          MVN      r0,#0
                  |L2.160|
;;;466    			}
;;;467    		}
;;;468    
;;;469    		/* If the function gets a msg, it should return the number of ms
;;;470    		 * spent waiting. */
;;;471    		TickStop = xTaskGetTickCount();
;;;472    		/* Take care of wrap-around. */
;;;473    		if (TickStop >= TickStart) {
;;;474    			TickElapsed = TickStop - TickStart;
;;;475    		} else {
;;;476    			TickElapsed = portMAX_DELAY - TickStart + TickStop;
;;;477    		}
;;;478    
;;;479    		return(TickElapsed * portTICK_RATE_MS);
;;;480    	} else {
;;;481    		return (u32_t)ERR_MEM;
;;;482    	}
;;;483    }
0000a0  e8bd83f8          POP      {r3-r9,pc}
                  |L2.164|
0000a4  ebfffffe          BL       xTaskGetTickCount
0000a8  e1a06000          MOV      r6,r0                 ;471
0000ac  e1560004          CMP      r6,r4                 ;473
0000b0  3a000001          BCC      |L2.188|
0000b4  e0465004          SUB      r5,r6,r4              ;474
0000b8  ea000002          B        |L2.200|
                  |L2.188|
0000bc  e3e00000          MVN      r0,#0                 ;476
0000c0  e0400004          SUB      r0,r0,r4              ;476
0000c4  e0805006          ADD      r5,r0,r6              ;476
                  |L2.200|
0000c8  e1a00005          MOV      r0,r5                 ;479
0000cc  eafffff3          B        |L2.160|
                  |L2.208|
0000d0  e3e00000          MVN      r0,#0                 ;481
0000d4  eafffff1          B        |L2.160|
;;;484    
                          ENDP

                  |L2.216|
                          DCD      0x00002710

                          AREA ||i.sys_arch_mbox_tryfetch||, CODE, READONLY, ALIGN=2

                  sys_arch_mbox_tryfetch PROC
;;;497     */
;;;498    u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
000000  e92d4038          PUSH     {r3-r5,lr}
;;;499    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;500    	void *tempoptr;
;;;501    	/* Sanity check */
;;;502    	if (mbox != NULL) {
00000c  e3540000          CMP      r4,#0
000010  0a00000d          BEQ      |L3.76|
;;;503    		if (msg == NULL) {
000014  e3550000          CMP      r5,#0
000018  1a000000          BNE      |L3.32|
;;;504    			msg = &tempoptr;
00001c  e1a0500d          MOV      r5,sp
                  |L3.32|
;;;505    		}
;;;506    
;;;507    		if (pdFALSE == xQueueReceive( *mbox, &(*msg), 0 )) {
000020  e3a03000          MOV      r3,#0
000024  e1a02003          MOV      r2,r3
000028  e1a01005          MOV      r1,r5
00002c  e5940000          LDR      r0,[r4,#0]
000030  ebfffffe          BL       xQueueGenericReceive
000034  e3500000          CMP      r0,#0
000038  1a000001          BNE      |L3.68|
;;;508    			/* if a message is not present in the mailbox, it
;;;509    			 * immediately returns with */
;;;510    			/* the code SYS_MBOX_EMPTY. */
;;;511    			return(SYS_MBOX_EMPTY);
00003c  e3e00000          MVN      r0,#0
                  |L3.64|
;;;512    		}
;;;513    
;;;514    		/* On success 0 is returned. */
;;;515    		return(0);
;;;516    	} else {
;;;517    		return(SYS_MBOX_EMPTY);
;;;518    	}
;;;519    }
000040  e8bd8038          POP      {r3-r5,pc}
                  |L3.68|
000044  e3a00000          MOV      r0,#0                 ;515
000048  eafffffc          B        |L3.64|
                  |L3.76|
00004c  e3e00000          MVN      r0,#0                 ;517
000050  eafffffa          B        |L3.64|
;;;520    
                          ENDP


                          AREA ||i.sys_arch_protect||, CODE, READONLY, ALIGN=2

                  sys_arch_protect PROC
;;;672     */
;;;673    sys_prot_t sys_arch_protect(void)
000000  e92d4010          PUSH     {r4,lr}
;;;674    {
;;;675    	vPortEnterCritical();
000004  ebfffffe          BL       vPortEnterCritical
;;;676    	return 1; /* Not used */
000008  e3a00001          MOV      r0,#1
;;;677    }
00000c  e8bd8010          POP      {r4,pc}
;;;678    
                          ENDP


                          AREA ||i.sys_arch_sem_wait||, CODE, READONLY, ALIGN=2

                  sys_arch_sem_wait PROC
;;;256     */
;;;257    u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;258    {
000004  e1a07000          MOV      r7,r0
000008  e1a08001          MOV      r8,r1
;;;259    	portTickType TickStart;
;;;260    	portTickType TickStop;
;;;261    	/* Express the timeout in OS tick. */
;;;262    	portTickType TickElapsed = (portTickType)(timeout / portTICK_RATE_MS);
00000c  e1a05008          MOV      r5,r8
;;;263        
;;;264    	/* Sanity check */
;;;265    	if (sem != NULL) {
000010  e3570000          CMP      r7,#0
000014  0a000027          BEQ      |L5.184|
;;;266    		if (timeout && !TickElapsed) {
000018  e3580000          CMP      r8,#0
00001c  0a000002          BEQ      |L5.44|
000020  e3550000          CMP      r5,#0
000024  1a000000          BNE      |L5.44|
;;;267    			TickElapsed = 1; /* Wait at least one tick */
000028  e3a05001          MOV      r5,#1
                  |L5.44|
;;;268    		}
;;;269    
;;;270    		if (0 == TickElapsed) {
00002c  e3550000          CMP      r5,#0
000030  1a00000a          BNE      |L5.96|
;;;271    			TickStart = xTaskGetTickCount();
000034  ebfffffe          BL       xTaskGetTickCount
000038  e1a04000          MOV      r4,r0
;;;272    			/* If timeout=0, then the function should block indefinitely */
;;;273    			while (pdFALSE == xSemaphoreTake( *sem,	SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
00003c  e1a00000          MOV      r0,r0
                  |L5.64|
000040  e3a03000          MOV      r3,#0
000044  e5970000          LDR      r0,[r7,#0]
000048  e59f2070          LDR      r2,|L5.192|
00004c  e1a01003          MOV      r1,r3
000050  ebfffffe          BL       xQueueGenericReceive
000054  e3500000          CMP      r0,#0
000058  0afffff8          BEQ      |L5.64|
00005c  ea00000a          B        |L5.140|
                  |L5.96|
;;;274    			}
;;;275    		} else {
;;;276    			TickStart = xTaskGetTickCount();
000060  ebfffffe          BL       xTaskGetTickCount
000064  e1a04000          MOV      r4,r0
;;;277    			if (pdFALSE == xSemaphoreTake( *sem, TickElapsed )) {
000068  e3a03000          MOV      r3,#0
00006c  e1a02005          MOV      r2,r5
000070  e1a01003          MOV      r1,r3
000074  e5970000          LDR      r0,[r7,#0]
000078  ebfffffe          BL       xQueueGenericReceive
00007c  e3500000          CMP      r0,#0
000080  1a000001          BNE      |L5.140|
;;;278    				/* if the function times out, it should return SYS_ARCH_TIMEOUT */
;;;279    				return(SYS_ARCH_TIMEOUT);
000084  e3e00000          MVN      r0,#0
                  |L5.136|
;;;280    			}
;;;281    		}
;;;282    
;;;283    		/* If the function acquires the semaphore, it should return how
;;;284    		  many milliseconds expired while waiting for the semaphore */
;;;285    		TickStop = xTaskGetTickCount();
;;;286    		/* Take care of wrap-around */
;;;287    		if (TickStop >= TickStart) {
;;;288    			TickElapsed = TickStop - TickStart;
;;;289    		} else {
;;;290    			TickElapsed = portMAX_DELAY - TickStart + TickStop;
;;;291    		}
;;;292    
;;;293    		return(TickElapsed * portTICK_RATE_MS);
;;;294    	} else {
;;;295    		return (u32_t)ERR_MEM;
;;;296    	}
;;;297    }
000088  e8bd81f0          POP      {r4-r8,pc}
                  |L5.140|
00008c  ebfffffe          BL       xTaskGetTickCount
000090  e1a06000          MOV      r6,r0                 ;285
000094  e1560004          CMP      r6,r4                 ;287
000098  3a000001          BCC      |L5.164|
00009c  e0465004          SUB      r5,r6,r4              ;288
0000a0  ea000002          B        |L5.176|
                  |L5.164|
0000a4  e3e00000          MVN      r0,#0                 ;290
0000a8  e0400004          SUB      r0,r0,r4              ;290
0000ac  e0805006          ADD      r5,r0,r6              ;290
                  |L5.176|
0000b0  e1a00005          MOV      r0,r5                 ;293
0000b4  eafffff3          B        |L5.136|
                  |L5.184|
0000b8  e3e00000          MVN      r0,#0                 ;295
0000bc  eafffff1          B        |L5.136|
;;;298    
                          ENDP

                  |L5.192|
                          DCD      0x00002710

                          AREA ||i.sys_arch_unprotect||, CODE, READONLY, ALIGN=2

                  sys_arch_unprotect PROC
;;;683     */
;;;684    void sys_arch_unprotect(sys_prot_t pval)
000000  e92d4010          PUSH     {r4,lr}
;;;685    {
000004  e1a04000          MOV      r4,r0
;;;686    	vPortExitCritical();
000008  ebfffffe          BL       vPortExitCritical
;;;687    }
00000c  e8bd8010          POP      {r4,pc}
;;;688    
                          ENDP


                          AREA ||i.sys_init||, CODE, READONLY, ALIGN=2

                  sys_init PROC
;;;154     */
;;;155    void sys_init(void)
000000  e3a00000          MOV      r0,#0
;;;156    {
;;;157    	int i;
;;;158    
;;;159    	/* Initialize the the per-thread sys_timeouts structures
;;;160    	   make sure there are no valid pids in the list */
;;;161    	for (i = 0; i < SYS_THREAD_MAX; i++) {
000004  ea000003          B        |L7.24|
                  |L7.8|
;;;162    		Threads_TimeoutsList[i].pid = 0;
000008  e3a01000          MOV      r1,#0
00000c  e59f201c          LDR      r2,|L7.48|
000010  e7821100          STR      r1,[r2,r0,LSL #2]
000014  e2800001          ADD      r0,r0,#1              ;161
                  |L7.24|
000018  e3500006          CMP      r0,#6                 ;161
00001c  bafffff9          BLT      |L7.8|
;;;163    	}
;;;164    
;;;165    	/* Keep track of how many threads have been created */
;;;166    	NbActiveThreads = 0;
000020  e3a01000          MOV      r1,#0
000024  e59f2008          LDR      r2,|L7.52|
000028  e1c210b0          STRH     r1,[r2,#0]  ; NbActiveThreads
;;;167    }
00002c  e12fff1e          BX       lr
;;;168    
                          ENDP

                  |L7.48|
                          DCD      Threads_TimeoutsList
                  |L7.52|
                          DCD      NbActiveThreads

                          AREA ||i.sys_mbox_free||, CODE, READONLY, ALIGN=2

                  sys_mbox_free PROC
;;;364     */
;;;365    void sys_mbox_free(sys_mbox_t *mbox)
000000  e92d4010          PUSH     {r4,lr}
;;;366    {
000004  e1a04000          MOV      r4,r0
;;;367    	/* Sanity check */
;;;368    	if (mbox != NULL) {
000008  e3540000          CMP      r4,#0
00000c  0a000004          BEQ      |L8.36|
;;;369    		if (SYS_MBOX_NULL != *mbox) {
000010  e5940000          LDR      r0,[r4,#0]
000014  e3500000          CMP      r0,#0
000018  0a000001          BEQ      |L8.36|
;;;370      #if SYS_STATS
;;;371    			lwip_stats.sys.mbox.used--;
;;;372      #endif /* SYS_STATS */
;;;373    			vQueueDelete( *mbox );
00001c  e5940000          LDR      r0,[r4,#0]
000020  ebfffffe          BL       vQueueDelete
                  |L8.36|
;;;374    		}
;;;375    	}
;;;376    }
000024  e8bd8010          POP      {r4,pc}
;;;377    
                          ENDP


                          AREA ||i.sys_mbox_new||, CODE, READONLY, ALIGN=2

                  sys_mbox_new PROC
;;;334     */
;;;335    err_t sys_mbox_new(sys_mbox_t *mBoxNew, int size )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;336    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;337    	err_t err_mbox = ERR_MEM;
00000c  e3e06000          MVN      r6,#0
;;;338        
;;;339    	/* Sanity check */
;;;340    	if (mBoxNew != NULL) {
000010  e3540000          CMP      r4,#0
000014  0a000005          BEQ      |L9.48|
;;;341    		*mBoxNew = xQueueCreate( size, sizeof(void *));
000018  e3a02000          MOV      r2,#0
00001c  e3a01004          MOV      r1,#4
000020  e1a00005          MOV      r0,r5
000024  ebfffffe          BL       xQueueGenericCreate
000028  e5840000          STR      r0,[r4,#0]
;;;342      #if SYS_STATS
;;;343    		if (SYS_MBOX_NULL != *mBoxNew) {
;;;344    			lwip_stats.sys.mbox.used++;
;;;345    			if (lwip_stats.sys.mbox.used > lwip_stats.sys.mbox.max) {
;;;346    				lwip_stats.sys.mbox.max	= lwip_stats.sys.mbox.used;
;;;347    			}
;;;348    		}
;;;349    
;;;350      #endif /* SYS_STATS */
;;;351    		err_mbox = ERR_OK;
00002c  e3a06000          MOV      r6,#0
                  |L9.48|
;;;352    	}
;;;353    
;;;354    	return(err_mbox);
000030  e1a00006          MOV      r0,r6
;;;355    }
000034  e8bd8070          POP      {r4-r6,pc}
;;;356    
                          ENDP


                          AREA ||i.sys_mbox_post||, CODE, READONLY, ALIGN=2

                  sys_mbox_post PROC
;;;384     */
;;;385    void sys_mbox_post(sys_mbox_t *mbox, void *msg)
000000  e92d4013          PUSH     {r0,r1,r4,lr}
;;;386    {
000004  e1a04000          MOV      r4,r0
;;;387    	/* Sanit check */
;;;388    	if (mbox != NULL) {
000008  e3540000          CMP      r4,#0
00000c  0a000007          BEQ      |L10.48|
;;;389    		while (pdTRUE != xQueueSend( *mbox, &msg, SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
000010  e1a00000          MOV      r0,r0
                  |L10.20|
000014  e3a03000          MOV      r3,#0
000018  e5940000          LDR      r0,[r4,#0]
00001c  e59f2010          LDR      r2,|L10.52|
000020  e28d1004          ADD      r1,sp,#4
000024  ebfffffe          BL       xQueueGenericSend
000028  e3500001          CMP      r0,#1
00002c  1afffff8          BNE      |L10.20|
                  |L10.48|
;;;390    		}
;;;391    	}
;;;392    }
000030  e8bd801c          POP      {r2-r4,pc}
;;;393    
                          ENDP

                  |L10.52|
                          DCD      0x00002710

                          AREA ||i.sys_mbox_set_invalid||, CODE, READONLY, ALIGN=2

                  sys_mbox_set_invalid PROC
;;;540     */
;;;541    void sys_mbox_set_invalid(sys_mbox_t *mbox)
000000  e3a01000          MOV      r1,#0
;;;542    {
;;;543    	*mbox = NULL;
000004  e5801000          STR      r1,[r0,#0]
;;;544    }
000008  e12fff1e          BX       lr
;;;545    
                          ENDP


                          AREA ||i.sys_mbox_trypost||, CODE, READONLY, ALIGN=2

                  sys_mbox_trypost PROC
;;;401     */
;;;402    err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
000000  e92d4073          PUSH     {r0,r1,r4-r6,lr}
;;;403    {
000004  e1a04000          MOV      r4,r0
;;;404    	err_t err_mbox = ERR_MEM;
000008  e3e05000          MVN      r5,#0
;;;405    
;;;406    	/* Sanity check */
;;;407    	if (mbox != NULL) {
00000c  e3540000          CMP      r4,#0
000010  0a000007          BEQ      |L12.52|
;;;408    //        vPortEnterCritical();
;;;409    		if (errQUEUE_FULL != xQueueSend( *mbox, &msg, 0 )) {
000014  e3a03000          MOV      r3,#0
000018  e1a02003          MOV      r2,r3
00001c  e28d1004          ADD      r1,sp,#4
000020  e5940000          LDR      r0,[r4,#0]
000024  ebfffffe          BL       xQueueGenericSend
000028  e3500000          CMP      r0,#0
00002c  0a000000          BEQ      |L12.52|
;;;410    			err_mbox = ERR_OK;
000030  e3a05000          MOV      r5,#0
                  |L12.52|
;;;411    		}
;;;412    //        vPortExitCritical();
;;;413    	}
;;;414    
;;;415    	return (err_mbox);
000034  e1a00005          MOV      r0,r5
;;;416    }
000038  e8bd807c          POP      {r2-r6,pc}
;;;417    
                          ENDP


                          AREA ||i.sys_mbox_valid||, CODE, READONLY, ALIGN=2

                  sys_mbox_valid PROC
;;;528     */
;;;529    int sys_mbox_valid(sys_mbox_t *mbox)
000000  e1a01000          MOV      r1,r0
;;;530    {
;;;531    	return ((int)(*mbox));
000004  e5910000          LDR      r0,[r1,#0]
;;;532    }
000008  e12fff1e          BX       lr
;;;533    #endif
                          ENDP


                          AREA ||i.sys_sem_free||, CODE, READONLY, ALIGN=2

                  sys_sem_free PROC
;;;213     */
;;;214    void sys_sem_free(sys_sem_t *sem)
000000  e92d4010          PUSH     {r4,lr}
;;;215    {
000004  e1a04000          MOV      r4,r0
;;;216    	/* Sanity check */
;;;217    	if (sem != NULL) {
000008  e3540000          CMP      r4,#0
00000c  0a000004          BEQ      |L14.36|
;;;218    		if (SYS_SEM_NULL != *sem) {
000010  e5940000          LDR      r0,[r4,#0]
000014  e3500000          CMP      r0,#0
000018  0a000001          BEQ      |L14.36|
;;;219      #if SYS_STATS
;;;220    			lwip_stats.sys.sem.used--;
;;;221      #endif /* SYS_STATS */
;;;222    			vQueueDelete( *sem );
00001c  e5940000          LDR      r0,[r4,#0]
000020  ebfffffe          BL       vQueueDelete
                  |L14.36|
;;;223    		}
;;;224    	}
;;;225    }
000024  e8bd8010          POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.sys_sem_new||, CODE, READONLY, ALIGN=2

                  sys_sem_new PROC
;;;176     */
;;;177    err_t sys_sem_new(sys_sem_t *sem, u8_t count)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;178    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;179    	err_t err_sem = ERR_MEM;
00000c  e3e06000          MVN      r6,#0
;;;180    
;;;181    	/* Sanity check */
;;;182    	if (sem != NULL) {
000010  e3540000          CMP      r4,#0
000014  0a000019          BEQ      |L15.128|
;;;183    		portENTER_CRITICAL();
000018  ebfffffe          BL       vPortEnterCritical
;;;184    
;;;185    		vSemaphoreCreateBinary( *sem );
00001c  e3a02003          MOV      r2,#3
000020  e3a01000          MOV      r1,#0
000024  e3a00001          MOV      r0,#1
000028  ebfffffe          BL       xQueueGenericCreate
00002c  e5840000          STR      r0,[r4,#0]
000030  e5940000          LDR      r0,[r4,#0]
000034  e3500000          CMP      r0,#0
000038  0a000004          BEQ      |L15.80|
00003c  e3a03000          MOV      r3,#0
000040  e1a02003          MOV      r2,r3
000044  e1a01003          MOV      r1,r3
000048  e5940000          LDR      r0,[r4,#0]
00004c  ebfffffe          BL       xQueueGenericSend
                  |L15.80|
;;;186    		if (*sem != SYS_SEM_NULL) {
000050  e5940000          LDR      r0,[r4,#0]
000054  e3500000          CMP      r0,#0
000058  0a000007          BEQ      |L15.124|
;;;187      #if SYS_STATS
;;;188    			lwip_stats.sys.sem.used++;
;;;189    			if (lwip_stats.sys.sem.used > lwip_stats.sys.sem.max) {
;;;190    				lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
;;;191    			}
;;;192    
;;;193      #endif /* SYS_STATS */
;;;194    
;;;195    			if (0 == count) { /* Means we want the sem to be
00005c  e3550000          CMP      r5,#0
000060  1a000004          BNE      |L15.120|
;;;196    			                     unavailable at init state. */
;;;197    				xSemaphoreTake( *sem, 1);
000064  e3a03000          MOV      r3,#0
000068  e3a02001          MOV      r2,#1
00006c  e1a01003          MOV      r1,r3
000070  e5940000          LDR      r0,[r4,#0]
000074  ebfffffe          BL       xQueueGenericReceive
                  |L15.120|
;;;198    			}
;;;199    
;;;200    			err_sem = ERR_OK;
000078  e3a06000          MOV      r6,#0
                  |L15.124|
;;;201    		}
;;;202    
;;;203    		portEXIT_CRITICAL();
00007c  ebfffffe          BL       vPortExitCritical
                  |L15.128|
;;;204    	}
;;;205    
;;;206    	return err_sem;
000080  e1a00006          MOV      r0,r6
;;;207    }
000084  e8bd8070          POP      {r4-r6,pc}
;;;208    
                          ENDP


                          AREA ||i.sys_sem_set_invalid||, CODE, READONLY, ALIGN=2

                  sys_sem_set_invalid PROC
;;;319     */
;;;320    void sys_sem_set_invalid(sys_sem_t *sem)
000000  e3a01000          MOV      r1,#0
;;;321    {
;;;322    	*sem = NULL;
000004  e5801000          STR      r1,[r0,#0]
;;;323    }
000008  e12fff1e          BX       lr
;;;324    #endif
                          ENDP


                          AREA ||i.sys_sem_signal||, CODE, READONLY, ALIGN=2

                  sys_sem_signal PROC
;;;231     */
;;;232    void sys_sem_signal(sys_sem_t *sem)
000000  e92d4010          PUSH     {r4,lr}
;;;233    {
000004  e1a04000          MOV      r4,r0
;;;234    	/* Sanity check */
;;;235    	if (sem != NULL) {
000008  e3540000          CMP      r4,#0
00000c  0a000004          BEQ      |L17.36|
;;;236                xSemaphoreGive( *sem );
000010  e3a03000          MOV      r3,#0
000014  e1a02003          MOV      r2,r3
000018  e1a01003          MOV      r1,r3
00001c  e5940000          LDR      r0,[r4,#0]
000020  ebfffffe          BL       xQueueGenericSend
                  |L17.36|
;;;237    	}
;;;238    }
000024  e8bd8010          POP      {r4,pc}
;;;239    
                          ENDP


                          AREA ||i.sys_sem_valid||, CODE, READONLY, ALIGN=2

                  sys_sem_valid PROC
;;;306     */
;;;307    int sys_sem_valid(sys_sem_t *sem)
000000  e1a01000          MOV      r1,r0
;;;308    {
;;;309    	return ((int)(*sem));
000004  e5910000          LDR      r0,[r1,#0]
;;;310    }
000008  e12fff1e          BX       lr
;;;311    
                          ENDP


                          AREA ||i.sys_thread_new||, CODE, READONLY, ALIGN=2

                  sys_thread_new PROC
;;;559    
;;;560    sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;561    		int stacksize, int prio)
;;;562    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a06002          MOV      r6,r2
000010  e1a07003          MOV      r7,r3
000014  e59d8030          LDR      r8,[sp,#0x30]
;;;563        sys_thread_t newthread;
;;;564    	portBASE_TYPE result;
;;;565    	SYS_ARCH_DECL_PROTECT(protectionLevel);
;;;566    
;;;567    	result = xTaskCreate( thread, (const portCHAR *)name, stacksize, arg,
000018  e28d0008          ADD      r0,sp,#8
00001c  e1a02807          LSL      r2,r7,#16
000020  e1a02822          LSR      r2,r2,#16
000024  e1a03006          MOV      r3,r6
000028  e1a01004          MOV      r1,r4
00002c  e58d0004          STR      r0,[sp,#4]
000030  e1a00005          MOV      r0,r5
000034  e58d8000          STR      r8,[sp,#0]
000038  ebfffffe          BL       xTaskCreate
00003c  e1a09000          MOV      r9,r0
;;;568    			prio, &newthread );
;;;569    
;;;570    	/* Need to protect this -- preemption here could be a problem! */
;;;571    	SYS_ARCH_PROTECT(protectionLevel);
000040  ebfffffe          BL       sys_arch_protect
000044  e1a0a000          MOV      r10,r0
;;;572    	if (pdPASS == result) {
000048  e3590001          CMP      r9,#1
00004c  1a00000b          BNE      |L19.128|
;;;573    		/* For each task created, store the task handle (pid) in the
;;;574    		 * timers array. */
;;;575    		/* This scheme doesn't allow for threads to be deleted */
;;;576    		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
000050  e59f1040          LDR      r1,|L19.152|
000054  e59d0008          LDR      r0,[sp,#8]
000058  e1d110b0          LDRH     r1,[r1,#0]  ; NbActiveThreads
00005c  e59f2034          LDR      r2,|L19.152|
000060  e1d220b0          LDRH     r2,[r2,#0]  ; NbActiveThreads
000064  e2822001          ADD      r2,r2,#1
000068  e3c22801          BIC      r2,r2,#0x10000
00006c  e59f3024          LDR      r3,|L19.152|
000070  e1c320b0          STRH     r2,[r3,#0]  ; NbActiveThreads
000074  e59f2020          LDR      r2,|L19.156|
000078  e7820101          STR      r0,[r2,r1,LSL #2]
00007c  ea000001          B        |L19.136|
                  |L19.128|
;;;577    	} else {
;;;578    		newthread = NULL;
000080  e3a00000          MOV      r0,#0
000084  e58d0008          STR      r0,[sp,#8]
                  |L19.136|
;;;579    	}
;;;580    
;;;581    	SYS_ARCH_UNPROTECT(protectionLevel);
000088  e1a0000a          MOV      r0,r10
00008c  ebfffffe          BL       sys_arch_unprotect
;;;582    
;;;583    	return(newthread);
000090  e59d0008          LDR      r0,[sp,#8]
;;;584    }
000094  e8bd8ffe          POP      {r1-r11,pc}
;;;585    
                          ENDP

                  |L19.152|
                          DCD      NbActiveThreads
                  |L19.156|
                          DCD      Threads_TimeoutsList

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Threads_TimeoutsList
                          %        24

                          AREA ||.data||, DATA, ALIGN=1

                  NbActiveThreads
000000  0000              DCW      0x0000
