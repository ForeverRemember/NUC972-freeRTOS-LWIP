; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\sys_arch.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\sys_arch.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\sys_arch.crf lwip-1.4.1\sys_arch.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sys_now PROC
;;;110    #endif /* __CC_H__ */
;;;35     u32_t sys_now(void)
000000  e92d4010          PUSH     {r4,lr}
;;;36     {
;;;37         return sysGetTicks(TIMER0) * 10;
000004  e3a00000          MOV      r0,#0
000008  ebfffffe          BL       sysGetTicks
00000c  e0800100          ADD      r0,r0,r0,LSL #2
000010  e1a00080          LSL      r0,r0,#1
;;;38         
;;;39     }
000014  e8bd8010          POP      {r4,pc}
;;;40     
                          ENDP

                  sys_init PROC
;;;133     */
;;;134    void sys_init(void)
000018  e59f237c          LDR      r2,|L1.924|
;;;135    {
;;;136    	int i;
;;;137    
;;;138    	/* Initialize the the per-thread sys_timeouts structures
;;;139    	   make sure there are no valid pids in the list */
;;;140    	for (i = 0; i < SYS_THREAD_MAX; i++) {
00001c  e3a00000          MOV      r0,#0
000020  e1a01000          MOV      r1,r0
                  |L1.36|
;;;141    		Threads_TimeoutsList[i].pid = 0;
000024  e7821100          STR      r1,[r2,r0,LSL #2]
000028  e2800001          ADD      r0,r0,#1
00002c  e3500006          CMP      r0,#6                 ;140
;;;142    	}
;;;143    
;;;144    	/* Keep track of how many threads have been created */
;;;145    	NbActiveThreads = 0;
000030  a59f0368          LDRGE    r0,|L1.928|
000034  a1c010b0          STRHGE   r1,[r0,#0]  ; NbActiveThreads
000038  bafffff9          BLT      |L1.36|
;;;146    }
00003c  e12fff1e          BX       lr
;;;147    
                          ENDP

                  sys_sem_new PROC
;;;155     */
;;;156    err_t sys_sem_new(sys_sem_t *sem, u8_t count)
000040  e92d4070          PUSH     {r4-r6,lr}
;;;157    {
000044  e1b04000          MOVS     r4,r0
000048  e1a06001          MOV      r6,r1
;;;158    	err_t err_sem = ERR_MEM;
00004c  e3e05000          MVN      r5,#0
000050  0a000016          BEQ      |L1.176|
;;;159    
;;;160    	/* Sanity check */
;;;161    	if (sem != NULL) {
;;;162    		portENTER_CRITICAL();
000054  ebfffffe          BL       vPortEnterCritical
;;;163    
;;;164    		vSemaphoreCreateBinary( *sem );
000058  e3a02003          MOV      r2,#3
00005c  e3a01000          MOV      r1,#0
000060  e3a00001          MOV      r0,#1
000064  ebfffffe          BL       xQueueGenericCreate
000068  e3500000          CMP      r0,#0
00006c  e5840000          STR      r0,[r4,#0]
000070  0a00000d          BEQ      |L1.172|
000074  e3a03000          MOV      r3,#0
000078  e1a02003          MOV      r2,r3
00007c  e1a01003          MOV      r1,r3
000080  ebfffffe          BL       xQueueGenericSend
;;;165    		if (*sem != SYS_SEM_NULL) {
000084  e5940000          LDR      r0,[r4,#0]
000088  e3500000          CMP      r0,#0
00008c  0a000006          BEQ      |L1.172|
;;;166      #if SYS_STATS
;;;167    			lwip_stats.sys.sem.used++;
;;;168    			if (lwip_stats.sys.sem.used > lwip_stats.sys.sem.max) {
;;;169    				lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
;;;170    			}
;;;171    
;;;172      #endif /* SYS_STATS */
;;;173    
;;;174    			if (0 == count) { /* Means we want the sem to be
000090  e3560000          CMP      r6,#0
000094  1a000003          BNE      |L1.168|
;;;175    			                     unavailable at init state. */
;;;176    				xSemaphoreTake( *sem, 1);
000098  e3a03000          MOV      r3,#0
00009c  e3a02001          MOV      r2,#1
0000a0  e1a01003          MOV      r1,r3
0000a4  ebfffffe          BL       xQueueGenericReceive
                  |L1.168|
;;;177    			}
;;;178    
;;;179    			err_sem = ERR_OK;
0000a8  e3a05000          MOV      r5,#0
                  |L1.172|
;;;180    		}
;;;181    
;;;182    		portEXIT_CRITICAL();
0000ac  ebfffffe          BL       vPortExitCritical
                  |L1.176|
;;;183    	}
;;;184    
;;;185    	return err_sem;
0000b0  e1a00005          MOV      r0,r5
;;;186    }
0000b4  e8bd8070          POP      {r4-r6,pc}
;;;187    
                          ENDP

                  sys_sem_free PROC
;;;192     */
;;;193    void sys_sem_free(sys_sem_t *sem)
0000b8  e3500000          CMP      r0,#0
;;;194    {
;;;195    	/* Sanity check */
;;;196    	if (sem != NULL) {
;;;197    		if (SYS_SEM_NULL != *sem) {
0000bc  15900000          LDRNE    r0,[r0,#0]
0000c0  13500000          CMPNE    r0,#0
;;;198      #if SYS_STATS
;;;199    			lwip_stats.sys.sem.used--;
;;;200      #endif /* SYS_STATS */
;;;201    			vQueueDelete( *sem );
;;;202    		}
;;;203    	}
;;;204    }
0000c4  012fff1e          BXEQ     lr
0000c8  eafffffe          B        vQueueDelete
;;;205    
                          ENDP

                  sys_sem_signal PROC
;;;210     */
;;;211    void sys_sem_signal(sys_sem_t *sem)
0000cc  e3500000          CMP      r0,#0
;;;212    {
;;;213    	/* Sanity check */
;;;214    	if (sem != NULL) {
;;;215    		xSemaphoreGive( *sem );
;;;216    	}
;;;217    }
0000d0  012fff1e          BXEQ     lr
0000d4  e3a03000          MOV      r3,#0                 ;215
0000d8  e5900000          LDR      r0,[r0,#0]            ;215
0000dc  e1a02003          MOV      r2,r3                 ;215
0000e0  e1a01003          MOV      r1,r3                 ;215
0000e4  eafffffe          B        xQueueGenericSend
;;;218    
                          ENDP

                  sys_arch_sem_wait PROC
;;;235     */
;;;236    u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
0000e8  e92d4070          PUSH     {r4-r6,lr}
;;;237    {
0000ec  e1b05000          MOVS     r5,r0
;;;238    	portTickType TickStart;
;;;239    	portTickType TickStop;
;;;240    	/* Express the timeout in OS tick. */
;;;241    	portTickType TickElapsed = (portTickType)(timeout / portTICK_RATE_MS);
0000f0  e1a06001          MOV      r6,r1
0000f4  0a00001b          BEQ      |L1.360|
;;;242    
;;;243    	/* Sanity check */
;;;244    	if (sem != NULL) {
;;;245    		if (timeout && !TickElapsed) {
0000f8  e3560000          CMP      r6,#0
0000fc  0a00000e          BEQ      |L1.316|
;;;246    			TickElapsed = 1; /* Wait at least one tick */
;;;247    		}
;;;248    
;;;249    		if (0 == TickElapsed) {
;;;250    			TickStart = xTaskGetTickCount();
;;;251    			/* If timeout=0, then the function should block indefinitely */
;;;252    			while (pdFALSE == xSemaphoreTake( *sem,	SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
;;;253    			}
;;;254    		} else {
;;;255    			TickStart = xTaskGetTickCount();
000100  ebfffffe          BL       xTaskGetTickCount
000104  e1a04000          MOV      r4,r0
;;;256    			if (pdFALSE == xSemaphoreTake( *sem, TickElapsed )) {
000108  e3a03000          MOV      r3,#0
00010c  e5950000          LDR      r0,[r5,#0]
000110  e1a02006          MOV      r2,r6
000114  e1a01003          MOV      r1,r3
000118  ebfffffe          BL       xQueueGenericReceive
00011c  e3500000          CMP      r0,#0
000120  0a000010          BEQ      |L1.360|
                  |L1.292|
;;;257    				/* if the function times out, it should return SYS_ARCH_TIMEOUT */
;;;258    				return(SYS_ARCH_TIMEOUT);
;;;259    			}
;;;260    		}
;;;261    
;;;262    		/* If the function acquires the semaphore, it should return how
;;;263    		  many milliseconds expired while waiting for the semaphore */
;;;264    		TickStop = xTaskGetTickCount();
000124  ebfffffe          BL       xTaskGetTickCount
;;;265    		/* Take care of wrap-around */
;;;266    		if (TickStop >= TickStart) {
000128  e1500004          CMP      r0,r4
;;;267    			TickElapsed = TickStop - TickStart;
00012c  20400004          SUBCS    r0,r0,r4
;;;268    		} else {
;;;269    			TickElapsed = portMAX_DELAY - TickStart + TickStop;
000130  31e01004          MVNCC    r1,r4
000134  30800001          ADDCC    r0,r0,r1
;;;270    		}
;;;271    
;;;272    		return(TickElapsed * portTICK_RATE_MS);
;;;273    	} else {
;;;274    		return (u32_t)ERR_MEM;
;;;275    	}
;;;276    }
000138  e8bd8070          POP      {r4-r6,pc}
                  |L1.316|
00013c  ebfffffe          BL       xTaskGetTickCount
000140  e59f625c          LDR      r6,|L1.932|
000144  e1a04000          MOV      r4,r0                 ;250
                  |L1.328|
000148  e3a03000          MOV      r3,#0                 ;252
00014c  e5950000          LDR      r0,[r5,#0]            ;252
000150  e1a02006          MOV      r2,r6                 ;252
000154  e1a01003          MOV      r1,r3                 ;252
000158  ebfffffe          BL       xQueueGenericReceive
00015c  e3500000          CMP      r0,#0                 ;252
000160  0afffff8          BEQ      |L1.328|
000164  eaffffee          B        |L1.292|
                  |L1.360|
000168  e3e00000          MVN      r0,#0                 ;274
00016c  e8bd8070          POP      {r4-r6,pc}
;;;277    
                          ENDP

                  sys_sem_valid PROC
;;;285     */
;;;286    int sys_sem_valid(sys_sem_t *sem)
000170  e5900000          LDR      r0,[r0,#0]
;;;287    {
;;;288    	return ((int)(*sem));
;;;289    }
000174  e12fff1e          BX       lr
;;;290    
                          ENDP

                  sys_sem_set_invalid PROC
;;;298     */
;;;299    void sys_sem_set_invalid(sys_sem_t *sem)
000178  e3a01000          MOV      r1,#0
;;;300    {
;;;301    	*sem = NULL;
00017c  e5801000          STR      r1,[r0,#0]
;;;302    }
000180  e12fff1e          BX       lr
;;;303    #endif
                          ENDP

                  sys_mbox_new PROC
;;;313     */
;;;314    err_t sys_mbox_new(sys_mbox_t *mBoxNew, int size )
000184  e92d4010          PUSH     {r4,lr}
;;;315    {
000188  e1b04000          MOVS     r4,r0
00018c  e1a03001          MOV      r3,r1
;;;316    	err_t err_mbox = ERR_MEM;
000190  e3e00000          MVN      r0,#0
;;;317    
;;;318    	/* Sanity check */
;;;319    	if (mBoxNew != NULL) {
;;;320    		*mBoxNew = xQueueCreate( size, sizeof(void *));
;;;321      #if SYS_STATS
;;;322    		if (SYS_MBOX_NULL != *mBoxNew) {
;;;323    			lwip_stats.sys.mbox.used++;
;;;324    			if (lwip_stats.sys.mbox.used > lwip_stats.sys.mbox.max) {
;;;325    				lwip_stats.sys.mbox.max	= lwip_stats.sys.mbox.used;
;;;326    			}
;;;327    		}
;;;328    
;;;329      #endif /* SYS_STATS */
;;;330    		err_mbox = ERR_OK;
;;;331    	}
;;;332    
;;;333    	return(err_mbox);
;;;334    }
000194  08bd8010          POPEQ    {r4,pc}
000198  e3a02000          MOV      r2,#0                 ;320
00019c  e3a01004          MOV      r1,#4                 ;320
0001a0  e1a00003          MOV      r0,r3                 ;320
0001a4  ebfffffe          BL       xQueueGenericCreate
0001a8  e5840000          STR      r0,[r4,#0]            ;320
0001ac  e3a00000          MOV      r0,#0                 ;330
0001b0  e8bd8010          POP      {r4,pc}
;;;335    
                          ENDP

                  sys_mbox_free PROC
;;;343     */
;;;344    void sys_mbox_free(sys_mbox_t *mbox)
0001b4  e3500000          CMP      r0,#0
;;;345    {
;;;346    	/* Sanity check */
;;;347    	if (mbox != NULL) {
;;;348    		if (SYS_MBOX_NULL != *mbox) {
0001b8  15900000          LDRNE    r0,[r0,#0]
0001bc  13500000          CMPNE    r0,#0
;;;349      #if SYS_STATS
;;;350    			lwip_stats.sys.mbox.used--;
;;;351      #endif /* SYS_STATS */
;;;352    			vQueueDelete( *mbox );
;;;353    		}
;;;354    	}
;;;355    }
0001c0  012fff1e          BXEQ     lr
0001c4  eafffffe          B        vQueueDelete
;;;356    
                          ENDP

                  sys_mbox_post PROC
;;;363     */
;;;364    void sys_mbox_post(sys_mbox_t *mbox, void *msg)
0001c8  e92d4073          PUSH     {r0,r1,r4-r6,lr}
;;;365    {
0001cc  e1b04000          MOVS     r4,r0
;;;366    	/* Sanit check */
;;;367    	if (mbox != NULL) {
;;;368    		while (pdTRUE != xQueueSend( *mbox, &msg, SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
0001d0  159f51cc          LDRNE    r5,|L1.932|
0001d4  0a000006          BEQ      |L1.500|
                  |L1.472|
0001d8  e5940000          LDR      r0,[r4,#0]
0001dc  e3a03000          MOV      r3,#0
0001e0  e1a02005          MOV      r2,r5
0001e4  e28d1004          ADD      r1,sp,#4
0001e8  ebfffffe          BL       xQueueGenericSend
0001ec  e3500001          CMP      r0,#1
0001f0  1afffff8          BNE      |L1.472|
                  |L1.500|
;;;369    		}
;;;370    	}
;;;371    }
0001f4  e8bd807c          POP      {r2-r6,pc}
;;;372    
                          ENDP

                  sys_mbox_trypost PROC
;;;380     */
;;;381    err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
0001f8  e92d4013          PUSH     {r0,r1,r4,lr}
;;;382    {
;;;383    	err_t err_mbox = ERR_MEM;
;;;384    
;;;385    	/* Sanity check */
;;;386    	if (mbox != NULL) {
0001fc  e3500000          CMP      r0,#0
000200  e3e04000          MVN      r4,#0                 ;383
000204  0a000006          BEQ      |L1.548|
;;;387    //        vPortEnterCritical();
;;;388    		if (errQUEUE_FULL != xQueueSend( *mbox, &msg, 0 )) {
000208  e3a03000          MOV      r3,#0
00020c  e5900000          LDR      r0,[r0,#0]
000210  e1a02003          MOV      r2,r3
000214  e28d1004          ADD      r1,sp,#4
000218  ebfffffe          BL       xQueueGenericSend
00021c  e3500000          CMP      r0,#0
;;;389    			err_mbox = ERR_OK;
000220  13a04000          MOVNE    r4,#0
                  |L1.548|
;;;390    		}
;;;391    //        vPortExitCritical();
;;;392    	}
;;;393    
;;;394    	return (err_mbox);
000224  e1a00004          MOV      r0,r4
;;;395    }
000228  e8bd801c          POP      {r2-r4,pc}
;;;396    
                          ENDP

                  sys_arch_mbox_fetch PROC
;;;410     */
;;;411    u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
00022c  e92d40f8          PUSH     {r3-r7,lr}
;;;412    {
000230  e1b05000          MOVS     r5,r0
000234  e1a07002          MOV      r7,r2
000238  e1a06001          MOV      r6,r1
00023c  0a00001f          BEQ      |L1.704|
;;;413    	portTickType TickStart;
;;;414    	portTickType TickStop;
;;;415    	void *tempoptr;
;;;416    	/* Express the timeout in OS tick. */
;;;417    	portTickType TickElapsed = (portTickType)(timeout / portTICK_RATE_MS);
;;;418    
;;;419    	/* Sanity check */
;;;420    	if (mbox != NULL) {
;;;421    		if (timeout && !TickElapsed) {
;;;422    			TickElapsed = 1; /* Wait at least one tick */
;;;423    		}
;;;424    
;;;425    		if (msg == NULL) {
000240  e3560000          CMP      r6,#0
;;;426    			msg = &tempoptr;
000244  01a0600d          MOVEQ    r6,sp
;;;427    		}
;;;428    
;;;429    		/* NOTE: INCLUDE_xTaskGetSchedulerState must be set to 1 in
;;;430    		 * FreeRTOSConfig.h for xTaskGetTickCount() to be available */
;;;431    		if (0 == TickElapsed) {
000248  e3570000          CMP      r7,#0
00024c  0a00000b          BEQ      |L1.640|
;;;432    			TickStart = xTaskGetTickCount();
;;;433    			/* If "timeout" is 0, the thread should be blocked until
;;;434    			 * a message arrives */
;;;435    			while (pdFALSE == xQueueReceive( *mbox, &(*msg),
;;;436    					SYS_ARCH_BLOCKING_TICKTIMEOUT )) {
;;;437    			}
;;;438    		} else {
;;;439    			TickStart = xTaskGetTickCount();
000250  ebfffffe          BL       xTaskGetTickCount
000254  e1a04000          MOV      r4,r0
;;;440    			if (pdFALSE == xQueueReceive( *mbox, &(*msg), TickElapsed )) {
000258  e5950000          LDR      r0,[r5,#0]
00025c  e3a03000          MOV      r3,#0
000260  e1a02007          MOV      r2,r7
000264  e1a01006          MOV      r1,r6
000268  ebfffffe          BL       xQueueGenericReceive
00026c  e3500000          CMP      r0,#0
;;;441    				*msg = NULL;
000270  03a00000          MOVEQ    r0,#0
000274  05860000          STREQ    r0,[r6,#0]
000278  0a000010          BEQ      |L1.704|
00027c  ea000009          B        |L1.680|
                  |L1.640|
000280  ebfffffe          BL       xTaskGetTickCount
000284  e59f7118          LDR      r7,|L1.932|
000288  e1a04000          MOV      r4,r0                 ;432
                  |L1.652|
00028c  e5950000          LDR      r0,[r5,#0]            ;435
000290  e3a03000          MOV      r3,#0                 ;435
000294  e1a02007          MOV      r2,r7                 ;435
000298  e1a01006          MOV      r1,r6                 ;435
00029c  ebfffffe          BL       xQueueGenericReceive
0002a0  e3500000          CMP      r0,#0                 ;435
0002a4  0afffff8          BEQ      |L1.652|
                  |L1.680|
;;;442    				/* if the function times out, it should return
;;;443    				 * SYS_ARCH_TIMEOUT. */
;;;444    				return(SYS_ARCH_TIMEOUT);
;;;445    			}
;;;446    		}
;;;447    
;;;448    		/* If the function gets a msg, it should return the number of ms
;;;449    		 * spent waiting. */
;;;450    		TickStop = xTaskGetTickCount();
0002a8  ebfffffe          BL       xTaskGetTickCount
;;;451    		/* Take care of wrap-around. */
;;;452    		if (TickStop >= TickStart) {
0002ac  e1500004          CMP      r0,r4
;;;453    			TickElapsed = TickStop - TickStart;
0002b0  20400004          SUBCS    r0,r0,r4
;;;454    		} else {
;;;455    			TickElapsed = portMAX_DELAY - TickStart + TickStop;
0002b4  31e01004          MVNCC    r1,r4
0002b8  30800001          ADDCC    r0,r0,r1
;;;456    		}
;;;457    
;;;458    		return(TickElapsed * portTICK_RATE_MS);
;;;459    	} else {
;;;460    		return (u32_t)ERR_MEM;
;;;461    	}
;;;462    }
0002bc  e8bd80f8          POP      {r3-r7,pc}
                  |L1.704|
0002c0  e3e00000          MVN      r0,#0                 ;460
0002c4  e8bd80f8          POP      {r3-r7,pc}
;;;463    
                          ENDP

                  sys_arch_mbox_tryfetch PROC
;;;476     */
;;;477    u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
0002c8  e92d4008          PUSH     {r3,lr}
;;;478    {
;;;479    	void *tempoptr;
;;;480    
;;;481    	/* Sanity check */
;;;482    	if (mbox != NULL) {
0002cc  e3500000          CMP      r0,#0
0002d0  0a000008          BEQ      |L1.760|
;;;483    		if (msg == NULL) {
0002d4  e3510000          CMP      r1,#0
;;;484    			msg = &tempoptr;
;;;485    		}
;;;486    
;;;487    		if (pdFALSE == xQueueReceive( *mbox, &(*msg), 0 )) {
0002d8  e3a03000          MOV      r3,#0
0002dc  e5900000          LDR      r0,[r0,#0]
0002e0  01a0100d          MOVEQ    r1,sp                 ;484
0002e4  e1a02003          MOV      r2,r3
0002e8  ebfffffe          BL       xQueueGenericReceive
0002ec  e3500000          CMP      r0,#0
;;;488    			/* if a message is not present in the mailbox, it
;;;489    			 * immediately returns with */
;;;490    			/* the code SYS_MBOX_EMPTY. */
;;;491    			return(SYS_MBOX_EMPTY);
;;;492    		}
;;;493    
;;;494    		/* On success 0 is returned. */
;;;495    		return(0);
0002f0  13a00000          MOVNE    r0,#0
0002f4  1a000000          BNE      |L1.764|
                  |L1.760|
;;;496    	} else {
;;;497    		return(SYS_MBOX_EMPTY);
0002f8  e3e00000          MVN      r0,#0
                  |L1.764|
;;;498    	}
;;;499    }
0002fc  e8bd8008          POP      {r3,pc}
;;;500    
                          ENDP

                  sys_mbox_valid PROC
;;;508     */
;;;509    int sys_mbox_valid(sys_mbox_t *mbox)
000300  e5900000          LDR      r0,[r0,#0]
;;;510    {
;;;511    	return ((int)(*mbox));
;;;512    }
000304  e12fff1e          BX       lr
;;;513    #endif
                          ENDP

                  sys_mbox_set_invalid PROC
;;;520     */
;;;521    void sys_mbox_set_invalid(sys_mbox_t *mbox)
000308  e3a01000          MOV      r1,#0
;;;522    {
;;;523    	*mbox = NULL;
00030c  e5801000          STR      r1,[r0,#0]
;;;524    }
000310  e12fff1e          BX       lr
;;;525    
                          ENDP

                  sys_arch_unprotect PROC
;;;663     */
;;;664    void sys_arch_unprotect(sys_prot_t pval)
000314  eafffffe          B        vPortExitCritical
;;;665    {
;;;666    	vPortExitCritical();
;;;667    }
;;;668    
                          ENDP

                  sys_arch_protect PROC
;;;652     */
;;;653    sys_prot_t sys_arch_protect(void)
000318  e92d4010          PUSH     {r4,lr}
;;;654    {
;;;655    	vPortEnterCritical();
00031c  ebfffffe          BL       vPortEnterCritical
;;;656    	return 1; /* Not used */
000320  e3a00001          MOV      r0,#1
;;;657    }
000324  e8bd8010          POP      {r4,pc}
;;;658    
                          ENDP

                  sys_thread_new PROC
;;;539    
;;;540    sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg,
000328  e92d403e          PUSH     {r1-r5,lr}
;;;541    		int stacksize, int prio)
;;;542    {
00032c  e1a04002          MOV      r4,r2
000330  e59d2018          LDR      r2,[sp,#0x18]
;;;543        sys_thread_t newthread;
;;;544    	portBASE_TYPE result;
;;;545    	SYS_ARCH_DECL_PROTECT(protectionLevel);
;;;546    
;;;547    	result = xTaskCreate( thread, (const portCHAR *)name, stacksize, arg,
000334  e28dc008          ADD      r12,sp,#8
000338  e88d1004          STM      sp,{r2,r12}
00033c  e1a05001          MOV      r5,r1                 ;542
000340  e1a02803          LSL      r2,r3,#16
000344  e1a01000          MOV      r1,r0
000348  e1a02822          LSR      r2,r2,#16
00034c  e1a03004          MOV      r3,r4
000350  e1a00005          MOV      r0,r5
000354  ebfffffe          BL       xTaskCreate
000358  e1a04000          MOV      r4,r0
00035c  ebfffffe          BL       vPortEnterCritical
;;;548    			prio, &newthread );
;;;549    
;;;550    	/* Need to protect this -- preemption here could be a problem! */
;;;551    	SYS_ARCH_PROTECT(protectionLevel);
;;;552    	if (pdPASS == result) {
000360  e3540001          CMP      r4,#1
;;;553    		/* For each task created, store the task handle (pid) in the
;;;554    		 * timers array. */
;;;555    		/* This scheme doesn't allow for threads to be deleted */
;;;556    		Threads_TimeoutsList[NbActiveThreads++].pid = newthread;
;;;557    	} else {
;;;558    		newthread = NULL;
000364  13a00000          MOVNE    r0,#0
000368  158d0008          STRNE    r0,[sp,#8]
00036c  0a000002          BEQ      |L1.892|
                  |L1.880|
000370  ebfffffe          BL       vPortExitCritical
;;;559    	}
;;;560    
;;;561    	SYS_ARCH_UNPROTECT(protectionLevel);
;;;562    
;;;563    	return(newthread);
000374  e59d0008          LDR      r0,[sp,#8]
;;;564    }
000378  e8bd803e          POP      {r1-r5,pc}
                  |L1.892|
00037c  e59f101c          LDR      r1,|L1.928|
000380  e59f3014          LDR      r3,|L1.924|
000384  e1d100b0          LDRH     r0,[r1,#0]            ;556  ; NbActiveThreads
000388  e59d2008          LDR      r2,[sp,#8]            ;556
00038c  e7832100          STR      r2,[r3,r0,LSL #2]     ;556
000390  e2800001          ADD      r0,r0,#1              ;556
000394  e1c100b0          STRH     r0,[r1,#0]            ;556  ; NbActiveThreads
000398  eafffff4          B        |L1.880|
;;;565    
                          ENDP

                  |L1.924|
                          DCD      ||.bss||
                  |L1.928|
                          DCD      ||.data||
                  |L1.932|
                          DCD      0x00002710

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Threads_TimeoutsList
                          %        24

                          AREA ||.data||, DATA, ALIGN=1

                  NbActiveThreads
000000  0000              DCW      0x0000
