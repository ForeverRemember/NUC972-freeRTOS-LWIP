; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\icmp.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\icmp.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\icmp.crf lwip-1.4.1\src\core\ipv4\icmp.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  icmp_input PROC
;;;76     void
;;;77     icmp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;78     {
;;;79       u8_t type;
;;;80     #ifdef LWIP_DEBUG
;;;81       u8_t code;
;;;82     #endif /* LWIP_DEBUG */
;;;83       struct icmp_echo_hdr *iecho;
;;;84       struct ip_hdr *iphdr;
;;;85       s16_t hlen;
;;;86     
;;;87       ICMP_STATS_INC(icmp.recv);
;;;88       snmp_inc_icmpinmsgs();
;;;89     
;;;90     
;;;91       iphdr = (struct ip_hdr *)p->payload;
000004  e5904004          LDR      r4,[r0,#4]
000008  e1a05000          MOV      r5,r0                 ;78
;;;92       hlen = IPH_HL(iphdr) * 4;
00000c  e5d40000          LDRB     r0,[r4,#0]
000010  e1a08001          MOV      r8,r1                 ;78
000014  e1a00e00          LSL      r0,r0,#28
000018  e1a07d20          LSR      r7,r0,#26
;;;93       if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
00001c  e2671000          RSB      r1,r7,#0
000020  e1a0a001          MOV      r10,r1
000024  e1a00005          MOV      r0,r5
000028  ebfffffe          BL       pbuf_header
00002c  e3500000          CMP      r0,#0
000030  1a0000ca          BNE      |L1.864|
000034  e1d500b8          LDRH     r0,[r5,#8]
000038  e3500004          CMP      r0,#4
00003c  3a0000c7          BCC      |L1.864|
;;;94         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
;;;95         goto lenerr;
;;;96       }
;;;97     
;;;98       type = *((u8_t *)p->payload);
000040  e5950004          LDR      r0,[r5,#4]
000044  e5d00000          LDRB     r0,[r0,#0]
;;;99     #ifdef LWIP_DEBUG
;;;100      code = *(((u8_t *)p->payload)+1);
;;;101    #endif /* LWIP_DEBUG */
;;;102      switch (type) {
000048  e3500000          CMP      r0,#0
00004c  0a0000c3          BEQ      |L1.864|
000050  e3500008          CMP      r0,#8
000054  1a0000c1          BNE      |L1.864|
;;;103      case ICMP_ER:
;;;104        /* This is OK, echo reply might have been parsed by a raw PCB
;;;105           (as obviously, an echo request has been sent, too). */
;;;106        break; 
;;;107      case ICMP_ECHO:
;;;108    #if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;109        {
;;;110          int accepted = 1;
;;;111    #if !LWIP_MULTICAST_PING
;;;112          /* multicast destination address? */
;;;113          if (ip_addr_ismulticast(&current_iphdr_dest)) {
000058  e59f9104          LDR      r9,|L1.356|
00005c  e3a06001          MOV      r6,#1                 ;110
000060  e5990000          LDR      r0,[r9,#0]  ; current_iphdr_dest
000064  e20010f0          AND      r1,r0,#0xf0
000068  e35100e0          CMP      r1,#0xe0
;;;114            accepted = 0;
00006c  03a06000          MOVEQ    r6,#0
;;;115          }
;;;116    #endif /* LWIP_MULTICAST_PING */
;;;117    #if !LWIP_BROADCAST_PING
;;;118          /* broadcast destination address? */
;;;119          if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
000070  e1a01008          MOV      r1,r8
000074  ebfffffe          BL       ip4_addr_isbroadcast
000078  e3500000          CMP      r0,#0
00007c  1a0000b7          BNE      |L1.864|
;;;120            accepted = 0;
;;;121          }
;;;122    #endif /* LWIP_BROADCAST_PING */
;;;123          /* broadcast or multicast destination address not acceptd? */
;;;124          if (!accepted) {
000080  e3560000          CMP      r6,#0
000084  0a0000b5          BEQ      |L1.864|
;;;125            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
;;;126            ICMP_STATS_INC(icmp.err);
;;;127            pbuf_free(p);
;;;128            return;
;;;129          }
;;;130        }
;;;131    #endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;132        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;133        if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
000088  e1d500b8          LDRH     r0,[r5,#8]
00008c  e3500008          CMP      r0,#8
000090  3a0000b2          BCC      |L1.864|
;;;134          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;135          goto lenerr;
;;;136        }
;;;137        if (inet_chksum_pbuf(p) != 0) {
000094  e1a00005          MOV      r0,r5
000098  ebfffffe          BL       inet_chksum_pbuf
00009c  e3500000          CMP      r0,#0
0000a0  1a0000ae          BNE      |L1.864|
;;;138          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;139          pbuf_free(p);
;;;140          ICMP_STATS_INC(icmp.chkerr);
;;;141          snmp_inc_icmpinerrors();
;;;142          return;
;;;143        }
;;;144    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;145        if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
0000a4  e3a01024          MOV      r1,#0x24
0000a8  e1a00005          MOV      r0,r5
0000ac  ebfffffe          BL       pbuf_header
0000b0  e3500000          CMP      r0,#0
0000b4  0a000073          BEQ      |L1.648|
;;;146          /* p is not big enough to contain link headers
;;;147           * allocate a new one and copy p into it
;;;148           */
;;;149          struct pbuf *r;
;;;150          /* switch p->payload to ip header */
;;;151          if (pbuf_header(p, hlen)) {
0000b8  e1a01007          MOV      r1,r7
0000bc  e1a00005          MOV      r0,r5
0000c0  ebfffffe          BL       pbuf_header
0000c4  e3500000          CMP      r0,#0
;;;152            LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
0000c8  128f3098          ADRNE    r3,|L1.360|
0000cc  13a02098          MOVNE    r2,#0x98
0000d0  128f10b0          ADRNE    r1,|L1.392|
0000d4  1a00001f          BNE      |L1.344|
;;;153            goto memerr;
;;;154          }
;;;155          /* allocate new packet buffer with space for link headers */
;;;156          r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
0000d8  e1d510b8          LDRH     r1,[r5,#8]
0000dc  e3a02000          MOV      r2,#0
0000e0  e3a00002          MOV      r0,#2
0000e4  ebfffffe          BL       pbuf_alloc
0000e8  e1b06000          MOVS     r6,r0
;;;157          if (r == NULL) {
0000ec  0a00009b          BEQ      |L1.864|
;;;158            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;159            goto memerr;
;;;160          }
;;;161          LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
0000f0  e1d600ba          LDRH     r0,[r6,#0xa]
0000f4  e2871008          ADD      r1,r7,#8
0000f8  e1510000          CMP      r1,r0
0000fc  9a000004          BLS      |L1.276|
000100  e28f3060          ADR      r3,|L1.360|
000104  e3a020a1          MOV      r2,#0xa1
000108  e28f10ac          ADR      r1,|L1.444|
00010c  e28f00e0          ADR      r0,|L1.500|
000110  ebfffffe          BL       sysprintf
                  |L1.276|
;;;162                      (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
;;;163          /* copy the whole packet including ip header */
;;;164          if (pbuf_copy(r, p) != ERR_OK) {
000114  e1a01005          MOV      r1,r5
000118  e1a00006          MOV      r0,r6
00011c  ebfffffe          BL       pbuf_copy
000120  e3500000          CMP      r0,#0
;;;165            LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
000124  128f303c          ADRNE    r3,|L1.360|
000128  13a020a5          MOVNE    r2,#0xa5
00012c  128f10e8          ADRNE    r1,|L1.540|
000130  1a000008          BNE      |L1.344|
;;;166            goto memerr;
;;;167          }
;;;168          iphdr = (struct ip_hdr *)r->payload;
000134  e5964004          LDR      r4,[r6,#4]
000138  e1a0100a          MOV      r1,r10
;;;169          /* switch r->payload back to icmp header */
;;;170          if (pbuf_header(r, -hlen)) {
00013c  e1a00006          MOV      r0,r6
000140  ebfffffe          BL       pbuf_header
000144  e3500000          CMP      r0,#0
;;;171            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
000148  128f3018          ADRNE    r3,|L1.360|
00014c  13a020ab          MOVNE    r2,#0xab
000150  0a000048          BEQ      |L1.632|
                  |L1.340|
000154  e28f10e8          ADR      r1,|L1.580|
                  |L1.344|
;;;172            goto memerr;
;;;173          }
;;;174          /* free the original p */
;;;175          pbuf_free(p);
;;;176          /* we now have an identical copy of p that has room for link headers */
;;;177          p = r;
;;;178        } else {
;;;179          /* restore p->payload to point to icmp header */
;;;180          if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;181            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;182            goto memerr;
;;;183          }
;;;184        }
;;;185    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;186        /* At this point, all checks are OK. */
;;;187        /* We generate an answer by switching the dest and src ip addresses,
;;;188         * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;189        iecho = (struct icmp_echo_hdr *)p->payload;
;;;190        ip_addr_copy(iphdr->src, *ip_current_dest_addr());
;;;191        ip_addr_copy(iphdr->dest, *ip_current_src_addr());
;;;192        ICMPH_TYPE_SET(iecho, ICMP_ER);
;;;193    #if CHECKSUM_GEN_ICMP
;;;194        /* adjust the checksum */
;;;195        if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
;;;196          iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
;;;197        } else {
;;;198          iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
;;;199        }
;;;200    #else /* CHECKSUM_GEN_ICMP */
;;;201        iecho->chksum = 0;
;;;202    #endif /* CHECKSUM_GEN_ICMP */
;;;203    
;;;204        /* Set the correct TTL and recalculate the header checksum. */
;;;205        IPH_TTL_SET(iphdr, ICMP_TTL);
;;;206        IPH_CHKSUM_SET(iphdr, 0);
;;;207    #if CHECKSUM_GEN_IP
;;;208        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;209    #endif /* CHECKSUM_GEN_IP */
;;;210    
;;;211        ICMP_STATS_INC(icmp.xmit);
;;;212        /* increase number of messages attempted to send */
;;;213        snmp_inc_icmpoutmsgs();
;;;214        /* increase number of echo replies attempted to send */
;;;215        snmp_inc_icmpoutechoreps();
;;;216    
;;;217        if(pbuf_header(p, hlen)) {
;;;218          LWIP_ASSERT("Can't move over header in packet", 0);
000158  e28f0094          ADR      r0,|L1.500|
00015c  ebfffffe          BL       sysprintf
000160  ea00007e          B        |L1.864|
                  |L1.356|
                          DCD      current_iphdr_dest
                  |L1.360|
000168  6c776970          DCB      "lwip-1.4.1\\src\\core\\ipv4\\icmp.c",0
00016c  2d312e34
000170  2e315c73
000174  72635c63
000178  6f72655c
00017c  69707634
000180  5c69636d
000184  702e6300
                  |L1.392|
000188  69636d70          DCB      "icmp_input: moving p->payload to ip header failed\n",0
00018c  5f696e70
000190  75743a20
000194  6d6f7669
000198  6e672070
00019c  2d3e7061
0001a0  796c6f61
0001a4  6420746f
0001a8  20697020
0001ac  68656164
0001b0  65722066
0001b4  61696c65
0001b8  640a00  
0001bb  00                DCB      0
                  |L1.444|
0001bc  63686563          DCB      "check that first pbuf can hold struct the ICMP header",0
0001c0  6b207468
0001c4  61742066
0001c8  69727374
0001cc  20706275
0001d0  66206361
0001d4  6e20686f
0001d8  6c642073
0001dc  74727563
0001e0  74207468
0001e4  65204943
0001e8  4d502068
0001ec  65616465
0001f0  7200    
0001f2  00                DCB      0
0001f3  00                DCB      0
                  |L1.500|
0001f4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001f8  7274696f
0001fc  6e202225
000200  73222066
000204  61696c65
000208  64206174
00020c  206c696e
000210  65202564
000214  20696e20
000218  25730a00
                  |L1.540|
00021c  69636d70          DCB      "icmp_input: copying to new pbuf failed\n",0
000220  5f696e70
000224  75743a20
000228  636f7079
00022c  696e6720
000230  746f206e
000234  65772070
000238  62756620
00023c  6661696c
000240  65640a00
                  |L1.580|
000244  69636d70          DCB      "icmp_input: restoring original p->payload failed\n",0
000248  5f696e70
00024c  75743a20
000250  72657374
000254  6f72696e
000258  67206f72
00025c  6967696e
000260  616c2070
000264  2d3e7061
000268  796c6f61
00026c  64206661
000270  696c6564
000274  0a00    
000276  00                DCB      0
000277  00                DCB      0
                  |L1.632|
000278  e1a00005          MOV      r0,r5                 ;175
00027c  ebfffffe          BL       pbuf_free
000280  e1a05006          MOV      r5,r6                 ;177
000284  ea000006          B        |L1.676|
                  |L1.648|
000288  e3e01023          MVN      r1,#0x23              ;180
00028c  e1a00005          MOV      r0,r5                 ;180
000290  ebfffffe          BL       pbuf_header
000294  e3500000          CMP      r0,#0                 ;180
000298  124f3f4e          ADRNE    r3,|L1.360|
00029c  13a020b5          MOVNE    r2,#0xb5              ;181
0002a0  1affffab          BNE      |L1.340|
                  |L1.676|
0002a4  e5956004          LDR      r6,[r5,#4]            ;190
0002a8  e5990000          LDR      r0,[r9,#0]            ;190  ; current_iphdr_dest
0002ac  e284100c          ADD      r1,r4,#0xc            ;190
0002b0  ebfffffe          BL       __aeabi_uwrite4
0002b4  e59f01a4          LDR      r0,|L1.1120|
0002b8  e2841010          ADD      r1,r4,#0x10           ;191
0002bc  e5900000          LDR      r0,[r0,#0]            ;191  ; current_iphdr_src
0002c0  ebfffffe          BL       __aeabi_uwrite4
0002c4  e3a09000          MOV      r9,#0                 ;192
0002c8  e5c69000          STRB     r9,[r6,#0]            ;192
0002cc  e5d60003          LDRB     r0,[r6,#3]            ;195
0002d0  e5d61002          LDRB     r1,[r6,#2]            ;195
0002d4  e1810400          ORR      r0,r1,r0,LSL #8       ;195
0002d8  e59f1184          LDR      r1,|L1.1124|
0002dc  e1500001          CMP      r0,r1                 ;195
0002e0  22800009          ADDCS    r0,r0,#9              ;195
0002e4  32800008          ADDCC    r0,r0,#8              ;195
0002e8  e5c60002          STRB     r0,[r6,#2]            ;198
0002ec  e1a00420          LSR      r0,r0,#8              ;198
0002f0  e5c60003          STRB     r0,[r6,#3]            ;198
0002f4  e3a000ff          MOV      r0,#0xff              ;205
0002f8  e5c40008          STRB     r0,[r4,#8]            ;205
0002fc  e1a00429          LSR      r0,r9,#8              ;206
000300  e5c4900a          STRB     r9,[r4,#0xa]          ;206
000304  e5c4000b          STRB     r0,[r4,#0xb]          ;206
000308  e3a01014          MOV      r1,#0x14              ;208
00030c  e1a00004          MOV      r0,r4                 ;208
000310  ebfffffe          BL       inet_chksum
000314  e5c4000a          STRB     r0,[r4,#0xa]          ;208
000318  e1a00420          LSR      r0,r0,#8              ;208
00031c  e5c4000b          STRB     r0,[r4,#0xb]          ;208
000320  e1a01007          MOV      r1,r7                 ;217
000324  e1a00005          MOV      r0,r5                 ;217
000328  ebfffffe          BL       pbuf_header
00032c  e3500000          CMP      r0,#0                 ;217
000330  124f3e1d          ADRNE    r3,|L1.360|
000334  13a020da          MOVNE    r2,#0xda
000338  128f1f4a          ADRNE    r1,|L1.1128|
00033c  1affff85          BNE      |L1.344|
;;;219        } else {
;;;220          err_t ret;
;;;221          /* send an ICMP packet, src addr is the dest addr of the curren packet */
;;;222          ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
000340  e3a00001          MOV      r0,#1
000344  e98d0101          STMIB    sp,{r0,r8}
000348  e51f11ec          LDR      r1,|L1.356|
00034c  e3a030ff          MOV      r3,#0xff
000350  e3a02000          MOV      r2,#0
000354  e1a00005          MOV      r0,r5
000358  e58d9000          STR      r9,[sp,#0]
00035c  ebfffffe          BL       ip_output_if
                  |L1.864|
;;;223                       ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;224          if (ret != ERR_OK) {
;;;225            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
;;;226          }
;;;227        }
;;;228        break;
;;;229      default:
;;;230        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
;;;231                    (s16_t)type, (s16_t)code));
;;;232        ICMP_STATS_INC(icmp.proterr);
;;;233        ICMP_STATS_INC(icmp.drop);
;;;234      }
;;;235      pbuf_free(p);
;;;236      return;
;;;237    lenerr:
;;;238      pbuf_free(p);
;;;239      ICMP_STATS_INC(icmp.lenerr);
;;;240      snmp_inc_icmpinerrors();
;;;241      return;
;;;242    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;243    memerr:
;;;244      pbuf_free(p);
000360  e1a00005          MOV      r0,r5
000364  e8bd4ffe          POP      {r1-r11,lr}
000368  eafffffe          B        pbuf_free
;;;245      ICMP_STATS_INC(icmp.err);
;;;246      snmp_inc_icmpinerrors();
;;;247      return;
;;;248    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;249    }
;;;250    
                          ENDP

                  icmp_send_response PROC
;;;290    static void
;;;291    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
00036c  e92d43fe          PUSH     {r1-r9,lr}
;;;292    {
000370  e1a06002          MOV      r6,r2
000374  e1a09001          MOV      r9,r1
000378  e1a07000          MOV      r7,r0
;;;293      struct pbuf *q;
;;;294      struct ip_hdr *iphdr;
;;;295      /* we can use the echo header here */
;;;296      struct icmp_echo_hdr *icmphdr;
;;;297      ip_addr_t iphdr_src;
;;;298    
;;;299      /* ICMP header + IP header + 8 bytes of data */
;;;300      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
00037c  e3a02000          MOV      r2,#0
000380  e3a01024          MOV      r1,#0x24
000384  e3a00001          MOV      r0,#1
000388  ebfffffe          BL       pbuf_alloc
00038c  e1b05000          MOVS     r5,r0
;;;301                     PBUF_RAM);
;;;302      if (q == NULL) {
000390  0a00002b          BEQ      |L1.1092|
;;;303        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
;;;304        return;
;;;305      }
;;;306      LWIP_ASSERT("check that first pbuf can hold icmp message",
000394  e1d500ba          LDRH     r0,[r5,#0xa]
000398  e3500024          CMP      r0,#0x24
00039c  2a000004          BCS      |L1.948|
0003a0  e59f20e4          LDR      r2,|L1.1164|
0003a4  e24f3f91          ADR      r3,|L1.360|
0003a8  e28f10e0          ADR      r1,|L1.1168|
0003ac  e24f0d07          ADR      r0,|L1.500|
0003b0  ebfffffe          BL       sysprintf
                  |L1.948|
;;;307                 (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;308    
;;;309      iphdr = (struct ip_hdr *)p->payload;
;;;310      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;311      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
;;;312      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;313      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
;;;314      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;315    
;;;316      icmphdr = (struct icmp_echo_hdr *)q->payload;
0003b4  e5954004          LDR      r4,[r5,#4]
0003b8  e5978004          LDR      r8,[r7,#4]
;;;317      icmphdr->type = type;
0003bc  e5c49000          STRB     r9,[r4,#0]
;;;318      icmphdr->code = code;
0003c0  e5c46001          STRB     r6,[r4,#1]
;;;319      icmphdr->id = 0;
0003c4  e3a06000          MOV      r6,#0
0003c8  e5c46004          STRB     r6,[r4,#4]
0003cc  e5c46005          STRB     r6,[r4,#5]
;;;320      icmphdr->seqno = 0;
0003d0  e5c46006          STRB     r6,[r4,#6]
0003d4  e5c46007          STRB     r6,[r4,#7]
;;;321    
;;;322      /* copy fields from original packet */
;;;323      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
0003d8  e5950004          LDR      r0,[r5,#4]
0003dc  e5971004          LDR      r1,[r7,#4]
0003e0  e3a0201c          MOV      r2,#0x1c
0003e4  e2800008          ADD      r0,r0,#8
0003e8  ebfffffe          BL       __aeabi_memcpy
;;;324              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;325    
;;;326      /* calculate checksum */
;;;327      icmphdr->chksum = 0;
0003ec  e1a00426          LSR      r0,r6,#8
0003f0  e5c46002          STRB     r6,[r4,#2]
0003f4  e5c40003          STRB     r0,[r4,#3]
;;;328      icmphdr->chksum = inet_chksum(icmphdr, q->len);
0003f8  e1d510ba          LDRH     r1,[r5,#0xa]
0003fc  e1a00004          MOV      r0,r4
000400  ebfffffe          BL       inet_chksum
000404  e5c40002          STRB     r0,[r4,#2]
000408  e1a00420          LSR      r0,r0,#8
00040c  e5c40003          STRB     r0,[r4,#3]
;;;329      ICMP_STATS_INC(icmp.xmit);
;;;330      /* increase number of messages attempted to send */
;;;331      snmp_inc_icmpoutmsgs();
;;;332      /* increase number of destination unreachable messages attempted to send */
;;;333      snmp_inc_icmpouttimeexcds();
;;;334      ip_addr_copy(iphdr_src, iphdr->src);
000410  e288000c          ADD      r0,r8,#0xc
000414  ebfffffe          BL       __aeabi_uread4
000418  e58d0008          STR      r0,[sp,#8]
;;;335      ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
00041c  e3a00001          MOV      r0,#1
000420  e58d0004          STR      r0,[sp,#4]
000424  e3a030ff          MOV      r3,#0xff
000428  e28d2008          ADD      r2,sp,#8
00042c  e3a01000          MOV      r1,#0
000430  e1a00005          MOV      r0,r5
000434  e58d6000          STR      r6,[sp,#0]
000438  ebfffffe          BL       ip_output
;;;336      pbuf_free(q);
00043c  e1a00005          MOV      r0,r5
000440  ebfffffe          BL       pbuf_free
                  |L1.1092|
;;;337    }
000444  e8bd83fe          POP      {r1-r9,pc}
;;;338    
                          ENDP

                  icmp_dest_unreach PROC
;;;260    void
;;;261    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
000448  e1a02001          MOV      r2,r1
;;;262    {
;;;263      icmp_send_response(p, ICMP_DUR, t);
00044c  e3a01003          MOV      r1,#3
000450  eafffffe          B        icmp_send_response
;;;264    }
;;;265    
                          ENDP

                  icmp_time_exceeded PROC
;;;274    void
;;;275    icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
000454  e1a02001          MOV      r2,r1
;;;276    {
;;;277      icmp_send_response(p, ICMP_TE, t);
000458  e3a0100b          MOV      r1,#0xb
00045c  eafffffe          B        icmp_send_response
;;;278    }
;;;279    
                          ENDP

                  |L1.1120|
                          DCD      current_iphdr_src
                  |L1.1124|
                          DCD      0x0000fff7
                  |L1.1128|
000468  43616e27          DCB      "Can't move over header in packet",0
00046c  74206d6f
000470  7665206f
000474  76657220
000478  68656164
00047c  65722069
000480  6e207061
000484  636b6574
000488  00      
000489  00                DCB      0
00048a  00                DCB      0
00048b  00                DCB      0
                  |L1.1164|
                          DCD      0x00000132
                  |L1.1168|
000490  63686563          DCB      "check that first pbuf can hold icmp message",0
000494  6b207468
000498  61742066
00049c  69727374
0004a0  20706275
0004a4  66206361
0004a8  6e20686f
0004ac  6c642069
0004b0  636d7020
0004b4  6d657373
0004b8  61676500
