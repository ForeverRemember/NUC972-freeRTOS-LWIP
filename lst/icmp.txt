; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\icmp.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\icmp.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -D__UVISION_VERSION=524 --omf_browse=.\obj\icmp.crf lwip-1.4.1\src\core\ipv4\icmp.c]
                          ARM

                          AREA ||i.icmp_dest_unreach||, CODE, READONLY, ALIGN=2

                  icmp_dest_unreach PROC
;;;260    void
;;;261    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;262    {
000004  e1a05000          MOV      r5,r0
000008  e1a04001          MOV      r4,r1
;;;263      icmp_send_response(p, ICMP_DUR, t);
00000c  e1a02004          MOV      r2,r4
000010  e3a01003          MOV      r1,#3
000014  e1a00005          MOV      r0,r5
000018  ebfffffe          BL       icmp_send_response
;;;264    }
00001c  e8bd8070          POP      {r4-r6,pc}
;;;265    
                          ENDP


                          AREA ||i.icmp_input||, CODE, READONLY, ALIGN=2

                  icmp_input PROC
;;;76     void
;;;77     icmp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;78     {
000004  e1a04000          MOV      r4,r0
000008  e1a09001          MOV      r9,r1
;;;79       u8_t type;
;;;80     #ifdef LWIP_DEBUG
;;;81       u8_t code;
;;;82     #endif /* LWIP_DEBUG */
;;;83       struct icmp_echo_hdr *iecho;
;;;84       struct ip_hdr *iphdr;
;;;85       s16_t hlen;
;;;86     
;;;87       ICMP_STATS_INC(icmp.recv);
;;;88       snmp_inc_icmpinmsgs();
;;;89     
;;;90     
;;;91       iphdr = (struct ip_hdr *)p->payload;
00000c  e5946004          LDR      r6,[r4,#4]
;;;92       hlen = IPH_HL(iphdr) * 4;
000010  e5d60000          LDRB     r0,[r6,#0]
000014  e1a00e00          LSL      r0,r0,#28
000018  e1a08d20          LSR      r8,r0,#26
;;;93       if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
00001c  e2681000          RSB      r1,r8,#0
000020  e1a00004          MOV      r0,r4
000024  ebfffffe          BL       pbuf_header
000028  e3500000          CMP      r0,#0
00002c  1a000002          BNE      |L2.60|
000030  e1d400b8          LDRH     r0,[r4,#8]
000034  e3500004          CMP      r0,#4
000038  2a000000          BCS      |L2.64|
                  |L2.60|
;;;94         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
;;;95         goto lenerr;
00003c  ea000118          B        |L2.1188|
                  |L2.64|
;;;96       }
;;;97     
;;;98       type = *((u8_t *)p->payload);
000040  e5940004          LDR      r0,[r4,#4]
000044  e5d0a000          LDRB     r10,[r0,#0]
;;;99     #ifdef LWIP_DEBUG
;;;100      code = *(((u8_t *)p->payload)+1);
000048  e5940004          LDR      r0,[r4,#4]
00004c  e5d0b001          LDRB     r11,[r0,#1]
;;;101    #endif /* LWIP_DEBUG */
;;;102      switch (type) {
000050  e35a0000          CMP      r10,#0
000054  0a000002          BEQ      |L2.100|
000058  e35a0008          CMP      r10,#8
00005c  1a00010a          BNE      |L2.1164|
000060  ea000001          B        |L2.108|
                  |L2.100|
;;;103      case ICMP_ER:
000064  e1a00000          MOV      r0,r0
;;;104        /* This is OK, echo reply might have been parsed by a raw PCB
;;;105           (as obviously, an echo request has been sent, too). */
;;;106        break; 
000068  ea000109          B        |L2.1172|
                  |L2.108|
;;;107      case ICMP_ECHO:
00006c  e1a00000          MOV      r0,r0
;;;108    #if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;109        {
;;;110          int accepted = 1;
000070  e3a07001          MOV      r7,#1
;;;111    #if !LWIP_MULTICAST_PING
;;;112          /* multicast destination address? */
;;;113          if (ip_addr_ismulticast(&current_iphdr_dest)) {
000074  e59f0194          LDR      r0,|L2.528|
000078  e5d00000          LDRB     r0,[r0,#0]  ; current_iphdr_dest
00007c  e20000f0          AND      r0,r0,#0xf0
000080  e35000e0          CMP      r0,#0xe0
000084  1a000000          BNE      |L2.140|
;;;114            accepted = 0;
000088  e3a07000          MOV      r7,#0
                  |L2.140|
;;;115          }
;;;116    #endif /* LWIP_MULTICAST_PING */
;;;117    #if !LWIP_BROADCAST_PING
;;;118          /* broadcast destination address? */
;;;119          if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
00008c  e59f117c          LDR      r1,|L2.528|
000090  e5910000          LDR      r0,[r1,#0]  ; current_iphdr_dest
000094  e1a01009          MOV      r1,r9
000098  ebfffffe          BL       ip4_addr_isbroadcast
00009c  e3500000          CMP      r0,#0
0000a0  0a000000          BEQ      |L2.168|
;;;120            accepted = 0;
0000a4  e3a07000          MOV      r7,#0
                  |L2.168|
;;;121          }
;;;122    #endif /* LWIP_BROADCAST_PING */
;;;123          /* broadcast or multicast destination address not acceptd? */
;;;124          if (!accepted) {
0000a8  e3570000          CMP      r7,#0
0000ac  1a000002          BNE      |L2.188|
;;;125            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
;;;126            ICMP_STATS_INC(icmp.err);
;;;127            pbuf_free(p);
0000b0  e1a00004          MOV      r0,r4
0000b4  ebfffffe          BL       pbuf_free
                  |L2.184|
;;;128            return;
;;;129          }
;;;130        }
;;;131    #endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;132        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;133        if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
;;;134          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;135          goto lenerr;
;;;136        }
;;;137        if (inet_chksum_pbuf(p) != 0) {
;;;138          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;139          pbuf_free(p);
;;;140          ICMP_STATS_INC(icmp.chkerr);
;;;141          snmp_inc_icmpinerrors();
;;;142          return;
;;;143        }
;;;144    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;145        if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;146          /* p is not big enough to contain link headers
;;;147           * allocate a new one and copy p into it
;;;148           */
;;;149          struct pbuf *r;
;;;150          /* switch p->payload to ip header */
;;;151          if (pbuf_header(p, hlen)) {
;;;152            LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
;;;153            goto memerr;
;;;154          }
;;;155          /* allocate new packet buffer with space for link headers */
;;;156          r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
;;;157          if (r == NULL) {
;;;158            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;159            goto memerr;
;;;160          }
;;;161          LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
;;;162                      (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
;;;163          /* copy the whole packet including ip header */
;;;164          if (pbuf_copy(r, p) != ERR_OK) {
;;;165            LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
;;;166            goto memerr;
;;;167          }
;;;168          iphdr = (struct ip_hdr *)r->payload;
;;;169          /* switch r->payload back to icmp header */
;;;170          if (pbuf_header(r, -hlen)) {
;;;171            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;172            goto memerr;
;;;173          }
;;;174          /* free the original p */
;;;175          pbuf_free(p);
;;;176          /* we now have an identical copy of p that has room for link headers */
;;;177          p = r;
;;;178        } else {
;;;179          /* restore p->payload to point to icmp header */
;;;180          if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;181            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;182            goto memerr;
;;;183          }
;;;184        }
;;;185    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;186        /* At this point, all checks are OK. */
;;;187        /* We generate an answer by switching the dest and src ip addresses,
;;;188         * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;189        iecho = (struct icmp_echo_hdr *)p->payload;
;;;190        ip_addr_copy(iphdr->src, *ip_current_dest_addr());
;;;191        ip_addr_copy(iphdr->dest, *ip_current_src_addr());
;;;192        ICMPH_TYPE_SET(iecho, ICMP_ER);
;;;193    #if CHECKSUM_GEN_ICMP
;;;194        /* adjust the checksum */
;;;195        if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
;;;196          iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
;;;197        } else {
;;;198          iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
;;;199        }
;;;200    #else /* CHECKSUM_GEN_ICMP */
;;;201        iecho->chksum = 0;
;;;202    #endif /* CHECKSUM_GEN_ICMP */
;;;203    
;;;204        /* Set the correct TTL and recalculate the header checksum. */
;;;205        IPH_TTL_SET(iphdr, ICMP_TTL);
;;;206        IPH_CHKSUM_SET(iphdr, 0);
;;;207    #if CHECKSUM_GEN_IP
;;;208        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;209    #endif /* CHECKSUM_GEN_IP */
;;;210    
;;;211        ICMP_STATS_INC(icmp.xmit);
;;;212        /* increase number of messages attempted to send */
;;;213        snmp_inc_icmpoutmsgs();
;;;214        /* increase number of echo replies attempted to send */
;;;215        snmp_inc_icmpoutechoreps();
;;;216    
;;;217        if(pbuf_header(p, hlen)) {
;;;218          LWIP_ASSERT("Can't move over header in packet", 0);
;;;219        } else {
;;;220          err_t ret;
;;;221          /* send an ICMP packet, src addr is the dest addr of the curren packet */
;;;222          ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
;;;223                       ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;224          if (ret != ERR_OK) {
;;;225            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
;;;226          }
;;;227        }
;;;228        break;
;;;229      default:
;;;230        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
;;;231                    (s16_t)type, (s16_t)code));
;;;232        ICMP_STATS_INC(icmp.proterr);
;;;233        ICMP_STATS_INC(icmp.drop);
;;;234      }
;;;235      pbuf_free(p);
;;;236      return;
;;;237    lenerr:
;;;238      pbuf_free(p);
;;;239      ICMP_STATS_INC(icmp.lenerr);
;;;240      snmp_inc_icmpinerrors();
;;;241      return;
;;;242    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;243    memerr:
;;;244      pbuf_free(p);
;;;245      ICMP_STATS_INC(icmp.err);
;;;246      snmp_inc_icmpinerrors();
;;;247      return;
;;;248    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;249    }
0000b8  e8bd8ffe          POP      {r1-r11,pc}
                  |L2.188|
0000bc  e1d400b8          LDRH     r0,[r4,#8]            ;133
0000c0  e3500008          CMP      r0,#8                 ;133
0000c4  2a000000          BCS      |L2.204|
0000c8  ea0000f5          B        |L2.1188|
                  |L2.204|
0000cc  e1a00004          MOV      r0,r4                 ;137
0000d0  ebfffffe          BL       inet_chksum_pbuf
0000d4  e3500000          CMP      r0,#0                 ;137
0000d8  0a000002          BEQ      |L2.232|
0000dc  e1a00004          MOV      r0,r4                 ;139
0000e0  ebfffffe          BL       pbuf_free
0000e4  eafffff3          B        |L2.184|
                  |L2.232|
0000e8  e3a01024          MOV      r1,#0x24              ;145
0000ec  e1a00004          MOV      r0,r4                 ;145
0000f0  ebfffffe          BL       pbuf_header
0000f4  e3500000          CMP      r0,#0                 ;145
0000f8  0a00008d          BEQ      |L2.820|
0000fc  e1a01008          MOV      r1,r8                 ;151
000100  e1a00004          MOV      r0,r4                 ;151
000104  ebfffffe          BL       pbuf_header
000108  e3500000          CMP      r0,#0                 ;151
00010c  0a000009          BEQ      |L2.312|
000110  e1a00000          MOV      r0,r0                 ;152
000114  e1a00000          MOV      r0,r0                 ;152
000118  e28f30f4          ADR      r3,|L2.532|
00011c  e3a02098          MOV      r2,#0x98              ;152
000120  e28f1f43          ADR      r1,|L2.564|
000124  e28f0f4f          ADR      r0,|L2.616|
000128  ebfffffe          BL       sysprintf
00012c  e1a00000          MOV      r0,r0                 ;152
000130  e1a00000          MOV      r0,r0                 ;152
000134  ea0000de          B        |L2.1204|
                  |L2.312|
000138  e1d410b8          LDRH     r1,[r4,#8]            ;156
00013c  e3a02000          MOV      r2,#0                 ;156
000140  e3a00002          MOV      r0,#2                 ;156
000144  ebfffffe          BL       pbuf_alloc
000148  e1a07000          MOV      r7,r0                 ;156
00014c  e3570000          CMP      r7,#0                 ;157
000150  1a000000          BNE      |L2.344|
000154  ea0000d6          B        |L2.1204|
                  |L2.344|
000158  e1a00000          MOV      r0,r0                 ;161
00015c  e1d700ba          LDRH     r0,[r7,#0xa]          ;161
000160  e2881008          ADD      r1,r8,#8              ;161
000164  e1500001          CMP      r0,r1                 ;161
000168  2a000006          BCS      |L2.392|
00016c  e1a00000          MOV      r0,r0                 ;161
000170  e28f309c          ADR      r3,|L2.532|
000174  e3a020a1          MOV      r2,#0xa1              ;161
000178  e28f1e11          ADR      r1,|L2.656|
00017c  e28f00e4          ADR      r0,|L2.616|
000180  ebfffffe          BL       sysprintf
000184  e1a00000          MOV      r0,r0                 ;161
                  |L2.392|
000188  e1a00000          MOV      r0,r0                 ;161
00018c  e1a01004          MOV      r1,r4                 ;164
000190  e1a00007          MOV      r0,r7                 ;164
000194  ebfffffe          BL       pbuf_copy
000198  e3500000          CMP      r0,#0                 ;164
00019c  0a000009          BEQ      |L2.456|
0001a0  e1a00000          MOV      r0,r0                 ;165
0001a4  e1a00000          MOV      r0,r0                 ;165
0001a8  e28f3064          ADR      r3,|L2.532|
0001ac  e3a020a5          MOV      r2,#0xa5              ;165
0001b0  e28f1e11          ADR      r1,|L2.712|
0001b4  e28f00ac          ADR      r0,|L2.616|
0001b8  ebfffffe          BL       sysprintf
0001bc  e1a00000          MOV      r0,r0                 ;165
0001c0  e1a00000          MOV      r0,r0                 ;165
0001c4  ea0000ba          B        |L2.1204|
                  |L2.456|
0001c8  e5976004          LDR      r6,[r7,#4]            ;168
0001cc  e2680000          RSB      r0,r8,#0              ;170
0001d0  e1a01800          LSL      r1,r0,#16             ;170
0001d4  e1a01841          ASR      r1,r1,#16             ;170
0001d8  e1a00007          MOV      r0,r7                 ;170
0001dc  ebfffffe          BL       pbuf_header
0001e0  e3500000          CMP      r0,#0                 ;170
0001e4  0a00004e          BEQ      |L2.804|
0001e8  e1a00000          MOV      r0,r0                 ;171
0001ec  e1a00000          MOV      r0,r0                 ;171
0001f0  e28f301c          ADR      r3,|L2.532|
0001f4  e3a020ab          MOV      r2,#0xab              ;171
0001f8  e28f10f0          ADR      r1,|L2.752|
0001fc  e28f0064          ADR      r0,|L2.616|
000200  ebfffffe          BL       sysprintf
000204  e1a00000          MOV      r0,r0                 ;171
000208  e1a00000          MOV      r0,r0                 ;171
00020c  ea0000a8          B        |L2.1204|
                  |L2.528|
                          DCD      current_iphdr_dest
                  |L2.532|
000214  6c776970          DCB      "lwip-1.4.1\\src\\core\\ipv4\\icmp.c",0
000218  2d312e34
00021c  2e315c73
000220  72635c63
000224  6f72655c
000228  69707634
00022c  5c69636d
000230  702e6300
                  |L2.564|
000234  69636d70          DCB      "icmp_input: moving p->payload to ip header failed\n",0
000238  5f696e70
00023c  75743a20
000240  6d6f7669
000244  6e672070
000248  2d3e7061
00024c  796c6f61
000250  6420746f
000254  20697020
000258  68656164
00025c  65722066
000260  61696c65
000264  640a00  
000267  00                DCB      0
                  |L2.616|
000268  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00026c  7274696f
000270  6e202225
000274  73222066
000278  61696c65
00027c  64206174
000280  206c696e
000284  65202564
000288  20696e20
00028c  25730a00
                  |L2.656|
000290  63686563          DCB      "check that first pbuf can hold struct the ICMP header",0
000294  6b207468
000298  61742066
00029c  69727374
0002a0  20706275
0002a4  66206361
0002a8  6e20686f
0002ac  6c642073
0002b0  74727563
0002b4  74207468
0002b8  65204943
0002bc  4d502068
0002c0  65616465
0002c4  7200    
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L2.712|
0002c8  69636d70          DCB      "icmp_input: copying to new pbuf failed\n",0
0002cc  5f696e70
0002d0  75743a20
0002d4  636f7079
0002d8  696e6720
0002dc  746f206e
0002e0  65772070
0002e4  62756620
0002e8  6661696c
0002ec  65640a00
                  |L2.752|
0002f0  69636d70          DCB      "icmp_input: restoring original p->payload failed\n",0
0002f4  5f696e70
0002f8  75743a20
0002fc  72657374
000300  6f72696e
000304  67206f72
000308  6967696e
00030c  616c2070
000310  2d3e7061
000314  796c6f61
000318  64206661
00031c  696c6564
000320  0a00    
000322  00                DCB      0
000323  00                DCB      0
                  |L2.804|
000324  e1a00004          MOV      r0,r4                 ;175
000328  ebfffffe          BL       pbuf_free
00032c  e1a04007          MOV      r4,r7                 ;177
000330  ea00000e          B        |L2.880|
                  |L2.820|
000334  e3e01023          MVN      r1,#0x23              ;180
000338  e1a00004          MOV      r0,r4                 ;180
00033c  ebfffffe          BL       pbuf_header
000340  e3500000          CMP      r0,#0                 ;180
000344  0a000009          BEQ      |L2.880|
000348  e1a00000          MOV      r0,r0                 ;181
00034c  e1a00000          MOV      r0,r0                 ;181
000350  e24f3f51          ADR      r3,|L2.532|
000354  e3a020b5          MOV      r2,#0xb5              ;181
000358  e24f1070          ADR      r1,|L2.752|
00035c  e24f00fc          ADR      r0,|L2.616|
000360  ebfffffe          BL       sysprintf
000364  e1a00000          MOV      r0,r0                 ;181
000368  e1a00000          MOV      r0,r0                 ;181
00036c  ea000050          B        |L2.1204|
                  |L2.880|
000370  e5945004          LDR      r5,[r4,#4]            ;189
000374  e51f116c          LDR      r1,|L2.528|
000378  e5910000          LDR      r0,[r1,#0]            ;190  ; current_iphdr_dest
00037c  e286100c          ADD      r1,r6,#0xc            ;190
000380  ebfffffe          BL       __aeabi_uwrite4
000384  e59f113c          LDR      r1,|L2.1224|
000388  e5910000          LDR      r0,[r1,#0]            ;191  ; current_iphdr_src
00038c  e2861010          ADD      r1,r6,#0x10           ;191
000390  ebfffffe          BL       __aeabi_uwrite4
000394  e3a00000          MOV      r0,#0                 ;192
000398  e5c50000          STRB     r0,[r5,#0]            ;192
00039c  e5d50003          LDRB     r0,[r5,#3]            ;195
0003a0  e5d51002          LDRB     r1,[r5,#2]            ;195
0003a4  e1810400          ORR      r0,r1,r0,LSL #8       ;195
0003a8  e59f111c          LDR      r1,|L2.1228|
0003ac  e1500001          CMP      r0,r1                 ;195
0003b0  3a000008          BCC      |L2.984|
0003b4  e5d50003          LDRB     r0,[r5,#3]            ;196
0003b8  e5d51002          LDRB     r1,[r5,#2]            ;196
0003bc  e1810400          ORR      r0,r1,r0,LSL #8       ;196
0003c0  e2800009          ADD      r0,r0,#9              ;196
0003c4  e3c00801          BIC      r0,r0,#0x10000        ;196
0003c8  e5c50002          STRB     r0,[r5,#2]            ;196
0003cc  e1a00420          LSR      r0,r0,#8              ;196
0003d0  e5c50003          STRB     r0,[r5,#3]            ;196
0003d4  ea000007          B        |L2.1016|
                  |L2.984|
0003d8  e5d50003          LDRB     r0,[r5,#3]            ;198
0003dc  e5d51002          LDRB     r1,[r5,#2]            ;198
0003e0  e1810400          ORR      r0,r1,r0,LSL #8       ;198
0003e4  e2800008          ADD      r0,r0,#8              ;198
0003e8  e3c00801          BIC      r0,r0,#0x10000        ;198
0003ec  e5c50002          STRB     r0,[r5,#2]            ;198
0003f0  e1a00420          LSR      r0,r0,#8              ;198
0003f4  e5c50003          STRB     r0,[r5,#3]            ;198
                  |L2.1016|
0003f8  e3a000ff          MOV      r0,#0xff              ;205
0003fc  e5c60008          STRB     r0,[r6,#8]            ;205
000400  e3a00000          MOV      r0,#0                 ;206
000404  e5c6000a          STRB     r0,[r6,#0xa]          ;206
000408  e5c6000b          STRB     r0,[r6,#0xb]          ;206
00040c  e3a01014          MOV      r1,#0x14              ;208
000410  e1a00006          MOV      r0,r6                 ;208
000414  ebfffffe          BL       inet_chksum
000418  e5c6000a          STRB     r0,[r6,#0xa]          ;208
00041c  e1a00420          LSR      r0,r0,#8              ;208
000420  e5c6000b          STRB     r0,[r6,#0xb]          ;208
000424  e1a01008          MOV      r1,r8                 ;217
000428  e1a00004          MOV      r0,r4                 ;217
00042c  ebfffffe          BL       pbuf_header
000430  e3500000          CMP      r0,#0                 ;217
000434  0a000008          BEQ      |L2.1116|
000438  e1a00000          MOV      r0,r0                 ;218
00043c  e1a00000          MOV      r0,r0                 ;218
000440  e24f3f8d          ADR      r3,|L2.532|
000444  e3a020da          MOV      r2,#0xda              ;218
000448  e28f1080          ADR      r1,|L2.1232|
00044c  e24f0f7b          ADR      r0,|L2.616|
000450  ebfffffe          BL       sysprintf
000454  e1a00000          MOV      r0,r0                 ;218
000458  ea00000a          B        |L2.1160|
                  |L2.1116|
00045c  e3a00001          MOV      r0,#1                 ;222
000460  e3a01000          MOV      r1,#0                 ;222
000464  e3a030ff          MOV      r3,#0xff              ;222
000468  e58d1000          STR      r1,[sp,#0]            ;222
00046c  e1a02001          MOV      r2,r1                 ;222
000470  e51f1268          LDR      r1,|L2.528|
000474  e98d0201          STMIB    sp,{r0,r9}            ;222
000478  e1a00004          MOV      r0,r4                 ;222
00047c  ebfffffe          BL       ip_output_if
000480  e1a07000          MOV      r7,r0                 ;222
000484  e1a00000          MOV      r0,r0                 ;227
                  |L2.1160|
000488  ea000001          B        |L2.1172|
                  |L2.1164|
00048c  e1a00000          MOV      r0,r0                 ;229
000490  e1a00000          MOV      r0,r0                 ;102
                  |L2.1172|
000494  e1a00000          MOV      r0,r0                 ;106
000498  e1a00004          MOV      r0,r4                 ;235
00049c  ebfffffe          BL       pbuf_free
0004a0  eaffff04          B        |L2.184|
                  |L2.1188|
0004a4  e1a00000          MOV      r0,r0                 ;237
0004a8  e1a00004          MOV      r0,r4                 ;238
0004ac  ebfffffe          BL       pbuf_free
0004b0  eaffff00          B        |L2.184|
                  |L2.1204|
0004b4  e1a00000          MOV      r0,r0                 ;243
0004b8  e1a00004          MOV      r0,r4                 ;244
0004bc  ebfffffe          BL       pbuf_free
0004c0  e1a00000          MOV      r0,r0                 ;247
0004c4  eafffefb          B        |L2.184|
;;;250    
                          ENDP

                  |L2.1224|
                          DCD      current_iphdr_src
                  |L2.1228|
                          DCD      0x0000fff7
                  |L2.1232|
0004d0  43616e27          DCB      "Can't move over header in packet",0
0004d4  74206d6f
0004d8  7665206f
0004dc  76657220
0004e0  68656164
0004e4  65722069
0004e8  6e207061
0004ec  636b6574
0004f0  00      
0004f1  00                DCB      0
0004f2  00                DCB      0
0004f3  00                DCB      0

                          AREA ||i.icmp_send_response||, CODE, READONLY, ALIGN=2

                  icmp_send_response PROC
;;;290    static void
;;;291    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;292    {
000004  e1a06000          MOV      r6,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a08002          MOV      r8,r2
;;;293      struct pbuf *q;
;;;294      struct ip_hdr *iphdr;
;;;295      /* we can use the echo header here */
;;;296      struct icmp_echo_hdr *icmphdr;
;;;297      ip_addr_t iphdr_src;
;;;298    
;;;299      /* ICMP header + IP header + 8 bytes of data */
;;;300      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
000010  e3a02000          MOV      r2,#0
000014  e3a01024          MOV      r1,#0x24
000018  e3a00001          MOV      r0,#1
00001c  ebfffffe          BL       pbuf_alloc
000020  e1a05000          MOV      r5,r0
;;;301                     PBUF_RAM);
;;;302      if (q == NULL) {
000024  e3550000          CMP      r5,#0
000028  1a000000          BNE      |L3.48|
                  |L3.44|
;;;303        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
;;;304        return;
;;;305      }
;;;306      LWIP_ASSERT("check that first pbuf can hold icmp message",
;;;307                 (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;308    
;;;309      iphdr = (struct ip_hdr *)p->payload;
;;;310      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;311      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
;;;312      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;313      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
;;;314      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;315    
;;;316      icmphdr = (struct icmp_echo_hdr *)q->payload;
;;;317      icmphdr->type = type;
;;;318      icmphdr->code = code;
;;;319      icmphdr->id = 0;
;;;320      icmphdr->seqno = 0;
;;;321    
;;;322      /* copy fields from original packet */
;;;323      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
;;;324              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;325    
;;;326      /* calculate checksum */
;;;327      icmphdr->chksum = 0;
;;;328      icmphdr->chksum = inet_chksum(icmphdr, q->len);
;;;329      ICMP_STATS_INC(icmp.xmit);
;;;330      /* increase number of messages attempted to send */
;;;331      snmp_inc_icmpoutmsgs();
;;;332      /* increase number of destination unreachable messages attempted to send */
;;;333      snmp_inc_icmpouttimeexcds();
;;;334      ip_addr_copy(iphdr_src, iphdr->src);
;;;335      ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
;;;336      pbuf_free(q);
;;;337    }
00002c  e8bd83fe          POP      {r1-r9,pc}
                  |L3.48|
000030  e1a00000          MOV      r0,r0                 ;306
000034  e1d500ba          LDRH     r0,[r5,#0xa]          ;306
000038  e3500024          CMP      r0,#0x24              ;306
00003c  2a000006          BCS      |L3.92|
000040  e1a00000          MOV      r0,r0                 ;306
000044  e28f30ac          ADR      r3,|L3.248|
000048  e59f20c8          LDR      r2,|L3.280|
00004c  e28f10c8          ADR      r1,|L3.284|
000050  e28f00f0          ADR      r0,|L3.328|
000054  ebfffffe          BL       sysprintf
000058  e1a00000          MOV      r0,r0                 ;306
                  |L3.92|
00005c  e1a00000          MOV      r0,r0                 ;306
000060  e5969004          LDR      r9,[r6,#4]            ;309
000064  e5954004          LDR      r4,[r5,#4]            ;316
000068  e5c47000          STRB     r7,[r4,#0]            ;317
00006c  e5c48001          STRB     r8,[r4,#1]            ;318
000070  e3a00000          MOV      r0,#0                 ;319
000074  e5c40004          STRB     r0,[r4,#4]            ;319
000078  e5c40005          STRB     r0,[r4,#5]            ;319
00007c  e5c40006          STRB     r0,[r4,#6]            ;320
000080  e5c40007          STRB     r0,[r4,#7]            ;320
000084  e5961004          LDR      r1,[r6,#4]            ;323
000088  e5952004          LDR      r2,[r5,#4]            ;323
00008c  e2820008          ADD      r0,r2,#8              ;323
000090  e3a0201c          MOV      r2,#0x1c              ;323
000094  ebfffffe          BL       __aeabi_memcpy
000098  e3a00000          MOV      r0,#0                 ;327
00009c  e5c40002          STRB     r0,[r4,#2]            ;327
0000a0  e5c40003          STRB     r0,[r4,#3]            ;327
0000a4  e1d510ba          LDRH     r1,[r5,#0xa]          ;328
0000a8  e1a00004          MOV      r0,r4                 ;328
0000ac  ebfffffe          BL       inet_chksum
0000b0  e5c40002          STRB     r0,[r4,#2]            ;328
0000b4  e1a00420          LSR      r0,r0,#8              ;328
0000b8  e5c40003          STRB     r0,[r4,#3]            ;328
0000bc  e289000c          ADD      r0,r9,#0xc            ;334
0000c0  ebfffffe          BL       __aeabi_uread4
0000c4  e58d0008          STR      r0,[sp,#8]            ;334
0000c8  e3a00001          MOV      r0,#1                 ;335
0000cc  e3a01000          MOV      r1,#0                 ;335
0000d0  e3a030ff          MOV      r3,#0xff              ;335
0000d4  e58d0004          STR      r0,[sp,#4]            ;335
0000d8  e58d1000          STR      r1,[sp,#0]            ;335
0000dc  e28d2008          ADD      r2,sp,#8              ;335
0000e0  e1a00005          MOV      r0,r5                 ;335
0000e4  ebfffffe          BL       ip_output
0000e8  e1a00005          MOV      r0,r5                 ;336
0000ec  ebfffffe          BL       pbuf_free
0000f0  e1a00000          MOV      r0,r0
0000f4  eaffffcc          B        |L3.44|
;;;338    
                          ENDP

                  |L3.248|
0000f8  6c776970          DCB      "lwip-1.4.1\\src\\core\\ipv4\\icmp.c",0
0000fc  2d312e34
000100  2e315c73
000104  72635c63
000108  6f72655c
00010c  69707634
000110  5c69636d
000114  702e6300
                  |L3.280|
                          DCD      0x00000132
                  |L3.284|
00011c  63686563          DCB      "check that first pbuf can hold icmp message",0
000120  6b207468
000124  61742066
000128  69727374
00012c  20706275
000130  66206361
000134  6e20686f
000138  6c642069
00013c  636d7020
000140  6d657373
000144  61676500
                  |L3.328|
000148  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00014c  7274696f
000150  6e202225
000154  73222066
000158  61696c65
00015c  64206174
000160  206c696e
000164  65202564
000168  20696e20
00016c  25730a00

                          AREA ||i.icmp_time_exceeded||, CODE, READONLY, ALIGN=2

                  icmp_time_exceeded PROC
;;;274    void
;;;275    icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;276    {
000004  e1a05000          MOV      r5,r0
000008  e1a04001          MOV      r4,r1
;;;277      icmp_send_response(p, ICMP_TE, t);
00000c  e1a02004          MOV      r2,r4
000010  e3a0100b          MOV      r1,#0xb
000014  e1a00005          MOV      r0,r5
000018  ebfffffe          BL       icmp_send_response
;;;278    }
00001c  e8bd8070          POP      {r4-r6,pc}
;;;279    
                          ENDP

