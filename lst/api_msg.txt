; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\api_msg.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\api_msg.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -D__UVISION_VERSION=524 --omf_browse=.\obj\api_msg.crf lwip-1.4.1\src\api\api_msg.c]
                          ARM

                          AREA ||i.accept_function||, CODE, READONLY, ALIGN=2

                  accept_function PROC
;;;431    static err_t
;;;432    accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;433    {
000004  e1a06000          MOV      r6,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a08002          MOV      r8,r2
;;;434      struct netconn *newconn;
;;;435      struct netconn *conn = (struct netconn *)arg;
000010  e1a05006          MOV      r5,r6
;;;436    
;;;437      LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));
;;;438    
;;;439      if (!sys_mbox_valid(&conn->acceptmbox)) {
000014  e2850014          ADD      r0,r5,#0x14
000018  ebfffffe          BL       sys_mbox_valid
00001c  e3500000          CMP      r0,#0
000020  1a000001          BNE      |L1.44|
;;;440        LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
;;;441        return ERR_VAL;
000024  e3e00005          MVN      r0,#5
                  |L1.40|
;;;442      }
;;;443    
;;;444      /* We have to set the callback here even though
;;;445       * the new socket is unknown. conn->socket is marked as -1. */
;;;446      newconn = netconn_alloc(conn->type, conn->callback);
;;;447      if (newconn == NULL) {
;;;448        return ERR_MEM;
;;;449      }
;;;450      newconn->pcb.tcp = newpcb;
;;;451      setup_tcp(newconn);
;;;452      /* no protection: when creating the pcb, the netconn is not yet known
;;;453         to the application thread */
;;;454      newconn->last_err = err;
;;;455    
;;;456      if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
;;;457        /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
;;;458           so do nothing here! */
;;;459        /* remove all references to this netconn from the pcb */
;;;460        struct tcp_pcb* pcb = newconn->pcb.tcp;
;;;461        tcp_arg(pcb, NULL);
;;;462        tcp_recv(pcb, NULL);
;;;463        tcp_sent(pcb, NULL);
;;;464        tcp_poll(pcb, NULL, 4);
;;;465        tcp_err(pcb, NULL);
;;;466        /* remove reference from to the pcb from this netconn */
;;;467        newconn->pcb.tcp = NULL;
;;;468        /* no need to drain since we know the recvmbox is empty. */
;;;469        sys_mbox_free(&newconn->recvmbox);
;;;470        sys_mbox_set_invalid(&newconn->recvmbox);
;;;471        netconn_free(newconn);
;;;472        return ERR_MEM;
;;;473      } else {
;;;474        /* Register event with callback */
;;;475        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
;;;476      }
;;;477    
;;;478      return ERR_OK;
;;;479    }
000028  e8bd87f0          POP      {r4-r10,pc}
                  |L1.44|
00002c  e5951028          LDR      r1,[r5,#0x28]         ;446
000030  e5d50000          LDRB     r0,[r5,#0]            ;446
000034  ebfffffe          BL       netconn_alloc
000038  e1a04000          MOV      r4,r0                 ;446
00003c  e3540000          CMP      r4,#0                 ;447
000040  1a000001          BNE      |L1.76|
000044  e3e00000          MVN      r0,#0                 ;448
000048  eafffff6          B        |L1.40|
                  |L1.76|
00004c  e5847004          STR      r7,[r4,#4]            ;450
000050  e1a00004          MOV      r0,r4                 ;451
000054  ebfffffe          BL       setup_tcp
000058  e5c48008          STRB     r8,[r4,#8]            ;454
00005c  e1a01004          MOV      r1,r4                 ;456
000060  e2850014          ADD      r0,r5,#0x14           ;456
000064  ebfffffe          BL       sys_mbox_trypost
000068  e3500000          CMP      r0,#0                 ;456
00006c  0a00001a          BEQ      |L1.220|
000070  e5949004          LDR      r9,[r4,#4]            ;460
000074  e3a01000          MOV      r1,#0                 ;461
000078  e1a00009          MOV      r0,r9                 ;461
00007c  ebfffffe          BL       tcp_arg
000080  e3a01000          MOV      r1,#0                 ;462
000084  e1a00009          MOV      r0,r9                 ;462
000088  ebfffffe          BL       tcp_recv
00008c  e3a01000          MOV      r1,#0                 ;463
000090  e1a00009          MOV      r0,r9                 ;463
000094  ebfffffe          BL       tcp_sent
000098  e3a02004          MOV      r2,#4                 ;464
00009c  e3a01000          MOV      r1,#0                 ;464
0000a0  e1a00009          MOV      r0,r9                 ;464
0000a4  ebfffffe          BL       tcp_poll
0000a8  e3a01000          MOV      r1,#0                 ;465
0000ac  e1a00009          MOV      r0,r9                 ;465
0000b0  ebfffffe          BL       tcp_err
0000b4  e3a00000          MOV      r0,#0                 ;467
0000b8  e5840004          STR      r0,[r4,#4]            ;467
0000bc  e2840010          ADD      r0,r4,#0x10           ;469
0000c0  ebfffffe          BL       sys_mbox_free
0000c4  e2840010          ADD      r0,r4,#0x10           ;470
0000c8  ebfffffe          BL       sys_mbox_set_invalid
0000cc  e1a00004          MOV      r0,r4                 ;471
0000d0  ebfffffe          BL       netconn_free
0000d4  e3e00000          MVN      r0,#0                 ;472
0000d8  eaffffd2          B        |L1.40|
                  |L1.220|
0000dc  e1a00000          MOV      r0,r0                 ;473
0000e0  e5950028          LDR      r0,[r5,#0x28]         ;475
0000e4  e3500000          CMP      r0,#0                 ;475
0000e8  0a000004          BEQ      |L1.256|
0000ec  e3a02000          MOV      r2,#0                 ;475
0000f0  e1a01002          MOV      r1,r2                 ;475
0000f4  e5953028          LDR      r3,[r5,#0x28]         ;475
0000f8  e1a00005          MOV      r0,r5                 ;475
0000fc  e12fff33          BLX      r3                    ;475
                  |L1.256|
000100  e3a00000          MOV      r0,#0                 ;478
000104  eaffffc7          B        |L1.40|
;;;480    #endif /* LWIP_TCP */
                          ENDP


                          AREA ||i.do_bind||, CODE, READONLY, ALIGN=2

                  do_bind PROC
;;;898    void
;;;899    do_bind(struct api_msg_msg *msg)
000000  e92d4010          PUSH     {r4,lr}
;;;900    {
000004  e1a04000          MOV      r4,r0
;;;901      if (ERR_IS_FATAL(msg->conn->last_err)) {
000008  e5940000          LDR      r0,[r4,#0]
00000c  e1d000d8          LDRSB    r0,[r0,#8]
000010  e3700009          CMN      r0,#9
000014  aa000003          BGE      |L2.40|
;;;902        msg->err = msg->conn->last_err;
000018  e5940000          LDR      r0,[r4,#0]
00001c  e5d00008          LDRB     r0,[r0,#8]
000020  e5c40004          STRB     r0,[r4,#4]
000024  ea00001e          B        |L2.164|
                  |L2.40|
;;;903      } else {
;;;904        msg->err = ERR_VAL;
000028  e3a000fa          MOV      r0,#0xfa
00002c  e5c40004          STRB     r0,[r4,#4]
;;;905        if (msg->conn->pcb.tcp != NULL) {
000030  e5940000          LDR      r0,[r4,#0]
000034  e5900004          LDR      r0,[r0,#4]
000038  e3500000          CMP      r0,#0
00003c  0a000018          BEQ      |L2.164|
;;;906          switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000040  e5940000          LDR      r0,[r4,#0]
000044  e5d00000          LDRB     r0,[r0,#0]
000048  e20000f0          AND      r0,r0,#0xf0
00004c  e3500010          CMP      r0,#0x10
000050  0a000008          BEQ      |L2.120|
000054  e3500020          CMP      r0,#0x20
000058  1a00000e          BNE      |L2.152|
;;;907    #if LWIP_RAW
;;;908          case NETCONN_RAW:
;;;909            msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
;;;910            break;
;;;911    #endif /* LWIP_RAW */
;;;912    #if LWIP_UDP
;;;913          case NETCONN_UDP:
;;;914            msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
00005c  e1d420bc          LDRH     r2,[r4,#0xc]
000060  e5941008          LDR      r1,[r4,#8]
000064  e5943000          LDR      r3,[r4,#0]
000068  e5930004          LDR      r0,[r3,#4]
00006c  ebfffffe          BL       udp_bind
000070  e5c40004          STRB     r0,[r4,#4]
;;;915            break;
000074  ea000009          B        |L2.160|
                  |L2.120|
;;;916    #endif /* LWIP_UDP */
;;;917    #if LWIP_TCP
;;;918          case NETCONN_TCP:
000078  e1a00000          MOV      r0,r0
;;;919            msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
00007c  e1d420bc          LDRH     r2,[r4,#0xc]
000080  e5941008          LDR      r1,[r4,#8]
000084  e5943000          LDR      r3,[r4,#0]
000088  e5930004          LDR      r0,[r3,#4]
00008c  ebfffffe          BL       tcp_bind
000090  e5c40004          STRB     r0,[r4,#4]
;;;920            break;
000094  ea000001          B        |L2.160|
                  |L2.152|
;;;921    #endif /* LWIP_TCP */
;;;922          default:
000098  e1a00000          MOV      r0,r0
;;;923            break;
00009c  e1a00000          MOV      r0,r0
                  |L2.160|
0000a0  e1a00000          MOV      r0,r0                 ;915
                  |L2.164|
;;;924          }
;;;925        }
;;;926      }
;;;927      TCPIP_APIMSG_ACK(msg);
0000a4  e5941000          LDR      r1,[r4,#0]
0000a8  e281000c          ADD      r0,r1,#0xc
0000ac  ebfffffe          BL       sys_sem_signal
;;;928    }
0000b0  e8bd8010          POP      {r4,pc}
;;;929    
                          ENDP


                          AREA ||i.do_close||, CODE, READONLY, ALIGN=2

                  do_close PROC
;;;1451   void
;;;1452   do_close(struct api_msg_msg *msg)
000000  e92d4010          PUSH     {r4,lr}
;;;1453   {
000004  e1a04000          MOV      r4,r0
;;;1454   #if LWIP_TCP
;;;1455     /* @todo: abort running write/connect? */
;;;1456     if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
000008  e5940000          LDR      r0,[r4,#0]
00000c  e5d00001          LDRB     r0,[r0,#1]
000010  e3500000          CMP      r0,#0
000014  0a000013          BEQ      |L3.104|
000018  e5940000          LDR      r0,[r4,#0]
00001c  e5d00001          LDRB     r0,[r0,#1]
000020  e3500002          CMP      r0,#2
000024  0a00000f          BEQ      |L3.104|
;;;1457       /* this only happens for TCP netconns */
;;;1458       LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
000028  e1a00000          MOV      r0,r0
00002c  e5940000          LDR      r0,[r4,#0]
000030  e5d00000          LDRB     r0,[r0,#0]
000034  e3500010          CMP      r0,#0x10
000038  0a000006          BEQ      |L3.88|
00003c  e1a00000          MOV      r0,r0
000040  e28f3c01          ADR      r3,|L3.328|
000044  e59f211c          LDR      r2,|L3.360|
000048  e28f1f47          ADR      r1,|L3.364|
00004c  e28f0f4e          ADR      r0,|L3.396|
000050  ebfffffe          BL       sysprintf
000054  e1a00000          MOV      r0,r0
                  |L3.88|
000058  e1a00000          MOV      r0,r0
;;;1459       msg->err = ERR_INPROGRESS;
00005c  e3a000fb          MOV      r0,#0xfb
000060  e5c40004          STRB     r0,[r4,#4]
000064  ea000032          B        |L3.308|
                  |L3.104|
;;;1460     } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
000068  e5940000          LDR      r0,[r4,#0]
00006c  e5900004          LDR      r0,[r0,#4]
000070  e3500000          CMP      r0,#0
000074  0a00002c          BEQ      |L3.300|
000078  e5940000          LDR      r0,[r4,#0]
00007c  e5d00000          LDRB     r0,[r0,#0]
000080  e3500010          CMP      r0,#0x10
000084  1a000028          BNE      |L3.300|
;;;1461       if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
000088  e5d40008          LDRB     r0,[r4,#8]
00008c  e3500003          CMP      r0,#3
000090  0a000006          BEQ      |L3.176|
000094  e5940000          LDR      r0,[r4,#0]
000098  e5d00001          LDRB     r0,[r0,#1]
00009c  e3500002          CMP      r0,#2
0000a0  1a000002          BNE      |L3.176|
;;;1462         /* LISTEN doesn't support half shutdown */
;;;1463         msg->err = ERR_CONN;
0000a4  e3a000f3          MOV      r0,#0xf3
0000a8  e5c40004          STRB     r0,[r4,#4]
0000ac  ea000020          B        |L3.308|
                  |L3.176|
;;;1464       } else {
;;;1465         if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
0000b0  e5d40008          LDRB     r0,[r4,#8]
0000b4  e2000001          AND      r0,r0,#1
0000b8  e3500000          CMP      r0,#0
0000bc  0a000001          BEQ      |L3.200|
;;;1466           /* Drain and delete mboxes */
;;;1467           netconn_drain(msg->conn);
0000c0  e5940000          LDR      r0,[r4,#0]
0000c4  ebfffffe          BL       netconn_drain
                  |L3.200|
;;;1468         }
;;;1469         LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
0000c8  e1a00000          MOV      r0,r0
0000cc  e5940000          LDR      r0,[r4,#0]
0000d0  e5900024          LDR      r0,[r0,#0x24]
0000d4  e3500000          CMP      r0,#0
0000d8  1a000003          BNE      |L3.236|
0000dc  e5940000          LDR      r0,[r4,#0]
0000e0  e5900020          LDR      r0,[r0,#0x20]
0000e4  e3500000          CMP      r0,#0
0000e8  0a000006          BEQ      |L3.264|
                  |L3.236|
0000ec  e1a00000          MOV      r0,r0
0000f0  e28f3050          ADR      r3,|L3.328|
0000f4  e59f20b8          LDR      r2,|L3.436|
0000f8  e28f10b8          ADR      r1,|L3.440|
0000fc  e28f0088          ADR      r0,|L3.396|
000100  ebfffffe          BL       sysprintf
000104  e1a00000          MOV      r0,r0
                  |L3.264|
000108  e1a00000          MOV      r0,r0
;;;1470           msg->conn->write_offset == 0);
;;;1471         msg->conn->state = NETCONN_CLOSE;
00010c  e3a00004          MOV      r0,#4
000110  e5941000          LDR      r1,[r4,#0]
000114  e5c10001          STRB     r0,[r1,#1]
;;;1472         msg->conn->current_msg = msg;
000118  e5940000          LDR      r0,[r4,#0]
00011c  e5804024          STR      r4,[r0,#0x24]
;;;1473         do_close_internal(msg->conn);
000120  e5940000          LDR      r0,[r4,#0]
000124  ebfffffe          BL       do_close_internal
                  |L3.296|
;;;1474         /* for tcp netconns, do_close_internal ACKs the message */
;;;1475         return;
;;;1476       }
;;;1477     } else
;;;1478   #endif /* LWIP_TCP */
;;;1479     {
;;;1480       msg->err = ERR_VAL;
;;;1481     }
;;;1482     sys_sem_signal(&msg->conn->op_completed);
;;;1483   }
000128  e8bd8010          POP      {r4,pc}
                  |L3.300|
00012c  e3a000fa          MOV      r0,#0xfa              ;1480
000130  e5c40004          STRB     r0,[r4,#4]            ;1480
                  |L3.308|
000134  e5941000          LDR      r1,[r4,#0]            ;1482
000138  e281000c          ADD      r0,r1,#0xc            ;1482
00013c  ebfffffe          BL       sys_sem_signal
000140  e1a00000          MOV      r0,r0
000144  eafffff7          B        |L3.296|
;;;1484   
                          ENDP

                  |L3.328|
000148  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
00014c  2d312e34
000150  2e315c73
000154  72635c61
000158  70695c61
00015c  70695f6d
000160  73672e63
000164  00      
000165  00                DCB      0
000166  00                DCB      0
000167  00                DCB      0
                  |L3.360|
                          DCD      0x000005b2
                  |L3.364|
00016c  6d73672d          DCB      "msg->conn->type == NETCONN_TCP",0
000170  3e636f6e
000174  6e2d3e74
000178  79706520
00017c  3d3d204e
000180  4554434f
000184  4e4e5f54
000188  435000  
00018b  00                DCB      0
                  |L3.396|
00018c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000190  7274696f
000194  6e202225
000198  73222066
00019c  61696c65
0001a0  64206174
0001a4  206c696e
0001a8  65202564
0001ac  20696e20
0001b0  25730a00
                  |L3.436|
                          DCD      0x000005bd
                  |L3.440|
0001b8  616c7265          DCB      "already writing or closing",0
0001bc  61647920
0001c0  77726974
0001c4  696e6720
0001c8  6f722063
0001cc  6c6f7369
0001d0  6e6700  
0001d3  00                DCB      0

                          AREA ||i.do_close_internal||, CODE, READONLY, ALIGN=2

                  do_close_internal PROC
;;;747    static void
;;;748    do_close_internal(struct netconn *conn)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;749    {
000004  e1a04000          MOV      r4,r0
;;;750      err_t err;
;;;751      u8_t shut, shut_rx, shut_tx, close;
;;;752    
;;;753      LWIP_ASSERT("invalid conn", (conn != NULL));
000008  e1a00000          MOV      r0,r0
00000c  e3540000          CMP      r4,#0
000010  1a000006          BNE      |L4.48|
000014  e1a00000          MOV      r0,r0
000018  e28f3fb1          ADR      r3,|L4.740|
00001c  e59f22e0          LDR      r2,|L4.772|
000020  e28f1e2e          ADR      r1,|L4.776|
000024  e28f0fbb          ADR      r0,|L4.792|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L4.48|
000030  e1a00000          MOV      r0,r0
;;;754      LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
000034  e1a00000          MOV      r0,r0
000038  e5d40000          LDRB     r0,[r4,#0]
00003c  e3500010          CMP      r0,#0x10
000040  0a000006          BEQ      |L4.96|
000044  e1a00000          MOV      r0,r0
000048  e28f3fa5          ADR      r3,|L4.740|
00004c  e59f22ec          LDR      r2,|L4.832|
000050  e28f1fbb          ADR      r1,|L4.836|
000054  e28f0faf          ADR      r0,|L4.792|
000058  ebfffffe          BL       sysprintf
00005c  e1a00000          MOV      r0,r0
                  |L4.96|
000060  e1a00000          MOV      r0,r0
;;;755      LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
000064  e1a00000          MOV      r0,r0
000068  e5d40001          LDRB     r0,[r4,#1]
00006c  e3500004          CMP      r0,#4
000070  0a000006          BEQ      |L4.144|
000074  e1a00000          MOV      r0,r0
000078  e28f3f99          ADR      r3,|L4.740|
00007c  e59f22e0          LDR      r2,|L4.868|
000080  e28f1e2e          ADR      r1,|L4.872|
000084  e28f0fa3          ADR      r0,|L4.792|
000088  ebfffffe          BL       sysprintf
00008c  e1a00000          MOV      r0,r0
                  |L4.144|
000090  e1a00000          MOV      r0,r0
;;;756      LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
000094  e1a00000          MOV      r0,r0
000098  e5940004          LDR      r0,[r4,#4]
00009c  e3500000          CMP      r0,#0
0000a0  1a000006          BNE      |L4.192|
0000a4  e1a00000          MOV      r0,r0
0000a8  e28f3f8d          ADR      r3,|L4.740|
0000ac  e3a02fbd          MOV      r2,#0x2f4
0000b0  e28f1fb5          ADR      r1,|L4.908|
0000b4  e28f0f97          ADR      r0,|L4.792|
0000b8  ebfffffe          BL       sysprintf
0000bc  e1a00000          MOV      r0,r0
                  |L4.192|
0000c0  e1a00000          MOV      r0,r0
;;;757      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
0000c4  e1a00000          MOV      r0,r0
0000c8  e5940024          LDR      r0,[r4,#0x24]
0000cc  e3500000          CMP      r0,#0
0000d0  1a000006          BNE      |L4.240|
0000d4  e1a00000          MOV      r0,r0
0000d8  e28f3f81          ADR      r3,|L4.740|
0000dc  e59f22bc          LDR      r2,|L4.928|
0000e0  e28f1faf          ADR      r1,|L4.932|
0000e4  e28f0f8b          ADR      r0,|L4.792|
0000e8  ebfffffe          BL       sysprintf
0000ec  e1a00000          MOV      r0,r0
                  |L4.240|
0000f0  e1a00000          MOV      r0,r0
;;;758    
;;;759      shut = conn->current_msg->msg.sd.shut;
0000f4  e5940024          LDR      r0,[r4,#0x24]
0000f8  e5d06008          LDRB     r6,[r0,#8]
;;;760      shut_rx = shut & NETCONN_SHUT_RD;
0000fc  e2067001          AND      r7,r6,#1
;;;761      shut_tx = shut & NETCONN_SHUT_WR;
000100  e2068002          AND      r8,r6,#2
;;;762      /* shutting down both ends is the same as closing */
;;;763      close = shut == NETCONN_SHUT_RDWR;
000104  e3560003          CMP      r6,#3
000108  1a000001          BNE      |L4.276|
00010c  e3a00001          MOV      r0,#1
000110  ea000000          B        |L4.280|
                  |L4.276|
000114  e3a00000          MOV      r0,#0
                  |L4.280|
000118  e1a09000          MOV      r9,r0
;;;764    
;;;765      /* Set back some callback pointers */
;;;766      if (close) {
00011c  e3590000          CMP      r9,#0
000120  0a000002          BEQ      |L4.304|
;;;767        tcp_arg(conn->pcb.tcp, NULL);
000124  e3a01000          MOV      r1,#0
000128  e5940004          LDR      r0,[r4,#4]
00012c  ebfffffe          BL       tcp_arg
                  |L4.304|
;;;768      }
;;;769      if (conn->pcb.tcp->state == LISTEN) {
000130  e5940004          LDR      r0,[r4,#4]
000134  e5d00018          LDRB     r0,[r0,#0x18]
000138  e3500001          CMP      r0,#1
00013c  1a000003          BNE      |L4.336|
;;;770        tcp_accept(conn->pcb.tcp, NULL);
000140  e3a01000          MOV      r1,#0
000144  e5940004          LDR      r0,[r4,#4]
000148  ebfffffe          BL       tcp_accept
00014c  ea000015          B        |L4.424|
                  |L4.336|
;;;771      } else {
;;;772        /* some callbacks have to be reset if tcp_close is not successful */
;;;773        if (shut_rx) {
000150  e3570000          CMP      r7,#0
000154  0a000005          BEQ      |L4.368|
;;;774          tcp_recv(conn->pcb.tcp, NULL);
000158  e3a01000          MOV      r1,#0
00015c  e5940004          LDR      r0,[r4,#4]
000160  ebfffffe          BL       tcp_recv
;;;775          tcp_accept(conn->pcb.tcp, NULL);
000164  e3a01000          MOV      r1,#0
000168  e5940004          LDR      r0,[r4,#4]
00016c  ebfffffe          BL       tcp_accept
                  |L4.368|
;;;776        }
;;;777        if (shut_tx) {
000170  e3580000          CMP      r8,#0
000174  0a000002          BEQ      |L4.388|
;;;778          tcp_sent(conn->pcb.tcp, NULL);
000178  e3a01000          MOV      r1,#0
00017c  e5940004          LDR      r0,[r4,#4]
000180  ebfffffe          BL       tcp_sent
                  |L4.388|
;;;779        }
;;;780        if (close) {
000184  e3590000          CMP      r9,#0
000188  0a000006          BEQ      |L4.424|
;;;781          tcp_poll(conn->pcb.tcp, NULL, 4);
00018c  e3a02004          MOV      r2,#4
000190  e3a01000          MOV      r1,#0
000194  e5940004          LDR      r0,[r4,#4]
000198  ebfffffe          BL       tcp_poll
;;;782          tcp_err(conn->pcb.tcp, NULL);
00019c  e3a01000          MOV      r1,#0
0001a0  e5940004          LDR      r0,[r4,#4]
0001a4  ebfffffe          BL       tcp_err
                  |L4.424|
;;;783        }
;;;784      }
;;;785      /* Try to close the connection */
;;;786      if (close) {
0001a8  e3590000          CMP      r9,#0
0001ac  0a000003          BEQ      |L4.448|
;;;787        err = tcp_close(conn->pcb.tcp);
0001b0  e5940004          LDR      r0,[r4,#4]
0001b4  ebfffffe          BL       tcp_close
0001b8  e1a05000          MOV      r5,r0
0001bc  ea000004          B        |L4.468|
                  |L4.448|
;;;788      } else {
;;;789        err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
0001c0  e1a02008          MOV      r2,r8
0001c4  e1a01007          MOV      r1,r7
0001c8  e5940004          LDR      r0,[r4,#4]
0001cc  ebfffffe          BL       tcp_shutdown
0001d0  e1a05000          MOV      r5,r0
                  |L4.468|
;;;790      }
;;;791      if (err == ERR_OK) {
0001d4  e3550000          CMP      r5,#0
0001d8  1a000026          BNE      |L4.632|
;;;792        /* Closing succeeded */
;;;793        conn->current_msg->err = ERR_OK;
0001dc  e3a00000          MOV      r0,#0
0001e0  e5941024          LDR      r1,[r4,#0x24]
0001e4  e5c10004          STRB     r0,[r1,#4]
;;;794        conn->current_msg = NULL;
0001e8  e5840024          STR      r0,[r4,#0x24]
;;;795        conn->state = NETCONN_NONE;
0001ec  e5c40001          STRB     r0,[r4,#1]
;;;796        if (close) {
0001f0  e3590000          CMP      r9,#0
0001f4  0a000008          BEQ      |L4.540|
;;;797          /* Set back some callback pointers as conn is going away */
;;;798          conn->pcb.tcp = NULL;
0001f8  e5840004          STR      r0,[r4,#4]
;;;799          /* Trigger select() in socket layer. Make sure everybody notices activity
;;;800           on the connection, error first! */
;;;801          API_EVENT(conn, NETCONN_EVT_ERROR, 0);
0001fc  e5940028          LDR      r0,[r4,#0x28]
000200  e3500000          CMP      r0,#0
000204  0a000004          BEQ      |L4.540|
000208  e3a02000          MOV      r2,#0
00020c  e3a01004          MOV      r1,#4
000210  e5943028          LDR      r3,[r4,#0x28]
000214  e1a00004          MOV      r0,r4
000218  e12fff33          BLX      r3
                  |L4.540|
;;;802        }
;;;803        if (shut_rx) {
00021c  e3570000          CMP      r7,#0
000220  0a000007          BEQ      |L4.580|
;;;804          API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
000224  e5940028          LDR      r0,[r4,#0x28]
000228  e3500000          CMP      r0,#0
00022c  0a000004          BEQ      |L4.580|
000230  e3a02000          MOV      r2,#0
000234  e1a01002          MOV      r1,r2
000238  e5943028          LDR      r3,[r4,#0x28]
00023c  e1a00004          MOV      r0,r4
000240  e12fff33          BLX      r3
                  |L4.580|
;;;805        }
;;;806        if (shut_tx) {
000244  e3580000          CMP      r8,#0
000248  0a000007          BEQ      |L4.620|
;;;807          API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
00024c  e5940028          LDR      r0,[r4,#0x28]
000250  e3500000          CMP      r0,#0
000254  0a000004          BEQ      |L4.620|
000258  e3a02000          MOV      r2,#0
00025c  e3a01002          MOV      r1,#2
000260  e5943028          LDR      r3,[r4,#0x28]
000264  e1a00004          MOV      r0,r4
000268  e12fff33          BLX      r3
                  |L4.620|
;;;808        }
;;;809        /* wake up the application task */
;;;810        sys_sem_signal(&conn->op_completed);
00026c  e284000c          ADD      r0,r4,#0xc
000270  ebfffffe          BL       sys_sem_signal
000274  ea000019          B        |L4.736|
                  |L4.632|
;;;811      } else {
;;;812        /* Closing failed, restore some of the callbacks */
;;;813        /* Closing of listen pcb will never fail! */
;;;814        LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
000278  e1a00000          MOV      r0,r0
00027c  e5940004          LDR      r0,[r4,#4]
000280  e5d00018          LDRB     r0,[r0,#0x18]
000284  e3500001          CMP      r0,#1
000288  1a000006          BNE      |L4.680|
00028c  e1a00000          MOV      r0,r0
000290  e28f304c          ADR      r3,|L4.740|
000294  e59f2124          LDR      r2,|L4.960|
000298  e28f1f49          ADR      r1,|L4.964|
00029c  e28f0074          ADR      r0,|L4.792|
0002a0  ebfffffe          BL       sysprintf
0002a4  e1a00000          MOV      r0,r0
                  |L4.680|
0002a8  e1a00000          MOV      r0,r0
;;;815        tcp_sent(conn->pcb.tcp, sent_tcp);
0002ac  e59f1134          LDR      r1,|L4.1000|
0002b0  e5940004          LDR      r0,[r4,#4]
0002b4  ebfffffe          BL       tcp_sent
;;;816        tcp_poll(conn->pcb.tcp, poll_tcp, 4);
0002b8  e3a02004          MOV      r2,#4
0002bc  e59f1128          LDR      r1,|L4.1004|
0002c0  e5940004          LDR      r0,[r4,#4]
0002c4  ebfffffe          BL       tcp_poll
;;;817        tcp_err(conn->pcb.tcp, err_tcp);
0002c8  e59f1120          LDR      r1,|L4.1008|
0002cc  e5940004          LDR      r0,[r4,#4]
0002d0  ebfffffe          BL       tcp_err
;;;818        tcp_arg(conn->pcb.tcp, conn);
0002d4  e5940004          LDR      r0,[r4,#4]
0002d8  e1a01004          MOV      r1,r4
0002dc  ebfffffe          BL       tcp_arg
                  |L4.736|
;;;819        /* don't restore recv callback: we don't want to receive any more data */
;;;820      }
;;;821      /* If closing didn't succeed, we get called again either
;;;822         from poll_tcp or from sent_tcp */
;;;823    }
0002e0  e8bd87f0          POP      {r4-r10,pc}
                  |L4.740|
0002e4  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
0002e8  2d312e34
0002ec  2e315c73
0002f0  72635c61
0002f4  70695c61
0002f8  70695f6d
0002fc  73672e63
000300  00      
000301  00                DCB      0
000302  00                DCB      0
000303  00                DCB      0
                  |L4.772|
                          DCD      0x000002f1
                  |L4.776|
000308  696e7661          DCB      "invalid conn",0
00030c  6c696420
000310  636f6e6e
000314  00      
000315  00                DCB      0
000316  00                DCB      0
000317  00                DCB      0
                  |L4.792|
000318  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00031c  7274696f
000320  6e202225
000324  73222066
000328  61696c65
00032c  64206174
000330  206c696e
000334  65202564
000338  20696e20
00033c  25730a00
                  |L4.832|
                          DCD      0x000002f2
                  |L4.836|
000344  74686973          DCB      "this is for tcp netconns only",0
000348  20697320
00034c  666f7220
000350  74637020
000354  6e657463
000358  6f6e6e73
00035c  206f6e6c
000360  7900    
000362  00                DCB      0
000363  00                DCB      0
                  |L4.868|
                          DCD      0x000002f3
                  |L4.872|
000368  636f6e6e          DCB      "conn must be in state NETCONN_CLOSE",0
00036c  206d7573
000370  74206265
000374  20696e20
000378  73746174
00037c  65204e45
000380  54434f4e
000384  4e5f434c
000388  4f534500
                  |L4.908|
00038c  70636220          DCB      "pcb already closed",0
000390  616c7265
000394  61647920
000398  636c6f73
00039c  656400  
00039f  00                DCB      0
                  |L4.928|
                          DCD      0x000002f5
                  |L4.932|
0003a4  636f6e6e          DCB      "conn->current_msg != NULL",0
0003a8  2d3e6375
0003ac  7272656e
0003b0  745f6d73
0003b4  6720213d
0003b8  204e554c
0003bc  4c00    
0003be  00                DCB      0
0003bf  00                DCB      0
                  |L4.960|
                          DCD      0x0000032e
                  |L4.964|
0003c4  436c6f73          DCB      "Closing a listen pcb may not fail!",0
0003c8  696e6720
0003cc  61206c69
0003d0  7374656e
0003d4  20706362
0003d8  206d6179
0003dc  206e6f74
0003e0  20666169
0003e4  6c2100  
0003e7  00                DCB      0
                  |L4.1000|
                          DCD      sent_tcp
                  |L4.1004|
                          DCD      poll_tcp
                  |L4.1008|
                          DCD      err_tcp
                          ENDP


                          AREA ||i.do_connect||, CODE, READONLY, ALIGN=2

                  do_connect PROC
;;;984    void
;;;985    do_connect(struct api_msg_msg *msg)
000000  e92d4010          PUSH     {r4,lr}
;;;986    {
000004  e1a04000          MOV      r4,r0
;;;987      if (msg->conn->pcb.tcp == NULL) {
000008  e5940000          LDR      r0,[r4,#0]
00000c  e5900004          LDR      r0,[r0,#4]
000010  e3500000          CMP      r0,#0
000014  1a000002          BNE      |L5.36|
;;;988        /* This may happen when calling netconn_connect() a second time */
;;;989        msg->err = ERR_CLSD;
000018  e3a000f4          MOV      r0,#0xf4
00001c  e5c40004          STRB     r0,[r4,#4]
000020  ea000051          B        |L5.364|
                  |L5.36|
;;;990      } else {
;;;991        switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000024  e5940000          LDR      r0,[r4,#0]
000028  e5d00000          LDRB     r0,[r0,#0]
00002c  e20000f0          AND      r0,r0,#0xf0
000030  e3500010          CMP      r0,#0x10
000034  0a000008          BEQ      |L5.92|
000038  e3500020          CMP      r0,#0x20
00003c  1a00003a          BNE      |L5.300|
;;;992    #if LWIP_RAW
;;;993      case NETCONN_RAW:
;;;994        msg->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
;;;995        break;
;;;996    #endif /* LWIP_RAW */
;;;997    #if LWIP_UDP
;;;998      case NETCONN_UDP:
;;;999        msg->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
000040  e1d420bc          LDRH     r2,[r4,#0xc]
000044  e5941008          LDR      r1,[r4,#8]
000048  e5943000          LDR      r3,[r4,#0]
00004c  e5930004          LDR      r0,[r3,#4]
000050  ebfffffe          BL       udp_connect
000054  e5c40004          STRB     r0,[r4,#4]
;;;1000       break;
000058  ea000042          B        |L5.360|
                  |L5.92|
;;;1001   #endif /* LWIP_UDP */
;;;1002   #if LWIP_TCP
;;;1003     case NETCONN_TCP:
00005c  e1a00000          MOV      r0,r0
;;;1004       /* Prevent connect while doing any other action. */
;;;1005       if (msg->conn->state != NETCONN_NONE) {
000060  e5940000          LDR      r0,[r4,#0]
000064  e5d00001          LDRB     r0,[r0,#1]
000068  e3500000          CMP      r0,#0
00006c  0a000002          BEQ      |L5.124|
;;;1006         msg->err = ERR_ISCONN;
000070  e3a000f7          MOV      r0,#0xf7
000074  e5c40004          STRB     r0,[r4,#4]
000078  ea00002a          B        |L5.296|
                  |L5.124|
;;;1007       } else {
;;;1008         setup_tcp(msg->conn);
00007c  e5940000          LDR      r0,[r4,#0]
000080  ebfffffe          BL       setup_tcp
;;;1009         msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
000084  e1d420bc          LDRH     r2,[r4,#0xc]
000088  e5941008          LDR      r1,[r4,#8]
00008c  e5943000          LDR      r3,[r4,#0]
000090  e5930004          LDR      r0,[r3,#4]
000094  e59f30e4          LDR      r3,|L5.384|
000098  ebfffffe          BL       tcp_connect
00009c  e5c40004          STRB     r0,[r4,#4]
;;;1010           msg->msg.bc.port, do_connected);
;;;1011         if (msg->err == ERR_OK) {
0000a0  e5d40004          LDRB     r0,[r4,#4]
0000a4  e3500000          CMP      r0,#0
0000a8  1a00001e          BNE      |L5.296|
;;;1012           u8_t non_blocking = netconn_is_nonblocking(msg->conn);
0000ac  e5941000          LDR      r1,[r4,#0]
0000b0  e5d1101c          LDRB     r1,[r1,#0x1c]
0000b4  e2011002          AND      r1,r1,#2
0000b8  e1a000a1          LSR      r0,r1,#1
;;;1013           msg->conn->state = NETCONN_CONNECT;
0000bc  e3a01003          MOV      r1,#3
0000c0  e5942000          LDR      r2,[r4,#0]
0000c4  e5c21001          STRB     r1,[r2,#1]
;;;1014           SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
0000c8  e1a00000          MOV      r0,r0
0000cc  e3500000          CMP      r0,#0
0000d0  0a000005          BEQ      |L5.236|
0000d4  e5941000          LDR      r1,[r4,#0]
0000d8  e5d1101c          LDRB     r1,[r1,#0x1c]
0000dc  e3811004          ORR      r1,r1,#4
0000e0  e5942000          LDR      r2,[r4,#0]
0000e4  e5c2101c          STRB     r1,[r2,#0x1c]
0000e8  ea000004          B        |L5.256|
                  |L5.236|
0000ec  e5941000          LDR      r1,[r4,#0]
0000f0  e5d1101c          LDRB     r1,[r1,#0x1c]
0000f4  e3c11004          BIC      r1,r1,#4
0000f8  e5942000          LDR      r2,[r4,#0]
0000fc  e5c2101c          STRB     r1,[r2,#0x1c]
                  |L5.256|
000100  e1a00000          MOV      r0,r0
;;;1015           if (non_blocking) {
000104  e3500000          CMP      r0,#0
000108  0a000002          BEQ      |L5.280|
;;;1016             msg->err = ERR_INPROGRESS;
00010c  e3a010fb          MOV      r1,#0xfb
000110  e5c41004          STRB     r1,[r4,#4]
000114  ea000002          B        |L5.292|
                  |L5.280|
;;;1017           } else {
;;;1018             msg->conn->current_msg = msg;
000118  e5941000          LDR      r1,[r4,#0]
00011c  e5814024          STR      r4,[r1,#0x24]
                  |L5.288|
;;;1019             /* sys_sem_signal() is called from do_connected (or err_tcp()),
;;;1020             * when the connection is established! */
;;;1021             return;
;;;1022           }
;;;1023         }
;;;1024       }
;;;1025       break;
;;;1026   #endif /* LWIP_TCP */
;;;1027     default:
;;;1028       LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
;;;1029       break;
;;;1030       }
;;;1031     }
;;;1032     sys_sem_signal(&msg->conn->op_completed);
;;;1033   }
000120  e8bd8010          POP      {r4,pc}
                  |L5.292|
000124  e1a00000          MOV      r0,r0                 ;1023
                  |L5.296|
000128  ea00000e          B        |L5.360|
                  |L5.300|
00012c  e1a00000          MOV      r0,r0                 ;1027
000130  e1a00000          MOV      r0,r0                 ;1028
000134  e1a00000          MOV      r0,r0                 ;1028
000138  e28f3044          ADR      r3,|L5.388|
00013c  e59f2060          LDR      r2,|L5.420|
000140  e28f1060          ADR      r1,|L5.424|
000144  e28f0074          ADR      r0,|L5.448|
000148  ebfffffe          BL       sysprintf
00014c  e1a00000          MOV      r0,r0                 ;1028
000150  e1a00000          MOV      r0,r0                 ;1028
000154  e3a000fa          MOV      r0,#0xfa              ;1028
000158  e5c40004          STRB     r0,[r4,#4]            ;1028
00015c  e1a00000          MOV      r0,r0                 ;1028
000160  e1a00000          MOV      r0,r0                 ;1028
000164  e1a00000          MOV      r0,r0                 ;1029
                  |L5.360|
000168  e1a00000          MOV      r0,r0                 ;1000
                  |L5.364|
00016c  e5941000          LDR      r1,[r4,#0]            ;1032
000170  e281000c          ADD      r0,r1,#0xc            ;1032
000174  ebfffffe          BL       sys_sem_signal
000178  e1a00000          MOV      r0,r0
00017c  eaffffe7          B        |L5.288|
;;;1034   
                          ENDP

                  |L5.384|
                          DCD      do_connected
                  |L5.388|
000184  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
000188  2d312e34
00018c  2e315c73
000190  72635c61
000194  70695c61
000198  70695f6d
00019c  73672e63
0001a0  00      
0001a1  00                DCB      0
0001a2  00                DCB      0
0001a3  00                DCB      0
                  |L5.420|
                          DCD      0x00000404
                  |L5.424|
0001a8  496e7661          DCB      "Invalid netconn type",0
0001ac  6c696420
0001b0  6e657463
0001b4  6f6e6e20
0001b8  74797065
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L5.448|
0001c0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001c4  7274696f
0001c8  6e202225
0001cc  73222066
0001d0  61696c65
0001d4  64206174
0001d8  206c696e
0001dc  65202564
0001e0  20696e20
0001e4  25730a00

                          AREA ||i.do_connected||, CODE, READONLY, ALIGN=2

                  do_connected PROC
;;;937    static err_t
;;;938    do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;939    {
000004  e1a05000          MOV      r5,r0
000008  e1a09001          MOV      r9,r1
00000c  e1a06002          MOV      r6,r2
;;;940      struct netconn *conn;
;;;941      int was_blocking;
;;;942    
;;;943      LWIP_UNUSED_ARG(pcb);
;;;944    
;;;945      conn = (struct netconn *)arg;
000010  e1a04005          MOV      r4,r5
;;;946    
;;;947      if (conn == NULL) {
000014  e3540000          CMP      r4,#0
000018  1a000001          BNE      |L6.36|
;;;948        return ERR_VAL;
00001c  e3e00005          MVN      r0,#5
                  |L6.32|
;;;949      }
;;;950    
;;;951      LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
;;;952      LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
;;;953        (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));
;;;954    
;;;955      if (conn->current_msg != NULL) {
;;;956        conn->current_msg->err = err;
;;;957      }
;;;958      if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
;;;959        setup_tcp(conn);
;;;960      }
;;;961      was_blocking = !IN_NONBLOCKING_CONNECT(conn);
;;;962      SET_NONBLOCKING_CONNECT(conn, 0);
;;;963      conn->current_msg = NULL;
;;;964      conn->state = NETCONN_NONE;
;;;965      if (!was_blocking) {
;;;966        NETCONN_SET_SAFE_ERR(conn, ERR_OK);
;;;967      }
;;;968      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
;;;969    
;;;970      if (was_blocking) {
;;;971        sys_sem_signal(&conn->op_completed);
;;;972      }
;;;973      return ERR_OK;
;;;974    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L6.36|
000024  e1a00000          MOV      r0,r0                 ;951
000028  e5d40001          LDRB     r0,[r4,#1]            ;951
00002c  e3500003          CMP      r0,#3                 ;951
000030  0a000006          BEQ      |L6.80|
000034  e1a00000          MOV      r0,r0                 ;951
000038  e28f3f47          ADR      r3,|L6.348|
00003c  e59f2138          LDR      r2,|L6.380|
000040  e28f1f4e          ADR      r1,|L6.384|
000044  e28f0f55          ADR      r0,|L6.416|
000048  ebfffffe          BL       sysprintf
00004c  e1a00000          MOV      r0,r0                 ;951
                  |L6.80|
000050  e1a00000          MOV      r0,r0                 ;951
000054  e1a00000          MOV      r0,r0                 ;952
000058  e5940024          LDR      r0,[r4,#0x24]         ;952
00005c  e3500000          CMP      r0,#0                 ;952
000060  1a00000a          BNE      |L6.144|
000064  e5d4001c          LDRB     r0,[r4,#0x1c]         ;952
000068  e2000004          AND      r0,r0,#4              ;952
00006c  e3500000          CMP      r0,#0                 ;952
000070  1a000006          BNE      |L6.144|
000074  e1a00000          MOV      r0,r0                 ;952
000078  e28f30dc          ADR      r3,|L6.348|
00007c  e3a02fee          MOV      r2,#0x3b8             ;952
000080  e28f1d05          ADR      r1,|L6.456|
000084  e28f0f45          ADR      r0,|L6.416|
000088  ebfffffe          BL       sysprintf
00008c  e1a00000          MOV      r0,r0                 ;952
                  |L6.144|
000090  e1a00000          MOV      r0,r0                 ;952
000094  e5940024          LDR      r0,[r4,#0x24]         ;955
000098  e3500000          CMP      r0,#0                 ;955
00009c  0a000001          BEQ      |L6.168|
0000a0  e5940024          LDR      r0,[r4,#0x24]         ;956
0000a4  e5c06004          STRB     r6,[r0,#4]            ;956
                  |L6.168|
0000a8  e5d40000          LDRB     r0,[r4,#0]            ;958
0000ac  e3500010          CMP      r0,#0x10              ;958
0000b0  1a000003          BNE      |L6.196|
0000b4  e3560000          CMP      r6,#0                 ;958
0000b8  1a000001          BNE      |L6.196|
0000bc  e1a00004          MOV      r0,r4                 ;959
0000c0  ebfffffe          BL       setup_tcp
                  |L6.196|
0000c4  e5d4001c          LDRB     r0,[r4,#0x1c]         ;961
0000c8  e3a01001          MOV      r1,#1                 ;961
0000cc  e1c17120          BIC      r7,r1,r0,LSR #2       ;961
0000d0  e1a00000          MOV      r0,r0                 ;962
0000d4  e5d4001c          LDRB     r0,[r4,#0x1c]         ;962
0000d8  e3c00004          BIC      r0,r0,#4              ;962
0000dc  e5c4001c          STRB     r0,[r4,#0x1c]         ;962
0000e0  e1a00000          MOV      r0,r0                 ;962
0000e4  e3a00000          MOV      r0,#0                 ;963
0000e8  e5840024          STR      r0,[r4,#0x24]         ;963
0000ec  e5c40001          STRB     r0,[r4,#1]            ;964
0000f0  e3570000          CMP      r7,#0                 ;965
0000f4  1a00000a          BNE      |L6.292|
0000f8  e1a00000          MOV      r0,r0                 ;966
0000fc  ebfffffe          BL       sys_arch_protect
000100  e1a08000          MOV      r8,r0                 ;966
000104  e1d400d8          LDRSB    r0,[r4,#8]            ;966
000108  e3700009          CMN      r0,#9                 ;966
00010c  ba000001          BLT      |L6.280|
000110  e3a00000          MOV      r0,#0                 ;966
000114  e5c40008          STRB     r0,[r4,#8]            ;966
                  |L6.280|
000118  e1a00008          MOV      r0,r8                 ;966
00011c  ebfffffe          BL       sys_arch_unprotect
000120  e1a00000          MOV      r0,r0                 ;966
                  |L6.292|
000124  e5940028          LDR      r0,[r4,#0x28]         ;968
000128  e3500000          CMP      r0,#0                 ;968
00012c  0a000004          BEQ      |L6.324|
000130  e3a02000          MOV      r2,#0                 ;968
000134  e3a01002          MOV      r1,#2                 ;968
000138  e5943028          LDR      r3,[r4,#0x28]         ;968
00013c  e1a00004          MOV      r0,r4                 ;968
000140  e12fff33          BLX      r3                    ;968
                  |L6.324|
000144  e3570000          CMP      r7,#0                 ;970
000148  0a000001          BEQ      |L6.340|
00014c  e284000c          ADD      r0,r4,#0xc            ;971
000150  ebfffffe          BL       sys_sem_signal
                  |L6.340|
000154  e3a00000          MOV      r0,#0                 ;973
000158  eaffffb0          B        |L6.32|
;;;975    #endif /* LWIP_TCP */
                          ENDP

                  |L6.348|
00015c  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
000160  2d312e34
000164  2e315c73
000168  72635c61
00016c  70695c61
000170  70695f6d
000174  73672e63
000178  00      
000179  00                DCB      0
00017a  00                DCB      0
00017b  00                DCB      0
                  |L6.380|
                          DCD      0x000003b7
                  |L6.384|
000180  636f6e6e          DCB      "conn->state == NETCONN_CONNECT",0
000184  2d3e7374
000188  61746520
00018c  3d3d204e
000190  4554434f
000194  4e4e5f43
000198  4f4e4e45
00019c  435400  
00019f  00                DCB      0
                  |L6.416|
0001a0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001a4  7274696f
0001a8  6e202225
0001ac  73222066
0001b0  61696c65
0001b4  64206174
0001b8  206c696e
0001bc  65202564
0001c0  20696e20
0001c4  25730a00
                  |L6.456|
0001c8  28636f6e          DCB      "(conn->current_msg != NULL) || conn->in_non_blocking_co"
0001cc  6e2d3e63
0001d0  75727265
0001d4  6e745f6d
0001d8  73672021
0001dc  3d204e55
0001e0  4c4c2920
0001e4  7c7c2063
0001e8  6f6e6e2d
0001ec  3e696e5f
0001f0  6e6f6e5f
0001f4  626c6f63
0001f8  6b696e67
0001fc  5f636f  
0001ff  6e6e6563          DCB      "nnect",0
000203  7400    
000205  00                DCB      0
000206  00                DCB      0
000207  00                DCB      0

                          AREA ||i.do_delconn||, CODE, READONLY, ALIGN=2

                  do_delconn PROC
;;;832    void
;;;833    do_delconn(struct api_msg_msg *msg)
000000  e92d4010          PUSH     {r4,lr}
;;;834    {
000004  e1a04000          MOV      r4,r0
;;;835      /* @todo TCP: abort running write/connect? */
;;;836     if ((msg->conn->state != NETCONN_NONE) &&
000008  e5940000          LDR      r0,[r4,#0]
00000c  e5d00001          LDRB     r0,[r0,#1]
000010  e3500000          CMP      r0,#0
000014  0a000017          BEQ      |L7.120|
;;;837         (msg->conn->state != NETCONN_LISTEN) &&
000018  e5940000          LDR      r0,[r4,#0]
00001c  e5d00001          LDRB     r0,[r0,#1]
000020  e3500002          CMP      r0,#2
000024  0a000013          BEQ      |L7.120|
;;;838         (msg->conn->state != NETCONN_CONNECT)) {
000028  e5940000          LDR      r0,[r4,#0]
00002c  e5d00001          LDRB     r0,[r0,#1]
000030  e3500003          CMP      r0,#3
000034  0a00000f          BEQ      |L7.120|
;;;839        /* this only happens for TCP netconns */
;;;840        LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
000038  e1a00000          MOV      r0,r0
00003c  e5940000          LDR      r0,[r4,#0]
000040  e5d00000          LDRB     r0,[r0,#0]
000044  e3500010          CMP      r0,#0x10
000048  0a000006          BEQ      |L7.104|
00004c  e1a00000          MOV      r0,r0
000050  e28f3f6d          ADR      r3,|L7.524|
000054  e3a02fd2          MOV      r2,#0x348
000058  e28f1f73          ADR      r1,|L7.556|
00005c  e28f0f7a          ADR      r0,|L7.588|
000060  ebfffffe          BL       sysprintf
000064  e1a00000          MOV      r0,r0
                  |L7.104|
000068  e1a00000          MOV      r0,r0
;;;841        msg->err = ERR_INPROGRESS;
00006c  e3a000fb          MOV      r0,#0xfb
000070  e5c40004          STRB     r0,[r4,#4]
000074  ea00005a          B        |L7.484|
                  |L7.120|
;;;842      } else {
;;;843        LWIP_ASSERT("blocking connect in progress",
000078  e1a00000          MOV      r0,r0
00007c  e5940000          LDR      r0,[r4,#0]
000080  e5d00001          LDRB     r0,[r0,#1]
000084  e3500003          CMP      r0,#3
000088  1a00000b          BNE      |L7.188|
00008c  e5940000          LDR      r0,[r4,#0]
000090  e5d0001c          LDRB     r0,[r0,#0x1c]
000094  e2000004          AND      r0,r0,#4
000098  e3500000          CMP      r0,#0
00009c  1a000006          BNE      |L7.188|
0000a0  e1a00000          MOV      r0,r0
0000a4  e28f3e16          ADR      r3,|L7.524|
0000a8  e59f21c4          LDR      r2,|L7.628|
0000ac  e28f1f71          ADR      r1,|L7.632|
0000b0  e28f0f65          ADR      r0,|L7.588|
0000b4  ebfffffe          BL       sysprintf
0000b8  e1a00000          MOV      r0,r0
                  |L7.188|
0000bc  e1a00000          MOV      r0,r0
;;;844          (msg->conn->state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
;;;845        /* Drain and delete mboxes */
;;;846        netconn_drain(msg->conn);
0000c0  e5940000          LDR      r0,[r4,#0]
0000c4  ebfffffe          BL       netconn_drain
;;;847    
;;;848        if (msg->conn->pcb.tcp != NULL) {
0000c8  e5940000          LDR      r0,[r4,#0]
0000cc  e5900004          LDR      r0,[r0,#4]
0000d0  e3500000          CMP      r0,#0
0000d4  0a000030          BEQ      |L7.412|
;;;849    
;;;850          switch (NETCONNTYPE_GROUP(msg->conn->type)) {
0000d8  e5940000          LDR      r0,[r4,#0]
0000dc  e5d00000          LDRB     r0,[r0,#0]
0000e0  e20000f0          AND      r0,r0,#0xf0
0000e4  e3500010          CMP      r0,#0x10
0000e8  0a000009          BEQ      |L7.276|
0000ec  e3500020          CMP      r0,#0x20
0000f0  1a000023          BNE      |L7.388|
;;;851    #if LWIP_RAW
;;;852          case NETCONN_RAW:
;;;853            raw_remove(msg->conn->pcb.raw);
;;;854            break;
;;;855    #endif /* LWIP_RAW */
;;;856    #if LWIP_UDP
;;;857          case NETCONN_UDP:
;;;858            msg->conn->pcb.udp->recv_arg = NULL;
0000f4  e3a00000          MOV      r0,#0
0000f8  e5941000          LDR      r1,[r4,#0]
0000fc  e5911004          LDR      r1,[r1,#4]
000100  e581001c          STR      r0,[r1,#0x1c]
;;;859            udp_remove(msg->conn->pcb.udp);
000104  e5941000          LDR      r1,[r4,#0]
000108  e5910004          LDR      r0,[r1,#4]
00010c  ebfffffe          BL       udp_remove
;;;860            break;
000110  ea00001d          B        |L7.396|
                  |L7.276|
;;;861    #endif /* LWIP_UDP */
;;;862    #if LWIP_TCP
;;;863          case NETCONN_TCP:
000114  e1a00000          MOV      r0,r0
;;;864            LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
000118  e1a00000          MOV      r0,r0
00011c  e5940000          LDR      r0,[r4,#0]
000120  e5900024          LDR      r0,[r0,#0x24]
000124  e3500000          CMP      r0,#0
000128  1a000003          BNE      |L7.316|
00012c  e5940000          LDR      r0,[r4,#0]
000130  e5900020          LDR      r0,[r0,#0x20]
000134  e3500000          CMP      r0,#0
000138  0a000006          BEQ      |L7.344|
                  |L7.316|
00013c  e1a00000          MOV      r0,r0
000140  e28f30c4          ADR      r3,|L7.524|
000144  e3a02e36          MOV      r2,#0x360
000148  e28f1f52          ADR      r1,|L7.664|
00014c  e28f00f8          ADR      r0,|L7.588|
000150  ebfffffe          BL       sysprintf
000154  e1a00000          MOV      r0,r0
                  |L7.344|
000158  e1a00000          MOV      r0,r0
;;;865              msg->conn->write_offset == 0);
;;;866            msg->conn->state = NETCONN_CLOSE;
00015c  e3a00004          MOV      r0,#4
000160  e5941000          LDR      r1,[r4,#0]
000164  e5c10001          STRB     r0,[r1,#1]
;;;867            msg->msg.sd.shut = NETCONN_SHUT_RDWR;
000168  e3a00003          MOV      r0,#3
00016c  e5c40008          STRB     r0,[r4,#8]
;;;868            msg->conn->current_msg = msg;
000170  e5940000          LDR      r0,[r4,#0]
000174  e5804024          STR      r4,[r0,#0x24]
;;;869            do_close_internal(msg->conn);
000178  e5940000          LDR      r0,[r4,#0]
00017c  ebfffffe          BL       do_close_internal
                  |L7.384|
;;;870            /* API_EVENT is called inside do_close_internal, before releasing
;;;871               the application thread, so we can return at this point! */
;;;872            return;
;;;873    #endif /* LWIP_TCP */
;;;874          default:
;;;875            break;
;;;876          }
;;;877          msg->conn->pcb.tcp = NULL;
;;;878        }
;;;879        /* tcp netconns don't come here! */
;;;880    
;;;881        /* @todo: this lets select make the socket readable and writable,
;;;882           which is wrong! errfd instead? */
;;;883        API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
;;;884        API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
;;;885      }
;;;886      if (sys_sem_valid(&msg->conn->op_completed)) {
;;;887        sys_sem_signal(&msg->conn->op_completed);
;;;888      }
;;;889    }
000180  e8bd8010          POP      {r4,pc}
                  |L7.388|
000184  e1a00000          MOV      r0,r0                 ;874
000188  e1a00000          MOV      r0,r0                 ;875
                  |L7.396|
00018c  e1a00000          MOV      r0,r0                 ;860
000190  e3a00000          MOV      r0,#0                 ;877
000194  e5941000          LDR      r1,[r4,#0]            ;877
000198  e5810004          STR      r0,[r1,#4]            ;877
                  |L7.412|
00019c  e5940000          LDR      r0,[r4,#0]            ;883
0001a0  e5900028          LDR      r0,[r0,#0x28]         ;883
0001a4  e3500000          CMP      r0,#0                 ;883
0001a8  0a000004          BEQ      |L7.448|
0001ac  e5940000          LDR      r0,[r4,#0]            ;883
0001b0  e3a02000          MOV      r2,#0                 ;883
0001b4  e1a01002          MOV      r1,r2                 ;883
0001b8  e5903028          LDR      r3,[r0,#0x28]         ;883
0001bc  e12fff33          BLX      r3                    ;883
                  |L7.448|
0001c0  e5940000          LDR      r0,[r4,#0]            ;884
0001c4  e5900028          LDR      r0,[r0,#0x28]         ;884
0001c8  e3500000          CMP      r0,#0                 ;884
0001cc  0a000004          BEQ      |L7.484|
0001d0  e5940000          LDR      r0,[r4,#0]            ;884
0001d4  e3a02000          MOV      r2,#0                 ;884
0001d8  e3a01002          MOV      r1,#2                 ;884
0001dc  e5903028          LDR      r3,[r0,#0x28]         ;884
0001e0  e12fff33          BLX      r3                    ;884
                  |L7.484|
0001e4  e5941000          LDR      r1,[r4,#0]            ;886
0001e8  e281000c          ADD      r0,r1,#0xc            ;886
0001ec  ebfffffe          BL       sys_sem_valid
0001f0  e3500000          CMP      r0,#0                 ;886
0001f4  0a000002          BEQ      |L7.516|
0001f8  e5941000          LDR      r1,[r4,#0]            ;887
0001fc  e281000c          ADD      r0,r1,#0xc            ;887
000200  ebfffffe          BL       sys_sem_signal
                  |L7.516|
000204  e1a00000          MOV      r0,r0
000208  eaffffdc          B        |L7.384|
                  |L7.524|
00020c  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
000210  2d312e34
000214  2e315c73
000218  72635c61
00021c  70695c61
000220  70695f6d
000224  73672e63
000228  00      
000229  00                DCB      0
00022a  00                DCB      0
00022b  00                DCB      0
                  |L7.556|
00022c  6d73672d          DCB      "msg->conn->type == NETCONN_TCP",0
000230  3e636f6e
000234  6e2d3e74
000238  79706520
00023c  3d3d204e
000240  4554434f
000244  4e4e5f54
000248  435000  
00024b  00                DCB      0
                  |L7.588|
00024c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000250  7274696f
000254  6e202225
000258  73222066
00025c  61696c65
000260  64206174
000264  206c696e
000268  65202564
00026c  20696e20
000270  25730a00
                  |L7.628|
                          DCD      0x0000034b
                  |L7.632|
000278  626c6f63          DCB      "blocking connect in progress",0
00027c  6b696e67
000280  20636f6e
000284  6e656374
000288  20696e20
00028c  70726f67
000290  72657373
000294  00      
000295  00                DCB      0
000296  00                DCB      0
000297  00                DCB      0
                  |L7.664|
000298  616c7265          DCB      "already writing or closing",0
00029c  61647920
0002a0  77726974
0002a4  696e6720
0002a8  6f722063
0002ac  6c6f7369
0002b0  6e6700  
0002b3  00                DCB      0
                          ENDP


                          AREA ||i.do_disconnect||, CODE, READONLY, ALIGN=2

                  do_disconnect PROC
;;;1042   void
;;;1043   do_disconnect(struct api_msg_msg *msg)
000000  e92d4010          PUSH     {r4,lr}
;;;1044   {
000004  e1a04000          MOV      r4,r0
;;;1045   #if LWIP_UDP
;;;1046     if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
000008  e5940000          LDR      r0,[r4,#0]
00000c  e5d00000          LDRB     r0,[r0,#0]
000010  e20000f0          AND      r0,r0,#0xf0
000014  e3500020          CMP      r0,#0x20
000018  1a000005          BNE      |L8.52|
;;;1047       udp_disconnect(msg->conn->pcb.udp);
00001c  e5941000          LDR      r1,[r4,#0]
000020  e5910004          LDR      r0,[r1,#4]
000024  ebfffffe          BL       udp_disconnect
;;;1048       msg->err = ERR_OK;
000028  e3a00000          MOV      r0,#0
00002c  e5c40004          STRB     r0,[r4,#4]
000030  ea000001          B        |L8.60|
                  |L8.52|
;;;1049     } else
;;;1050   #endif /* LWIP_UDP */
;;;1051     {
;;;1052       msg->err = ERR_VAL;
000034  e3a000fa          MOV      r0,#0xfa
000038  e5c40004          STRB     r0,[r4,#4]
                  |L8.60|
;;;1053     }
;;;1054     TCPIP_APIMSG_ACK(msg);
00003c  e5941000          LDR      r1,[r4,#0]
000040  e281000c          ADD      r0,r1,#0xc
000044  ebfffffe          BL       sys_sem_signal
;;;1055   }
000048  e8bd8010          POP      {r4,pc}
;;;1056   
                          ENDP


                          AREA ||i.do_getaddr||, CODE, READONLY, ALIGN=2

                  do_getaddr PROC
;;;1398   void
;;;1399   do_getaddr(struct api_msg_msg *msg)
000000  e92d4010          PUSH     {r4,lr}
;;;1400   {
000004  e1a04000          MOV      r4,r0
;;;1401     if (msg->conn->pcb.ip != NULL) {
000008  e5940000          LDR      r0,[r4,#0]
00000c  e5900004          LDR      r0,[r0,#4]
000010  e3500000          CMP      r0,#0
000014  0a000048          BEQ      |L9.316|
;;;1402       *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
000018  e5d40010          LDRB     r0,[r4,#0x10]
00001c  e3500000          CMP      r0,#0
000020  0a000005          BEQ      |L9.60|
000024  e5940008          LDR      r0,[r4,#8]
000028  e5941000          LDR      r1,[r4,#0]
00002c  e5911004          LDR      r1,[r1,#4]
000030  e5911000          LDR      r1,[r1,#0]
000034  e5801000          STR      r1,[r0,#0]
000038  ea000004          B        |L9.80|
                  |L9.60|
00003c  e5940008          LDR      r0,[r4,#8]
000040  e5941000          LDR      r1,[r4,#0]
000044  e5911004          LDR      r1,[r1,#4]
000048  e5911004          LDR      r1,[r1,#4]
00004c  e5801000          STR      r1,[r0,#0]
                  |L9.80|
;;;1403                                msg->conn->pcb.ip->remote_ip);
;;;1404   
;;;1405       msg->err = ERR_OK;
000050  e3a00000          MOV      r0,#0
000054  e5c40004          STRB     r0,[r4,#4]
;;;1406       switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000058  e5940000          LDR      r0,[r4,#0]
00005c  e5d00000          LDRB     r0,[r0,#0]
000060  e20000f0          AND      r0,r0,#0xf0
000064  e3500010          CMP      r0,#0x10
000068  0a000019          BEQ      |L9.212|
00006c  e3500020          CMP      r0,#0x20
000070  1a000025          BNE      |L9.268|
;;;1407   #if LWIP_RAW
;;;1408       case NETCONN_RAW:
;;;1409         if (msg->msg.ad.local) {
;;;1410           *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
;;;1411         } else {
;;;1412           /* return an error as connecting is only a helper for upper layers */
;;;1413           msg->err = ERR_CONN;
;;;1414         }
;;;1415         break;
;;;1416   #endif /* LWIP_RAW */
;;;1417   #if LWIP_UDP
;;;1418       case NETCONN_UDP:
;;;1419         if (msg->msg.ad.local) {
000074  e5d40010          LDRB     r0,[r4,#0x10]
000078  e3500000          CMP      r0,#0
00007c  0a000005          BEQ      |L9.152|
;;;1420           *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
000080  e5940000          LDR      r0,[r4,#0]
000084  e5900004          LDR      r0,[r0,#4]
000088  e1d001b2          LDRH     r0,[r0,#0x12]
00008c  e594100c          LDR      r1,[r4,#0xc]
000090  e1c100b0          STRH     r0,[r1,#0]
000094  ea00000d          B        |L9.208|
                  |L9.152|
;;;1421         } else {
;;;1422           if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
000098  e5940000          LDR      r0,[r4,#0]
00009c  e5900004          LDR      r0,[r0,#4]
0000a0  e5d00010          LDRB     r0,[r0,#0x10]
0000a4  e2000004          AND      r0,r0,#4
0000a8  e3500000          CMP      r0,#0
0000ac  1a000002          BNE      |L9.188|
;;;1423             msg->err = ERR_CONN;
0000b0  e3a000f3          MOV      r0,#0xf3
0000b4  e5c40004          STRB     r0,[r4,#4]
0000b8  ea000004          B        |L9.208|
                  |L9.188|
;;;1424           } else {
;;;1425             *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
0000bc  e5940000          LDR      r0,[r4,#0]
0000c0  e5900004          LDR      r0,[r0,#4]
0000c4  e1d001b4          LDRH     r0,[r0,#0x14]
0000c8  e594100c          LDR      r1,[r4,#0xc]
0000cc  e1c100b0          STRH     r0,[r1,#0]
                  |L9.208|
;;;1426           }
;;;1427         }
;;;1428         break;
0000d0  ea000018          B        |L9.312|
                  |L9.212|
;;;1429   #endif /* LWIP_UDP */
;;;1430   #if LWIP_TCP
;;;1431       case NETCONN_TCP:
0000d4  e1a00000          MOV      r0,r0
;;;1432         *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
0000d8  e5d40010          LDRB     r0,[r4,#0x10]
0000dc  e3500000          CMP      r0,#0
0000e0  0a000003          BEQ      |L9.244|
0000e4  e5940000          LDR      r0,[r4,#0]
0000e8  e5900004          LDR      r0,[r0,#4]
0000ec  e1d001ba          LDRH     r0,[r0,#0x1a]
0000f0  ea000002          B        |L9.256|
                  |L9.244|
0000f4  e5940000          LDR      r0,[r4,#0]
0000f8  e5900004          LDR      r0,[r0,#4]
0000fc  e1d001bc          LDRH     r0,[r0,#0x1c]
                  |L9.256|
000100  e594100c          LDR      r1,[r4,#0xc]
000104  e1c100b0          STRH     r0,[r1,#0]
;;;1433         break;
000108  ea00000a          B        |L9.312|
                  |L9.268|
;;;1434   #endif /* LWIP_TCP */
;;;1435       default:
00010c  e1a00000          MOV      r0,r0
;;;1436         LWIP_ASSERT("invalid netconn_type", 0);
000110  e1a00000          MOV      r0,r0
000114  e1a00000          MOV      r0,r0
000118  e28f3034          ADR      r3,|L9.340|
00011c  e59f2050          LDR      r2,|L9.372|
000120  e28f1050          ADR      r1,|L9.376|
000124  e28f0064          ADR      r0,|L9.400|
000128  ebfffffe          BL       sysprintf
00012c  e1a00000          MOV      r0,r0
000130  e1a00000          MOV      r0,r0
;;;1437         break;
000134  e1a00000          MOV      r0,r0
                  |L9.312|
000138  ea000001          B        |L9.324|
                  |L9.316|
;;;1438       }
;;;1439     } else {
;;;1440       msg->err = ERR_CONN;
00013c  e3a000f3          MOV      r0,#0xf3
000140  e5c40004          STRB     r0,[r4,#4]
                  |L9.324|
;;;1441     }
;;;1442     TCPIP_APIMSG_ACK(msg);
000144  e5941000          LDR      r1,[r4,#0]
000148  e281000c          ADD      r0,r1,#0xc
00014c  ebfffffe          BL       sys_sem_signal
;;;1443   }
000150  e8bd8010          POP      {r4,pc}
;;;1444   
                          ENDP

                  |L9.340|
000154  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
000158  2d312e34
00015c  2e315c73
000160  72635c61
000164  70695c61
000168  70695f6d
00016c  73672e63
000170  00      
000171  00                DCB      0
000172  00                DCB      0
000173  00                DCB      0
                  |L9.372|
                          DCD      0x0000059c
                  |L9.376|
000178  696e7661          DCB      "invalid netconn_type",0
00017c  6c696420
000180  6e657463
000184  6f6e6e5f
000188  74797065
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L9.400|
000190  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000194  7274696f
000198  6e202225
00019c  73222066
0001a0  61696c65
0001a4  64206174
0001a8  206c696e
0001ac  65202564
0001b0  20696e20
0001b4  25730a00

                          AREA ||i.do_listen||, CODE, READONLY, ALIGN=2

                  do_listen PROC
;;;1064   void
;;;1065   do_listen(struct api_msg_msg *msg)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1066   {
000004  e1a04000          MOV      r4,r0
;;;1067     if (ERR_IS_FATAL(msg->conn->last_err)) {
000008  e5940000          LDR      r0,[r4,#0]
00000c  e1d000d8          LDRSB    r0,[r0,#8]
000010  e3700009          CMN      r0,#9
000014  aa000003          BGE      |L10.40|
;;;1068       msg->err = msg->conn->last_err;
000018  e5940000          LDR      r0,[r4,#0]
00001c  e5d00008          LDRB     r0,[r0,#8]
000020  e5c40004          STRB     r0,[r4,#4]
000024  ea000046          B        |L10.324|
                  |L10.40|
;;;1069     } else {
;;;1070       msg->err = ERR_CONN;
000028  e3a000f3          MOV      r0,#0xf3
00002c  e5c40004          STRB     r0,[r4,#4]
;;;1071       if (msg->conn->pcb.tcp != NULL) {
000030  e5940000          LDR      r0,[r4,#0]
000034  e5900004          LDR      r0,[r0,#4]
000038  e3500000          CMP      r0,#0
00003c  0a000040          BEQ      |L10.324|
;;;1072         if (msg->conn->type == NETCONN_TCP) {
000040  e5940000          LDR      r0,[r4,#0]
000044  e5d00000          LDRB     r0,[r0,#0]
000048  e3500010          CMP      r0,#0x10
00004c  1a00003a          BNE      |L10.316|
;;;1073           if (msg->conn->state == NETCONN_NONE) {
000050  e5940000          LDR      r0,[r4,#0]
000054  e5d00001          LDRB     r0,[r0,#1]
000058  e3500000          CMP      r0,#0
00005c  1a000038          BNE      |L10.324|
;;;1074   #if TCP_LISTEN_BACKLOG
;;;1075             struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
;;;1076   #else  /* TCP_LISTEN_BACKLOG */
;;;1077             struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
000060  e5941000          LDR      r1,[r4,#0]
000064  e5910004          LDR      r0,[r1,#4]
000068  e3a010ff          MOV      r1,#0xff
00006c  ebfffffe          BL       tcp_listen_with_backlog
000070  e1a05000          MOV      r5,r0
;;;1078   #endif /* TCP_LISTEN_BACKLOG */
;;;1079             if (lpcb == NULL) {
000074  e3550000          CMP      r5,#0
000078  1a000002          BNE      |L10.136|
;;;1080               /* in this case, the old pcb is still allocated */
;;;1081               msg->err = ERR_MEM;
00007c  e3a000ff          MOV      r0,#0xff
000080  e5c40004          STRB     r0,[r4,#4]
000084  ea00002b          B        |L10.312|
                  |L10.136|
;;;1082             } else {
;;;1083               /* delete the recvmbox and allocate the acceptmbox */
;;;1084               if (sys_mbox_valid(&msg->conn->recvmbox)) {
000088  e5941000          LDR      r1,[r4,#0]
00008c  e2810010          ADD      r0,r1,#0x10
000090  ebfffffe          BL       sys_mbox_valid
000094  e3500000          CMP      r0,#0
000098  0a000005          BEQ      |L10.180|
;;;1085                 /** @todo: should we drain the recvmbox here? */
;;;1086                 sys_mbox_free(&msg->conn->recvmbox);
00009c  e5941000          LDR      r1,[r4,#0]
0000a0  e2810010          ADD      r0,r1,#0x10
0000a4  ebfffffe          BL       sys_mbox_free
;;;1087                 sys_mbox_set_invalid(&msg->conn->recvmbox);
0000a8  e5941000          LDR      r1,[r4,#0]
0000ac  e2810010          ADD      r0,r1,#0x10
0000b0  ebfffffe          BL       sys_mbox_set_invalid
                  |L10.180|
;;;1088               }
;;;1089               msg->err = ERR_OK;
0000b4  e3a00000          MOV      r0,#0
0000b8  e5c40004          STRB     r0,[r4,#4]
;;;1090               if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
0000bc  e5941000          LDR      r1,[r4,#0]
0000c0  e2810014          ADD      r0,r1,#0x14
0000c4  ebfffffe          BL       sys_mbox_valid
0000c8  e3500000          CMP      r0,#0
0000cc  1a000004          BNE      |L10.228|
;;;1091                 msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
0000d0  e5941000          LDR      r1,[r4,#0]
0000d4  e2810014          ADD      r0,r1,#0x14
0000d8  e3a01080          MOV      r1,#0x80
0000dc  ebfffffe          BL       sys_mbox_new
0000e0  e5c40004          STRB     r0,[r4,#4]
                  |L10.228|
;;;1092               }
;;;1093               if (msg->err == ERR_OK) {
0000e4  e5d40004          LDRB     r0,[r4,#4]
0000e8  e3500000          CMP      r0,#0
0000ec  1a00000c          BNE      |L10.292|
;;;1094                 msg->conn->state = NETCONN_LISTEN;
0000f0  e3a00002          MOV      r0,#2
0000f4  e5941000          LDR      r1,[r4,#0]
0000f8  e5c10001          STRB     r0,[r1,#1]
;;;1095                 msg->conn->pcb.tcp = lpcb;
0000fc  e5940000          LDR      r0,[r4,#0]
000100  e5805004          STR      r5,[r0,#4]
;;;1096                 tcp_arg(msg->conn->pcb.tcp, msg->conn);
000104  e5941000          LDR      r1,[r4,#0]
000108  e5910004          LDR      r0,[r1,#4]
00010c  ebfffffe          BL       tcp_arg
;;;1097                 tcp_accept(msg->conn->pcb.tcp, accept_function);
000110  e5941000          LDR      r1,[r4,#0]
000114  e5910004          LDR      r0,[r1,#4]
000118  e59f1034          LDR      r1,|L10.340|
00011c  ebfffffe          BL       tcp_accept
000120  ea000004          B        |L10.312|
                  |L10.292|
;;;1098               } else {
;;;1099                 /* since the old pcb is already deallocated, free lpcb now */
;;;1100                 tcp_close(lpcb);
000124  e1a00005          MOV      r0,r5
000128  ebfffffe          BL       tcp_close
;;;1101                 msg->conn->pcb.tcp = NULL;
00012c  e3a00000          MOV      r0,#0
000130  e5941000          LDR      r1,[r4,#0]
000134  e5810004          STR      r0,[r1,#4]
                  |L10.312|
;;;1102               }
;;;1103             }
;;;1104           }
000138  ea000001          B        |L10.324|
                  |L10.316|
;;;1105         } else {
;;;1106           msg->err = ERR_ARG;
00013c  e3a000f2          MOV      r0,#0xf2
000140  e5c40004          STRB     r0,[r4,#4]
                  |L10.324|
;;;1107         }
;;;1108       }
;;;1109     }
;;;1110     TCPIP_APIMSG_ACK(msg);
000144  e5941000          LDR      r1,[r4,#0]
000148  e281000c          ADD      r0,r1,#0xc
00014c  ebfffffe          BL       sys_sem_signal
;;;1111   }
000150  e8bd8070          POP      {r4-r6,pc}
;;;1112   #endif /* LWIP_TCP */
                          ENDP

                  |L10.340|
                          DCD      accept_function

                          AREA ||i.do_newconn||, CODE, READONLY, ALIGN=2

                  do_newconn PROC
;;;547    void
;;;548    do_newconn(struct api_msg_msg *msg)
000000  e92d4010          PUSH     {r4,lr}
;;;549    {
000004  e1a04000          MOV      r4,r0
;;;550      msg->err = ERR_OK;
000008  e3a00000          MOV      r0,#0
00000c  e5c40004          STRB     r0,[r4,#4]
;;;551      if(msg->conn->pcb.tcp == NULL) {
000010  e5940000          LDR      r0,[r4,#0]
000014  e5900004          LDR      r0,[r0,#4]
000018  e3500000          CMP      r0,#0
00001c  1a000001          BNE      |L11.40|
;;;552        pcb_new(msg);
000020  e1a00004          MOV      r0,r4
000024  ebfffffe          BL       pcb_new
                  |L11.40|
;;;553      }
;;;554      /* Else? This "new" connection already has a PCB allocated. */
;;;555      /* Is this an error condition? Should it be deleted? */
;;;556      /* We currently just are happy and return. */
;;;557    
;;;558      TCPIP_APIMSG_ACK(msg);
000028  e5941000          LDR      r1,[r4,#0]
00002c  e281000c          ADD      r0,r1,#0xc
000030  ebfffffe          BL       sys_sem_signal
;;;559    }
000034  e8bd8010          POP      {r4,pc}
;;;560    
                          ENDP


                          AREA ||i.do_recv||, CODE, READONLY, ALIGN=2

                  do_recv PROC
;;;1173   void
;;;1174   do_recv(struct api_msg_msg *msg)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1175   {
000004  e1a04000          MOV      r4,r0
;;;1176     msg->err = ERR_OK;
000008  e3a00000          MOV      r0,#0
00000c  e5c40004          STRB     r0,[r4,#4]
;;;1177     if (msg->conn->pcb.tcp != NULL) {
000010  e5940000          LDR      r0,[r4,#0]
000014  e5900004          LDR      r0,[r0,#4]
000018  e3500000          CMP      r0,#0
00001c  0a000014          BEQ      |L12.116|
;;;1178       if (msg->conn->type == NETCONN_TCP) {
000020  e5940000          LDR      r0,[r4,#0]
000024  e5d00000          LDRB     r0,[r0,#0]
000028  e3500010          CMP      r0,#0x10
00002c  1a000010          BNE      |L12.116|
;;;1179   #if TCP_LISTEN_BACKLOG
;;;1180         if (msg->conn->pcb.tcp->state == LISTEN) {
;;;1181           tcp_accepted(msg->conn->pcb.tcp);
;;;1182         } else
;;;1183   #endif /* TCP_LISTEN_BACKLOG */
;;;1184         {
;;;1185           u32_t remaining = msg->msg.r.len;
000030  e5945008          LDR      r5,[r4,#8]
;;;1186           do {
000034  e1a00000          MOV      r0,r0
                  |L12.56|
;;;1187             u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
000038  e3550801          CMP      r5,#0x10000
00003c  3a000001          BCC      |L12.72|
000040  e59f003c          LDR      r0,|L12.132|
000044  ea000001          B        |L12.80|
                  |L12.72|
000048  e1a00805          LSL      r0,r5,#16
00004c  e1a00820          LSR      r0,r0,#16
                  |L12.80|
000050  e1a06000          MOV      r6,r0
;;;1188             tcp_recved(msg->conn->pcb.tcp, recved);
000054  e5941000          LDR      r1,[r4,#0]
000058  e5910004          LDR      r0,[r1,#4]
00005c  e1a01006          MOV      r1,r6
000060  ebfffffe          BL       tcp_recved
;;;1189             remaining -= recved;
000064  e0455006          SUB      r5,r5,r6
;;;1190           }while(remaining != 0);
000068  e3550000          CMP      r5,#0
00006c  1afffff1          BNE      |L12.56|
;;;1191         }
000070  e1a00000          MOV      r0,r0
                  |L12.116|
;;;1192       }
;;;1193     }
;;;1194     TCPIP_APIMSG_ACK(msg);
000074  e5941000          LDR      r1,[r4,#0]
000078  e281000c          ADD      r0,r1,#0xc
00007c  ebfffffe          BL       sys_sem_signal
;;;1195   }
000080  e8bd8070          POP      {r4-r6,pc}
;;;1196   
                          ENDP

                  |L12.132|
                          DCD      0x0000ffff

                          AREA ||i.do_send||, CODE, READONLY, ALIGN=2

                  do_send PROC
;;;1120   void
;;;1121   do_send(struct api_msg_msg *msg)
000000  e92d4010          PUSH     {r4,lr}
;;;1122   {
000004  e1a04000          MOV      r4,r0
;;;1123     if (ERR_IS_FATAL(msg->conn->last_err)) {
000008  e5940000          LDR      r0,[r4,#0]
00000c  e1d000d8          LDRSB    r0,[r0,#8]
000010  e3700009          CMN      r0,#9
000014  aa000003          BGE      |L13.40|
;;;1124       msg->err = msg->conn->last_err;
000018  e5940000          LDR      r0,[r4,#0]
00001c  e5d00008          LDRB     r0,[r0,#8]
000020  e5c40004          STRB     r0,[r4,#4]
000024  ea000025          B        |L13.192|
                  |L13.40|
;;;1125     } else {
;;;1126       msg->err = ERR_CONN;
000028  e3a000f3          MOV      r0,#0xf3
00002c  e5c40004          STRB     r0,[r4,#4]
;;;1127       if (msg->conn->pcb.tcp != NULL) {
000030  e5940000          LDR      r0,[r4,#0]
000034  e5900004          LDR      r0,[r0,#4]
000038  e3500000          CMP      r0,#0
00003c  0a00001f          BEQ      |L13.192|
;;;1128         switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000040  e5940000          LDR      r0,[r4,#0]
000044  e5d00000          LDRB     r0,[r0,#0]
000048  e20000f0          AND      r0,r0,#0xf0
00004c  e3500020          CMP      r0,#0x20
000050  1a000017          BNE      |L13.180|
;;;1129   #if LWIP_RAW
;;;1130         case NETCONN_RAW:
;;;1131           if (ip_addr_isany(&msg->msg.b->addr)) {
;;;1132             msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
;;;1133           } else {
;;;1134             msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
;;;1135           }
;;;1136           break;
;;;1137   #endif
;;;1138   #if LWIP_UDP
;;;1139         case NETCONN_UDP:
;;;1140   #if LWIP_CHECKSUM_ON_COPY
;;;1141           if (ip_addr_isany(&msg->msg.b->addr)) {
;;;1142             msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
;;;1143               msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
;;;1144           } else {
;;;1145             msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
;;;1146               &msg->msg.b->addr, msg->msg.b->port,
;;;1147               msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
;;;1148           }
;;;1149   #else /* LWIP_CHECKSUM_ON_COPY */
;;;1150           if (ip_addr_isany(&msg->msg.b->addr)) {
000054  e5940008          LDR      r0,[r4,#8]
000058  e2800008          ADD      r0,r0,#8
00005c  e3500000          CMP      r0,#0
000060  0a000003          BEQ      |L13.116|
000064  e5940008          LDR      r0,[r4,#8]
000068  e5900008          LDR      r0,[r0,#8]
00006c  e3500000          CMP      r0,#0
000070  1a000006          BNE      |L13.144|
                  |L13.116|
;;;1151             msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
000074  e5942008          LDR      r2,[r4,#8]
000078  e5921000          LDR      r1,[r2,#0]
00007c  e5942000          LDR      r2,[r4,#0]
000080  e5920004          LDR      r0,[r2,#4]
000084  ebfffffe          BL       udp_send
000088  e5c40004          STRB     r0,[r4,#4]
00008c  ea000007          B        |L13.176|
                  |L13.144|
;;;1152           } else {
;;;1153             msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
000090  e594c008          LDR      r12,[r4,#8]
000094  e1dc30bc          LDRH     r3,[r12,#0xc]
000098  e28c2008          ADD      r2,r12,#8
00009c  e59c1000          LDR      r1,[r12,#0]
0000a0  e594c000          LDR      r12,[r4,#0]
0000a4  e59c0004          LDR      r0,[r12,#4]
0000a8  ebfffffe          BL       udp_sendto
0000ac  e5c40004          STRB     r0,[r4,#4]
                  |L13.176|
;;;1154           }
;;;1155   #endif /* LWIP_CHECKSUM_ON_COPY */
;;;1156           break;
0000b0  ea000001          B        |L13.188|
                  |L13.180|
;;;1157   #endif /* LWIP_UDP */
;;;1158         default:
0000b4  e1a00000          MOV      r0,r0
;;;1159           break;
0000b8  e1a00000          MOV      r0,r0
                  |L13.188|
0000bc  e1a00000          MOV      r0,r0                 ;1156
                  |L13.192|
;;;1160         }
;;;1161       }
;;;1162     }
;;;1163     TCPIP_APIMSG_ACK(msg);
0000c0  e5941000          LDR      r1,[r4,#0]
0000c4  e281000c          ADD      r0,r1,#0xc
0000c8  ebfffffe          BL       sys_sem_signal
;;;1164   }
0000cc  e8bd8010          POP      {r4,pc}
;;;1165   
                          ENDP


                          AREA ||i.do_write||, CODE, READONLY, ALIGN=2

                  do_write PROC
;;;1343   void
;;;1344   do_write(struct api_msg_msg *msg)
000000  e92d4010          PUSH     {r4,lr}
;;;1345   {
000004  e1a04000          MOV      r4,r0
;;;1346     if (ERR_IS_FATAL(msg->conn->last_err)) {
000008  e5940000          LDR      r0,[r4,#0]
00000c  e1d000d8          LDRSB    r0,[r0,#8]
000010  e3700009          CMN      r0,#9
000014  aa000003          BGE      |L14.40|
;;;1347       msg->err = msg->conn->last_err;
000018  e5940000          LDR      r0,[r4,#0]
00001c  e5d00008          LDRB     r0,[r0,#8]
000020  e5c40004          STRB     r0,[r4,#4]
000024  ea00003b          B        |L14.280|
                  |L14.40|
;;;1348     } else {
;;;1349       if (msg->conn->type == NETCONN_TCP) {
000028  e5940000          LDR      r0,[r4,#0]
00002c  e5d00000          LDRB     r0,[r0,#0]
000030  e3500010          CMP      r0,#0x10
000034  1a000035          BNE      |L14.272|
;;;1350   #if LWIP_TCP
;;;1351         if (msg->conn->state != NETCONN_NONE) {
000038  e5940000          LDR      r0,[r4,#0]
00003c  e5d00001          LDRB     r0,[r0,#1]
000040  e3500000          CMP      r0,#0
000044  0a000002          BEQ      |L14.84|
;;;1352           /* netconn is connecting, closing or in blocking write */
;;;1353           msg->err = ERR_INPROGRESS;
000048  e3a000fb          MOV      r0,#0xfb
00004c  e5c40004          STRB     r0,[r4,#4]
000050  ea000030          B        |L14.280|
                  |L14.84|
;;;1354         } else if (msg->conn->pcb.tcp != NULL) {
000054  e5940000          LDR      r0,[r4,#0]
000058  e5900004          LDR      r0,[r0,#4]
00005c  e3500000          CMP      r0,#0
000060  0a000027          BEQ      |L14.260|
;;;1355           msg->conn->state = NETCONN_WRITE;
000064  e3a00001          MOV      r0,#1
000068  e5941000          LDR      r1,[r4,#0]
00006c  e5c10001          STRB     r0,[r1,#1]
;;;1356           /* set all the variables used by do_writemore */
;;;1357           LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
000070  e1a00000          MOV      r0,r0
000074  e5940000          LDR      r0,[r4,#0]
000078  e5900024          LDR      r0,[r0,#0x24]
00007c  e3500000          CMP      r0,#0
000080  1a000003          BNE      |L14.148|
000084  e5940000          LDR      r0,[r4,#0]
000088  e5900020          LDR      r0,[r0,#0x20]
00008c  e3500000          CMP      r0,#0
000090  0a000006          BEQ      |L14.176|
                  |L14.148|
000094  e1a00000          MOV      r0,r0
000098  e28f308c          ADR      r3,|L14.300|
00009c  e59f20a8          LDR      r2,|L14.332|
0000a0  e28f10a8          ADR      r1,|L14.336|
0000a4  e28f00c0          ADR      r0,|L14.364|
0000a8  ebfffffe          BL       sysprintf
0000ac  e1a00000          MOV      r0,r0
                  |L14.176|
0000b0  e1a00000          MOV      r0,r0
;;;1358             msg->conn->write_offset == 0);
;;;1359           LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
0000b4  e1a00000          MOV      r0,r0
0000b8  e594000c          LDR      r0,[r4,#0xc]
0000bc  e3500000          CMP      r0,#0
0000c0  1a000006          BNE      |L14.224|
0000c4  e1a00000          MOV      r0,r0
0000c8  e28f305c          ADR      r3,|L14.300|
0000cc  e59f20c0          LDR      r2,|L14.404|
0000d0  e28f10c0          ADR      r1,|L14.408|
0000d4  e28f0090          ADR      r0,|L14.364|
0000d8  ebfffffe          BL       sysprintf
0000dc  e1a00000          MOV      r0,r0
                  |L14.224|
0000e0  e1a00000          MOV      r0,r0
;;;1360           msg->conn->current_msg = msg;
0000e4  e5940000          LDR      r0,[r4,#0]
0000e8  e5804024          STR      r4,[r0,#0x24]
;;;1361           msg->conn->write_offset = 0;
0000ec  e3a00000          MOV      r0,#0
0000f0  e5941000          LDR      r1,[r4,#0]
0000f4  e5810020          STR      r0,[r1,#0x20]
;;;1362   #if LWIP_TCPIP_CORE_LOCKING
;;;1363           msg->conn->flags &= ~NETCONN_FLAG_WRITE_DELAYED;
;;;1364           if (do_writemore(msg->conn) != ERR_OK) {
;;;1365             LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
;;;1366             UNLOCK_TCPIP_CORE();
;;;1367             sys_arch_sem_wait(&msg->conn->op_completed, 0);
;;;1368             LOCK_TCPIP_CORE();
;;;1369             LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
;;;1370           }
;;;1371   #else /* LWIP_TCPIP_CORE_LOCKING */
;;;1372           do_writemore(msg->conn);
0000f8  e5940000          LDR      r0,[r4,#0]
0000fc  ebfffffe          BL       do_writemore
                  |L14.256|
;;;1373   #endif /* LWIP_TCPIP_CORE_LOCKING */
;;;1374           /* for both cases: if do_writemore was called, don't ACK the APIMSG
;;;1375              since do_writemore ACKs it! */
;;;1376           return;
;;;1377         } else {
;;;1378           msg->err = ERR_CONN;
;;;1379         }
;;;1380   #else /* LWIP_TCP */
;;;1381         msg->err = ERR_VAL;
;;;1382   #endif /* LWIP_TCP */
;;;1383   #if (LWIP_UDP || LWIP_RAW)
;;;1384       } else {
;;;1385         msg->err = ERR_VAL;
;;;1386   #endif /* (LWIP_UDP || LWIP_RAW) */
;;;1387       }
;;;1388     }
;;;1389     TCPIP_APIMSG_ACK(msg);
;;;1390   }
000100  e8bd8010          POP      {r4,pc}
                  |L14.260|
000104  e3a000f3          MOV      r0,#0xf3              ;1378
000108  e5c40004          STRB     r0,[r4,#4]            ;1378
00010c  ea000001          B        |L14.280|
                  |L14.272|
000110  e3a000fa          MOV      r0,#0xfa              ;1385
000114  e5c40004          STRB     r0,[r4,#4]            ;1385
                  |L14.280|
000118  e5941000          LDR      r1,[r4,#0]            ;1389
00011c  e281000c          ADD      r0,r1,#0xc            ;1389
000120  ebfffffe          BL       sys_sem_signal
000124  e1a00000          MOV      r0,r0
000128  eafffff4          B        |L14.256|
;;;1391   
                          ENDP

                  |L14.300|
00012c  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
000130  2d312e34
000134  2e315c73
000138  72635c61
00013c  70695c61
000140  70695f6d
000144  73672e63
000148  00      
000149  00                DCB      0
00014a  00                DCB      0
00014b  00                DCB      0
                  |L14.332|
                          DCD      0x0000054d
                  |L14.336|
000150  616c7265          DCB      "already writing or closing",0
000154  61647920
000158  77726974
00015c  696e6720
000160  6f722063
000164  6c6f7369
000168  6e6700  
00016b  00                DCB      0
                  |L14.364|
00016c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000170  7274696f
000174  6e202225
000178  73222066
00017c  61696c65
000180  64206174
000184  206c696e
000188  65202564
00018c  20696e20
000190  25730a00
                  |L14.404|
                          DCD      0x0000054f
                  |L14.408|
000198  6d73672d          DCB      "msg->msg.w.len != 0",0
00019c  3e6d7367
0001a0  2e772e6c
0001a4  656e2021
0001a8  3d203000

                          AREA ||i.do_writemore||, CODE, READONLY, ALIGN=2

                  do_writemore PROC
;;;1208   static err_t
;;;1209   do_writemore(struct netconn *conn)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1210   {
000004  e1a04000          MOV      r4,r0
;;;1211     err_t err;
;;;1212     void *dataptr;
;;;1213     u16_t len, available;
;;;1214     u8_t write_finished = 0;
000008  e3a00000          MOV      r0,#0
00000c  e58d0000          STR      r0,[sp,#0]
;;;1215     size_t diff;
;;;1216     u8_t dontblock = netconn_is_nonblocking(conn) ||
000010  e5d4001c          LDRB     r0,[r4,#0x1c]
000014  e2000002          AND      r0,r0,#2
000018  e3500000          CMP      r0,#0
00001c  1a000004          BNE      |L15.52|
;;;1217          (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
000020  e5940024          LDR      r0,[r4,#0x24]
000024  e5d00010          LDRB     r0,[r0,#0x10]
000028  e2000004          AND      r0,r0,#4
00002c  e3500000          CMP      r0,#0
000030  0a000001          BEQ      |L15.60|
                  |L15.52|
000034  e3a00001          MOV      r0,#1
000038  ea000000          B        |L15.64|
                  |L15.60|
00003c  e3a00000          MOV      r0,#0
                  |L15.64|
000040  e1a07000          MOV      r7,r0
;;;1218     u8_t apiflags = conn->current_msg->msg.w.apiflags;
000044  e5940024          LDR      r0,[r4,#0x24]
000048  e5d08010          LDRB     r8,[r0,#0x10]
;;;1219   
;;;1220     LWIP_ASSERT("conn != NULL", conn != NULL);
00004c  e1a00000          MOV      r0,r0
000050  e3540000          CMP      r4,#0
000054  1a000006          BNE      |L15.116|
000058  e1a00000          MOV      r0,r0
00005c  e28f3f7e          ADR      r3,|L15.604|
000060  e59f2214          LDR      r2,|L15.636|
000064  e28f1f85          ADR      r1,|L15.640|
000068  e28f0e22          ADR      r0,|L15.656|
00006c  ebfffffe          BL       sysprintf
000070  e1a00000          MOV      r0,r0
                  |L15.116|
000074  e1a00000          MOV      r0,r0
;;;1221     LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
000078  e1a00000          MOV      r0,r0
00007c  e5d40001          LDRB     r0,[r4,#1]
000080  e3500001          CMP      r0,#1
000084  0a000006          BEQ      |L15.164|
000088  e1a00000          MOV      r0,r0
00008c  e28f3f72          ADR      r3,|L15.604|
000090  e59f2220          LDR      r2,|L15.696|
000094  e28f1e22          ADR      r1,|L15.700|
000098  e28f0e1f          ADR      r0,|L15.656|
00009c  ebfffffe          BL       sysprintf
0000a0  e1a00000          MOV      r0,r0
                  |L15.164|
0000a4  e1a00000          MOV      r0,r0
;;;1222     LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
0000a8  e1a00000          MOV      r0,r0
0000ac  e5940024          LDR      r0,[r4,#0x24]
0000b0  e3500000          CMP      r0,#0
0000b4  1a000006          BNE      |L15.212|
0000b8  e1a00000          MOV      r0,r0
0000bc  e28f3f66          ADR      r3,|L15.604|
0000c0  e59f2214          LDR      r2,|L15.732|
0000c4  e28f1f85          ADR      r1,|L15.736|
0000c8  e28f0d07          ADR      r0,|L15.656|
0000cc  ebfffffe          BL       sysprintf
0000d0  e1a00000          MOV      r0,r0
                  |L15.212|
0000d4  e1a00000          MOV      r0,r0
;;;1223     LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
0000d8  e1a00000          MOV      r0,r0
0000dc  e5940004          LDR      r0,[r4,#4]
0000e0  e3500000          CMP      r0,#0
0000e4  1a000006          BNE      |L15.260|
0000e8  e1a00000          MOV      r0,r0
0000ec  e28f3f5a          ADR      r3,|L15.604|
0000f0  e59f2204          LDR      r2,|L15.764|
0000f4  e28f1f81          ADR      r1,|L15.768|
0000f8  e28f0e19          ADR      r0,|L15.656|
0000fc  ebfffffe          BL       sysprintf
000100  e1a00000          MOV      r0,r0
                  |L15.260|
000104  e1a00000          MOV      r0,r0
;;;1224     LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
000108  e1a00000          MOV      r0,r0
00010c  e5940020          LDR      r0,[r4,#0x20]
000110  e5941024          LDR      r1,[r4,#0x24]
000114  e591100c          LDR      r1,[r1,#0xc]
000118  e1500001          CMP      r0,r1
00011c  3a000006          BCC      |L15.316|
000120  e1a00000          MOV      r0,r0
000124  e28f3e13          ADR      r3,|L15.604|
000128  e59f21e8          LDR      r2,|L15.792|
00012c  e28f1f7a          ADR      r1,|L15.796|
000130  e28f0f56          ADR      r0,|L15.656|
000134  ebfffffe          BL       sysprintf
000138  e1a00000          MOV      r0,r0
                  |L15.316|
00013c  e1a00000          MOV      r0,r0
;;;1225       conn->write_offset < conn->current_msg->msg.w.len);
;;;1226   
;;;1227   #if LWIP_SO_SNDTIMEO
;;;1228     if ((conn->send_timeout != 0) &&
;;;1229         ((s32_t)(sys_now() - conn->current_msg->msg.w.time_started) >= conn->send_timeout)) {
;;;1230       write_finished = 1;
;;;1231       if (conn->write_offset == 0) {
;;;1232         /* nothing has been written */
;;;1233         err = ERR_WOULDBLOCK;
;;;1234         conn->current_msg->msg.w.len = 0;
;;;1235       } else {
;;;1236         /* partial write */
;;;1237         err = ERR_OK;
;;;1238         conn->current_msg->msg.w.len = conn->write_offset;
;;;1239       }
;;;1240     } else
;;;1241   #endif /* LWIP_SO_SNDTIMEO */
;;;1242     {
;;;1243       dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
000140  e5940024          LDR      r0,[r4,#0x24]
000144  e5900008          LDR      r0,[r0,#8]
000148  e5941020          LDR      r1,[r4,#0x20]
00014c  e080b001          ADD      r11,r0,r1
;;;1244       diff = conn->current_msg->msg.w.len - conn->write_offset;
000150  e5940024          LDR      r0,[r4,#0x24]
000154  e590000c          LDR      r0,[r0,#0xc]
000158  e5941020          LDR      r1,[r4,#0x20]
00015c  e040a001          SUB      r10,r0,r1
;;;1245       if (diff > 0xffffUL) { /* max_u16_t */
000160  e35a0801          CMP      r10,#0x10000
000164  3a000002          BCC      |L15.372|
;;;1246         len = 0xffff;
000168  e59f61e0          LDR      r6,|L15.848|
;;;1247   #if LWIP_TCPIP_CORE_LOCKING
;;;1248         conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1249   #endif
;;;1250         apiflags |= TCP_WRITE_FLAG_MORE;
00016c  e3888002          ORR      r8,r8,#2
000170  ea000001          B        |L15.380|
                  |L15.372|
;;;1251       } else {
;;;1252         len = (u16_t)diff;
000174  e1a0680a          LSL      r6,r10,#16
000178  e1a06826          LSR      r6,r6,#16
                  |L15.380|
;;;1253       }
;;;1254       available = tcp_sndbuf(conn->pcb.tcp);
00017c  e5940004          LDR      r0,[r4,#4]
000180  e1d096b6          LDRH     r9,[r0,#0x66]
;;;1255       if (available < len) {
000184  e1590006          CMP      r9,r6
000188  aa000007          BGE      |L15.428|
;;;1256         /* don't try to write more than sendbuf */
;;;1257         len = available;
00018c  e1a06009          MOV      r6,r9
;;;1258         if (dontblock){ 
000190  e3570000          CMP      r7,#0
000194  0a000003          BEQ      |L15.424|
;;;1259           if (!len) {
000198  e3560000          CMP      r6,#0
00019c  1a000002          BNE      |L15.428|
;;;1260             err = ERR_WOULDBLOCK;
0001a0  e3e05006          MVN      r5,#6
;;;1261             goto err_mem;
0001a4  ea00001a          B        |L15.532|
                  |L15.424|
;;;1262           }
;;;1263         } else {
;;;1264   #if LWIP_TCPIP_CORE_LOCKING
;;;1265           conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1266   #endif
;;;1267           apiflags |= TCP_WRITE_FLAG_MORE;
0001a8  e3888002          ORR      r8,r8,#2
                  |L15.428|
;;;1268         }
;;;1269       }
;;;1270       LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
0001ac  e1a00000          MOV      r0,r0
0001b0  e5940020          LDR      r0,[r4,#0x20]
0001b4  e0800006          ADD      r0,r0,r6
0001b8  e5941024          LDR      r1,[r4,#0x24]
0001bc  e591100c          LDR      r1,[r1,#0xc]
0001c0  e1500001          CMP      r0,r1
0001c4  9a000006          BLS      |L15.484|
0001c8  e1a00000          MOV      r0,r0
0001cc  e28f3088          ADR      r3,|L15.604|
0001d0  e59f217c          LDR      r2,|L15.852|
0001d4  e28f1f5f          ADR      r1,|L15.856|
0001d8  e28f00b0          ADR      r0,|L15.656|
0001dc  ebfffffe          BL       sysprintf
0001e0  e1a00000          MOV      r0,r0
                  |L15.484|
0001e4  e1a00000          MOV      r0,r0
;;;1271       err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
0001e8  e1a03008          MOV      r3,r8
0001ec  e1a02006          MOV      r2,r6
0001f0  e1a0100b          MOV      r1,r11
0001f4  e5940004          LDR      r0,[r4,#4]
0001f8  ebfffffe          BL       tcp_write
0001fc  e1a05000          MOV      r5,r0
;;;1272       /* if OK or memory error, check available space */
;;;1273       if ((err == ERR_OK) || (err == ERR_MEM)) {
000200  e3550000          CMP      r5,#0
000204  0a000001          BEQ      |L15.528|
000208  e3750001          CMN      r5,#1
00020c  1a000069          BNE      |L15.952|
                  |L15.528|
;;;1274   err_mem:
000210  e1a00000          MOV      r0,r0
                  |L15.532|
;;;1275         if (dontblock && (len < conn->current_msg->msg.w.len)) {
000214  e3570000          CMP      r7,#0
000218  0a000056          BEQ      |L15.888|
00021c  e5940024          LDR      r0,[r4,#0x24]
000220  e590000c          LDR      r0,[r0,#0xc]
000224  e1500006          CMP      r0,r6
000228  9a000052          BLS      |L15.888|
;;;1276           /* non-blocking write did not write everything: mark the pcb non-writable
;;;1277              and let poll_tcp check writable space to mark the pcb writable again */
;;;1278           API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
00022c  e5940028          LDR      r0,[r4,#0x28]
000230  e3500000          CMP      r0,#0
000234  0a000004          BEQ      |L15.588|
000238  e1a02006          MOV      r2,r6
00023c  e3a01003          MOV      r1,#3
000240  e5943028          LDR      r3,[r4,#0x28]
000244  e1a00004          MOV      r0,r4
000248  e12fff33          BLX      r3
                  |L15.588|
;;;1279           conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
00024c  e5d4001c          LDRB     r0,[r4,#0x1c]
000250  e3800010          ORR      r0,r0,#0x10
000254  e5c4001c          STRB     r0,[r4,#0x1c]
000258  ea000056          B        |L15.952|
                  |L15.604|
00025c  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
000260  2d312e34
000264  2e315c73
000268  72635c61
00026c  70695c61
000270  70695f6d
000274  73672e63
000278  00      
000279  00                DCB      0
00027a  00                DCB      0
00027b  00                DCB      0
                  |L15.636|
                          DCD      0x000004c4
                  |L15.640|
000280  636f6e6e          DCB      "conn != NULL",0
000284  20213d20
000288  4e554c4c
00028c  00      
00028d  00                DCB      0
00028e  00                DCB      0
00028f  00                DCB      0
                  |L15.656|
000290  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000294  7274696f
000298  6e202225
00029c  73222066
0002a0  61696c65
0002a4  64206174
0002a8  206c696e
0002ac  65202564
0002b0  20696e20
0002b4  25730a00
                  |L15.696|
                          DCD      0x000004c5
                  |L15.700|
0002bc  636f6e6e          DCB      "conn->state == NETCONN_WRITE",0
0002c0  2d3e7374
0002c4  61746520
0002c8  3d3d204e
0002cc  4554434f
0002d0  4e4e5f57
0002d4  52495445
0002d8  00      
0002d9  00                DCB      0
0002da  00                DCB      0
0002db  00                DCB      0
                  |L15.732|
                          DCD      0x000004c6
                  |L15.736|
0002e0  636f6e6e          DCB      "conn->current_msg != NULL",0
0002e4  2d3e6375
0002e8  7272656e
0002ec  745f6d73
0002f0  6720213d
0002f4  204e554c
0002f8  4c00    
0002fa  00                DCB      0
0002fb  00                DCB      0
                  |L15.764|
                          DCD      0x000004c7
                  |L15.768|
000300  636f6e6e          DCB      "conn->pcb.tcp != NULL",0
000304  2d3e7063
000308  622e7463
00030c  7020213d
000310  204e554c
000314  4c00    
000316  00                DCB      0
000317  00                DCB      0
                  |L15.792|
                          DCD      0x000004c8
                  |L15.796|
00031c  636f6e6e          DCB      "conn->write_offset < conn->current_msg->msg.w.len",0
000320  2d3e7772
000324  6974655f
000328  6f666673
00032c  6574203c
000330  20636f6e
000334  6e2d3e63
000338  75727265
00033c  6e745f6d
000340  73672d3e
000344  6d73672e
000348  772e6c65
00034c  6e00    
00034e  00                DCB      0
00034f  00                DCB      0
                  |L15.848|
                          DCD      0x0000ffff
                  |L15.852|
                          DCD      0x000004f6
                  |L15.856|
000358  646f5f77          DCB      "do_writemore: invalid length!",0
00035c  72697465
000360  6d6f7265
000364  3a20696e
000368  76616c69
00036c  64206c65
000370  6e677468
000374  2100    
000376  00                DCB      0
000377  00                DCB      0
                  |L15.888|
;;;1280         } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
000378  e5940004          LDR      r0,[r4,#4]
00037c  e1d006b6          LDRH     r0,[r0,#0x66]
000380  e3500e43          CMP      r0,#0x430
000384  ba000003          BLT      |L15.920|
;;;1281                    (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
000388  e5940004          LDR      r0,[r4,#4]
00038c  e1d006b8          LDRH     r0,[r0,#0x68]
000390  e3500005          CMP      r0,#5
000394  ba000007          BLT      |L15.952|
                  |L15.920|
;;;1282           /* The queued byte- or pbuf-count exceeds the configured low-water limit,
;;;1283              let select mark this pcb as non-writable. */
;;;1284           API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
000398  e5940028          LDR      r0,[r4,#0x28]
00039c  e3500000          CMP      r0,#0
0003a0  0a000004          BEQ      |L15.952|
0003a4  e1a02006          MOV      r2,r6
0003a8  e3a01003          MOV      r1,#3
0003ac  e5943028          LDR      r3,[r4,#0x28]
0003b0  e1a00004          MOV      r0,r4
0003b4  e12fff33          BLX      r3
                  |L15.952|
;;;1285         }
;;;1286       }
;;;1287   
;;;1288       if (err == ERR_OK) {
0003b8  e3550000          CMP      r5,#0
0003bc  1a000013          BNE      |L15.1040|
;;;1289         conn->write_offset += len;
0003c0  e5940020          LDR      r0,[r4,#0x20]
0003c4  e0800006          ADD      r0,r0,r6
0003c8  e5840020          STR      r0,[r4,#0x20]
;;;1290         if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
0003cc  e5940020          LDR      r0,[r4,#0x20]
0003d0  e5941024          LDR      r1,[r4,#0x24]
0003d4  e591100c          LDR      r1,[r1,#0xc]
0003d8  e1500001          CMP      r0,r1
0003dc  0a000001          BEQ      |L15.1000|
0003e0  e3570000          CMP      r7,#0
0003e4  0a000006          BEQ      |L15.1028|
                  |L15.1000|
;;;1291           /* return sent length */
;;;1292           conn->current_msg->msg.w.len = conn->write_offset;
0003e8  e5940020          LDR      r0,[r4,#0x20]
0003ec  e5941024          LDR      r1,[r4,#0x24]
0003f0  e581000c          STR      r0,[r1,#0xc]
;;;1293           /* everything was written */
;;;1294           write_finished = 1;
0003f4  e3a00001          MOV      r0,#1
0003f8  e58d0000          STR      r0,[sp,#0]
;;;1295           conn->write_offset = 0;
0003fc  e3a00000          MOV      r0,#0
000400  e5840020          STR      r0,[r4,#0x20]
                  |L15.1028|
;;;1296         }
;;;1297         tcp_output(conn->pcb.tcp);
000404  e5940004          LDR      r0,[r4,#4]
000408  ebfffffe          BL       tcp_output
00040c  ea00000b          B        |L15.1088|
                  |L15.1040|
;;;1298       } else if ((err == ERR_MEM) && !dontblock) {
000410  e3750001          CMN      r5,#1
000414  1a000004          BNE      |L15.1068|
000418  e3570000          CMP      r7,#0
00041c  1a000002          BNE      |L15.1068|
;;;1299         /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
;;;1300            we do NOT return to the application thread, since ERR_MEM is
;;;1301            only a temporary error! */
;;;1302   
;;;1303         /* tcp_write returned ERR_MEM, try tcp_output anyway */
;;;1304         tcp_output(conn->pcb.tcp);
000420  e5940004          LDR      r0,[r4,#4]
000424  ebfffffe          BL       tcp_output
000428  ea000004          B        |L15.1088|
                  |L15.1068|
;;;1305   
;;;1306   #if LWIP_TCPIP_CORE_LOCKING
;;;1307         conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1308   #endif
;;;1309       } else {
;;;1310         /* On errors != ERR_MEM, we don't try writing any more but return
;;;1311            the error to the application thread. */
;;;1312         write_finished = 1;
00042c  e3a00001          MOV      r0,#1
000430  e58d0000          STR      r0,[sp,#0]
;;;1313         conn->current_msg->msg.w.len = 0;
000434  e3a00000          MOV      r0,#0
000438  e5941024          LDR      r1,[r4,#0x24]
00043c  e581000c          STR      r0,[r1,#0xc]
                  |L15.1088|
;;;1314       }
;;;1315     }
;;;1316     if (write_finished) {
000440  e59d0000          LDR      r0,[sp,#0]
000444  e3500000          CMP      r0,#0
000448  0a000006          BEQ      |L15.1128|
;;;1317       /* everything was written: set back connection state
;;;1318          and back to application task */
;;;1319       conn->current_msg->err = err;
00044c  e5940024          LDR      r0,[r4,#0x24]
000450  e5c05004          STRB     r5,[r0,#4]
;;;1320       conn->current_msg = NULL;
000454  e3a00000          MOV      r0,#0
000458  e5840024          STR      r0,[r4,#0x24]
;;;1321       conn->state = NETCONN_NONE;
00045c  e5c40001          STRB     r0,[r4,#1]
;;;1322   #if LWIP_TCPIP_CORE_LOCKING
;;;1323       if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
;;;1324   #endif
;;;1325       {
;;;1326         sys_sem_signal(&conn->op_completed);
000460  e284000c          ADD      r0,r4,#0xc
000464  ebfffffe          BL       sys_sem_signal
                  |L15.1128|
;;;1327       }
;;;1328     }
;;;1329   #if LWIP_TCPIP_CORE_LOCKING
;;;1330     else
;;;1331       return ERR_MEM;
;;;1332   #endif
;;;1333     return ERR_OK;
000468  e3a00000          MOV      r0,#0
;;;1334   }
00046c  e8bd8ff8          POP      {r3-r11,pc}
;;;1335   #endif /* LWIP_TCP */
                          ENDP


                          AREA ||i.err_tcp||, CODE, READONLY, ALIGN=2

                  err_tcp PROC
;;;346    static void
;;;347    err_tcp(void *arg, err_t err)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;348    {
000004  e1a07000          MOV      r7,r0
000008  e1a06001          MOV      r6,r1
;;;349      struct netconn *conn;
;;;350      enum netconn_state old_state;
;;;351      SYS_ARCH_DECL_PROTECT(lev);
;;;352    
;;;353      conn = (struct netconn *)arg;
00000c  e1a04007          MOV      r4,r7
;;;354      LWIP_ASSERT("conn != NULL", (conn != NULL));
000010  e1a00000          MOV      r0,r0
000014  e3540000          CMP      r4,#0
000018  1a000006          BNE      |L16.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f3f65          ADR      r3,|L16.444|
000024  e59f21b0          LDR      r2,|L16.476|
000028  e28f1e1b          ADR      r1,|L16.480|
00002c  e28f0f6f          ADR      r0,|L16.496|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L16.56|
000038  e1a00000          MOV      r0,r0
;;;355    
;;;356      conn->pcb.tcp = NULL;
00003c  e3a00000          MOV      r0,#0
000040  e5840004          STR      r0,[r4,#4]
;;;357    
;;;358      /* no check since this is always fatal! */
;;;359      SYS_ARCH_PROTECT(lev);
000044  ebfffffe          BL       sys_arch_protect
000048  e1a09000          MOV      r9,r0
;;;360      conn->last_err = err;
00004c  e5c46008          STRB     r6,[r4,#8]
;;;361      SYS_ARCH_UNPROTECT(lev);
000050  e1a00009          MOV      r0,r9
000054  ebfffffe          BL       sys_arch_unprotect
;;;362    
;;;363      /* reset conn->state now before waking up other threads */
;;;364      old_state = conn->state;
000058  e5d45001          LDRB     r5,[r4,#1]
;;;365      conn->state = NETCONN_NONE;
00005c  e3a00000          MOV      r0,#0
000060  e5c40001          STRB     r0,[r4,#1]
;;;366    
;;;367      /* Notify the user layer about a connection error. Used to signal
;;;368         select. */
;;;369      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
000064  e5940028          LDR      r0,[r4,#0x28]
000068  e3500000          CMP      r0,#0
00006c  0a000004          BEQ      |L16.132|
000070  e3a02000          MOV      r2,#0
000074  e3a01004          MOV      r1,#4
000078  e5943028          LDR      r3,[r4,#0x28]
00007c  e1a00004          MOV      r0,r4
000080  e12fff33          BLX      r3
                  |L16.132|
;;;370      /* Try to release selects pending on 'read' or 'write', too.
;;;371         They will get an error if they actually try to read or write. */
;;;372      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
000084  e5940028          LDR      r0,[r4,#0x28]
000088  e3500000          CMP      r0,#0
00008c  0a000004          BEQ      |L16.164|
000090  e3a02000          MOV      r2,#0
000094  e1a01002          MOV      r1,r2
000098  e5943028          LDR      r3,[r4,#0x28]
00009c  e1a00004          MOV      r0,r4
0000a0  e12fff33          BLX      r3
                  |L16.164|
;;;373      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
0000a4  e5940028          LDR      r0,[r4,#0x28]
0000a8  e3500000          CMP      r0,#0
0000ac  0a000004          BEQ      |L16.196|
0000b0  e3a02000          MOV      r2,#0
0000b4  e3a01002          MOV      r1,#2
0000b8  e5943028          LDR      r3,[r4,#0x28]
0000bc  e1a00004          MOV      r0,r4
0000c0  e12fff33          BLX      r3
                  |L16.196|
;;;374    
;;;375      /* pass NULL-message to recvmbox to wake up pending recv */
;;;376      if (sys_mbox_valid(&conn->recvmbox)) {
0000c4  e2840010          ADD      r0,r4,#0x10
0000c8  ebfffffe          BL       sys_mbox_valid
0000cc  e3500000          CMP      r0,#0
0000d0  0a000002          BEQ      |L16.224|
;;;377        /* use trypost to prevent deadlock */
;;;378        sys_mbox_trypost(&conn->recvmbox, NULL);
0000d4  e3a01000          MOV      r1,#0
0000d8  e2840010          ADD      r0,r4,#0x10
0000dc  ebfffffe          BL       sys_mbox_trypost
                  |L16.224|
;;;379      }
;;;380      /* pass NULL-message to acceptmbox to wake up pending accept */
;;;381      if (sys_mbox_valid(&conn->acceptmbox)) {
0000e0  e2840014          ADD      r0,r4,#0x14
0000e4  ebfffffe          BL       sys_mbox_valid
0000e8  e3500000          CMP      r0,#0
0000ec  0a000002          BEQ      |L16.252|
;;;382        /* use trypost to preven deadlock */
;;;383        sys_mbox_trypost(&conn->acceptmbox, NULL);
0000f0  e3a01000          MOV      r1,#0
0000f4  e2840014          ADD      r0,r4,#0x14
0000f8  ebfffffe          BL       sys_mbox_trypost
                  |L16.252|
;;;384      }
;;;385    
;;;386      if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
0000fc  e3550001          CMP      r5,#1
000100  0a000003          BEQ      |L16.276|
000104  e3550004          CMP      r5,#4
000108  0a000001          BEQ      |L16.276|
;;;387          (old_state == NETCONN_CONNECT)) {
00010c  e3550003          CMP      r5,#3
000110  1a00001c          BNE      |L16.392|
                  |L16.276|
;;;388        /* calling do_writemore/do_close_internal is not necessary
;;;389           since the pcb has already been deleted! */
;;;390        int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
000114  e5d4001c          LDRB     r0,[r4,#0x1c]
000118  e2000004          AND      r0,r0,#4
00011c  e1a08120          LSR      r8,r0,#2
;;;391        SET_NONBLOCKING_CONNECT(conn, 0);
000120  e1a00000          MOV      r0,r0
000124  e5d4001c          LDRB     r0,[r4,#0x1c]
000128  e3c00004          BIC      r0,r0,#4
00012c  e5c4001c          STRB     r0,[r4,#0x1c]
000130  e1a00000          MOV      r0,r0
;;;392    
;;;393        if (!was_nonblocking_connect) {
000134  e3580000          CMP      r8,#0
000138  1a000011          BNE      |L16.388|
;;;394          /* set error return code */
;;;395          LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
00013c  e1a00000          MOV      r0,r0
000140  e5940024          LDR      r0,[r4,#0x24]
000144  e3500000          CMP      r0,#0
000148  1a000006          BNE      |L16.360|
00014c  e1a00000          MOV      r0,r0
000150  e28f3064          ADR      r3,|L16.444|
000154  e59f20bc          LDR      r2,|L16.536|
000158  e28f10bc          ADR      r1,|L16.540|
00015c  e28f008c          ADR      r0,|L16.496|
000160  ebfffffe          BL       sysprintf
000164  e1a00000          MOV      r0,r0
                  |L16.360|
000168  e1a00000          MOV      r0,r0
;;;396          conn->current_msg->err = err;
00016c  e5940024          LDR      r0,[r4,#0x24]
000170  e5c06004          STRB     r6,[r0,#4]
;;;397          conn->current_msg = NULL;
000174  e3a00000          MOV      r0,#0
000178  e5840024          STR      r0,[r4,#0x24]
;;;398          /* wake up the waiting task */
;;;399          sys_sem_signal(&conn->op_completed);
00017c  e284000c          ADD      r0,r4,#0xc
000180  ebfffffe          BL       sys_sem_signal
                  |L16.388|
;;;400        }
;;;401      } else {
000184  ea00000b          B        |L16.440|
                  |L16.392|
;;;402        LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
000188  e1a00000          MOV      r0,r0
00018c  e5940024          LDR      r0,[r4,#0x24]
000190  e3500000          CMP      r0,#0
000194  0a000006          BEQ      |L16.436|
000198  e1a00000          MOV      r0,r0
00019c  e28f3018          ADR      r3,|L16.444|
0001a0  e59f2090          LDR      r2,|L16.568|
0001a4  e28f1090          ADR      r1,|L16.572|
0001a8  e28f0040          ADR      r0,|L16.496|
0001ac  ebfffffe          BL       sysprintf
0001b0  e1a00000          MOV      r0,r0
                  |L16.436|
0001b4  e1a00000          MOV      r0,r0
                  |L16.440|
;;;403      }
;;;404    }
0001b8  e8bd87f0          POP      {r4-r10,pc}
;;;405    
                          ENDP

                  |L16.444|
0001bc  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
0001c0  2d312e34
0001c4  2e315c73
0001c8  72635c61
0001cc  70695c61
0001d0  70695f6d
0001d4  73672e63
0001d8  00      
0001d9  00                DCB      0
0001da  00                DCB      0
0001db  00                DCB      0
                  |L16.476|
                          DCD      0x00000162
                  |L16.480|
0001e0  636f6e6e          DCB      "conn != NULL",0
0001e4  20213d20
0001e8  4e554c4c
0001ec  00      
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L16.496|
0001f0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001f4  7274696f
0001f8  6e202225
0001fc  73222066
000200  61696c65
000204  64206174
000208  206c696e
00020c  65202564
000210  20696e20
000214  25730a00
                  |L16.536|
                          DCD      0x0000018b
                  |L16.540|
00021c  636f6e6e          DCB      "conn->current_msg != NULL",0
000220  2d3e6375
000224  7272656e
000228  745f6d73
00022c  6720213d
000230  204e554c
000234  4c00    
000236  00                DCB      0
000237  00                DCB      0
                  |L16.568|
                          DCD      0x00000192
                  |L16.572|
00023c  636f6e6e          DCB      "conn->current_msg == NULL",0
000240  2d3e6375
000244  7272656e
000248  745f6d73
00024c  67203d3d
000250  204e554c
000254  4c00    
000256  00                DCB      0
000257  00                DCB      0

                          AREA ||i.netconn_alloc||, CODE, READONLY, ALIGN=2

                  netconn_alloc PROC
;;;571    struct netconn*
;;;572    netconn_alloc(enum netconn_type t, netconn_callback callback)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;573    {
000004  e1a05000          MOV      r5,r0
000008  e1a07001          MOV      r7,r1
;;;574      struct netconn *conn;
;;;575      int size;
;;;576    
;;;577      conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
00000c  e3a00006          MOV      r0,#6
000010  ebfffffe          BL       memp_malloc
000014  e1a04000          MOV      r4,r0
;;;578      if (conn == NULL) {
000018  e3540000          CMP      r4,#0
00001c  1a000001          BNE      |L17.40|
;;;579        return NULL;
000020  e3a00000          MOV      r0,#0
                  |L17.36|
;;;580      }
;;;581    
;;;582      conn->last_err = ERR_OK;
;;;583      conn->type = t;
;;;584      conn->pcb.tcp = NULL;
;;;585    
;;;586    #if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
;;;587        (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
;;;588      size = DEFAULT_RAW_RECVMBOX_SIZE;
;;;589    #else
;;;590      switch(NETCONNTYPE_GROUP(t)) {
;;;591    #if LWIP_RAW
;;;592      case NETCONN_RAW:
;;;593        size = DEFAULT_RAW_RECVMBOX_SIZE;
;;;594        break;
;;;595    #endif /* LWIP_RAW */
;;;596    #if LWIP_UDP
;;;597      case NETCONN_UDP:
;;;598        size = DEFAULT_UDP_RECVMBOX_SIZE;
;;;599        break;
;;;600    #endif /* LWIP_UDP */
;;;601    #if LWIP_TCP
;;;602      case NETCONN_TCP:
;;;603        size = DEFAULT_TCP_RECVMBOX_SIZE;
;;;604        break;
;;;605    #endif /* LWIP_TCP */
;;;606      default:
;;;607        LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
;;;608        goto free_and_return;
;;;609      }
;;;610    #endif
;;;611    
;;;612      if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
;;;613        goto free_and_return;
;;;614      }
;;;615      if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
;;;616        sys_sem_free(&conn->op_completed);
;;;617        goto free_and_return;
;;;618      }
;;;619    
;;;620    #if LWIP_TCP
;;;621      sys_mbox_set_invalid(&conn->acceptmbox);
;;;622    #endif
;;;623      conn->state        = NETCONN_NONE;
;;;624    #if LWIP_SOCKET
;;;625      /* initialize socket to -1 since 0 is a valid socket */
;;;626      conn->socket       = -1;
;;;627    #endif /* LWIP_SOCKET */
;;;628      conn->callback     = callback;
;;;629    #if LWIP_TCP
;;;630      conn->current_msg  = NULL;
;;;631      conn->write_offset = 0;
;;;632    #endif /* LWIP_TCP */
;;;633    #if LWIP_SO_SNDTIMEO
;;;634      conn->send_timeout = 0;
;;;635    #endif /* LWIP_SO_SNDTIMEO */
;;;636    #if LWIP_SO_RCVTIMEO
;;;637      conn->recv_timeout = 0;
;;;638    #endif /* LWIP_SO_RCVTIMEO */
;;;639    #if LWIP_SO_RCVBUF
;;;640      conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
;;;641      conn->recv_avail   = 0;
;;;642    #endif /* LWIP_SO_RCVBUF */
;;;643      conn->flags = 0;
;;;644      return conn;
;;;645    free_and_return:
;;;646      memp_free(MEMP_NETCONN, conn);
;;;647      return NULL;
;;;648    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L17.40|
000028  e3a00000          MOV      r0,#0                 ;582
00002c  e5c40008          STRB     r0,[r4,#8]            ;582
000030  e5c45000          STRB     r5,[r4,#0]            ;583
000034  e5840004          STR      r0,[r4,#4]            ;584
000038  e20500f0          AND      r0,r5,#0xf0           ;590
00003c  e3500010          CMP      r0,#0x10              ;590
000040  0a000003          BEQ      |L17.84|
000044  e3500020          CMP      r0,#0x20              ;590
000048  1a000004          BNE      |L17.96|
00004c  e3a06c02          MOV      r6,#0x200             ;598
000050  ea00000d          B        |L17.140|
                  |L17.84|
000054  e1a00000          MOV      r0,r0                 ;602
000058  e3a06c01          MOV      r6,#0x100             ;603
00005c  ea00000a          B        |L17.140|
                  |L17.96|
000060  e1a00000          MOV      r0,r0                 ;606
000064  e1a00000          MOV      r0,r0                 ;607
000068  e1a00000          MOV      r0,r0                 ;607
00006c  e28f30a0          ADR      r3,|L17.276|
000070  e59f20bc          LDR      r2,|L17.308|
000074  e28f10bc          ADR      r1,|L17.312|
000078  e28f00e0          ADR      r0,|L17.352|
00007c  ebfffffe          BL       sysprintf
000080  e1a00000          MOV      r0,r0                 ;607
000084  e1a00000          MOV      r0,r0                 ;607
000088  ea00001b          B        |L17.252|
                  |L17.140|
00008c  e1a00000          MOV      r0,r0                 ;599
000090  e3a01000          MOV      r1,#0                 ;612
000094  e284000c          ADD      r0,r4,#0xc            ;612
000098  ebfffffe          BL       sys_sem_new
00009c  e3500000          CMP      r0,#0                 ;612
0000a0  0a000000          BEQ      |L17.168|
0000a4  ea000014          B        |L17.252|
                  |L17.168|
0000a8  e1a01006          MOV      r1,r6                 ;615
0000ac  e2840010          ADD      r0,r4,#0x10           ;615
0000b0  ebfffffe          BL       sys_mbox_new
0000b4  e3500000          CMP      r0,#0                 ;615
0000b8  0a000002          BEQ      |L17.200|
0000bc  e284000c          ADD      r0,r4,#0xc            ;616
0000c0  ebfffffe          BL       sys_sem_free
0000c4  ea00000c          B        |L17.252|
                  |L17.200|
0000c8  e2840014          ADD      r0,r4,#0x14           ;621
0000cc  ebfffffe          BL       sys_mbox_set_invalid
0000d0  e3a00000          MOV      r0,#0                 ;623
0000d4  e5c40001          STRB     r0,[r4,#1]            ;623
0000d8  e3e00000          MVN      r0,#0                 ;626
0000dc  e5840018          STR      r0,[r4,#0x18]         ;626
0000e0  e5847028          STR      r7,[r4,#0x28]         ;628
0000e4  e3a00000          MOV      r0,#0                 ;630
0000e8  e5840024          STR      r0,[r4,#0x24]         ;630
0000ec  e5840020          STR      r0,[r4,#0x20]         ;631
0000f0  e5c4001c          STRB     r0,[r4,#0x1c]         ;643
0000f4  e1a00004          MOV      r0,r4                 ;644
0000f8  eaffffc9          B        |L17.36|
                  |L17.252|
0000fc  e1a00000          MOV      r0,r0                 ;645
000100  e1a01004          MOV      r1,r4                 ;646
000104  e3a00006          MOV      r0,#6                 ;646
000108  ebfffffe          BL       memp_free
00010c  e3a00000          MOV      r0,#0                 ;647
000110  eaffffc3          B        |L17.36|
;;;649    
                          ENDP

                  |L17.276|
000114  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
000118  2d312e34
00011c  2e315c73
000120  72635c61
000124  70695c61
000128  70695f6d
00012c  73672e63
000130  00      
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0
                  |L17.308|
                          DCD      0x0000025f
                  |L17.312|
000138  6e657463          DCB      "netconn_alloc: undefined netconn_type",0
00013c  6f6e6e5f
000140  616c6c6f
000144  633a2075
000148  6e646566
00014c  696e6564
000150  206e6574
000154  636f6e6e
000158  5f747970
00015c  6500    
00015e  00                DCB      0
00015f  00                DCB      0
                  |L17.352|
000160  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000164  7274696f
000168  6e202225
00016c  73222066
000170  61696c65
000174  64206174
000178  206c696e
00017c  65202564
000180  20696e20
000184  25730a00

                          AREA ||i.netconn_drain||, CODE, READONLY, ALIGN=2

                  netconn_drain PROC
;;;681    static void
;;;682    netconn_drain(struct netconn *conn)
000000  e92d40f8          PUSH     {r3-r7,lr}
;;;683    {
000004  e1a04000          MOV      r4,r0
;;;684      void *mem;
;;;685    #if LWIP_TCP
;;;686      struct pbuf *p;
;;;687    #endif /* LWIP_TCP */
;;;688    
;;;689      /* This runs in tcpip_thread, so we don't need to lock against rx packets */
;;;690    
;;;691      /* Delete and drain the recvmbox. */
;;;692      if (sys_mbox_valid(&conn->recvmbox)) {
000008  e2840010          ADD      r0,r4,#0x10
00000c  ebfffffe          BL       sys_mbox_valid
000010  e3500000          CMP      r0,#0
000014  0a00001b          BEQ      |L18.136|
;;;693        while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
000018  ea000011          B        |L18.100|
                  |L18.28|
;;;694    #if LWIP_TCP
;;;695          if (conn->type == NETCONN_TCP) {
00001c  e5d40000          LDRB     r0,[r4,#0]
000020  e3500010          CMP      r0,#0x10
000024  1a00000c          BNE      |L18.92|
;;;696            if(mem != NULL) {
000028  e59d0000          LDR      r0,[sp,#0]
00002c  e3500000          CMP      r0,#0
000030  0a00000b          BEQ      |L18.100|
;;;697              p = (struct pbuf*)mem;
000034  e59d6000          LDR      r6,[sp,#0]
;;;698              /* pcb might be set to NULL already by err_tcp() */
;;;699              if (conn->pcb.tcp != NULL) {
000038  e5940004          LDR      r0,[r4,#4]
00003c  e3500000          CMP      r0,#0
000040  0a000002          BEQ      |L18.80|
;;;700                tcp_recved(conn->pcb.tcp, p->tot_len);
000044  e1d610b8          LDRH     r1,[r6,#8]
000048  e5940004          LDR      r0,[r4,#4]
00004c  ebfffffe          BL       tcp_recved
                  |L18.80|
;;;701              }
;;;702              pbuf_free(p);
000050  e1a00006          MOV      r0,r6
000054  ebfffffe          BL       pbuf_free
000058  ea000001          B        |L18.100|
                  |L18.92|
;;;703            }
;;;704          } else
;;;705    #endif /* LWIP_TCP */
;;;706          {
;;;707            netbuf_delete((struct netbuf *)mem);
00005c  e59d0000          LDR      r0,[sp,#0]
000060  ebfffffe          BL       netbuf_delete
                  |L18.100|
000064  e1a0100d          MOV      r1,sp                 ;693
000068  e2840010          ADD      r0,r4,#0x10           ;693
00006c  ebfffffe          BL       sys_arch_mbox_tryfetch
000070  e3700001          CMN      r0,#1                 ;693
000074  1affffe8          BNE      |L18.28|
;;;708          }
;;;709        }
;;;710        sys_mbox_free(&conn->recvmbox);
000078  e2840010          ADD      r0,r4,#0x10
00007c  ebfffffe          BL       sys_mbox_free
;;;711        sys_mbox_set_invalid(&conn->recvmbox);
000080  e2840010          ADD      r0,r4,#0x10
000084  ebfffffe          BL       sys_mbox_set_invalid
                  |L18.136|
;;;712      }
;;;713    
;;;714      /* Delete and drain the acceptmbox. */
;;;715    #if LWIP_TCP
;;;716      if (sys_mbox_valid(&conn->acceptmbox)) {
000088  e2840014          ADD      r0,r4,#0x14
00008c  ebfffffe          BL       sys_mbox_valid
000090  e3500000          CMP      r0,#0
000094  0a000028          BEQ      |L18.316|
;;;717        while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
000098  ea00001e          B        |L18.280|
                  |L18.156|
;;;718          struct netconn *newconn = (struct netconn *)mem;
00009c  e59d5000          LDR      r5,[sp,#0]
;;;719          /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
;;;720          /* pcb might be set to NULL already by err_tcp() */
;;;721          if (conn->pcb.tcp != NULL) {
0000a0  e5940004          LDR      r0,[r4,#4]
0000a4  e3500000          CMP      r0,#0
0000a8  0a00000c          BEQ      |L18.224|
;;;722            tcp_accepted(conn->pcb.tcp);
0000ac  e1a00000          MOV      r0,r0
0000b0  e5940004          LDR      r0,[r4,#4]
0000b4  e5d00018          LDRB     r0,[r0,#0x18]
0000b8  e3500001          CMP      r0,#1
0000bc  0a000006          BEQ      |L18.220|
0000c0  e1a00000          MOV      r0,r0
0000c4  e28f3074          ADR      r3,|L18.320|
0000c8  e59f2090          LDR      r2,|L18.352|
0000cc  e28f1090          ADR      r1,|L18.356|
0000d0  e28f00bc          ADR      r0,|L18.404|
0000d4  ebfffffe          BL       sysprintf
0000d8  e1a00000          MOV      r0,r0
                  |L18.220|
0000dc  e1a00000          MOV      r0,r0
                  |L18.224|
;;;723          }
;;;724          /* drain recvmbox */
;;;725          netconn_drain(newconn);
0000e0  e1a00005          MOV      r0,r5
0000e4  ebfffffe          BL       netconn_drain
;;;726          if (newconn->pcb.tcp != NULL) {
0000e8  e5950004          LDR      r0,[r5,#4]
0000ec  e3500000          CMP      r0,#0
0000f0  0a000005          BEQ      |L18.268|
;;;727              printf("-->f\n");
0000f4  e28f00c0          ADR      r0,|L18.444|
0000f8  ebfffffe          BL       __2printf
;;;728            tcp_abort(newconn->pcb.tcp);
0000fc  e5950004          LDR      r0,[r5,#4]
000100  ebfffffe          BL       tcp_abort
;;;729            newconn->pcb.tcp = NULL;
000104  e3a00000          MOV      r0,#0
000108  e5850004          STR      r0,[r5,#4]
                  |L18.268|
;;;730          }
;;;731          netconn_free(newconn);
00010c  e1a00005          MOV      r0,r5
000110  ebfffffe          BL       netconn_free
;;;732        }
000114  e1a00000          MOV      r0,r0
                  |L18.280|
000118  e1a0100d          MOV      r1,sp                 ;717
00011c  e2840014          ADD      r0,r4,#0x14           ;717
000120  ebfffffe          BL       sys_arch_mbox_tryfetch
000124  e3700001          CMN      r0,#1                 ;717
000128  1affffdb          BNE      |L18.156|
;;;733        sys_mbox_free(&conn->acceptmbox);
00012c  e2840014          ADD      r0,r4,#0x14
000130  ebfffffe          BL       sys_mbox_free
;;;734        sys_mbox_set_invalid(&conn->acceptmbox);
000134  e2840014          ADD      r0,r4,#0x14
000138  ebfffffe          BL       sys_mbox_set_invalid
                  |L18.316|
;;;735      }
;;;736    #endif /* LWIP_TCP */
;;;737    }
00013c  e8bd80f8          POP      {r3-r7,pc}
;;;738    
                          ENDP

                  |L18.320|
000140  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
000144  2d312e34
000148  2e315c73
00014c  72635c61
000150  70695c61
000154  70695f6d
000158  73672e63
00015c  00      
00015d  00                DCB      0
00015e  00                DCB      0
00015f  00                DCB      0
                  |L18.352|
                          DCD      0x000002d2
                  |L18.356|
000164  7063622d          DCB      "pcb->state == LISTEN (called for wrong pcb?)",0
000168  3e737461
00016c  7465203d
000170  3d204c49
000174  5354454e
000178  20286361
00017c  6c6c6564
000180  20666f72
000184  2077726f
000188  6e672070
00018c  63623f29
000190  00      
000191  00                DCB      0
000192  00                DCB      0
000193  00                DCB      0
                  |L18.404|
000194  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000198  7274696f
00019c  6e202225
0001a0  73222066
0001a4  61696c65
0001a8  64206174
0001ac  206c696e
0001b0  65202564
0001b4  20696e20
0001b8  25730a00
                  |L18.444|
0001bc  2d2d3e66          DCB      "-->f\n",0
0001c0  0a00    
0001c2  00                DCB      0
0001c3  00                DCB      0

                          AREA ||i.netconn_free||, CODE, READONLY, ALIGN=2

                  netconn_free PROC
;;;656    void
;;;657    netconn_free(struct netconn *conn)
000000  e92d4010          PUSH     {r4,lr}
;;;658    {
000004  e1a04000          MOV      r4,r0
;;;659      LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
000008  e1a00000          MOV      r0,r0
00000c  e5940004          LDR      r0,[r4,#4]
000010  e3500000          CMP      r0,#0
000014  0a000006          BEQ      |L19.52|
000018  e1a00000          MOV      r0,r0
00001c  e28f309c          ADR      r3,|L19.192|
000020  e59f20b8          LDR      r2,|L19.224|
000024  e28f10b8          ADR      r1,|L19.228|
000028  e28f00e4          ADR      r0,|L19.276|
00002c  ebfffffe          BL       sysprintf
000030  e1a00000          MOV      r0,r0
                  |L19.52|
000034  e1a00000          MOV      r0,r0
;;;660      LWIP_ASSERT("recvmbox must be deallocated before calling this function",
000038  e1a00000          MOV      r0,r0
00003c  e2840010          ADD      r0,r4,#0x10
000040  ebfffffe          BL       sys_mbox_valid
000044  e3500000          CMP      r0,#0
000048  0a000006          BEQ      |L19.104|
00004c  e1a00000          MOV      r0,r0
000050  e28f3068          ADR      r3,|L19.192|
000054  e3a02fa5          MOV      r2,#0x294
000058  e28f10dc          ADR      r1,|L19.316|
00005c  e28f00b0          ADR      r0,|L19.276|
000060  ebfffffe          BL       sysprintf
000064  e1a00000          MOV      r0,r0
                  |L19.104|
000068  e1a00000          MOV      r0,r0
;;;661        !sys_mbox_valid(&conn->recvmbox));
;;;662    #if LWIP_TCP
;;;663      LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
00006c  e1a00000          MOV      r0,r0
000070  e2840014          ADD      r0,r4,#0x14
000074  ebfffffe          BL       sys_mbox_valid
000078  e3500000          CMP      r0,#0
00007c  0a000006          BEQ      |L19.156|
000080  e1a00000          MOV      r0,r0
000084  e28f3034          ADR      r3,|L19.192|
000088  e59f20e8          LDR      r2,|L19.376|
00008c  e28f10e8          ADR      r1,|L19.380|
000090  e28f007c          ADR      r0,|L19.276|
000094  ebfffffe          BL       sysprintf
000098  e1a00000          MOV      r0,r0
                  |L19.156|
00009c  e1a00000          MOV      r0,r0
;;;664        !sys_mbox_valid(&conn->acceptmbox));
;;;665    #endif /* LWIP_TCP */
;;;666    
;;;667      sys_sem_free(&conn->op_completed);
0000a0  e284000c          ADD      r0,r4,#0xc
0000a4  ebfffffe          BL       sys_sem_free
;;;668      sys_sem_set_invalid(&conn->op_completed);
0000a8  e284000c          ADD      r0,r4,#0xc
0000ac  ebfffffe          BL       sys_sem_set_invalid
;;;669    
;;;670      memp_free(MEMP_NETCONN, conn);
0000b0  e1a01004          MOV      r1,r4
0000b4  e3a00006          MOV      r0,#6
0000b8  ebfffffe          BL       memp_free
;;;671    }
0000bc  e8bd8010          POP      {r4,pc}
;;;672    
                          ENDP

                  |L19.192|
0000c0  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
0000c4  2d312e34
0000c8  2e315c73
0000cc  72635c61
0000d0  70695c61
0000d4  70695f6d
0000d8  73672e63
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L19.224|
                          DCD      0x00000293
                  |L19.228|
0000e4  50434220          DCB      "PCB must be deallocated outside this function",0
0000e8  6d757374
0000ec  20626520
0000f0  6465616c
0000f4  6c6f6361
0000f8  74656420
0000fc  6f757473
000100  69646520
000104  74686973
000108  2066756e
00010c  6374696f
000110  6e00    
000112  00                DCB      0
000113  00                DCB      0
                  |L19.276|
000114  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000118  7274696f
00011c  6e202225
000120  73222066
000124  61696c65
000128  64206174
00012c  206c696e
000130  65202564
000134  20696e20
000138  25730a00
                  |L19.316|
00013c  72656376          DCB      "recvmbox must be deallocated before calling this functi"
000140  6d626f78
000144  206d7573
000148  74206265
00014c  20646561
000150  6c6c6f63
000154  61746564
000158  20626566
00015c  6f726520
000160  63616c6c
000164  696e6720
000168  74686973
00016c  2066756e
000170  637469  
000173  6f6e00            DCB      "on",0
000176  00                DCB      0
000177  00                DCB      0
                  |L19.376|
                          DCD      0x00000297
                  |L19.380|
00017c  61636365          DCB      "acceptmbox must be deallocated before calling this func"
000180  70746d62
000184  6f78206d
000188  75737420
00018c  62652064
000190  65616c6c
000194  6f636174
000198  65642062
00019c  65666f72
0001a0  65206361
0001a4  6c6c696e
0001a8  67207468
0001ac  69732066
0001b0  756e63  
0001b3  74696f6e          DCB      "tion",0
0001b7  00      

                          AREA ||i.pcb_new||, CODE, READONLY, ALIGN=2

                  pcb_new PROC
;;;489    static void
;;;490    pcb_new(struct api_msg_msg *msg)
000000  e92d4010          PUSH     {r4,lr}
;;;491    {
000004  e1a04000          MOV      r4,r0
;;;492      LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
000008  e1a00000          MOV      r0,r0
00000c  e5940000          LDR      r0,[r4,#0]
000010  e5900004          LDR      r0,[r0,#4]
000014  e3500000          CMP      r0,#0
000018  0a000006          BEQ      |L20.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f30dc          ADR      r3,|L20.260|
000024  e3a02f7b          MOV      r2,#0x1ec
000028  e28f10f4          ADR      r1,|L20.292|
00002c  e28f0e11          ADR      r0,|L20.324|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L20.56|
000038  e1a00000          MOV      r0,r0
;;;493    
;;;494      /* Allocate a PCB for this connection */
;;;495      switch(NETCONNTYPE_GROUP(msg->conn->type)) {
00003c  e5940000          LDR      r0,[r4,#0]
000040  e5d00000          LDRB     r0,[r0,#0]
000044  e20000f0          AND      r0,r0,#0xf0
000048  e3500010          CMP      r0,#0x10
00004c  0a000018          BEQ      |L20.180|
000050  e3500020          CMP      r0,#0x20
000054  1a000024          BNE      |L20.236|
;;;496    #if LWIP_RAW
;;;497      case NETCONN_RAW:
;;;498        msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
;;;499        if(msg->conn->pcb.raw == NULL) {
;;;500          msg->err = ERR_MEM;
;;;501          break;
;;;502        }
;;;503        raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
;;;504        break;
;;;505    #endif /* LWIP_RAW */
;;;506    #if LWIP_UDP
;;;507      case NETCONN_UDP:
;;;508        msg->conn->pcb.udp = udp_new();
000058  ebfffffe          BL       udp_new
00005c  e5941000          LDR      r1,[r4,#0]
000060  e5810004          STR      r0,[r1,#4]
;;;509        if(msg->conn->pcb.udp == NULL) {
000064  e5940000          LDR      r0,[r4,#0]
000068  e5900004          LDR      r0,[r0,#4]
00006c  e3500000          CMP      r0,#0
000070  1a000002          BNE      |L20.128|
;;;510          msg->err = ERR_MEM;
000074  e3a000ff          MOV      r0,#0xff
000078  e5c40004          STRB     r0,[r4,#4]
;;;511          break;
00007c  ea00001e          B        |L20.252|
                  |L20.128|
;;;512        }
;;;513    #if LWIP_UDPLITE
;;;514        if (msg->conn->type==NETCONN_UDPLITE) {
;;;515          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
;;;516        }
;;;517    #endif /* LWIP_UDPLITE */
;;;518        if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
000080  e5940000          LDR      r0,[r4,#0]
000084  e5d00000          LDRB     r0,[r0,#0]
000088  e3500022          CMP      r0,#0x22
00008c  1a000003          BNE      |L20.160|
;;;519          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
000090  e3a00001          MOV      r0,#1
000094  e5941000          LDR      r1,[r4,#0]
000098  e5911004          LDR      r1,[r1,#4]
00009c  e5c10010          STRB     r0,[r1,#0x10]
                  |L20.160|
;;;520        }
;;;521        udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
0000a0  e5942000          LDR      r2,[r4,#0]
0000a4  e59f10c0          LDR      r1,|L20.364|
0000a8  e5920004          LDR      r0,[r2,#4]
0000ac  ebfffffe          BL       udp_recv
;;;522        break;
0000b0  ea000011          B        |L20.252|
                  |L20.180|
;;;523    #endif /* LWIP_UDP */
;;;524    #if LWIP_TCP
;;;525      case NETCONN_TCP:
0000b4  e1a00000          MOV      r0,r0
;;;526        msg->conn->pcb.tcp = tcp_new();
0000b8  ebfffffe          BL       tcp_new
0000bc  e5941000          LDR      r1,[r4,#0]
0000c0  e5810004          STR      r0,[r1,#4]
;;;527        if(msg->conn->pcb.tcp == NULL) {
0000c4  e5940000          LDR      r0,[r4,#0]
0000c8  e5900004          LDR      r0,[r0,#4]
0000cc  e3500000          CMP      r0,#0
0000d0  1a000002          BNE      |L20.224|
;;;528          msg->err = ERR_MEM;
0000d4  e3a000ff          MOV      r0,#0xff
0000d8  e5c40004          STRB     r0,[r4,#4]
;;;529          break;
0000dc  ea000006          B        |L20.252|
                  |L20.224|
;;;530        }
;;;531        setup_tcp(msg->conn);
0000e0  e5940000          LDR      r0,[r4,#0]
0000e4  ebfffffe          BL       setup_tcp
;;;532        break;
0000e8  ea000003          B        |L20.252|
                  |L20.236|
;;;533    #endif /* LWIP_TCP */
;;;534      default:
0000ec  e1a00000          MOV      r0,r0
;;;535        /* Unsupported netconn type, e.g. protocol disabled */
;;;536        msg->err = ERR_VAL;
0000f0  e3a000fa          MOV      r0,#0xfa
0000f4  e5c40004          STRB     r0,[r4,#4]
;;;537        break;
0000f8  e1a00000          MOV      r0,r0
                  |L20.252|
0000fc  e1a00000          MOV      r0,r0                 ;511
;;;538      }
;;;539    }
000100  e8bd8010          POP      {r4,pc}
;;;540    
                          ENDP

                  |L20.260|
000104  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
000108  2d312e34
00010c  2e315c73
000110  72635c61
000114  70695c61
000118  70695f6d
00011c  73672e63
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L20.292|
000124  7063625f          DCB      "pcb_new: pcb already allocated",0
000128  6e65773a
00012c  20706362
000130  20616c72
000134  65616479
000138  20616c6c
00013c  6f636174
000140  656400  
000143  00                DCB      0
                  |L20.324|
000144  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000148  7274696f
00014c  6e202225
000150  73222066
000154  61696c65
000158  64206174
00015c  206c696e
000160  65202564
000164  20696e20
000168  25730a00
                  |L20.364|
                          DCD      recv_udp

                          AREA ||i.poll_tcp||, CODE, READONLY, ALIGN=2

                  poll_tcp PROC
;;;276    static err_t
;;;277    poll_tcp(void *arg, struct tcp_pcb *pcb)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;278    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;279      struct netconn *conn = (struct netconn *)arg;
00000c  e1a04005          MOV      r4,r5
;;;280    
;;;281      LWIP_UNUSED_ARG(pcb);
;;;282      LWIP_ASSERT("conn != NULL", (conn != NULL));
000010  e1a00000          MOV      r0,r0
000014  e3540000          CMP      r4,#0
000018  1a000006          BNE      |L21.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f30b0          ADR      r3,|L21.216|
000024  e59f20cc          LDR      r2,|L21.248|
000028  e28f10cc          ADR      r1,|L21.252|
00002c  e28f00d8          ADR      r0,|L21.268|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L21.56|
000038  e1a00000          MOV      r0,r0
;;;283    
;;;284      if (conn->state == NETCONN_WRITE) {
00003c  e5d40001          LDRB     r0,[r4,#1]
000040  e3500001          CMP      r0,#1
000044  1a000002          BNE      |L21.84|
;;;285        do_writemore(conn);
000048  e1a00004          MOV      r0,r4
00004c  ebfffffe          BL       do_writemore
000050  ea000004          B        |L21.104|
                  |L21.84|
;;;286      } else if (conn->state == NETCONN_CLOSE) {
000054  e5d40001          LDRB     r0,[r4,#1]
000058  e3500004          CMP      r0,#4
00005c  1a000001          BNE      |L21.104|
;;;287        do_close_internal(conn);
000060  e1a00004          MOV      r0,r4
000064  ebfffffe          BL       do_close_internal
                  |L21.104|
;;;288      }
;;;289      /* @todo: implement connect timeout here? */
;;;290    
;;;291      /* Did a nonblocking write fail before? Then check available write-space. */
;;;292      if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
000068  e5d4001c          LDRB     r0,[r4,#0x1c]
00006c  e2000010          AND      r0,r0,#0x10
000070  e3500000          CMP      r0,#0
000074  0a000015          BEQ      |L21.208|
;;;293        /* If the queued byte- or pbuf-count drops below the configured low-water limit,
;;;294           let select mark this pcb as writable again. */
;;;295        if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
000078  e5940004          LDR      r0,[r4,#4]
00007c  e3500000          CMP      r0,#0
000080  0a000012          BEQ      |L21.208|
000084  e5940004          LDR      r0,[r4,#4]
000088  e1d006b6          LDRH     r0,[r0,#0x66]
00008c  e3500e43          CMP      r0,#0x430
000090  ba00000e          BLT      |L21.208|
;;;296          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
000094  e5940004          LDR      r0,[r4,#4]
000098  e1d006b8          LDRH     r0,[r0,#0x68]
00009c  e3500005          CMP      r0,#5
0000a0  aa00000a          BGE      |L21.208|
;;;297          conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
0000a4  e5d4001c          LDRB     r0,[r4,#0x1c]
0000a8  e3c00010          BIC      r0,r0,#0x10
0000ac  e5c4001c          STRB     r0,[r4,#0x1c]
;;;298          API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
0000b0  e5940028          LDR      r0,[r4,#0x28]
0000b4  e3500000          CMP      r0,#0
0000b8  0a000004          BEQ      |L21.208|
0000bc  e3a02000          MOV      r2,#0
0000c0  e3a01002          MOV      r1,#2
0000c4  e5943028          LDR      r3,[r4,#0x28]
0000c8  e1a00004          MOV      r0,r4
0000cc  e12fff33          BLX      r3
                  |L21.208|
;;;299        }
;;;300      }
;;;301    
;;;302      return ERR_OK;
0000d0  e3a00000          MOV      r0,#0
;;;303    }
0000d4  e8bd8070          POP      {r4-r6,pc}
;;;304    
                          ENDP

                  |L21.216|
0000d8  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
0000dc  2d312e34
0000e0  2e315c73
0000e4  72635c61
0000e8  70695c61
0000ec  70695f6d
0000f0  73672e63
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L21.248|
                          DCD      0x0000011a
                  |L21.252|
0000fc  636f6e6e          DCB      "conn != NULL",0
000100  20213d20
000104  4e554c4c
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0
                  |L21.268|
00010c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000110  7274696f
000114  6e202225
000118  73222066
00011c  61696c65
000120  64206174
000124  206c696e
000128  65202564
00012c  20696e20
000130  25730a00

                          AREA ||i.recv_tcp||, CODE, READONLY, ALIGN=2

                  recv_tcp PROC
;;;215    static err_t
;;;216    recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;217    {
000004  e1a07000          MOV      r7,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a05002          MOV      r5,r2
000010  e1a09003          MOV      r9,r3
;;;218      struct netconn *conn;
;;;219      u16_t len;
;;;220    
;;;221      LWIP_UNUSED_ARG(pcb);
;;;222      LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
000014  e1a00000          MOV      r0,r0
000018  e3560000          CMP      r6,#0
00001c  1a000006          BNE      |L22.60|
000020  e1a00000          MOV      r0,r0
000024  e28f3f4e          ADR      r3,|L22.356|
000028  e3a020de          MOV      r2,#0xde
00002c  e28f1e15          ADR      r1,|L22.388|
000030  e28f0e17          ADR      r0,|L22.424|
000034  ebfffffe          BL       sysprintf
000038  e1a00000          MOV      r0,r0
                  |L22.60|
00003c  e1a00000          MOV      r0,r0
;;;223      LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
000040  e1a00000          MOV      r0,r0
000044  e3570000          CMP      r7,#0
000048  1a000006          BNE      |L22.104|
00004c  e1a00000          MOV      r0,r0
000050  e28f3f43          ADR      r3,|L22.356|
000054  e3a020df          MOV      r2,#0xdf
000058  e28f1e17          ADR      r1,|L22.464|
00005c  e28f0f51          ADR      r0,|L22.424|
000060  ebfffffe          BL       sysprintf
000064  e1a00000          MOV      r0,r0
                  |L22.104|
000068  e1a00000          MOV      r0,r0
;;;224      conn = (struct netconn *)arg;
00006c  e1a04007          MOV      r4,r7
;;;225      LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
000070  e1a00000          MOV      r0,r0
000074  e5940004          LDR      r0,[r4,#4]
000078  e1500006          CMP      r0,r6
00007c  0a000006          BEQ      |L22.156|
000080  e1a00000          MOV      r0,r0
000084  e28f30d8          ADR      r3,|L22.356|
000088  e3a020e1          MOV      r2,#0xe1
00008c  e28f1f57          ADR      r1,|L22.496|
000090  e28f0e11          ADR      r0,|L22.424|
000094  ebfffffe          BL       sysprintf
000098  e1a00000          MOV      r0,r0
                  |L22.156|
00009c  e1a00000          MOV      r0,r0
;;;226    
;;;227      if (conn == NULL) {
0000a0  e3540000          CMP      r4,#0
0000a4  1a000001          BNE      |L22.176|
;;;228        return ERR_VAL;
0000a8  e3e00005          MVN      r0,#5
                  |L22.172|
;;;229      }
;;;230      if (!sys_mbox_valid(&conn->recvmbox)) {
;;;231        /* recvmbox already deleted */
;;;232        if (p != NULL) {
;;;233          tcp_recved(pcb, p->tot_len);
;;;234          pbuf_free(p);
;;;235        }
;;;236        return ERR_OK;
;;;237      }
;;;238      /* Unlike for UDP or RAW pcbs, don't check for available space
;;;239         using recv_avail since that could break the connection
;;;240         (data is already ACKed) */
;;;241    
;;;242      /* don't overwrite fatal errors! */
;;;243      NETCONN_SET_SAFE_ERR(conn, err);
;;;244    
;;;245      if (p != NULL) {
;;;246        len = p->tot_len;
;;;247      } else {
;;;248        len = 0;
;;;249      }
;;;250    
;;;251      if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
;;;252        /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
;;;253        return ERR_MEM;
;;;254      } else {
;;;255    #if LWIP_SO_RCVBUF
;;;256        SYS_ARCH_INC(conn->recv_avail, len);
;;;257    #endif /* LWIP_SO_RCVBUF */
;;;258        /* Register event with callback */
;;;259        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;260      }
;;;261    
;;;262      return ERR_OK;
;;;263    }
0000ac  e8bd87f0          POP      {r4-r10,pc}
                  |L22.176|
0000b0  e2840010          ADD      r0,r4,#0x10           ;230
0000b4  ebfffffe          BL       sys_mbox_valid
0000b8  e3500000          CMP      r0,#0                 ;230
0000bc  1a000008          BNE      |L22.228|
0000c0  e3550000          CMP      r5,#0                 ;232
0000c4  0a000004          BEQ      |L22.220|
0000c8  e1d510b8          LDRH     r1,[r5,#8]            ;233
0000cc  e1a00006          MOV      r0,r6                 ;233
0000d0  ebfffffe          BL       tcp_recved
0000d4  e1a00005          MOV      r0,r5                 ;234
0000d8  ebfffffe          BL       pbuf_free
                  |L22.220|
0000dc  e3a00000          MOV      r0,#0                 ;236
0000e0  eafffff1          B        |L22.172|
                  |L22.228|
0000e4  e1a00000          MOV      r0,r0                 ;243
0000e8  ebfffffe          BL       sys_arch_protect
0000ec  e1a0a000          MOV      r10,r0                ;243
0000f0  e1d400d8          LDRSB    r0,[r4,#8]            ;243
0000f4  e3700009          CMN      r0,#9                 ;243
0000f8  ba000000          BLT      |L22.256|
0000fc  e5c49008          STRB     r9,[r4,#8]            ;243
                  |L22.256|
000100  e1a0000a          MOV      r0,r10                ;243
000104  ebfffffe          BL       sys_arch_unprotect
000108  e1a00000          MOV      r0,r0                 ;243
00010c  e3550000          CMP      r5,#0                 ;245
000110  0a000001          BEQ      |L22.284|
000114  e1d580b8          LDRH     r8,[r5,#8]            ;246
000118  ea000000          B        |L22.288|
                  |L22.284|
00011c  e3a08000          MOV      r8,#0                 ;248
                  |L22.288|
000120  e1a01005          MOV      r1,r5                 ;251
000124  e2840010          ADD      r0,r4,#0x10           ;251
000128  ebfffffe          BL       sys_mbox_trypost
00012c  e3500000          CMP      r0,#0                 ;251
000130  0a000001          BEQ      |L22.316|
000134  e3e00000          MVN      r0,#0                 ;253
000138  eaffffdb          B        |L22.172|
                  |L22.316|
00013c  e5940028          LDR      r0,[r4,#0x28]         ;259
000140  e3500000          CMP      r0,#0                 ;259
000144  0a000004          BEQ      |L22.348|
000148  e1a02008          MOV      r2,r8                 ;259
00014c  e3a01000          MOV      r1,#0                 ;259
000150  e5943028          LDR      r3,[r4,#0x28]         ;259
000154  e1a00004          MOV      r0,r4                 ;259
000158  e12fff33          BLX      r3                    ;259
                  |L22.348|
00015c  e3a00000          MOV      r0,#0                 ;262
000160  eaffffd1          B        |L22.172|
;;;264    
                          ENDP

                  |L22.356|
000164  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
000168  2d312e34
00016c  2e315c73
000170  72635c61
000174  70695c61
000178  70695f6d
00017c  73672e63
000180  00      
000181  00                DCB      0
000182  00                DCB      0
000183  00                DCB      0
                  |L22.388|
000184  72656376          DCB      "recv_tcp must have a pcb argument",0
000188  5f746370
00018c  206d7573
000190  74206861
000194  76652061
000198  20706362
00019c  20617267
0001a0  756d656e
0001a4  7400    
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L22.424|
0001a8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001ac  7274696f
0001b0  6e202225
0001b4  73222066
0001b8  61696c65
0001bc  64206174
0001c0  206c696e
0001c4  65202564
0001c8  20696e20
0001cc  25730a00
                  |L22.464|
0001d0  72656376          DCB      "recv_tcp must have an argument",0
0001d4  5f746370
0001d8  206d7573
0001dc  74206861
0001e0  76652061
0001e4  6e206172
0001e8  67756d65
0001ec  6e7400  
0001ef  00                DCB      0
                  |L22.496|
0001f0  72656376          DCB      "recv_tcp: recv for wrong pcb!",0
0001f4  5f746370
0001f8  3a207265
0001fc  63762066
000200  6f722077
000204  726f6e67
000208  20706362
00020c  2100    
00020e  00                DCB      0
00020f  00                DCB      0

                          AREA ||i.recv_udp||, CODE, READONLY, ALIGN=2

                  recv_udp PROC
;;;143    static void
;;;144    recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;145       ip_addr_t *addr, u16_t port)
;;;146    {
000004  e1a07000          MOV      r7,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a06002          MOV      r6,r2
000010  e1a09003          MOV      r9,r3
000014  e59db028          LDR      r11,[sp,#0x28]
;;;147      struct netbuf *buf;
;;;148      struct netconn *conn;
;;;149      u16_t len;
;;;150    #if LWIP_SO_RCVBUF
;;;151      int recv_avail;
;;;152    #endif /* LWIP_SO_RCVBUF */
;;;153    
;;;154      LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
;;;155      LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
000018  e1a00000          MOV      r0,r0
00001c  e3580000          CMP      r8,#0
000020  1a000006          BNE      |L23.64|
000024  e1a00000          MOV      r0,r0
000028  e28f3f4a          ADR      r3,|L23.344|
00002c  e3a0209b          MOV      r2,#0x9b
000030  e28f1d05          ADR      r1,|L23.376|
000034  e28f0e16          ADR      r0,|L23.412|
000038  ebfffffe          BL       sysprintf
00003c  e1a00000          MOV      r0,r0
                  |L23.64|
000040  e1a00000          MOV      r0,r0
;;;156      LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
000044  e1a00000          MOV      r0,r0
000048  e3570000          CMP      r7,#0
00004c  1a000006          BNE      |L23.108|
000050  e1a00000          MOV      r0,r0
000054  e28f30fc          ADR      r3,|L23.344|
000058  e3a0209c          MOV      r2,#0x9c
00005c  e28f1e16          ADR      r1,|L23.452|
000060  e28f0f4d          ADR      r0,|L23.412|
000064  ebfffffe          BL       sysprintf
000068  e1a00000          MOV      r0,r0
                  |L23.108|
00006c  e1a00000          MOV      r0,r0
;;;157      conn = (struct netconn *)arg;
000070  e1a05007          MOV      r5,r7
;;;158      LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
000074  e1a00000          MOV      r0,r0
000078  e5950004          LDR      r0,[r5,#4]
00007c  e1500008          CMP      r0,r8
000080  0a000006          BEQ      |L23.160|
000084  e1a00000          MOV      r0,r0
000088  e28f30c8          ADR      r3,|L23.344|
00008c  e3a0209e          MOV      r2,#0x9e
000090  e28f1f53          ADR      r1,|L23.484|
000094  e28f0c01          ADR      r0,|L23.412|
000098  ebfffffe          BL       sysprintf
00009c  e1a00000          MOV      r0,r0
                  |L23.160|
0000a0  e1a00000          MOV      r0,r0
;;;159    
;;;160    #if LWIP_SO_RCVBUF
;;;161      SYS_ARCH_GET(conn->recv_avail, recv_avail);
;;;162      if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
;;;163          ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
;;;164    #else  /* LWIP_SO_RCVBUF */
;;;165      if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
0000a4  e3550000          CMP      r5,#0
0000a8  0a000003          BEQ      |L23.188|
0000ac  e2850010          ADD      r0,r5,#0x10
0000b0  ebfffffe          BL       sys_mbox_valid
0000b4  e3500000          CMP      r0,#0
0000b8  1a000002          BNE      |L23.200|
                  |L23.188|
;;;166    #endif /* LWIP_SO_RCVBUF */
;;;167        pbuf_free(p);
0000bc  e1a00006          MOV      r0,r6
0000c0  ebfffffe          BL       pbuf_free
                  |L23.196|
;;;168        return;
;;;169      }
;;;170    
;;;171      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
;;;172      if (buf == NULL) {
;;;173        pbuf_free(p);
;;;174        return;
;;;175      } else {
;;;176        buf->p = p;
;;;177        buf->ptr = p;
;;;178        ip_addr_set(&buf->addr, addr);
;;;179        buf->port = port;
;;;180    #if LWIP_NETBUF_RECVINFO
;;;181        {
;;;182          const struct ip_hdr* iphdr = ip_current_header();
;;;183          /* get the UDP header - always in the first pbuf, ensured by udp_input */
;;;184          const struct udp_hdr* udphdr = (void*)(((char*)iphdr) + IPH_LEN(iphdr));
;;;185    #if LWIP_CHECKSUM_ON_COPY
;;;186          buf->flags = NETBUF_FLAG_DESTADDR;
;;;187    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;188          ip_addr_set(&buf->toaddr, ip_current_dest_addr());
;;;189          buf->toport_chksum = udphdr->dest;
;;;190        }
;;;191    #endif /* LWIP_NETBUF_RECVINFO */
;;;192      }
;;;193    
;;;194      len = p->tot_len;
;;;195      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
;;;196        netbuf_delete(buf);
;;;197        return;
;;;198      } else {
;;;199    #if LWIP_SO_RCVBUF
;;;200        SYS_ARCH_INC(conn->recv_avail, len);
;;;201    #endif /* LWIP_SO_RCVBUF */
;;;202        /* Register event with callback */
;;;203        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;204      }
;;;205    }
0000c4  e8bd9ff0          POP      {r4-r12,pc}
                  |L23.200|
0000c8  e3a00005          MOV      r0,#5                 ;171
0000cc  ebfffffe          BL       memp_malloc
0000d0  e1a04000          MOV      r4,r0                 ;171
0000d4  e3540000          CMP      r4,#0                 ;172
0000d8  1a000002          BNE      |L23.232|
0000dc  e1a00006          MOV      r0,r6                 ;173
0000e0  ebfffffe          BL       pbuf_free
0000e4  eafffff6          B        |L23.196|
                  |L23.232|
0000e8  e5846000          STR      r6,[r4,#0]            ;176
0000ec  e5846004          STR      r6,[r4,#4]            ;177
0000f0  e3590000          CMP      r9,#0                 ;178
0000f4  1a000001          BNE      |L23.256|
0000f8  e3a00000          MOV      r0,#0                 ;178
0000fc  ea000000          B        |L23.260|
                  |L23.256|
000100  e5990000          LDR      r0,[r9,#0]            ;178
                  |L23.260|
000104  e5840008          STR      r0,[r4,#8]            ;178
000108  e1c4b0bc          STRH     r11,[r4,#0xc]         ;179
00010c  e1d6a0b8          LDRH     r10,[r6,#8]           ;194
000110  e1a01004          MOV      r1,r4                 ;195
000114  e2850010          ADD      r0,r5,#0x10           ;195
000118  ebfffffe          BL       sys_mbox_trypost
00011c  e3500000          CMP      r0,#0                 ;195
000120  0a000002          BEQ      |L23.304|
000124  e1a00004          MOV      r0,r4                 ;196
000128  ebfffffe          BL       netbuf_delete
00012c  eaffffe4          B        |L23.196|
                  |L23.304|
000130  e5950028          LDR      r0,[r5,#0x28]         ;203
000134  e3500000          CMP      r0,#0                 ;203
000138  0a000004          BEQ      |L23.336|
00013c  e1a0200a          MOV      r2,r10                ;203
000140  e3a01000          MOV      r1,#0                 ;203
000144  e5953028          LDR      r3,[r5,#0x28]         ;203
000148  e1a00005          MOV      r0,r5                 ;203
00014c  e12fff33          BLX      r3                    ;203
                  |L23.336|
000150  e1a00000          MOV      r0,r0
000154  eaffffda          B        |L23.196|
;;;206    #endif /* LWIP_UDP */
                          ENDP

                  |L23.344|
000158  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
00015c  2d312e34
000160  2e315c73
000164  72635c61
000168  70695c61
00016c  70695f6d
000170  73672e63
000174  00      
000175  00                DCB      0
000176  00                DCB      0
000177  00                DCB      0
                  |L23.376|
000178  72656376          DCB      "recv_udp must have a pcb argument",0
00017c  5f756470
000180  206d7573
000184  74206861
000188  76652061
00018c  20706362
000190  20617267
000194  756d656e
000198  7400    
00019a  00                DCB      0
00019b  00                DCB      0
                  |L23.412|
00019c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001a0  7274696f
0001a4  6e202225
0001a8  73222066
0001ac  61696c65
0001b0  64206174
0001b4  206c696e
0001b8  65202564
0001bc  20696e20
0001c0  25730a00
                  |L23.452|
0001c4  72656376          DCB      "recv_udp must have an argument",0
0001c8  5f756470
0001cc  206d7573
0001d0  74206861
0001d4  76652061
0001d8  6e206172
0001dc  67756d65
0001e0  6e7400  
0001e3  00                DCB      0
                  |L23.484|
0001e4  72656376          DCB      "recv_udp: recv for wrong pcb!",0
0001e8  5f756470
0001ec  3a207265
0001f0  63762066
0001f4  6f722077
0001f8  726f6e67
0001fc  20706362
000200  2100    
000202  00                DCB      0
000203  00                DCB      0

                          AREA ||i.sent_tcp||, CODE, READONLY, ALIGN=2

                  sent_tcp PROC
;;;312    static err_t
;;;313    sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;314    {
000004  e1a05000          MOV      r5,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a06002          MOV      r6,r2
;;;315      struct netconn *conn = (struct netconn *)arg;
000010  e1a04005          MOV      r4,r5
;;;316    
;;;317      LWIP_UNUSED_ARG(pcb);
;;;318      LWIP_ASSERT("conn != NULL", (conn != NULL));
000014  e1a00000          MOV      r0,r0
000018  e3540000          CMP      r4,#0
00001c  1a000006          BNE      |L24.60|
000020  e1a00000          MOV      r0,r0
000024  e28f30a8          ADR      r3,|L24.212|
000028  e59f20c4          LDR      r2,|L24.244|
00002c  e28f10c4          ADR      r1,|L24.248|
000030  e28f00d0          ADR      r0,|L24.264|
000034  ebfffffe          BL       sysprintf
000038  e1a00000          MOV      r0,r0
                  |L24.60|
00003c  e1a00000          MOV      r0,r0
;;;319    
;;;320      if (conn->state == NETCONN_WRITE) {
000040  e5d40001          LDRB     r0,[r4,#1]
000044  e3500001          CMP      r0,#1
000048  1a000002          BNE      |L24.88|
;;;321        do_writemore(conn);
00004c  e1a00004          MOV      r0,r4
000050  ebfffffe          BL       do_writemore
000054  ea000004          B        |L24.108|
                  |L24.88|
;;;322      } else if (conn->state == NETCONN_CLOSE) {
000058  e5d40001          LDRB     r0,[r4,#1]
00005c  e3500004          CMP      r0,#4
000060  1a000001          BNE      |L24.108|
;;;323        do_close_internal(conn);
000064  e1a00004          MOV      r0,r4
000068  ebfffffe          BL       do_close_internal
                  |L24.108|
;;;324      }
;;;325    
;;;326      if (conn) {
00006c  e3540000          CMP      r4,#0
000070  0a000015          BEQ      |L24.204|
;;;327        /* If the queued byte- or pbuf-count drops below the configured low-water limit,
;;;328           let select mark this pcb as writable again. */
;;;329        if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
000074  e5940004          LDR      r0,[r4,#4]
000078  e3500000          CMP      r0,#0
00007c  0a000012          BEQ      |L24.204|
000080  e5940004          LDR      r0,[r4,#4]
000084  e1d006b6          LDRH     r0,[r0,#0x66]
000088  e3500e43          CMP      r0,#0x430
00008c  ba00000e          BLT      |L24.204|
;;;330          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
000090  e5940004          LDR      r0,[r4,#4]
000094  e1d006b8          LDRH     r0,[r0,#0x68]
000098  e3500005          CMP      r0,#5
00009c  aa00000a          BGE      |L24.204|
;;;331          conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
0000a0  e5d4001c          LDRB     r0,[r4,#0x1c]
0000a4  e3c00010          BIC      r0,r0,#0x10
0000a8  e5c4001c          STRB     r0,[r4,#0x1c]
;;;332          API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
0000ac  e5940028          LDR      r0,[r4,#0x28]
0000b0  e3500000          CMP      r0,#0
0000b4  0a000004          BEQ      |L24.204|
0000b8  e1a02006          MOV      r2,r6
0000bc  e3a01002          MOV      r1,#2
0000c0  e5943028          LDR      r3,[r4,#0x28]
0000c4  e1a00004          MOV      r0,r4
0000c8  e12fff33          BLX      r3
                  |L24.204|
;;;333        }
;;;334      }
;;;335      
;;;336      return ERR_OK;
0000cc  e3a00000          MOV      r0,#0
;;;337    }
0000d0  e8bd81f0          POP      {r4-r8,pc}
;;;338    
                          ENDP

                  |L24.212|
0000d4  6c776970          DCB      "lwip-1.4.1\\src\\api\\api_msg.c",0
0000d8  2d312e34
0000dc  2e315c73
0000e0  72635c61
0000e4  70695c61
0000e8  70695f6d
0000ec  73672e63
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L24.244|
                          DCD      0x0000013e
                  |L24.248|
0000f8  636f6e6e          DCB      "conn != NULL",0
0000fc  20213d20
000100  4e554c4c
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L24.264|
000108  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00010c  7274696f
000110  6e202225
000114  73222066
000118  61696c65
00011c  64206174
000120  206c696e
000124  65202564
000128  20696e20
00012c  25730a00

                          AREA ||i.setup_tcp||, CODE, READONLY, ALIGN=2

                  setup_tcp PROC
;;;412    static void
;;;413    setup_tcp(struct netconn *conn)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;414    {
000004  e1a04000          MOV      r4,r0
;;;415      struct tcp_pcb *pcb;
;;;416    
;;;417      pcb = conn->pcb.tcp;
000008  e5945004          LDR      r5,[r4,#4]
;;;418      tcp_arg(pcb, conn);
00000c  e1a01004          MOV      r1,r4
000010  e1a00005          MOV      r0,r5
000014  ebfffffe          BL       tcp_arg
;;;419      tcp_recv(pcb, recv_tcp);
000018  e59f1030          LDR      r1,|L25.80|
00001c  e1a00005          MOV      r0,r5
000020  ebfffffe          BL       tcp_recv
;;;420      tcp_sent(pcb, sent_tcp);
000024  e59f1028          LDR      r1,|L25.84|
000028  e1a00005          MOV      r0,r5
00002c  ebfffffe          BL       tcp_sent
;;;421      tcp_poll(pcb, poll_tcp, 4);
000030  e3a02004          MOV      r2,#4
000034  e59f101c          LDR      r1,|L25.88|
000038  e1a00005          MOV      r0,r5
00003c  ebfffffe          BL       tcp_poll
;;;422      tcp_err(pcb, err_tcp);
000040  e59f1014          LDR      r1,|L25.92|
000044  e1a00005          MOV      r0,r5
000048  ebfffffe          BL       tcp_err
;;;423    }
00004c  e8bd8070          POP      {r4-r6,pc}
;;;424    
                          ENDP

                  |L25.80|
                          DCD      recv_tcp
                  |L25.84|
                          DCD      sent_tcp
                  |L25.88|
                          DCD      poll_tcp
                  |L25.92|
                          DCD      err_tcp
