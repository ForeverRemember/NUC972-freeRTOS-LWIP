; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\heap_2.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\heap_2.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\heap_2.crf FreeRTOS\Source\portable\MemMang\heap_2.c]
                          ARM

                          AREA ||i.prvHeapInit||, CODE, READONLY, ALIGN=2

                  prvHeapInit PROC
;;;290    
;;;291    static void prvHeapInit( void )
000000  e59f2040          LDR      r2,|L1.72|
;;;292    {
;;;293    BlockLink_t *pxFirstFreeBlock;
;;;294    uint8_t *pucAlignedHeap;
;;;295    
;;;296    	/* Ensure the heap starts on a correctly aligned boundary. */
;;;297    	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
000004  e3c20007          BIC      r0,r2,#7
;;;298    
;;;299    	/* xStart is used to hold a pointer to the first item in the list of free
;;;300    	blocks.  The void cast is used to prevent compiler warnings. */
;;;301    	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
000008  e59f203c          LDR      r2,|L1.76|
00000c  e5820000          STR      r0,[r2,#0]  ; xStart
;;;302    	xStart.xBlockSize = ( size_t ) 0;
000010  e3a02000          MOV      r2,#0
000014  e59f3030          LDR      r3,|L1.76|
000018  e5832004          STR      r2,[r3,#4]  ; xStart
;;;303    
;;;304    	/* xEnd is used to mark the end of the list of free blocks. */
;;;305    	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
00001c  e59f202c          LDR      r2,|L1.80|
000020  e59f302c          LDR      r3,|L1.84|
000024  e5832004          STR      r2,[r3,#4]  ; xEnd
;;;306    	xEnd.pxNextFreeBlock = NULL;
000028  e3a02000          MOV      r2,#0
00002c  e5832000          STR      r2,[r3,#0]  ; xEnd
;;;307    
;;;308    	/* To start with there is a single free block that is sized to take up the
;;;309    	entire heap space. */
;;;310    	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
000030  e1a01000          MOV      r1,r0
;;;311    	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
000034  e59f2014          LDR      r2,|L1.80|
000038  e5812004          STR      r2,[r1,#4]
;;;312    	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
00003c  e2832000          ADD      r2,r3,#0
000040  e5812000          STR      r2,[r1,#0]
;;;313    }
000044  e12fff1e          BX       lr
;;;314    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.72|
                          DCD      ucHeap+0x8
                  |L1.76|
                          DCD      xStart
                  |L1.80|
                          DCD      0x000033f8
                  |L1.84|
                          DCD      xEnd

                          AREA ||i.pvPortMalloc||, CODE, READONLY, ALIGN=2

                  pvPortMalloc PROC
;;;159    
;;;160    void *pvPortMalloc( size_t xWantedSize )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;161    {
000004  e1a04000          MOV      r4,r0
;;;162    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;163    static BaseType_t xHeapHasBeenInitialised = pdFALSE;
;;;164    void *pvReturn = NULL;
000008  e3a08000          MOV      r8,#0
;;;165    
;;;166    	vTaskSuspendAll();
00000c  ebfffffe          BL       vTaskSuspendAll
;;;167    	{
;;;168    		/* If this is the first call to malloc then the heap will require
;;;169    		initialisation to setup the list of free blocks. */
;;;170    		if( xHeapHasBeenInitialised == pdFALSE )
000010  e59f0114          LDR      r0,|L2.300|
000014  e5900000          LDR      r0,[r0,#0]  ; xHeapHasBeenInitialised
000018  e3500000          CMP      r0,#0
00001c  1a000003          BNE      |L2.48|
;;;171    		{
;;;172    			prvHeapInit();
000020  ebfffffe          BL       prvHeapInit
;;;173    			xHeapHasBeenInitialised = pdTRUE;
000024  e3a00001          MOV      r0,#1
000028  e59f10fc          LDR      r1,|L2.300|
00002c  e5810000          STR      r0,[r1,#0]  ; xHeapHasBeenInitialised
                  |L2.48|
;;;174    		}
;;;175    
;;;176    		/* The wanted size is increased so it can contain a BlockLink_t
;;;177    		structure in addition to the requested amount of bytes. */
;;;178    		if( xWantedSize > 0 )
000030  e3540000          CMP      r4,#0
000034  0a000006          BEQ      |L2.84|
;;;179    		{
;;;180    			xWantedSize += heapSTRUCT_SIZE;
000038  e2844008          ADD      r4,r4,#8
;;;181    
;;;182    			/* Ensure that blocks are always aligned to the required number of bytes. */
;;;183    			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
00003c  e2040007          AND      r0,r4,#7
000040  e3500000          CMP      r0,#0
000044  0a000002          BEQ      |L2.84|
;;;184    			{
;;;185    				/* Byte alignment required. */
;;;186    				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
000048  e2040007          AND      r0,r4,#7
00004c  e2600008          RSB      r0,r0,#8
000050  e0844000          ADD      r4,r4,r0
                  |L2.84|
;;;187    			}
;;;188    		}
;;;189    
;;;190    		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
000054  e3540000          CMP      r4,#0
000058  0a000030          BEQ      |L2.288|
00005c  e59f00cc          LDR      r0,|L2.304|
000060  e1540000          CMP      r4,r0
000064  2a00002d          BCS      |L2.288|
;;;191    		{
;;;192    			/* Blocks are stored in byte order - traverse the list from the start
;;;193    			(smallest) block until one of adequate size is found. */
;;;194    			pxPreviousBlock = &xStart;
000068  e59f70c4          LDR      r7,|L2.308|
;;;195    			pxBlock = xStart.pxNextFreeBlock;
00006c  e2870000          ADD      r0,r7,#0
000070  e5905000          LDR      r5,[r0,#0]  ; xStart
;;;196    			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
000074  ea000001          B        |L2.128|
                  |L2.120|
;;;197    			{
;;;198    				pxPreviousBlock = pxBlock;
000078  e1a07005          MOV      r7,r5
;;;199    				pxBlock = pxBlock->pxNextFreeBlock;
00007c  e5955000          LDR      r5,[r5,#0]
                  |L2.128|
000080  e5950004          LDR      r0,[r5,#4]            ;196
000084  e1500004          CMP      r0,r4                 ;196
000088  2a000002          BCS      |L2.152|
00008c  e5950000          LDR      r0,[r5,#0]            ;196
000090  e3500000          CMP      r0,#0                 ;196
000094  1afffff7          BNE      |L2.120|
                  |L2.152|
;;;200    			}
;;;201    
;;;202    			/* If we found the end marker then a block of adequate size was not found. */
;;;203    			if( pxBlock != &xEnd )
000098  e59f0098          LDR      r0,|L2.312|
00009c  e1550000          CMP      r5,r0
0000a0  0a00001e          BEQ      |L2.288|
;;;204    			{
;;;205    				/* Return the memory space - jumping over the BlockLink_t structure
;;;206    				at its start. */
;;;207    				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
0000a4  e5970000          LDR      r0,[r7,#0]
0000a8  e2808008          ADD      r8,r0,#8
;;;208    
;;;209    				/* This block is being returned for use so must be taken out of the
;;;210    				list of free blocks. */
;;;211    				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
0000ac  e5950000          LDR      r0,[r5,#0]
0000b0  e5870000          STR      r0,[r7,#0]
;;;212    
;;;213    				/* If the block is larger than required it can be split into two. */
;;;214    				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
0000b4  e5950004          LDR      r0,[r5,#4]
0000b8  e0400004          SUB      r0,r0,r4
0000bc  e3500010          CMP      r0,#0x10
0000c0  9a000010          BLS      |L2.264|
;;;215    				{
;;;216    					/* This block is to be split into two.  Create a new block
;;;217    					following the number of bytes requested. The void cast is
;;;218    					used to prevent byte alignment warnings from the compiler. */
;;;219    					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
0000c4  e0856004          ADD      r6,r5,r4
;;;220    
;;;221    					/* Calculate the sizes of two blocks split from the single
;;;222    					block. */
;;;223    					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
0000c8  e5950004          LDR      r0,[r5,#4]
0000cc  e0400004          SUB      r0,r0,r4
0000d0  e5860004          STR      r0,[r6,#4]
;;;224    					pxBlock->xBlockSize = xWantedSize;
0000d4  e5854004          STR      r4,[r5,#4]
;;;225    
;;;226    					/* Insert the new block into the list of free blocks. */
;;;227    					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
0000d8  e5961004          LDR      r1,[r6,#4]
0000dc  e59f0050          LDR      r0,|L2.308|
0000e0  ea000000          B        |L2.232|
                  |L2.228|
0000e4  e5900000          LDR      r0,[r0,#0]
                  |L2.232|
0000e8  e5902000          LDR      r2,[r0,#0]
0000ec  e5922004          LDR      r2,[r2,#4]
0000f0  e1520001          CMP      r2,r1
0000f4  3afffffa          BCC      |L2.228|
0000f8  e5902000          LDR      r2,[r0,#0]
0000fc  e5862000          STR      r2,[r6,#0]
000100  e5806000          STR      r6,[r0,#0]
000104  e1a00000          MOV      r0,r0
                  |L2.264|
;;;228    				}
;;;229    
;;;230    				xFreeBytesRemaining -= pxBlock->xBlockSize;
000108  e59f102c          LDR      r1,|L2.316|
00010c  e5950004          LDR      r0,[r5,#4]
000110  e5911000          LDR      r1,[r1,#0]  ; xFreeBytesRemaining
000114  e0410000          SUB      r0,r1,r0
000118  e59f101c          LDR      r1,|L2.316|
00011c  e5810000          STR      r0,[r1,#0]  ; xFreeBytesRemaining
                  |L2.288|
;;;231    			}
;;;232    		}
;;;233    
;;;234    		traceMALLOC( pvReturn, xWantedSize );
;;;235    	}
;;;236    	( void ) xTaskResumeAll();
000120  ebfffffe          BL       xTaskResumeAll
;;;237    
;;;238    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;239    	{
;;;240    		if( pvReturn == NULL )
;;;241    		{
;;;242    			extern void vApplicationMallocFailedHook( void );
;;;243    			vApplicationMallocFailedHook();
;;;244    		}
;;;245    	}
;;;246    	#endif
;;;247    
;;;248    	return pvReturn;
000124  e1a00008          MOV      r0,r8
;;;249    }
000128  e8bd81f0          POP      {r4-r8,pc}
;;;250    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.300|
                          DCD      xHeapHasBeenInitialised
                  |L2.304|
                          DCD      0x000033f8
                  |L2.308|
                          DCD      xStart
                  |L2.312|
                          DCD      xEnd
                  |L2.316|
                          DCD      xFreeBytesRemaining

                          AREA ||i.vPortFree||, CODE, READONLY, ALIGN=2

                  vPortFree PROC
;;;251    
;;;252    void vPortFree( void *pv )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;253    {
000004  e1a06000          MOV      r6,r0
;;;254    uint8_t *puc = ( uint8_t * ) pv;
000008  e1a05006          MOV      r5,r6
;;;255    BlockLink_t *pxLink;
;;;256    
;;;257    	if( pv != NULL )
00000c  e3560000          CMP      r6,#0
000010  0a000014          BEQ      |L3.104|
;;;258    	{
;;;259    		/* The memory being freed will have an BlockLink_t structure immediately
;;;260    		before it. */
;;;261    		puc -= heapSTRUCT_SIZE;
000014  e2455008          SUB      r5,r5,#8
;;;262    
;;;263    		/* This unexpected casting is to keep some compilers from issuing
;;;264    		byte alignment warnings. */
;;;265    		pxLink = ( void * ) puc;
000018  e1a04005          MOV      r4,r5
;;;266    
;;;267    		vTaskSuspendAll();
00001c  ebfffffe          BL       vTaskSuspendAll
;;;268    		{
;;;269    			/* Add this block to the list of free blocks. */
;;;270    			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
000020  e5941004          LDR      r1,[r4,#4]
000024  e59f0040          LDR      r0,|L3.108|
000028  ea000000          B        |L3.48|
                  |L3.44|
00002c  e5900000          LDR      r0,[r0,#0]
                  |L3.48|
000030  e5902000          LDR      r2,[r0,#0]
000034  e5922004          LDR      r2,[r2,#4]
000038  e1520001          CMP      r2,r1
00003c  3afffffa          BCC      |L3.44|
000040  e5902000          LDR      r2,[r0,#0]
000044  e5842000          STR      r2,[r4,#0]
000048  e5804000          STR      r4,[r0,#0]
;;;271    			xFreeBytesRemaining += pxLink->xBlockSize;
00004c  e59f101c          LDR      r1,|L3.112|
000050  e5940004          LDR      r0,[r4,#4]
000054  e5911000          LDR      r1,[r1,#0]  ; xFreeBytesRemaining
000058  e0800001          ADD      r0,r0,r1
00005c  e59f100c          LDR      r1,|L3.112|
000060  e5810000          STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;272    			traceFREE( pv, pxLink->xBlockSize );
;;;273    		}
;;;274    		( void ) xTaskResumeAll();
000064  ebfffffe          BL       xTaskResumeAll
                  |L3.104|
;;;275    	}
;;;276    }
000068  e8bd8070          POP      {r4-r6,pc}
;;;277    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.108|
                          DCD      xStart
                  |L3.112|
                          DCD      xFreeBytesRemaining

                          AREA ||i.vPortInitialiseBlocks||, CODE, READONLY, ALIGN=2

                  vPortInitialiseBlocks PROC
;;;284    
;;;285    void vPortInitialiseBlocks( void )
000000  e12fff1e          BX       lr
;;;286    {
;;;287    	/* This just exists to keep the linker quiet. */
;;;288    }
;;;289    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xPortGetFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetFreeHeapSize PROC
;;;278    
;;;279    size_t xPortGetFreeHeapSize( void )
000000  e59f0004          LDR      r0,|L5.12|
;;;280    {
;;;281    	return xFreeBytesRemaining;
000004  e5900000          LDR      r0,[r0,#0]  ; xFreeBytesRemaining
;;;282    }
000008  e12fff1e          BX       lr
;;;283    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.12|
                          DCD      xFreeBytesRemaining

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        13312

                          AREA ||.data||, DATA, ALIGN=2

                  xStart
                          %        8
                  xEnd
                          %        8
                  xFreeBytesRemaining
                          DCD      0x000033f8
                  xHeapHasBeenInitialised
                          DCD      0x00000000
