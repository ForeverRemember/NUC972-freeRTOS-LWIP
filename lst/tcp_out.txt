; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\tcp_out.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tcp_out.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\tcp_out.crf lwip-1.4.1\src\core\tcp_out.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tcp_output_alloc_header PROC
;;;93     static struct pbuf *
;;;94     tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;95                           u32_t seqno_be /* already in network byte order */)
;;;96     {
000004  e1a05000          MOV      r5,r0
;;;97       struct tcp_hdr *tcphdr;
;;;98       struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
000008  e0810002          ADD      r0,r1,r2
00000c  e1a07001          MOV      r7,r1                 ;96
000010  e2800014          ADD      r0,r0,#0x14
000014  e3c01803          BIC      r1,r0,#0x30000
000018  e1a08003          MOV      r8,r3                 ;96
00001c  e3a02000          MOV      r2,#0
000020  e3a00001          MOV      r0,#1
000024  ebfffffe          BL       pbuf_alloc
000028  e1b06000          MOVS     r6,r0
;;;99       if (p != NULL) {
00002c  0a000032          BEQ      |L1.252|
;;;100        LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
000030  e1d600ba          LDRH     r0,[r6,#0xa]
000034  e2871014          ADD      r1,r7,#0x14
000038  e1510000          CMP      r1,r0
00003c  9a000004          BLS      |L1.84|
000040  e28f3e1d          ADR      r3,|L1.536|
000044  e3a02064          MOV      r2,#0x64
000048  e28f1f7a          ADR      r1,|L1.568|
00004c  e28f0f85          ADR      r0,|L1.616|
000050  ebfffffe          BL       sysprintf
                  |L1.84|
;;;101                     (p->len >= TCP_HLEN + optlen));
;;;102        tcphdr = (struct tcp_hdr *)p->payload;
000054  e5964004          LDR      r4,[r6,#4]
;;;103        tcphdr->src = htons(pcb->local_port);
000058  e1d501ba          LDRH     r0,[r5,#0x1a]
00005c  ebfffffe          BL       lwip_htons
000060  e5c40000          STRB     r0,[r4,#0]
000064  e1a00420          LSR      r0,r0,#8
000068  e5c40001          STRB     r0,[r4,#1]
;;;104        tcphdr->dest = htons(pcb->remote_port);
00006c  e1d501bc          LDRH     r0,[r5,#0x1c]
000070  ebfffffe          BL       lwip_htons
000074  e5c40002          STRB     r0,[r4,#2]
000078  e1a00420          LSR      r0,r0,#8
00007c  e5c40003          STRB     r0,[r4,#3]
;;;105        tcphdr->seqno = seqno_be;
000080  e2841004          ADD      r1,r4,#4
000084  e1a00008          MOV      r0,r8
000088  ebfffffe          BL       __aeabi_uwrite4
;;;106        tcphdr->ackno = htonl(pcb->rcv_nxt);
00008c  e5950028          LDR      r0,[r5,#0x28]
000090  ebfffffe          BL       lwip_htonl
000094  e2841008          ADD      r1,r4,#8
000098  ebfffffe          BL       __aeabi_uwrite4
;;;107        TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
00009c  e1a00127          LSR      r0,r7,#2
0000a0  e1a00600          LSL      r0,r0,#12
0000a4  e2800a05          ADD      r0,r0,#0x5000
0000a8  e1a00800          LSL      r0,r0,#16
0000ac  e1a00820          LSR      r0,r0,#16
0000b0  e3800010          ORR      r0,r0,#0x10
0000b4  ebfffffe          BL       lwip_htons
0000b8  e5c4000c          STRB     r0,[r4,#0xc]
0000bc  e1a00420          LSR      r0,r0,#8
0000c0  e5c4000d          STRB     r0,[r4,#0xd]
;;;108        tcphdr->wnd = htons(pcb->rcv_ann_wnd);
0000c4  e1d502be          LDRH     r0,[r5,#0x2e]
0000c8  ebfffffe          BL       lwip_htons
0000cc  e5c4000e          STRB     r0,[r4,#0xe]
0000d0  e1a00420          LSR      r0,r0,#8
0000d4  e5c4000f          STRB     r0,[r4,#0xf]
;;;109        tcphdr->chksum = 0;
0000d8  e3a00000          MOV      r0,#0
0000dc  e5c40010          STRB     r0,[r4,#0x10]
0000e0  e5c40011          STRB     r0,[r4,#0x11]
;;;110        tcphdr->urgp = 0;
0000e4  e5c40012          STRB     r0,[r4,#0x12]
0000e8  e5c40013          STRB     r0,[r4,#0x13]
;;;111    
;;;112        /* If we're sending a packet, update the announced right window edge */
;;;113        pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
0000ec  e1d512be          LDRH     r1,[r5,#0x2e]
0000f0  e5950028          LDR      r0,[r5,#0x28]
0000f4  e0800001          ADD      r0,r0,r1
0000f8  e5850030          STR      r0,[r5,#0x30]
                  |L1.252|
;;;114      }
;;;115      return p;
0000fc  e1a00006          MOV      r0,r6
;;;116    }
000100  e8bd81f0          POP      {r4-r8,pc}
;;;117    
                          ENDP

                  tcp_create_segment PROC
;;;158    static struct tcp_seg *
;;;159    tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
000104  e92d47f0          PUSH     {r4-r10,lr}
;;;160    {
000108  e59d6020          LDR      r6,[sp,#0x20]
00010c  e1a07000          MOV      r7,r0
;;;161      struct tcp_seg *seg;
;;;162      u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
000110  e2160001          ANDS     r0,r6,#1
000114  e1a0a001          MOV      r10,r1                ;160
000118  13a00004          MOVNE    r0,#4
00011c  e2161002          ANDS     r1,r6,#2
000120  13a0100c          MOVNE    r1,#0xc
000124  e0805001          ADD      r5,r0,r1
000128  e1a09003          MOV      r9,r3                 ;160
00012c  e1a08002          MOV      r8,r2                 ;160
;;;163    
;;;164      if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
000130  e3a00003          MOV      r0,#3
000134  ebfffffe          BL       memp_malloc
000138  e1b04000          MOVS     r4,r0
00013c  0a00000f          BEQ      |L1.384|
;;;165        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
;;;166        pbuf_free(p);
;;;167        return NULL;
;;;168      }
;;;169      seg->flags = optflags;
000140  e5c4600c          STRB     r6,[r4,#0xc]
;;;170      seg->next = NULL;
000144  e3a06000          MOV      r6,#0
000148  e8840440          STM      r4,{r6,r10}
;;;171      seg->p = p;
;;;172      seg->len = p->tot_len - optlen;
00014c  e1da00b8          LDRH     r0,[r10,#8]
;;;173    #if TCP_OVERSIZE_DBGCHECK
;;;174      seg->oversize_left = 0;
;;;175    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;176    #if TCP_CHECKSUM_ON_COPY
;;;177      seg->chksum = 0;
;;;178      seg->chksum_swapped = 0;
;;;179      /* check optflags */
;;;180      LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
;;;181                  (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
;;;182    #endif /* TCP_CHECKSUM_ON_COPY */
;;;183    
;;;184      /* build TCP header */
;;;185      if (pbuf_header(p, TCP_HLEN)) {
000150  e3a01014          MOV      r1,#0x14
000154  e0400005          SUB      r0,r0,r5              ;172
000158  e1c400b8          STRH     r0,[r4,#8]            ;172
00015c  e1a0000a          MOV      r0,r10
000160  e1c460ba          STRH     r6,[r4,#0xa]          ;174
000164  ebfffffe          BL       pbuf_header
000168  e3500000          CMP      r0,#0
00016c  0a000006          BEQ      |L1.396|
;;;186        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
;;;187        TCP_STATS_INC(tcp.err);
;;;188        tcp_seg_free(seg);
000170  e1a00004          MOV      r0,r4
000174  ebfffffe          BL       tcp_seg_free
                  |L1.376|
;;;189        return NULL;
000178  e3a00000          MOV      r0,#0
;;;190      }
;;;191      seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
;;;192      seg->tcphdr->src = htons(pcb->local_port);
;;;193      seg->tcphdr->dest = htons(pcb->remote_port);
;;;194      seg->tcphdr->seqno = htonl(seqno);
;;;195      /* ackno is set in tcp_output */
;;;196      TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
;;;197      /* wnd and chksum are set in tcp_output */
;;;198      seg->tcphdr->urgp = 0;
;;;199      return seg;
;;;200    } 
00017c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.384|
000180  e1a0000a          MOV      r0,r10                ;166
000184  ebfffffe          BL       pbuf_free
000188  eafffffa          B        |L1.376|
                  |L1.396|
00018c  e5940004          LDR      r0,[r4,#4]            ;191
000190  e5900004          LDR      r0,[r0,#4]            ;191
000194  e5840010          STR      r0,[r4,#0x10]         ;191
000198  e1d701ba          LDRH     r0,[r7,#0x1a]         ;192
00019c  ebfffffe          BL       lwip_htons
0001a0  e5941010          LDR      r1,[r4,#0x10]         ;192
0001a4  e5c10000          STRB     r0,[r1,#0]            ;192
0001a8  e1a00420          LSR      r0,r0,#8              ;192
0001ac  e5c10001          STRB     r0,[r1,#1]            ;192
0001b0  e1d701bc          LDRH     r0,[r7,#0x1c]         ;193
0001b4  ebfffffe          BL       lwip_htons
0001b8  e5941010          LDR      r1,[r4,#0x10]         ;193
0001bc  e5c10002          STRB     r0,[r1,#2]            ;193
0001c0  e1a00420          LSR      r0,r0,#8              ;193
0001c4  e5c10003          STRB     r0,[r1,#3]            ;193
0001c8  e1a00009          MOV      r0,r9                 ;194
0001cc  ebfffffe          BL       lwip_htonl
0001d0  e5941010          LDR      r1,[r4,#0x10]         ;194
0001d4  e2811004          ADD      r1,r1,#4              ;194
0001d8  ebfffffe          BL       __aeabi_uwrite4
0001dc  e1a00125          LSR      r0,r5,#2              ;196
0001e0  e1a00600          LSL      r0,r0,#12             ;196
0001e4  e2800a05          ADD      r0,r0,#0x5000         ;196
0001e8  e1800008          ORR      r0,r0,r8              ;196
0001ec  ebfffffe          BL       lwip_htons
0001f0  e5941010          LDR      r1,[r4,#0x10]         ;196
0001f4  e5c1000c          STRB     r0,[r1,#0xc]          ;196
0001f8  e1a00420          LSR      r0,r0,#8              ;196
0001fc  e5c1000d          STRB     r0,[r1,#0xd]          ;196
000200  e5940010          LDR      r0,[r4,#0x10]         ;198
000204  e1a01426          LSR      r1,r6,#8              ;198
000208  e5c06012          STRB     r6,[r0,#0x12]         ;198
00020c  e5c01013          STRB     r1,[r0,#0x13]         ;198
000210  e1a00004          MOV      r0,r4                 ;199
000214  e8bd87f0          POP      {r4-r10,pc}
                  |L1.536|
000218  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_out.c",0
00021c  2d312e34
000220  2e315c73
000224  72635c63
000228  6f72655c
00022c  7463705f
000230  6f75742e
000234  6300    
000236  00                DCB      0
000237  00                DCB      0
                  |L1.568|
000238  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
00023c  6b207468
000240  61742066
000244  69727374
000248  20706275
00024c  66206361
000250  6e20686f
000254  6c642073
000258  74727563
00025c  74207463
000260  705f6864
000264  7200    
000266  00                DCB      0
000267  00                DCB      0
                  |L1.616|
000268  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00026c  7274696f
000270  6e202225
000274  73222066
000278  61696c65
00027c  64206174
000280  206c696e
000284  65202564
000288  20696e20
00028c  25730a00
                          ENDP

                  tcp_enqueue_flags PROC
;;;721    err_t
;;;722    tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
000290  e92d43f8          PUSH     {r3-r9,lr}
;;;723    {
;;;724      struct pbuf *p;
;;;725      struct tcp_seg *seg;
;;;726      u8_t optflags = 0;
;;;727      u8_t optlen = 0;
;;;728    
;;;729      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;730    
;;;731      LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
000294  e3110003          TST      r1,#3
000298  e1a06001          MOV      r6,r1                 ;723
00029c  e1a04000          MOV      r4,r0                 ;723
0002a0  e3a05000          MOV      r5,#0                 ;726
0002a4  1a000004          BNE      |L1.700|
0002a8  e59f22dc          LDR      r2,|L1.1420|
0002ac  e59f12dc          LDR      r1,|L1.1424|
0002b0  e24f30a0          ADR      r3,|L1.536|
0002b4  e24f0054          ADR      r0,|L1.616|
0002b8  ebfffffe          BL       sysprintf
                  |L1.700|
;;;732                  (flags & (TCP_SYN | TCP_FIN)) != 0);
;;;733    
;;;734      /* check for configured max queuelen and possible overflow */
;;;735      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
0002bc  e1d406b8          LDRH     r0,[r4,#0x68]
0002c0  e3500008          CMP      r0,#8
0002c4  3a000004          BCC      |L1.732|
                  |L1.712|
;;;736        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
;;;737                                           pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;738        TCP_STATS_INC(tcp.memerr);
;;;739        pcb->flags |= TF_NAGLEMEMERR;
0002c8  e5d4001e          LDRB     r0,[r4,#0x1e]
0002cc  e3800080          ORR      r0,r0,#0x80
0002d0  e5c4001e          STRB     r0,[r4,#0x1e]
                  |L1.724|
;;;740        return ERR_MEM;
;;;741      }
;;;742    
;;;743      if (flags & TCP_SYN) {
;;;744        optflags = TF_SEG_OPTS_MSS;
;;;745      }
;;;746    #if LWIP_TCP_TIMESTAMPS
;;;747      if ((pcb->flags & TF_TIMESTAMP)) {
;;;748        optflags |= TF_SEG_OPTS_TS;
;;;749      }
;;;750    #endif /* LWIP_TCP_TIMESTAMPS */
;;;751      optlen = LWIP_TCP_OPT_LENGTH(optflags);
;;;752    
;;;753      /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
;;;754       * We need one available snd_buf byte to do that.
;;;755       * This means we can't send FIN while snd_buf==0. A better fix would be to
;;;756       * not include SYN and FIN sequence numbers in the snd_buf count. */
;;;757      if (pcb->snd_buf == 0) {
;;;758        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
;;;759        TCP_STATS_INC(tcp.memerr);
;;;760        return ERR_MEM;
0002d4  e3e00000          MVN      r0,#0
;;;761      }
;;;762    
;;;763      /* Allocate pbuf with room for TCP header + options */
;;;764      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;765        pcb->flags |= TF_NAGLEMEMERR;
;;;766        TCP_STATS_INC(tcp.memerr);
;;;767        return ERR_MEM;
;;;768      }
;;;769      LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
;;;770                  (p->len >= optlen));
;;;771    
;;;772      /* Allocate memory for tcp_seg, and fill in fields. */
;;;773      if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
;;;774        pcb->flags |= TF_NAGLEMEMERR;
;;;775        TCP_STATS_INC(tcp.memerr);
;;;776        return ERR_MEM;
;;;777      }
;;;778      LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
;;;779      LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
;;;780    
;;;781      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
;;;782                  ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
;;;783                   ntohl(seg->tcphdr->seqno),
;;;784                   ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
;;;785                   (u16_t)flags));
;;;786    
;;;787      /* Now append seg to pcb->unsent queue */
;;;788      if (pcb->unsent == NULL) {
;;;789        pcb->unsent = seg;
;;;790      } else {
;;;791        struct tcp_seg *useg;
;;;792        for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
;;;793        useg->next = seg;
;;;794      }
;;;795    #if TCP_OVERSIZE
;;;796      /* The new unsent tail has no space */
;;;797      pcb->unsent_oversize = 0;
;;;798    #endif /* TCP_OVERSIZE */
;;;799    
;;;800      /* SYN and FIN bump the sequence number */
;;;801      if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
;;;802        pcb->snd_lbb++;
;;;803        /* optlen does not influence snd_buf */
;;;804        pcb->snd_buf--;
;;;805      }
;;;806      if (flags & TCP_FIN) {
;;;807        pcb->flags |= TF_FIN;
;;;808      }
;;;809    
;;;810      /* update number of segments on the queues */
;;;811      pcb->snd_queuelen += pbuf_clen(seg->p);
;;;812      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
;;;813      if (pcb->snd_queuelen != 0) {
;;;814        LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
;;;815          pcb->unacked != NULL || pcb->unsent != NULL);
;;;816      }
;;;817    
;;;818      return ERR_OK;
;;;819    }
0002d8  e8bd83f8          POP      {r3-r9,pc}
                  |L1.732|
0002dc  e3160002          TST      r6,#2                 ;743
0002e0  13a05001          MOVNE    r5,#1                 ;744
0002e4  e3550000          CMP      r5,#0                 ;751
0002e8  13a00004          MOVNE    r0,#4                 ;751
0002ec  03a00000          MOVEQ    r0,#0                 ;751
0002f0  e2151002          ANDS     r1,r5,#2              ;751
0002f4  13a0100c          MOVNE    r1,#0xc               ;751
0002f8  e0808001          ADD      r8,r0,r1              ;751
0002fc  e1d406b6          LDRH     r0,[r4,#0x66]         ;757
000300  e3500000          CMP      r0,#0                 ;757
000304  0afffff2          BEQ      |L1.724|
000308  e3a02000          MOV      r2,#0                 ;764
00030c  e1a01008          MOV      r1,r8                 ;764
000310  e1a00002          MOV      r0,r2                 ;764
000314  ebfffffe          BL       pbuf_alloc
000318  e1b07000          MOVS     r7,r0                 ;764
00031c  0affffe9          BEQ      |L1.712|
000320  e1d700ba          LDRH     r0,[r7,#0xa]          ;769
000324  e1580000          CMP      r8,r0                 ;769
000328  9a000004          BLS      |L1.832|
00032c  e59f2260          LDR      r2,|L1.1428|
000330  e24f3e12          ADR      r3,|L1.536|
000334  e28f1f97          ADR      r1,|L1.1432|
000338  e24f00d8          ADR      r0,|L1.616|
00033c  ebfffffe          BL       sysprintf
                  |L1.832|
000340  e58d5000          STR      r5,[sp,#0]            ;773
000344  e594305c          LDR      r3,[r4,#0x5c]         ;773
000348  e1a02006          MOV      r2,r6                 ;773
00034c  e1a01007          MOV      r1,r7                 ;773
000350  e1a00004          MOV      r0,r4                 ;773
000354  ebfffffe          BL       tcp_create_segment
000358  e1b05000          MOVS     r5,r0                 ;773
00035c  0affffd9          BEQ      |L1.712|
000360  e5d50010          LDRB     r0,[r5,#0x10]         ;778
000364  e3100003          TST      r0,#3                 ;778
000368  0a000004          BEQ      |L1.896|
00036c  e59f2260          LDR      r2,|L1.1492|
000370  e24f3e16          ADR      r3,|L1.536|
000374  e28f1f97          ADR      r1,|L1.1496|
000378  e24f0f46          ADR      r0,|L1.616|
00037c  ebfffffe          BL       sysprintf
                  |L1.896|
000380  e1d500b8          LDRH     r0,[r5,#8]            ;779
000384  e3500000          CMP      r0,#0                 ;779
000388  0a000004          BEQ      |L1.928|
00038c  e59f225c          LDR      r2,|L1.1520|
000390  e24f3d06          ADR      r3,|L1.536|
000394  e28f1f96          ADR      r1,|L1.1524|
000398  e24f0f4e          ADR      r0,|L1.616|
00039c  ebfffffe          BL       sysprintf
                  |L1.928|
0003a0  e594006c          LDR      r0,[r4,#0x6c]         ;788
0003a4  e3500000          CMP      r0,#0                 ;788
0003a8  0584506c          STREQ    r5,[r4,#0x6c]         ;789
0003ac  0a000004          BEQ      |L1.964|
                  |L1.944|
0003b0  e5901000          LDR      r1,[r0,#0]            ;792
0003b4  e3510000          CMP      r1,#0                 ;792
0003b8  11a00001          MOVNE    r0,r1                 ;792
0003bc  05805000          STREQ    r5,[r0,#0]            ;793
0003c0  1afffffa          BNE      |L1.944|
                  |L1.964|
0003c4  e3a00000          MOV      r0,#0                 ;797
0003c8  e3160003          TST      r6,#3                 ;801
0003cc  e1c406ba          STRH     r0,[r4,#0x6a]         ;797
0003d0  0a000005          BEQ      |L1.1004|
0003d4  e594005c          LDR      r0,[r4,#0x5c]         ;802
0003d8  e2800001          ADD      r0,r0,#1              ;802
0003dc  e584005c          STR      r0,[r4,#0x5c]         ;802
0003e0  e1d406b6          LDRH     r0,[r4,#0x66]         ;804
0003e4  e2400001          SUB      r0,r0,#1              ;804
0003e8  e1c406b6          STRH     r0,[r4,#0x66]         ;804
                  |L1.1004|
0003ec  e3160001          TST      r6,#1                 ;806
0003f0  15d4001e          LDRBNE   r0,[r4,#0x1e]         ;807
0003f4  13800020          ORRNE    r0,r0,#0x20           ;807
0003f8  15c4001e          STRBNE   r0,[r4,#0x1e]         ;807
0003fc  e5950004          LDR      r0,[r5,#4]            ;811
000400  ebfffffe          BL       pbuf_clen
000404  e1d416b8          LDRH     r1,[r4,#0x68]         ;811
000408  e0800001          ADD      r0,r0,r1              ;811
00040c  e3d00801          BICS     r0,r0,#0x10000        ;811
000410  e1c406b8          STRH     r0,[r4,#0x68]         ;811
000414  0a000009          BEQ      |L1.1088|
000418  e5940070          LDR      r0,[r4,#0x70]         ;814
00041c  e3500000          CMP      r0,#0                 ;814
000420  0594006c          LDREQ    r0,[r4,#0x6c]         ;814
000424  03500000          CMPEQ    r0,#0                 ;814
000428  1a000004          BNE      |L1.1088|
00042c  e59f21ec          LDR      r2,|L1.1568|
000430  e24f3e22          ADR      r3,|L1.536|
000434  e28f1f7a          ADR      r1,|L1.1572|
000438  e24f0f76          ADR      r0,|L1.616|
00043c  ebfffffe          BL       sysprintf
                  |L1.1088|
000440  e3a00000          MOV      r0,#0                 ;818
000444  e8bd83f8          POP      {r3-r9,pc}
;;;820    
                          ENDP

                  tcp_send_fin PROC
;;;124    err_t
;;;125    tcp_send_fin(struct tcp_pcb *pcb)
000448  e92d4070          PUSH     {r4-r6,lr}
;;;126    {
;;;127      /* first, try to add the fin to the last unsent segment */
;;;128      if (pcb->unsent != NULL) {
00044c  e590406c          LDR      r4,[r0,#0x6c]
000450  e1a05000          MOV      r5,r0                 ;126
000454  e3540000          CMP      r4,#0
000458  0a00000a          BEQ      |L1.1160|
                  |L1.1116|
;;;129        struct tcp_seg *last_unsent;
;;;130        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
00045c  e5941000          LDR      r1,[r4,#0]
000460  e3510000          CMP      r1,#0
;;;131             last_unsent = last_unsent->next);
000464  11a04001          MOVNE    r4,r1
000468  1afffffb          BNE      |L1.1116|
;;;132    
;;;133        if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
00046c  e5940010          LDR      r0,[r4,#0x10]
000470  e5d0100d          LDRB     r1,[r0,#0xd]
000474  e5d0000c          LDRB     r0,[r0,#0xc]
000478  e1800401          ORR      r0,r0,r1,LSL #8
00047c  ebfffffe          BL       lwip_ntohs
000480  e3100007          TST      r0,#7
000484  0a000003          BEQ      |L1.1176|
                  |L1.1160|
;;;134          /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
;;;135          TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
;;;136          pcb->flags |= TF_FIN;
;;;137          return ERR_OK;
;;;138        }
;;;139      }
;;;140      /* no data, no length, flags, copy=1, no optdata */
;;;141      return tcp_enqueue_flags(pcb, TCP_FIN);
000488  e1a00005          MOV      r0,r5
00048c  e8bd4070          POP      {r4-r6,lr}
000490  e3a01001          MOV      r1,#1
000494  eafffffe          B        tcp_enqueue_flags
                  |L1.1176|
000498  e3a00001          MOV      r0,#1                 ;135
00049c  ebfffffe          BL       lwip_htons
0004a0  e5941010          LDR      r1,[r4,#0x10]         ;135
0004a4  e5d1200d          LDRB     r2,[r1,#0xd]          ;135
0004a8  e5d1300c          LDRB     r3,[r1,#0xc]          ;135
0004ac  e1832402          ORR      r2,r3,r2,LSL #8       ;135
0004b0  e1800002          ORR      r0,r0,r2              ;135
0004b4  e5c1000c          STRB     r0,[r1,#0xc]          ;135
0004b8  e1a00420          LSR      r0,r0,#8              ;135
0004bc  e5c1000d          STRB     r0,[r1,#0xd]          ;135
0004c0  e5d5001e          LDRB     r0,[r5,#0x1e]         ;136
0004c4  e3800020          ORR      r0,r0,#0x20           ;136
0004c8  e5c5001e          STRB     r0,[r5,#0x1e]         ;136
0004cc  e3a00000          MOV      r0,#0                 ;137
;;;142    }
0004d0  e8bd8070          POP      {r4-r6,pc}
;;;143    
                          ENDP

                  tcp_pbuf_prealloc PROC
;;;218    static struct pbuf *
;;;219    tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
0004d4  e92d4070          PUSH     {r4-r6,lr}
;;;220                      u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
;;;221                      u8_t first_seg)
;;;222    {
0004d8  e1a06003          MOV      r6,r3
;;;223      struct pbuf *p;
;;;224      u16_t alloc = length;
;;;225    
;;;226    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;227      LWIP_UNUSED_ARG(max_length);
;;;228      LWIP_UNUSED_ARG(pcb);
;;;229      LWIP_UNUSED_ARG(apiflags);
;;;230      LWIP_UNUSED_ARG(first_seg);
;;;231      /* always create MSS-sized pbufs */
;;;232      alloc = max_length;
;;;233    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;234      if (length < max_length) {
0004dc  e59d3014          LDR      r3,[sp,#0x14]
0004e0  e59d4018          LDR      r4,[sp,#0x18]
0004e4  e59dc010          LDR      r12,[sp,#0x10]
0004e8  e1510002          CMP      r1,r2
0004ec  e1a05001          MOV      r5,r1                 ;222
0004f0  2a000004          BCS      |L1.1288|
;;;235        /* Should we allocate an oversized pbuf, or just the minimum
;;;236         * length required? If tcp_write is going to be called again
;;;237         * before this segment is transmitted, we want the oversized
;;;238         * buffer. If the segment will be transmitted immediately, we can
;;;239         * save memory by allocating only length. We use a simple
;;;240         * heuristic based on the following information:
;;;241         *
;;;242         * Did the user set TCP_WRITE_FLAG_MORE?
;;;243         *
;;;244         * Will the Nagle algorithm defer transmission of this segment?
;;;245         */
;;;246        if ((apiflags & TCP_WRITE_FLAG_MORE) ||
0004f4  e3130002          TST      r3,#2
0004f8  1a00001c          BNE      |L1.1392|
;;;247            (!(pcb->flags & TF_NODELAY) &&
0004fc  e5dc301e          LDRB     r3,[r12,#0x1e]
000500  e3130040          TST      r3,#0x40
000504  0a000012          BEQ      |L1.1364|
                  |L1.1288|
;;;248             (!first_seg ||
;;;249              pcb->unsent != NULL ||
;;;250              pcb->unacked != NULL))) {
;;;251          alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
;;;252        }
;;;253      }
;;;254    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;255      p = pbuf_alloc(layer, alloc, PBUF_RAM);
000508  e3a02000          MOV      r2,#0
00050c  ebfffffe          BL       pbuf_alloc
000510  e1b04000          MOVS     r4,r0
;;;256      if (p == NULL) {
;;;257        return NULL;
;;;258      }
;;;259      LWIP_ASSERT("need unchained pbuf", p->next == NULL);
;;;260      *oversize = p->len - length;
;;;261      /* trim p->len to the currently used size */
;;;262      p->len = p->tot_len = length;
;;;263      return p;
;;;264    }
000514  08bd8070          POPEQ    {r4-r6,pc}
000518  e5940000          LDR      r0,[r4,#0]            ;259
00051c  e3500000          CMP      r0,#0                 ;259
000520  0a000004          BEQ      |L1.1336|
000524  e59f2120          LDR      r2,|L1.1612|
000528  e24f3fc6          ADR      r3,|L1.536|
00052c  e28f1f47          ADR      r1,|L1.1616|
000530  e24f0e2d          ADR      r0,|L1.616|
000534  ebfffffe          BL       sysprintf
                  |L1.1336|
000538  e1d400ba          LDRH     r0,[r4,#0xa]          ;260
00053c  e0400005          SUB      r0,r0,r5              ;260
000540  e1c600b0          STRH     r0,[r6,#0]            ;260
000544  e1c450b8          STRH     r5,[r4,#8]            ;262
000548  e1a00004          MOV      r0,r4                 ;263
00054c  e1c450ba          STRH     r5,[r4,#0xa]          ;262
000550  e8bd8070          POP      {r4-r6,pc}
                  |L1.1364|
000554  e3540000          CMP      r4,#0                 ;248
000558  0a000004          BEQ      |L1.1392|
00055c  e59c306c          LDR      r3,[r12,#0x6c]        ;249
000560  e3530000          CMP      r3,#0                 ;249
000564  059c3070          LDREQ    r3,[r12,#0x70]        ;250
000568  03530000          CMPEQ    r3,#0                 ;250
00056c  0affffe5          BEQ      |L1.1288|
                  |L1.1392|
000570  e2851c03          ADD      r1,r5,#0x300          ;251
000574  e28110eb          ADD      r1,r1,#0xeb           ;251
000578  e3c11003          BIC      r1,r1,#3              ;251
00057c  e1510002          CMP      r1,r2                 ;251
000580  91a02001          MOVLS    r2,r1                 ;251
000584  e3c21801          BIC      r1,r2,#0x10000        ;251
000588  eaffffde          B        |L1.1288|
                  |L1.1420|
                          DCD      0x000002db
                  |L1.1424|
                          DCD      ||.conststring||
                  |L1.1428|
                          DCD      0x00000301
                  |L1.1432|
000598  7463705f          DCB      "tcp_enqueue_flags: check that first pbuf can hold optle"
00059c  656e7175
0005a0  6575655f
0005a4  666c6167
0005a8  733a2063
0005ac  6865636b
0005b0  20746861
0005b4  74206669
0005b8  72737420
0005bc  70627566
0005c0  2063616e
0005c4  20686f6c
0005c8  64206f70
0005cc  746c65  
0005cf  6e00              DCB      "n",0
0005d1  00                DCB      0
0005d2  00                DCB      0
0005d3  00                DCB      0
                  |L1.1492|
                          DCD      0x0000030a
                  |L1.1496|
0005d8  7365672d          DCB      "seg->tcphdr not aligned",0
0005dc  3e746370
0005e0  68647220
0005e4  6e6f7420
0005e8  616c6967
0005ec  6e656400
                  |L1.1520|
                          DCD      0x0000030b
                  |L1.1524|
0005f4  7463705f          DCB      "tcp_enqueue_flags: invalid segment length",0
0005f8  656e7175
0005fc  6575655f
000600  666c6167
000604  733a2069
000608  6e76616c
00060c  69642073
000610  65676d65
000614  6e74206c
000618  656e6774
00061c  6800    
00061e  00                DCB      0
00061f  00                DCB      0
                  |L1.1568|
                          DCD      0x0000032e
                  |L1.1572|
000624  7463705f          DCB      "tcp_enqueue_flags: invalid queue length",0
000628  656e7175
00062c  6575655f
000630  666c6167
000634  733a2069
000638  6e76616c
00063c  69642071
000640  75657565
000644  206c656e
000648  67746800
                  |L1.1612|
                          DCD      0x00000103
                  |L1.1616|
000650  6e656564          DCB      "need unchained pbuf",0
000654  20756e63
000658  6861696e
00065c  65642070
000660  62756600
                          ENDP

                  tcp_write PROC
;;;353    err_t
;;;354    tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
000664  e92d4fff          PUSH     {r0-r11,lr}
;;;355    {
000668  e1a05000          MOV      r5,r0
;;;356      struct pbuf *concat_p = NULL;
00066c  e3a00000          MOV      r0,#0
000670  e24dd02c          SUB      sp,sp,#0x2c           ;355
;;;357      struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
;;;358      u16_t pos = 0; /* position in 'arg' data */
;;;359      u16_t queuelen;
;;;360      u8_t optlen = 0;
;;;361      u8_t optflags = 0;
000674  e58d0014          STR      r0,[sp,#0x14]
000678  e58d001c          STR      r0,[sp,#0x1c]         ;356
00067c  e58d0024          STR      r0,[sp,#0x24]         ;357
000680  e58d0028          STR      r0,[sp,#0x28]
;;;362    #if TCP_OVERSIZE
;;;363      u16_t oversize = 0;
000684  e1cd01b8          STRH     r0,[sp,#0x18]
000688  e1a04000          MOV      r4,r0                 ;357
00068c  e1a07000          MOV      r7,r0                 ;357
000690  e1a0b000          MOV      r11,r0                ;357
000694  e1a06000          MOV      r6,r0                 ;358
;;;364      u16_t oversize_used = 0;
000698  e1a08000          MOV      r8,r0
;;;365    #endif /* TCP_OVERSIZE */
;;;366    #if TCP_CHECKSUM_ON_COPY
;;;367      u16_t concat_chksum = 0;
;;;368      u8_t concat_chksum_swapped = 0;
;;;369      u16_t concat_chksummed = 0;
;;;370    #endif /* TCP_CHECKSUM_ON_COPY */
;;;371      err_t err;
;;;372      /* don't allocate segments bigger than half the maximum window we ever received */
;;;373      u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
00069c  e1d503b6          LDRH     r0,[r5,#0x36]
0006a0  e1d516b2          LDRH     r1,[r5,#0x62]
0006a4  e1a09002          MOV      r9,r2                 ;355
0006a8  e15000a1          CMP      r0,r1,LSR #1
0006ac  21a000a1          LSRCS    r0,r1,#1
;;;374    
;;;375    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;376      /* Always copy to try to create single pbufs for TX */
;;;377      apiflags |= TCP_WRITE_FLAG_COPY;
;;;378    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;379    
;;;380      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
;;;381        (void *)pcb, arg, len, (u16_t)apiflags));
;;;382      LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
0006b0  e58d0020          STR      r0,[sp,#0x20]
0006b4  e59d0030          LDR      r0,[sp,#0x30]
0006b8  e3500000          CMP      r0,#0
0006bc  0a00006e          BEQ      |L1.2172|
;;;383                 arg != NULL, return ERR_ARG;);
;;;384    
;;;385      err = tcp_write_checks(pcb, len);
0006c0  e1a01002          MOV      r1,r2
0006c4  e1a00005          MOV      r0,r5
0006c8  ebfffffe          BL       tcp_write_checks
;;;386      if (err != ERR_OK) {
0006cc  e3500000          CMP      r0,#0
0006d0  1a00006f          BNE      |L1.2196|
;;;387        return err;
;;;388      }
;;;389      queuelen = pcb->snd_queuelen;
0006d4  e1d5a6b8          LDRH     r10,[r5,#0x68]
;;;390    
;;;391    #if LWIP_TCP_TIMESTAMPS
;;;392      if ((pcb->flags & TF_TIMESTAMP)) {
;;;393        optflags = TF_SEG_OPTS_TS;
;;;394        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;395      }
;;;396    #endif /* LWIP_TCP_TIMESTAMPS */
;;;397    
;;;398    
;;;399      /*
;;;400       * TCP segmentation is done in three phases with increasing complexity:
;;;401       *
;;;402       * 1. Copy data directly into an oversized pbuf.
;;;403       * 2. Chain a new pbuf to the end of pcb->unsent.
;;;404       * 3. Create new segments.
;;;405       *
;;;406       * We may run out of memory at any point. In that case we must
;;;407       * return ERR_MEM and not change anything in pcb. Therefore, all
;;;408       * changes are recorded in local variables and committed at the end
;;;409       * of the function. Some pcb fields are maintained in local copies:
;;;410       *
;;;411       * queuelen = pcb->snd_queuelen
;;;412       * oversize = pcb->unsent_oversize
;;;413       *
;;;414       * These variables are set consistently by the phases:
;;;415       *
;;;416       * seg points to the last segment tampered with.
;;;417       *
;;;418       * pos records progress as data is segmented.
;;;419       */
;;;420    
;;;421      /* Find the tail of the unsent queue. */
;;;422      if (pcb->unsent != NULL) {
0006d8  e595006c          LDR      r0,[r5,#0x6c]
0006dc  e3500000          CMP      r0,#0
0006e0  0a000080          BEQ      |L1.2280|
                  |L1.1764|
;;;423        u16_t space;
;;;424        u16_t unsent_optlen;
;;;425    
;;;426        /* @todo: this could be sped up by keeping last_unsent in the pcb */
;;;427        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
0006e4  e1a04000          MOV      r4,r0
0006e8  e5900000          LDR      r0,[r0,#0]
0006ec  e3500000          CMP      r0,#0
0006f0  1afffffb          BNE      |L1.1764|
;;;428             last_unsent = last_unsent->next);
;;;429    
;;;430        /* Usable space at the end of the last unsent segment */
;;;431        unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
0006f4  e5d4000c          LDRB     r0,[r4,#0xc]
0006f8  e2101001          ANDS     r1,r0,#1
0006fc  13a01004          MOVNE    r1,#4
000700  e2100002          ANDS     r0,r0,#2
000704  13a0000c          MOVNE    r0,#0xc
000708  e0800001          ADD      r0,r0,r1
;;;432        space = mss_local - (last_unsent->len + unsent_optlen);
00070c  e1d410b8          LDRH     r1,[r4,#8]
000710  e0811000          ADD      r1,r1,r0
000714  e59d0020          LDR      r0,[sp,#0x20]
000718  e0400001          SUB      r0,r0,r1
00071c  e1a00800          LSL      r0,r0,#16
000720  e1a00820          LSR      r0,r0,#16
000724  e58d000c          STR      r0,[sp,#0xc]
;;;433    
;;;434        /*
;;;435         * Phase 1: Copy data directly into an oversized pbuf.
;;;436         *
;;;437         * The number of bytes copied is recorded in the oversize_used
;;;438         * variable. The actual copying is done at the bottom of the
;;;439         * function.
;;;440         */
;;;441    #if TCP_OVERSIZE
;;;442    #if TCP_OVERSIZE_DBGCHECK
;;;443        /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
;;;444        LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
000728  e1d506ba          LDRH     r0,[r5,#0x6a]
00072c  e1d410ba          LDRH     r1,[r4,#0xa]
000730  e1500001          CMP      r0,r1
000734  0a000004          BEQ      |L1.1868|
000738  e59f3288          LDR      r3,|L1.2504|
00073c  e59f02b8          LDR      r0,|L1.2556|
000740  e3a02f6f          MOV      r2,#0x1bc
000744  e28f1d0a          ADR      r1,|L1.2508|
000748  ebfffffe          BL       sysprintf
                  |L1.1868|
;;;445                    pcb->unsent_oversize == last_unsent->oversize_left);
;;;446    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;447        oversize = pcb->unsent_oversize;
00074c  e1d506ba          LDRH     r0,[r5,#0x6a]
;;;448        if (oversize > 0) {
000750  e3500000          CMP      r0,#0
000754  e1cd01b8          STRH     r0,[sp,#0x18]         ;447
000758  0a000015          BEQ      |L1.1972|
;;;449          LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
00075c  e59d000c          LDR      r0,[sp,#0xc]
000760  e1580000          CMP      r8,r0
000764  9a000004          BLS      |L1.1916|
000768  e59f3258          LDR      r3,|L1.2504|
00076c  e59f228c          LDR      r2,|L1.2560|
000770  e59f0284          LDR      r0,|L1.2556|
000774  e28f1fa2          ADR      r1,|L1.2564|
000778  ebfffffe          BL       sysprintf
                  |L1.1916|
;;;450          seg = last_unsent;
;;;451          oversize_used = oversize < len ? oversize : len;
00077c  e1dd01b8          LDRH     r0,[sp,#0x18]
000780  e1a07004          MOV      r7,r4                 ;450
000784  e1500009          CMP      r0,r9
000788  31a08000          MOVCC    r8,r0
00078c  21a08009          MOVCS    r8,r9
;;;452          pos += oversize_used;
;;;453          oversize -= oversize_used;
000790  e0400008          SUB      r0,r0,r8
000794  e1cd01b8          STRH     r0,[sp,#0x18]
;;;454          space -= oversize_used;
000798  e59d000c          LDR      r0,[sp,#0xc]
00079c  e0861008          ADD      r1,r6,r8              ;452
0007a0  e0400008          SUB      r0,r0,r8
0007a4  e1a00800          LSL      r0,r0,#16
0007a8  e1a00820          LSR      r0,r0,#16
0007ac  e3c16801          BIC      r6,r1,#0x10000        ;452
0007b0  e58d000c          STR      r0,[sp,#0xc]
                  |L1.1972|
;;;455        }
;;;456        /* now we are either finished or oversize is zero */
;;;457        LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
0007b4  e1dd01b8          LDRH     r0,[sp,#0x18]
0007b8  e3500000          CMP      r0,#0
0007bc  11560009          CMPNE    r6,r9
0007c0  0a000004          BEQ      |L1.2008|
0007c4  e59f31fc          LDR      r3,|L1.2504|
0007c8  e59f2254          LDR      r2,|L1.2596|
0007cc  e59f0228          LDR      r0,|L1.2556|
0007d0  e28f1e25          ADR      r1,|L1.2600|
0007d4  ebfffffe          BL       sysprintf
                  |L1.2008|
;;;458    #endif /* TCP_OVERSIZE */
;;;459    
;;;460        /*
;;;461         * Phase 2: Chain a new pbuf to the end of pcb->unsent.
;;;462         *
;;;463         * We don't extend segments containing SYN/FIN flags or options
;;;464         * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
;;;465         * the end.
;;;466         */
;;;467        if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
0007d8  e1560009          CMP      r6,r9
0007dc  2a000107          BCS      |L1.3072|
0007e0  e59d000c          LDR      r0,[sp,#0xc]
0007e4  e3500000          CMP      r0,#0
0007e8  11d400b8          LDRHNE   r0,[r4,#8]
0007ec  13500000          CMPNE    r0,#0
0007f0  0a000102          BEQ      |L1.3072|
;;;468          u16_t seglen = space < len - pos ? space : len - pos;
0007f4  e59d100c          LDR      r1,[sp,#0xc]
0007f8  e0490006          SUB      r0,r9,r6
0007fc  e1500001          CMP      r0,r1
000800  c1a00001          MOVGT    r0,r1
000804  e1a00800          LSL      r0,r0,#16
000808  e1a00820          LSR      r0,r0,#16
;;;469          seg = last_unsent;
;;;470    
;;;471          /* Create a pbuf with a copy or reference to seglen bytes. We
;;;472           * can use PBUF_RAW here since the data appears in the middle of
;;;473           * a segment. A header will never be prepended. */
;;;474          if (apiflags & TCP_WRITE_FLAG_COPY) {
00080c  e58d0010          STR      r0,[sp,#0x10]
000810  e59d0038          LDR      r0,[sp,#0x38]
000814  e1a07004          MOV      r7,r4                 ;469
000818  e3100001          TST      r0,#1
00081c  0a00001e          BEQ      |L1.2204|
;;;475            /* Data is copied */
;;;476            if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
000820  e59d0038          LDR      r0,[sp,#0x38]
000824  e3a01001          MOV      r1,#1
000828  e98d0003          STMIB    sp,{r0,r1}
00082c  e59d1010          LDR      r1,[sp,#0x10]
000830  e59d200c          LDR      r2,[sp,#0xc]
000834  e28d3018          ADD      r3,sp,#0x18
000838  e3a00003          MOV      r0,#3
00083c  e58d5000          STR      r5,[sp,#0]
000840  ebfffffe          BL       tcp_pbuf_prealloc
000844  e3500000          CMP      r0,#0
000848  e58d001c          STR      r0,[sp,#0x1c]
00084c  0a00014f          BEQ      |L1.3472|
;;;477              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;478                          ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
;;;479                           seglen));
;;;480              goto memerr;
;;;481            }
;;;482    #if TCP_OVERSIZE_DBGCHECK
;;;483            last_unsent->oversize_left += oversize;
000850  e1d400ba          LDRH     r0,[r4,#0xa]
000854  e1dd11b8          LDRH     r1,[sp,#0x18]
000858  e0800001          ADD      r0,r0,r1
00085c  e1c400ba          STRH     r0,[r4,#0xa]
;;;484    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;485            TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
000860  e59d0030          LDR      r0,[sp,#0x30]
000864  e59d2010          LDR      r2,[sp,#0x10]
000868  e0801006          ADD      r1,r0,r6
00086c  e59d001c          LDR      r0,[sp,#0x1c]
000870  e5900004          LDR      r0,[r0,#4]
000874  ebfffffe          BL       __aeabi_memcpy
000878  ea000012          B        |L1.2248|
                  |L1.2172|
00087c  e59f3144          LDR      r3,|L1.2504|
000880  e59f21c0          LDR      r2,|L1.2632|
000884  e59f0170          LDR      r0,|L1.2556|
000888  e28f1f6f          ADR      r1,|L1.2636|
00088c  ebfffffe          BL       sysprintf
000890  e3e0000d          MVN      r0,#0xd               ;382
                  |L1.2196|
000894  e28dd03c          ADD      sp,sp,#0x3c           ;382
;;;486    #if TCP_CHECKSUM_ON_COPY
;;;487            concat_chksummed += seglen;
;;;488    #endif /* TCP_CHECKSUM_ON_COPY */
;;;489          } else {
;;;490            /* Data is not copied */
;;;491            if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
;;;492              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;493                          ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;494              goto memerr;
;;;495            }
;;;496    #if TCP_CHECKSUM_ON_COPY
;;;497            /* calculate the checksum of nocopy-data */
;;;498            tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
;;;499              &concat_chksum, &concat_chksum_swapped);
;;;500            concat_chksummed += seglen;
;;;501    #endif /* TCP_CHECKSUM_ON_COPY */
;;;502            /* reference the non-volatile payload data */
;;;503            concat_p->payload = (u8_t*)arg + pos;
;;;504          }
;;;505    
;;;506          pos += seglen;
;;;507          queuelen += pbuf_clen(concat_p);
;;;508        }
;;;509      } else {
;;;510    #if TCP_OVERSIZE
;;;511        LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
;;;512                    pcb->unsent_oversize == 0);
;;;513    #endif /* TCP_OVERSIZE */
;;;514      }
;;;515    
;;;516      /*
;;;517       * Phase 3: Create new segments.
;;;518       *
;;;519       * The new segments are chained together in the local 'queue'
;;;520       * variable, ready to be appended to pcb->unsent.
;;;521       */
;;;522      while (pos < len) {
;;;523        struct pbuf *p;
;;;524        u16_t left = len - pos;
;;;525        u16_t max_len = mss_local - optlen;
;;;526        u16_t seglen = left > max_len ? max_len : left;
;;;527    #if TCP_CHECKSUM_ON_COPY
;;;528        u16_t chksum = 0;
;;;529        u8_t chksum_swapped = 0;
;;;530    #endif /* TCP_CHECKSUM_ON_COPY */
;;;531    
;;;532        if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;533          /* If copy is set, memory should be allocated and data copied
;;;534           * into pbuf */
;;;535          if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
;;;536            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
;;;537            goto memerr;
;;;538          }
;;;539          LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
;;;540                      (p->len >= seglen));
;;;541          TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
;;;542        } else {
;;;543          /* Copy is not set: First allocate a pbuf for holding the data.
;;;544           * Since the referenced data is available at least until it is
;;;545           * sent out on the link (as it has to be ACKed by the remote
;;;546           * party) we can safely use PBUF_ROM instead of PBUF_REF here.
;;;547           */
;;;548          struct pbuf *p2;
;;;549    #if TCP_OVERSIZE
;;;550          LWIP_ASSERT("oversize == 0", oversize == 0);
;;;551    #endif /* TCP_OVERSIZE */
;;;552          if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
;;;553            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;554            goto memerr;
;;;555          }
;;;556    #if TCP_CHECKSUM_ON_COPY
;;;557          /* calculate the checksum of nocopy-data */
;;;558          chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
;;;559    #endif /* TCP_CHECKSUM_ON_COPY */
;;;560          /* reference the non-volatile payload data */
;;;561          p2->payload = (u8_t*)arg + pos;
;;;562    
;;;563          /* Second, allocate a pbuf for the headers. */
;;;564          if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;565            /* If allocation fails, we have to deallocate the data pbuf as
;;;566             * well. */
;;;567            pbuf_free(p2);
;;;568            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
;;;569            goto memerr;
;;;570          }
;;;571          /* Concatenate the headers and data pbufs together. */
;;;572          pbuf_cat(p/*header*/, p2/*data*/);
;;;573        }
;;;574    
;;;575        queuelen += pbuf_clen(p);
;;;576    
;;;577        /* Now that there are more segments queued, we check again if the
;;;578         * length of the queue exceeds the configured maximum or
;;;579         * overflows. */
;;;580        if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;581          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
;;;582          pbuf_free(p);
;;;583          goto memerr;
;;;584        }
;;;585    
;;;586        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
;;;587          goto memerr;
;;;588        }
;;;589    #if TCP_OVERSIZE_DBGCHECK
;;;590        seg->oversize_left = oversize;
;;;591    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;592    #if TCP_CHECKSUM_ON_COPY
;;;593        seg->chksum = chksum;
;;;594        seg->chksum_swapped = chksum_swapped;
;;;595        seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;596    #endif /* TCP_CHECKSUM_ON_COPY */
;;;597    
;;;598        /* first segment of to-be-queued data? */
;;;599        if (queue == NULL) {
;;;600          queue = seg;
;;;601        } else {
;;;602          /* Attach the segment to the end of the queued segments */
;;;603          LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
;;;604          prev_seg->next = seg;
;;;605        }
;;;606        /* remember last segment of to-be-queued data for next iteration */
;;;607        prev_seg = seg;
;;;608    
;;;609        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
;;;610          ntohl(seg->tcphdr->seqno),
;;;611          ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
;;;612    
;;;613        pos += seglen;
;;;614      }
;;;615    
;;;616      /*
;;;617       * All three segmentation phases were successful. We can commit the
;;;618       * transaction.
;;;619       */
;;;620    
;;;621      /*
;;;622       * Phase 1: If data has been added to the preallocated tail of
;;;623       * last_unsent, we update the length fields of the pbuf chain.
;;;624       */
;;;625    #if TCP_OVERSIZE
;;;626      if (oversize_used > 0) {
;;;627        struct pbuf *p;
;;;628        /* Bump tot_len of whole chain, len of tail */
;;;629        for (p = last_unsent->p; p; p = p->next) {
;;;630          p->tot_len += oversize_used;
;;;631          if (p->next == NULL) {
;;;632            TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
;;;633            p->len += oversize_used;
;;;634          }
;;;635        }
;;;636        last_unsent->len += oversize_used;
;;;637    #if TCP_OVERSIZE_DBGCHECK
;;;638        LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
;;;639                    last_unsent->oversize_left >= oversize_used);
;;;640        last_unsent->oversize_left -= oversize_used;
;;;641    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;642      }
;;;643      pcb->unsent_oversize = oversize;
;;;644    #endif /* TCP_OVERSIZE */
;;;645    
;;;646      /*
;;;647       * Phase 2: concat_p can be concatenated onto last_unsent->p
;;;648       */
;;;649      if (concat_p != NULL) {
;;;650        LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
;;;651          (last_unsent != NULL));
;;;652        pbuf_cat(last_unsent->p, concat_p);
;;;653        last_unsent->len += concat_p->tot_len;
;;;654    #if TCP_CHECKSUM_ON_COPY
;;;655        if (concat_chksummed) {
;;;656          tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
;;;657            &last_unsent->chksum_swapped);
;;;658          last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;659        }
;;;660    #endif /* TCP_CHECKSUM_ON_COPY */
;;;661      }
;;;662    
;;;663      /*
;;;664       * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
;;;665       * is harmless
;;;666       */
;;;667      if (last_unsent == NULL) {
;;;668        pcb->unsent = queue;
;;;669      } else {
;;;670        last_unsent->next = queue;
;;;671      }
;;;672    
;;;673      /*
;;;674       * Finally update the pcb state.
;;;675       */
;;;676      pcb->snd_lbb += len;
;;;677      pcb->snd_buf -= len;
;;;678      pcb->snd_queuelen = queuelen;
;;;679    
;;;680      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
;;;681        pcb->snd_queuelen));
;;;682      if (pcb->snd_queuelen != 0) {
;;;683        LWIP_ASSERT("tcp_write: valid queue length",
;;;684                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;685      }
;;;686    
;;;687      /* Set the PSH flag in the last segment that we enqueued. */
;;;688      if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
;;;689        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
;;;690      }
;;;691    
;;;692      return ERR_OK;
;;;693    memerr:
;;;694      pcb->flags |= TF_NAGLEMEMERR;
;;;695      TCP_STATS_INC(tcp.memerr);
;;;696    
;;;697      if (concat_p != NULL) {
;;;698        pbuf_free(concat_p);
;;;699      }
;;;700      if (queue != NULL) {
;;;701        tcp_segs_free(queue);
;;;702      }
;;;703      if (pcb->snd_queuelen != 0) {
;;;704        LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
;;;705          pcb->unsent != NULL);
;;;706      }
;;;707      LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
;;;708      return ERR_MEM;
;;;709    }
000898  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2204|
00089c  e59d1010          LDR      r1,[sp,#0x10]         ;491
0008a0  e3a02001          MOV      r2,#1                 ;491
0008a4  e3a00003          MOV      r0,#3                 ;491
0008a8  ebfffffe          BL       pbuf_alloc
0008ac  e3500000          CMP      r0,#0                 ;491
0008b0  e58d001c          STR      r0,[sp,#0x1c]         ;491
0008b4  0a000135          BEQ      |L1.3472|
0008b8  e59d0030          LDR      r0,[sp,#0x30]         ;503
0008bc  e0801006          ADD      r1,r0,r6              ;503
0008c0  e59d001c          LDR      r0,[sp,#0x1c]         ;503
0008c4  e5801004          STR      r1,[r0,#4]            ;503
                  |L1.2248|
0008c8  e59d0010          LDR      r0,[sp,#0x10]         ;506
0008cc  e0800006          ADD      r0,r0,r6              ;506
0008d0  e3c06801          BIC      r6,r0,#0x10000        ;506
0008d4  e59d001c          LDR      r0,[sp,#0x1c]         ;507
0008d8  ebfffffe          BL       pbuf_clen
0008dc  e080000a          ADD      r0,r0,r10             ;507
0008e0  e3c0a801          BIC      r10,r0,#0x10000       ;507
0008e4  ea0000c5          B        |L1.3072|
                  |L1.2280|
0008e8  e1d506ba          LDRH     r0,[r5,#0x6a]         ;511
0008ec  e3500000          CMP      r0,#0                 ;511
0008f0  0a0000c2          BEQ      |L1.3072|
0008f4  e59f30cc          LDR      r3,|L1.2504|
0008f8  e59f2180          LDR      r2,|L1.2688|
0008fc  e59f00f8          LDR      r0,|L1.2556|
000900  e28f1f5f          ADR      r1,|L1.2692|
000904  ebfffffe          BL       sysprintf
000908  ea0000bc          B        |L1.3072|
                  |L1.2316|
00090c  e0490006          SUB      r0,r9,r6              ;524
000910  e1a01800          LSL      r1,r0,#16             ;524
000914  e59d0020          LDR      r0,[sp,#0x20]         ;525
000918  e59d2014          LDR      r2,[sp,#0x14]         ;525
00091c  e1a01821          LSR      r1,r1,#16             ;524
000920  e0400002          SUB      r0,r0,r2              ;525
000924  e1a00800          LSL      r0,r0,#16             ;525
000928  e1a00820          LSR      r0,r0,#16             ;525
00092c  e1510000          CMP      r1,r0                 ;526
000930  91a00001          MOVLS    r0,r1                 ;526
000934  e58d0010          STR      r0,[sp,#0x10]         ;532
000938  e59d0038          LDR      r0,[sp,#0x38]         ;532
00093c  e3100001          TST      r0,#1                 ;532
000940  0a00006c          BEQ      |L1.2808|
000944  e35b0000          CMP      r11,#0                ;535
000948  03a00001          MOVEQ    r0,#1                 ;535
00094c  13a00000          MOVNE    r0,#0                 ;535
000950  e58d0008          STR      r0,[sp,#8]            ;535
000954  e59d0010          LDR      r0,[sp,#0x10]         ;535
000958  e59d1038          LDR      r1,[sp,#0x38]         ;535
00095c  e0800002          ADD      r0,r0,r2              ;535
000960  e58d1004          STR      r1,[sp,#4]            ;535
000964  e3c01801          BIC      r1,r0,#0x10000        ;535
000968  e59d2020          LDR      r2,[sp,#0x20]         ;535
00096c  e28d3018          ADD      r3,sp,#0x18           ;535
000970  e3a00000          MOV      r0,#0                 ;535
000974  e58d5000          STR      r5,[sp,#0]            ;535
000978  ebfffffe          BL       tcp_pbuf_prealloc
00097c  e1b07000          MOVS     r7,r0                 ;535
000980  0a000102          BEQ      |L1.3472|
000984  e1d710ba          LDRH     r1,[r7,#0xa]          ;539
000988  e59d0010          LDR      r0,[sp,#0x10]         ;539
00098c  e1500001          CMP      r0,r1                 ;539
000990  9a000004          BLS      |L1.2472|
000994  e59f302c          LDR      r3,|L1.2504|
000998  e59f2114          LDR      r2,|L1.2740|
00099c  e59f0058          LDR      r0,|L1.2556|
0009a0  e28f1e11          ADR      r1,|L1.2744|
0009a4  ebfffffe          BL       sysprintf
                  |L1.2472|
0009a8  e59d0030          LDR      r0,[sp,#0x30]         ;541
0009ac  e5972004          LDR      r2,[r7,#4]            ;541
0009b0  e0801006          ADD      r1,r0,r6              ;541
0009b4  e59d0014          LDR      r0,[sp,#0x14]         ;541
0009b8  e0800002          ADD      r0,r0,r2              ;541
0009bc  e59d2010          LDR      r2,[sp,#0x10]         ;541
0009c0  ebfffffe          BL       __aeabi_memcpy
0009c4  ea000067          B        |L1.2920|
                  |L1.2504|
                          DCD      ||.text||+0x218
                  |L1.2508|
0009cc  756e7365          DCB      "unsent_oversize mismatch (pcb vs. last_unsent)",0
0009d0  6e745f6f
0009d4  76657273
0009d8  697a6520
0009dc  6d69736d
0009e0  61746368
0009e4  20287063
0009e8  62207673
0009ec  2e206c61
0009f0  73745f75
0009f4  6e73656e
0009f8  742900  
0009fb  00                DCB      0
                  |L1.2556|
                          DCD      ||.text||+0x268
                  |L1.2560|
                          DCD      0x000001c1
                  |L1.2564|
000a04  696e636f          DCB      "inconsistent oversize vs. space",0
000a08  6e736973
000a0c  74656e74
000a10  206f7665
000a14  7273697a
000a18  65207673
000a1c  2e207370
000a20  61636500
                  |L1.2596|
                          DCD      0x000001c9
                  |L1.2600|
000a28  696e636f          DCB      "inconsistend oversize vs. len",0
000a2c  6e736973
000a30  74656e64
000a34  206f7665
000a38  7273697a
000a3c  65207673
000a40  2e206c65
000a44  6e00    
000a46  00                DCB      0
000a47  00                DCB      0
                  |L1.2632|
                          DCD      0x0000017e
                  |L1.2636|
000a4c  7463705f          DCB      "tcp_write: arg == NULL (programmer violates API)",0
000a50  77726974
000a54  653a2061
000a58  7267203d
000a5c  3d204e55
000a60  4c4c2028
000a64  70726f67
000a68  72616d6d
000a6c  65722076
000a70  696f6c61
000a74  74657320
000a78  41504929
000a7c  00      
000a7d  00                DCB      0
000a7e  00                DCB      0
000a7f  00                DCB      0
                  |L1.2688|
                          DCD      0x000001ff
                  |L1.2692|
000a84  756e7365          DCB      "unsent_oversize mismatch (pcb->unsent is NULL)",0
000a88  6e745f6f
000a8c  76657273
000a90  697a6520
000a94  6d69736d
000a98  61746368
000a9c  20287063
000aa0  622d3e75
000aa4  6e73656e
000aa8  74206973
000aac  204e554c
000ab0  4c2900  
000ab3  00                DCB      0
                  |L1.2740|
                          DCD      0x0000021b
                  |L1.2744|
000ab8  7463705f          DCB      "tcp_write: check that first pbuf can hold the complete "
000abc  77726974
000ac0  653a2063
000ac4  6865636b
000ac8  20746861
000acc  74206669
000ad0  72737420
000ad4  70627566
000ad8  2063616e
000adc  20686f6c
000ae0  64207468
000ae4  6520636f
000ae8  6d706c65
000aec  746520  
000aef  7365676c          DCB      "seglen",0
000af3  656e00  
000af6  00                DCB      0
000af7  00                DCB      0
                  |L1.2808|
000af8  e1dd01b8          LDRH     r0,[sp,#0x18]         ;550
000afc  e3500000          CMP      r0,#0                 ;550
000b00  0a000004          BEQ      |L1.2840|
000b04  e51f3144          LDR      r3,|L1.2504|
000b08  e59f22e0          LDR      r2,|L1.3568|
000b0c  e51f0118          LDR      r0,|L1.2556|
000b10  e28f1fb7          ADR      r1,|L1.3572|
000b14  ebfffffe          BL       sysprintf
                  |L1.2840|
000b18  e59d1010          LDR      r1,[sp,#0x10]         ;552
000b1c  e3a02001          MOV      r2,#1                 ;552
000b20  e3a00000          MOV      r0,#0                 ;552
000b24  ebfffffe          BL       pbuf_alloc
000b28  e3500000          CMP      r0,#0                 ;552
000b2c  e58d0000          STR      r0,[sp,#0]            ;552
000b30  0a000096          BEQ      |L1.3472|
000b34  e59d0030          LDR      r0,[sp,#0x30]         ;561
000b38  e3a02000          MOV      r2,#0                 ;564
000b3c  e0801006          ADD      r1,r0,r6              ;561
000b40  e59d0000          LDR      r0,[sp,#0]            ;561
000b44  e5801004          STR      r1,[r0,#4]            ;564
000b48  e59d1014          LDR      r1,[sp,#0x14]         ;564
000b4c  e1a00002          MOV      r0,r2                 ;564
000b50  ebfffffe          BL       pbuf_alloc
000b54  e1b07000          MOVS     r7,r0                 ;564
000b58  059d0000          LDREQ    r0,[sp,#0]            ;567
000b5c  0a000008          BEQ      |L1.2948|
000b60  e59d1000          LDR      r1,[sp,#0]            ;572
000b64  ebfffffe          BL       pbuf_cat
                  |L1.2920|
000b68  e1a00007          MOV      r0,r7                 ;575
000b6c  ebfffffe          BL       pbuf_clen
000b70  e080000a          ADD      r0,r0,r10             ;575
000b74  e3c0a801          BIC      r10,r0,#0x10000       ;575
000b78  e35a0008          CMP      r10,#8                ;580
000b7c  81a00007          MOVHI    r0,r7                 ;582
000b80  9a000001          BLS      |L1.2956|
                  |L1.2948|
000b84  ebfffffe          BL       pbuf_free
000b88  ea000080          B        |L1.3472|
                  |L1.2956|
000b8c  e59d0028          LDR      r0,[sp,#0x28]         ;586
000b90  e3a02000          MOV      r2,#0                 ;586
000b94  e58d0000          STR      r0,[sp,#0]            ;586
000b98  e595005c          LDR      r0,[r5,#0x5c]         ;586
000b9c  e1a01007          MOV      r1,r7                 ;586
000ba0  e0803006          ADD      r3,r0,r6              ;586
000ba4  e1a00005          MOV      r0,r5                 ;586
000ba8  ebfffffe          BL       tcp_create_segment
000bac  e1b07000          MOVS     r7,r0                 ;586
000bb0  0a000076          BEQ      |L1.3472|
000bb4  e1dd01b8          LDRH     r0,[sp,#0x18]         ;590
000bb8  e35b0000          CMP      r11,#0                ;599
000bbc  01a0b007          MOVEQ    r11,r7                ;600
000bc0  e1c700ba          STRH     r0,[r7,#0xa]          ;590
000bc4  0a000009          BEQ      |L1.3056|
000bc8  e59d0024          LDR      r0,[sp,#0x24]         ;603
000bcc  e3500000          CMP      r0,#0                 ;603
000bd0  1a000004          BNE      |L1.3048|
000bd4  e51f3214          LDR      r3,|L1.2504|
000bd8  e59f2224          LDR      r2,|L1.3588|
000bdc  e51f01e8          LDR      r0,|L1.2556|
000be0  e28f1e22          ADR      r1,|L1.3592|
000be4  ebfffffe          BL       sysprintf
                  |L1.3048|
000be8  e59d0024          LDR      r0,[sp,#0x24]         ;604
000bec  e5807000          STR      r7,[r0,#0]            ;604
                  |L1.3056|
000bf0  e58d7024          STR      r7,[sp,#0x24]         ;613
000bf4  e59d0010          LDR      r0,[sp,#0x10]         ;613
000bf8  e0800006          ADD      r0,r0,r6              ;613
000bfc  e3c06801          BIC      r6,r0,#0x10000        ;613
                  |L1.3072|
000c00  e1560009          CMP      r6,r9                 ;522
000c04  3affff40          BCC      |L1.2316|
000c08  e3580000          CMP      r8,#0                 ;626
000c0c  15946004          LDRNE    r6,[r4,#4]            ;629
000c10  1a000010          BNE      |L1.3160|
000c14  ea00001f          B        |L1.3224|
                  |L1.3096|
000c18  e1d600b8          LDRH     r0,[r6,#8]            ;630
000c1c  e0800008          ADD      r0,r0,r8              ;630
000c20  e1c600b8          STRH     r0,[r6,#8]            ;630
000c24  e5960000          LDR      r0,[r6,#0]            ;631
000c28  e3500000          CMP      r0,#0                 ;631
000c2c  1a000008          BNE      |L1.3156|
000c30  e1d610ba          LDRH     r1,[r6,#0xa]          ;632
000c34  e5960004          LDR      r0,[r6,#4]            ;632
000c38  e1a02008          MOV      r2,r8                 ;632
000c3c  e0800001          ADD      r0,r0,r1              ;632
000c40  e59d1030          LDR      r1,[sp,#0x30]         ;632
000c44  ebfffffe          BL       __aeabi_memcpy
000c48  e1d600ba          LDRH     r0,[r6,#0xa]          ;633
000c4c  e0800008          ADD      r0,r0,r8              ;633
000c50  e1c600ba          STRH     r0,[r6,#0xa]          ;633
                  |L1.3156|
000c54  e5966000          LDR      r6,[r6,#0]            ;629
                  |L1.3160|
000c58  e3560000          CMP      r6,#0                 ;629
000c5c  1affffed          BNE      |L1.3096|
000c60  e1d400b8          LDRH     r0,[r4,#8]            ;636
000c64  e0800008          ADD      r0,r0,r8              ;636
000c68  e1c400b8          STRH     r0,[r4,#8]            ;636
000c6c  e1d400ba          LDRH     r0,[r4,#0xa]          ;638
000c70  e1500008          CMP      r0,r8                 ;638
000c74  2a000004          BCS      |L1.3212|
000c78  e51f32b8          LDR      r3,|L1.2504|
000c7c  e59f2198          LDR      r2,|L1.3612|
000c80  e51f028c          LDR      r0,|L1.2556|
000c84  e28f1f65          ADR      r1,|L1.3616|
000c88  ebfffffe          BL       sysprintf
                  |L1.3212|
000c8c  e1d400ba          LDRH     r0,[r4,#0xa]          ;640
000c90  e0400008          SUB      r0,r0,r8              ;640
000c94  e1c400ba          STRH     r0,[r4,#0xa]          ;640
                  |L1.3224|
000c98  e1dd01b8          LDRH     r0,[sp,#0x18]         ;643
000c9c  e1c506ba          STRH     r0,[r5,#0x6a]         ;643
000ca0  e59d001c          LDR      r0,[sp,#0x1c]         ;649
000ca4  e3500000          CMP      r0,#0                 ;649
000ca8  0a00000e          BEQ      |L1.3304|
000cac  e3540000          CMP      r4,#0                 ;650
000cb0  1a000004          BNE      |L1.3272|
000cb4  e51f32f4          LDR      r3,|L1.2504|
000cb8  e59f218c          LDR      r2,|L1.3660|
000cbc  e51f02c8          LDR      r0,|L1.2556|
000cc0  e28f1f62          ADR      r1,|L1.3664|
000cc4  ebfffffe          BL       sysprintf
                  |L1.3272|
000cc8  e5940004          LDR      r0,[r4,#4]            ;652
000ccc  e59d101c          LDR      r1,[sp,#0x1c]         ;652
000cd0  ebfffffe          BL       pbuf_cat
000cd4  e59d001c          LDR      r0,[sp,#0x1c]         ;653
000cd8  e1d410b8          LDRH     r1,[r4,#8]            ;653
000cdc  e1d000b8          LDRH     r0,[r0,#8]            ;653
000ce0  e0800001          ADD      r0,r0,r1              ;653
000ce4  e1c400b8          STRH     r0,[r4,#8]            ;653
                  |L1.3304|
000ce8  e3540000          CMP      r4,#0                 ;667
000cec  0585b06c          STREQ    r11,[r5,#0x6c]        ;668
000cf0  1584b000          STRNE    r11,[r4,#0]           ;670
000cf4  e595005c          LDR      r0,[r5,#0x5c]         ;676
000cf8  e35a0000          CMP      r10,#0                ;682
000cfc  e0800009          ADD      r0,r0,r9              ;676
000d00  e585005c          STR      r0,[r5,#0x5c]         ;676
000d04  e1d506b6          LDRH     r0,[r5,#0x66]         ;677
000d08  e0400009          SUB      r0,r0,r9              ;677
000d0c  e1c506b6          STRH     r0,[r5,#0x66]         ;677
000d10  e1c5a6b8          STRH     r10,[r5,#0x68]        ;678
000d14  0a000009          BEQ      |L1.3392|
000d18  e5950070          LDR      r0,[r5,#0x70]         ;683
000d1c  e3500000          CMP      r0,#0                 ;683
000d20  0595006c          LDREQ    r0,[r5,#0x6c]         ;683
000d24  03500000          CMPEQ    r0,#0                 ;683
000d28  1a000004          BNE      |L1.3392|
000d2c  e51f336c          LDR      r3,|L1.2504|
000d30  e59f2150          LDR      r2,|L1.3720|
000d34  e51f0340          LDR      r0,|L1.2556|
000d38  e28f1f53          ADR      r1,|L1.3724|
000d3c  ebfffffe          BL       sysprintf
                  |L1.3392|
000d40  e3570000          CMP      r7,#0                 ;688
000d44  15970010          LDRNE    r0,[r7,#0x10]         ;688
000d48  13500000          CMPNE    r0,#0                 ;688
000d4c  0a00000d          BEQ      |L1.3464|
000d50  e59d0038          LDR      r0,[sp,#0x38]         ;688
000d54  e3100002          TST      r0,#2                 ;688
000d58  1a00000a          BNE      |L1.3464|
000d5c  e3a00008          MOV      r0,#8                 ;689
000d60  ebfffffe          BL       lwip_htons
000d64  e1a01000          MOV      r1,r0                 ;689
000d68  e5970010          LDR      r0,[r7,#0x10]         ;689
000d6c  e5d0200d          LDRB     r2,[r0,#0xd]          ;689
000d70  e5d0300c          LDRB     r3,[r0,#0xc]          ;689
000d74  e1832402          ORR      r2,r3,r2,LSL #8       ;689
000d78  e1811002          ORR      r1,r1,r2              ;689
000d7c  e5c0100c          STRB     r1,[r0,#0xc]          ;689
000d80  e1a01421          LSR      r1,r1,#8              ;689
000d84  e5c0100d          STRB     r1,[r0,#0xd]          ;689
                  |L1.3464|
000d88  e3a00000          MOV      r0,#0                 ;692
000d8c  eafffec0          B        |L1.2196|
                  |L1.3472|
000d90  e5d5001e          LDRB     r0,[r5,#0x1e]         ;694
000d94  e3800080          ORR      r0,r0,#0x80           ;694
000d98  e5c5001e          STRB     r0,[r5,#0x1e]         ;694
000d9c  e59d001c          LDR      r0,[sp,#0x1c]         ;697
000da0  e3500000          CMP      r0,#0                 ;697
000da4  1bfffffe          BLNE     pbuf_free
000da8  e35b0000          CMP      r11,#0                ;700
000dac  11a0000b          MOVNE    r0,r11                ;701
000db0  1bfffffe          BLNE     tcp_segs_free
000db4  e1d506b8          LDRH     r0,[r5,#0x68]         ;703
000db8  e3500000          CMP      r0,#0                 ;703
000dbc  0a000009          BEQ      |L1.3560|
000dc0  e5950070          LDR      r0,[r5,#0x70]         ;704
000dc4  e3500000          CMP      r0,#0                 ;704
000dc8  0595006c          LDREQ    r0,[r5,#0x6c]         ;704
000dcc  03500000          CMPEQ    r0,#0                 ;704
000dd0  1a000004          BNE      |L1.3560|
000dd4  e51f3414          LDR      r3,|L1.2504|
000dd8  e51f03e4          LDR      r0,|L1.2556|
000ddc  e3a02d0b          MOV      r2,#0x2c0             ;704
000de0  e28f10a4          ADR      r1,|L1.3724|
000de4  ebfffffe          BL       sysprintf
                  |L1.3560|
000de8  e3e00000          MVN      r0,#0                 ;708
000dec  eafffea8          B        |L1.2196|
                  |L1.3568|
                          DCD      0x00000226
                  |L1.3572|
000df4  6f766572          DCB      "oversize == 0",0
000df8  73697a65
000dfc  203d3d20
000e00  3000    
000e02  00                DCB      0
000e03  00                DCB      0
                  |L1.3588|
                          DCD      0x0000025b
                  |L1.3592|
000e08  70726576          DCB      "prev_seg != NULL",0
000e0c  5f736567
000e10  20213d20
000e14  4e554c4c
000e18  00      
000e19  00                DCB      0
000e1a  00                DCB      0
000e1b  00                DCB      0
                  |L1.3612|
                          DCD      0x0000027e
                  |L1.3616|
000e20  6c617374          DCB      "last_unsent->oversize_left >= oversize_used",0
000e24  5f756e73
000e28  656e742d
000e2c  3e6f7665
000e30  7273697a
000e34  655f6c65
000e38  6674203e
000e3c  3d206f76
000e40  65727369
000e44  7a655f75
000e48  73656400
                  |L1.3660|
                          DCD      0x0000028a
                  |L1.3664|
000e50  7463705f          DCB      "tcp_write: cannot concatenate when pcb->unsent is empty"
000e54  77726974
000e58  653a2063
000e5c  616e6e6f
000e60  7420636f
000e64  6e636174
000e68  656e6174
000e6c  65207768
000e70  656e2070
000e74  63622d3e
000e78  756e7365
000e7c  6e742069
000e80  7320656d
000e84  707479  
000e87  00                DCB      0
                  |L1.3720|
                          DCD      0x000002ab
                  |L1.3724|
000e8c  7463705f          DCB      "tcp_write: valid queue length",0
000e90  77726974
000e94  653a2076
000e98  616c6964
000e9c  20717565
000ea0  7565206c
000ea4  656e6774
000ea8  6800    
000eaa  00                DCB      0
000eab  00                DCB      0
                          ENDP

                  tcp_send_empty_ack PROC
;;;841    err_t
;;;842    tcp_send_empty_ack(struct tcp_pcb *pcb)
000eac  e92d407c          PUSH     {r2-r6,lr}
;;;843    {
000eb0  e1a04000          MOV      r4,r0
;;;844      struct pbuf *p;
;;;845      struct tcp_hdr *tcphdr;
;;;846      u8_t optlen = 0;
;;;847    
;;;848    #if LWIP_TCP_TIMESTAMPS
;;;849      if (pcb->flags & TF_TIMESTAMP) {
;;;850        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;851      }
;;;852    #endif
;;;853    
;;;854      p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
000eb4  e5900050          LDR      r0,[r0,#0x50]
000eb8  e3a05000          MOV      r5,#0                 ;846
000ebc  ebfffffe          BL       lwip_htonl
000ec0  e1a03000          MOV      r3,r0
000ec4  e3a02000          MOV      r2,#0
000ec8  e1a01005          MOV      r1,r5
000ecc  e1a00004          MOV      r0,r4
000ed0  ebfffffe          BL       tcp_output_alloc_header
000ed4  e1b05000          MOVS     r5,r0
;;;855      if (p == NULL) {
;;;856        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
;;;857        return ERR_BUF;
000ed8  03e00001          MVNEQ    r0,#1
000edc  0a000018          BEQ      |L1.3908|
;;;858      }
;;;859      tcphdr = (struct tcp_hdr *)p->payload;
;;;860      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
;;;861                  ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
;;;862      /* remove ACK flags from the PCB, as we send an empty ACK now */
;;;863      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
000ee0  e5d4001e          LDRB     r0,[r4,#0x1e]
000ee4  e5956004          LDR      r6,[r5,#4]            ;859
;;;864    
;;;865      /* NB. MSS option is only sent on SYNs, so ignore it here */
;;;866    #if LWIP_TCP_TIMESTAMPS
;;;867      pcb->ts_lastacksent = pcb->rcv_nxt;
;;;868    
;;;869      if (pcb->flags & TF_TIMESTAMP) {
;;;870        tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
;;;871      }
;;;872    #endif 
;;;873    
;;;874    #if CHECKSUM_GEN_TCP
;;;875      tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
000ee8  e3a03006          MOV      r3,#6
000eec  e3c00003          BIC      r0,r0,#3              ;863
000ef0  e5c4001e          STRB     r0,[r4,#0x1e]         ;863
000ef4  e1d500b8          LDRH     r0,[r5,#8]
000ef8  e2842004          ADD      r2,r4,#4
000efc  e1a01004          MOV      r1,r4
000f00  e58d0000          STR      r0,[sp,#0]
000f04  e1a00005          MOV      r0,r5
000f08  ebfffffe          BL       inet_chksum_pseudo
000f0c  e5c60010          STRB     r0,[r6,#0x10]
000f10  e1a00420          LSR      r0,r0,#8
000f14  e5c60011          STRB     r0,[r6,#0x11]
;;;876            IP_PROTO_TCP, p->tot_len);
;;;877    #endif
;;;878    #if LWIP_NETIF_HWADDRHINT
;;;879      ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;880          IP_PROTO_TCP, &(pcb->addr_hint));
;;;881    #else /* LWIP_NETIF_HWADDRHINT*/
;;;882      ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
000f18  e5d40009          LDRB     r0,[r4,#9]
000f1c  e3a01006          MOV      r1,#6
000f20  e2842004          ADD      r2,r4,#4
000f24  e1cd00f0          STRD     r0,r1,[sp,#0]
000f28  e5d4300a          LDRB     r3,[r4,#0xa]
000f2c  e1a01004          MOV      r1,r4
000f30  e1a00005          MOV      r0,r5
000f34  ebfffffe          BL       ip_output
;;;883          IP_PROTO_TCP);
;;;884    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;885      pbuf_free(p);
000f38  e1a00005          MOV      r0,r5
000f3c  ebfffffe          BL       pbuf_free
;;;886    
;;;887      return ERR_OK;
000f40  e3a00000          MOV      r0,#0
                  |L1.3908|
;;;888    }
000f44  e8bd807c          POP      {r2-r6,pc}
;;;889    
                          ENDP

                  tcp_output_segment PROC
;;;1048   static void
;;;1049   tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
000f48  e92d407c          PUSH     {r2-r6,lr}
;;;1050   {
000f4c  e1a05000          MOV      r5,r0
;;;1051     u16_t len;
;;;1052     struct netif *netif;
;;;1053     u32_t *opts;
;;;1054   
;;;1055     /** @bug Exclude retransmitted segments from this count. */
;;;1056     snmp_inc_tcpoutsegs();
;;;1057   
;;;1058     /* The TCP header has already been constructed, but the ackno and
;;;1059      wnd fields remain. */
;;;1060     seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
000f50  e5910028          LDR      r0,[r1,#0x28]
000f54  e1a04001          MOV      r4,r1                 ;1050
000f58  ebfffffe          BL       lwip_htonl
000f5c  e5951010          LDR      r1,[r5,#0x10]
000f60  e2811008          ADD      r1,r1,#8
000f64  ebfffffe          BL       __aeabi_uwrite4
;;;1061   
;;;1062     /* advertise our receive window size in this TCP segment */
;;;1063     seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
000f68  e1d402be          LDRH     r0,[r4,#0x2e]
000f6c  ebfffffe          BL       lwip_htons
000f70  e5951010          LDR      r1,[r5,#0x10]
000f74  e5c1000e          STRB     r0,[r1,#0xe]
000f78  e1a00420          LSR      r0,r0,#8
000f7c  e5c1000f          STRB     r0,[r1,#0xf]
;;;1064   
;;;1065     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
000f80  e1d412be          LDRH     r1,[r4,#0x2e]
000f84  e5940028          LDR      r0,[r4,#0x28]
000f88  e0800001          ADD      r0,r0,r1
;;;1066   
;;;1067     /* Add any requested options.  NB MSS option is only set on SYN
;;;1068        packets, so ignore it here */
;;;1069     opts = (u32_t *)(void *)(seg->tcphdr + 1);
000f8c  e5840030          STR      r0,[r4,#0x30]
000f90  e5950010          LDR      r0,[r5,#0x10]
000f94  e2806014          ADD      r6,r0,#0x14
;;;1070     if (seg->flags & TF_SEG_OPTS_MSS) {
000f98  e5d5000c          LDRB     r0,[r5,#0xc]
000f9c  e3100001          TST      r0,#1
000fa0  0a000005          BEQ      |L1.4028|
;;;1071       u16_t mss;
;;;1072   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1073       mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
000fa4  e2841004          ADD      r1,r4,#4
000fa8  e3a00ffa          MOV      r0,#0x3e8
000fac  ebfffffe          BL       tcp_eff_send_mss
;;;1074   #else /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1075       mss = TCP_MSS;
;;;1076   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1077       *opts = TCP_BUILD_MSS_OPTION(mss);
000fb0  e3800781          ORR      r0,r0,#0x2040000
000fb4  ebfffffe          BL       lwip_htonl
000fb8  e5860000          STR      r0,[r6,#0]
                  |L1.4028|
;;;1078       opts += 1;
;;;1079     }
;;;1080   #if LWIP_TCP_TIMESTAMPS
;;;1081     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;1082   
;;;1083     if (seg->flags & TF_SEG_OPTS_TS) {
;;;1084       tcp_build_timestamp_option(pcb, opts);
;;;1085       opts += 3;
;;;1086     }
;;;1087   #endif
;;;1088   
;;;1089     /* Set retransmission timer running if it is not currently enabled 
;;;1090        This must be set before checking the route. */
;;;1091     if (pcb->rtime == -1) {
000fbc  e1d403f4          LDRSH    r0,[r4,#0x34]
000fc0  e3a06000          MOV      r6,#0
000fc4  e3700001          CMN      r0,#1
;;;1092       pcb->rtime = 0;
000fc8  01c463b4          STRHEQ   r6,[r4,#0x34]
;;;1093     }
;;;1094   
;;;1095     /* If we don't have a local IP address, we get one by
;;;1096        calling ip_route(). */
;;;1097     if (ip_addr_isany(&(pcb->local_ip))) {
000fcc  e3540000          CMP      r4,#0
000fd0  15940000          LDRNE    r0,[r4,#0]
000fd4  13500000          CMPNE    r0,#0
000fd8  0a000003          BEQ      |L1.4076|
                  |L1.4060|
;;;1098       netif = ip_route(&(pcb->remote_ip));
;;;1099       if (netif == NULL) {
;;;1100         return;
;;;1101       }
;;;1102       ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;1103     }
;;;1104   
;;;1105     if (pcb->rttest == 0) {
000fdc  e5940038          LDR      r0,[r4,#0x38]
000fe0  e3500000          CMP      r0,#0
000fe4  1a00000f          BNE      |L1.4136|
000fe8  ea000006          B        |L1.4104|
                  |L1.4076|
000fec  e2840004          ADD      r0,r4,#4              ;1098
000ff0  ebfffffe          BL       ip_route
000ff4  e3500000          CMP      r0,#0                 ;1099
000ff8  15900004          LDRNE    r0,[r0,#4]            ;1102
000ffc  15840000          STRNE    r0,[r4,#0]            ;1102
001000  1afffff5          BNE      |L1.4060|
;;;1106       pcb->rttest = tcp_ticks;
;;;1107       pcb->rtseq = ntohl(seg->tcphdr->seqno);
;;;1108   
;;;1109       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
;;;1110     }
;;;1111     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
;;;1112             htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
;;;1113             seg->len));
;;;1114   
;;;1115     len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
;;;1116   
;;;1117     seg->p->len -= len;
;;;1118     seg->p->tot_len -= len;
;;;1119   
;;;1120     seg->p->payload = seg->tcphdr;
;;;1121   
;;;1122     seg->tcphdr->chksum = 0;
;;;1123   #if CHECKSUM_GEN_TCP
;;;1124   #if TCP_CHECKSUM_ON_COPY
;;;1125     {
;;;1126       u32_t acc;
;;;1127   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1128       u16_t chksum_slow = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1129              &(pcb->remote_ip),
;;;1130              IP_PROTO_TCP, seg->p->tot_len);
;;;1131   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1132       if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
;;;1133         LWIP_ASSERT("data included but not checksummed",
;;;1134           seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
;;;1135       }
;;;1136   
;;;1137       /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
;;;1138       acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
;;;1139                &(pcb->remote_ip),
;;;1140                IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
;;;1141       /* add payload checksum */
;;;1142       if (seg->chksum_swapped) {
;;;1143         seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1144         seg->chksum_swapped = 0;
;;;1145       }
;;;1146       acc += (u16_t)~(seg->chksum);
;;;1147       seg->tcphdr->chksum = FOLD_U32T(acc);
;;;1148   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1149       if (chksum_slow != seg->tcphdr->chksum) {
;;;1150         LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1151                     ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
;;;1152                     seg->tcphdr->chksum, chksum_slow));
;;;1153         seg->tcphdr->chksum = chksum_slow;
;;;1154       }
;;;1155   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1156     }
;;;1157   #else /* TCP_CHECKSUM_ON_COPY */
;;;1158     seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1159            &(pcb->remote_ip),
;;;1160            IP_PROTO_TCP, seg->p->tot_len);
;;;1161   #endif /* TCP_CHECKSUM_ON_COPY */
;;;1162   #endif /* CHECKSUM_GEN_TCP */
;;;1163     TCP_STATS_INC(tcp.xmit);
;;;1164   
;;;1165   #if LWIP_NETIF_HWADDRHINT
;;;1166     ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1167         IP_PROTO_TCP, &(pcb->addr_hint));
;;;1168   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1169     ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1170         IP_PROTO_TCP);
;;;1171   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1172   }
001004  e8bd807c          POP      {r2-r6,pc}
                  |L1.4104|
001008  e59f03b8          LDR      r0,|L1.5064|
00100c  e5900000          LDR      r0,[r0,#0]            ;1106  ; tcp_ticks
001010  e5840038          STR      r0,[r4,#0x38]         ;1107
001014  e5950010          LDR      r0,[r5,#0x10]         ;1107
001018  e2800004          ADD      r0,r0,#4              ;1107
00101c  ebfffffe          BL       __aeabi_uread4
001020  ebfffffe          BL       lwip_ntohl
001024  e584003c          STR      r0,[r4,#0x3c]         ;1107
                  |L1.4136|
001028  e5951004          LDR      r1,[r5,#4]            ;1115
00102c  e1d501b0          LDRH     r0,[r5,#0x10]         ;1115
001030  e1d120b4          LDRH     r2,[r1,#4]            ;1115
001034  e3a03006          MOV      r3,#6                 ;1158
001038  e0400002          SUB      r0,r0,r2              ;1115
00103c  e1d120ba          LDRH     r2,[r1,#0xa]          ;1117
001040  e0422000          SUB      r2,r2,r0              ;1117
001044  e1c120ba          STRH     r2,[r1,#0xa]          ;1117
001048  e5951004          LDR      r1,[r5,#4]            ;1118
00104c  e1d120b8          LDRH     r2,[r1,#8]            ;1118
001050  e0420000          SUB      r0,r2,r0              ;1118
001054  e1c100b8          STRH     r0,[r1,#8]            ;1118
001058  e5950010          LDR      r0,[r5,#0x10]         ;1120
00105c  e5951004          LDR      r1,[r5,#4]            ;1120
001060  e2842004          ADD      r2,r4,#4              ;1158
001064  e5810004          STR      r0,[r1,#4]            ;1122
001068  e5950010          LDR      r0,[r5,#0x10]         ;1122
00106c  e1a01426          LSR      r1,r6,#8              ;1122
001070  e5c06010          STRB     r6,[r0,#0x10]         ;1122
001074  e5c01011          STRB     r1,[r0,#0x11]         ;1122
001078  e5950004          LDR      r0,[r5,#4]            ;1158
00107c  e1d010b8          LDRH     r1,[r0,#8]            ;1158
001080  e58d1000          STR      r1,[sp,#0]            ;1158
001084  e1a01004          MOV      r1,r4                 ;1158
001088  ebfffffe          BL       inet_chksum_pseudo
00108c  e5951010          LDR      r1,[r5,#0x10]         ;1158
001090  e2842004          ADD      r2,r4,#4              ;1169
001094  e5c10010          STRB     r0,[r1,#0x10]         ;1158
001098  e1a00420          LSR      r0,r0,#8              ;1158
00109c  e5c10011          STRB     r0,[r1,#0x11]         ;1158
0010a0  e5d40009          LDRB     r0,[r4,#9]            ;1169
0010a4  e3a01006          MOV      r1,#6                 ;1169
0010a8  e1cd00f0          STRD     r0,r1,[sp,#0]         ;1169
0010ac  e5d4300a          LDRB     r3,[r4,#0xa]          ;1169
0010b0  e5950004          LDR      r0,[r5,#4]            ;1169
0010b4  e1a01004          MOV      r1,r4                 ;1169
0010b8  ebfffffe          BL       ip_output
0010bc  e8bd807c          POP      {r2-r6,pc}
;;;1173   
                          ENDP

                  tcp_output PROC
;;;897    err_t
;;;898    tcp_output(struct tcp_pcb *pcb)
0010c0  e92d47f0          PUSH     {r4-r10,lr}
;;;899    {
0010c4  e1a04000          MOV      r4,r0
;;;900      struct tcp_seg *seg, *useg;
;;;901      u32_t wnd, snd_nxt;
;;;902    #if TCP_CWND_DEBUG
;;;903      s16_t i = 0;
;;;904    #endif /* TCP_CWND_DEBUG */
;;;905    
;;;906      /* pcb->state LISTEN not allowed here */
;;;907      LWIP_ASSERT("don't call tcp_output for listen-pcbs",
0010c8  e5d00018          LDRB     r0,[r0,#0x18]
0010cc  e3500001          CMP      r0,#1
0010d0  1a000004          BNE      |L1.4328|
0010d4  e51f3714          LDR      r3,|L1.2504|
0010d8  e59f22ec          LDR      r2,|L1.5068|
0010dc  e51f06e8          LDR      r0,|L1.2556|
0010e0  e28f1fba          ADR      r1,|L1.5072|
0010e4  ebfffffe          BL       sysprintf
                  |L1.4328|
;;;908        pcb->state != LISTEN);
;;;909    
;;;910      /* First, check if we are invoked by the TCP input processing
;;;911         code. If so, we do not output anything. Instead, we rely on the
;;;912         input processing code to call us when input processing is done
;;;913         with. */
;;;914      if (tcp_input_pcb == pcb) {
0010e8  e59f0308          LDR      r0,|L1.5112|
0010ec  e5900000          LDR      r0,[r0,#0]  ; tcp_input_pcb
0010f0  e1500004          CMP      r0,r4
0010f4  1a000001          BNE      |L1.4352|
                  |L1.4344|
;;;915        return ERR_OK;
0010f8  e3a00000          MOV      r0,#0
;;;916      }
;;;917    
;;;918      wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
;;;919    
;;;920      seg = pcb->unsent;
;;;921    
;;;922      /* If the TF_ACK_NOW flag is set and no data will be sent (either
;;;923       * because the ->unsent queue is empty or because the window does
;;;924       * not allow it), construct an empty ACK segment and send it.
;;;925       *
;;;926       * If data is to be sent, we will just piggyback the ACK (see below).
;;;927       */
;;;928      if (pcb->flags & TF_ACK_NOW &&
;;;929         (seg == NULL ||
;;;930          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
;;;931         return tcp_send_empty_ack(pcb);
;;;932      }
;;;933    
;;;934      /* useg should point to last segment on unacked queue */
;;;935      useg = pcb->unacked;
;;;936      if (useg != NULL) {
;;;937        for (; useg->next != NULL; useg = useg->next);
;;;938      }
;;;939    
;;;940    #if TCP_OUTPUT_DEBUG
;;;941      if (seg == NULL) {
;;;942        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
;;;943                                       (void*)pcb->unsent));
;;;944      }
;;;945    #endif /* TCP_OUTPUT_DEBUG */
;;;946    #if TCP_CWND_DEBUG
;;;947      if (seg == NULL) {
;;;948        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F
;;;949                                     ", cwnd %"U16_F", wnd %"U32_F
;;;950                                     ", seg == NULL, ack %"U32_F"\n",
;;;951                                     pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
;;;952      } else {
;;;953        LWIP_DEBUGF(TCP_CWND_DEBUG, 
;;;954                    ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F
;;;955                     ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
;;;956                     pcb->snd_wnd, pcb->cwnd, wnd,
;;;957                     ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
;;;958                     ntohl(seg->tcphdr->seqno), pcb->lastack));
;;;959      }
;;;960    #endif /* TCP_CWND_DEBUG */
;;;961      /* data available and window allows it to be sent? */
;;;962      while (seg != NULL &&
;;;963             ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
;;;964        LWIP_ASSERT("RST not expected here!", 
;;;965                    (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
;;;966        /* Stop sending if the nagle algorithm would prevent it
;;;967         * Don't stop:
;;;968         * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
;;;969         * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
;;;970         *   either seg->next != NULL or pcb->unacked == NULL;
;;;971         *   RST is no sent using tcp_write/tcp_output.
;;;972         */
;;;973        if((tcp_do_output_nagle(pcb) == 0) &&
;;;974          ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
;;;975          break;
;;;976        }
;;;977    #if TCP_CWND_DEBUG
;;;978        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
;;;979                                pcb->snd_wnd, pcb->cwnd, wnd,
;;;980                                ntohl(seg->tcphdr->seqno) + seg->len -
;;;981                                pcb->lastack,
;;;982                                ntohl(seg->tcphdr->seqno), pcb->lastack, i));
;;;983        ++i;
;;;984    #endif /* TCP_CWND_DEBUG */
;;;985    
;;;986        pcb->unsent = seg->next;
;;;987    
;;;988        if (pcb->state != SYN_SENT) {
;;;989          TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
;;;990          pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;991        }
;;;992    
;;;993        tcp_output_segment(seg, pcb);
;;;994        snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;995        if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;996          pcb->snd_nxt = snd_nxt;
;;;997        }
;;;998        /* put segment on unacknowledged list if length > 0 */
;;;999        if (TCP_TCPLEN(seg) > 0) {
;;;1000         seg->next = NULL;
;;;1001         /* unacked list is empty? */
;;;1002         if (pcb->unacked == NULL) {
;;;1003           pcb->unacked = seg;
;;;1004           useg = seg;
;;;1005         /* unacked list is not empty? */
;;;1006         } else {
;;;1007           /* In the case of fast retransmit, the packet should not go to the tail
;;;1008            * of the unacked queue, but rather somewhere before it. We need to check for
;;;1009            * this case. -STJ Jul 27, 2004 */
;;;1010           if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
;;;1011             /* add segment to before tail of unacked list, keeping the list sorted */
;;;1012             struct tcp_seg **cur_seg = &(pcb->unacked);
;;;1013             while (*cur_seg &&
;;;1014               TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1015                 cur_seg = &((*cur_seg)->next );
;;;1016             }
;;;1017             seg->next = (*cur_seg);
;;;1018             (*cur_seg) = seg;
;;;1019           } else {
;;;1020             /* add segment to tail of unacked list */
;;;1021             useg->next = seg;
;;;1022             useg = useg->next;
;;;1023           }
;;;1024         }
;;;1025       /* do not queue empty segments on the unacked list */
;;;1026       } else {
;;;1027         tcp_seg_free(seg);
;;;1028       }
;;;1029       seg = pcb->unsent;
;;;1030     }
;;;1031   #if TCP_OVERSIZE
;;;1032     if (pcb->unsent == NULL) {
;;;1033       /* last unsent has been removed, reset unsent_oversize */
;;;1034       pcb->unsent_oversize = 0;
;;;1035     }
;;;1036   #endif /* TCP_OVERSIZE */
;;;1037   
;;;1038     pcb->flags &= ~TF_NAGLEMEMERR;
;;;1039     return ERR_OK;
;;;1040   }
0010fc  e8bd87f0          POP      {r4-r10,pc}
                  |L1.4352|
001100  e1d486b0          LDRH     r8,[r4,#0x60]         ;918
001104  e1d404bc          LDRH     r0,[r4,#0x4c]         ;918
001108  e594506c          LDR      r5,[r4,#0x6c]         ;920
00110c  e1580000          CMP      r8,r0                 ;918
001110  21a08000          MOVCS    r8,r0                 ;918
001114  e5d4001e          LDRB     r0,[r4,#0x1e]         ;928
001118  e3100002          TST      r0,#2                 ;928
00111c  0a00000e          BEQ      |L1.4444|
001120  e3550000          CMP      r5,#0                 ;929
001124  0a000009          BEQ      |L1.4432|
001128  e5950010          LDR      r0,[r5,#0x10]         ;930
00112c  e2800004          ADD      r0,r0,#4              ;930
001130  ebfffffe          BL       __aeabi_uread4
001134  ebfffffe          BL       lwip_ntohl
001138  e5941048          LDR      r1,[r4,#0x48]         ;930
00113c  e0400001          SUB      r0,r0,r1              ;930
001140  e1d510b8          LDRH     r1,[r5,#8]            ;930
001144  e0800001          ADD      r0,r0,r1              ;930
001148  e1500008          CMP      r0,r8                 ;930
00114c  9a000002          BLS      |L1.4444|
                  |L1.4432|
001150  e1a00004          MOV      r0,r4                 ;931
001154  e8bd47f0          POP      {r4-r10,lr}           ;931
001158  eafffffe          B        tcp_send_empty_ack
                  |L1.4444|
00115c  e5947070          LDR      r7,[r4,#0x70]         ;935
001160  e3a09000          MOV      r9,#0                 ;935
001164  e3570000          CMP      r7,#0                 ;936
001168  0a000083          BEQ      |L1.4988|
                  |L1.4460|
00116c  e5970000          LDR      r0,[r7,#0]            ;937
001170  e3500000          CMP      r0,#0                 ;937
001174  11a07000          MOVNE    r7,r0                 ;937
001178  1afffffb          BNE      |L1.4460|
00117c  ea00007e          B        |L1.4988|
                  |L1.4480|
001180  e5950010          LDR      r0,[r5,#0x10]         ;964
001184  e5d0100d          LDRB     r1,[r0,#0xd]          ;964
001188  e5d0000c          LDRB     r0,[r0,#0xc]          ;964
00118c  e1800401          ORR      r0,r0,r1,LSL #8       ;964
001190  ebfffffe          BL       lwip_ntohs
001194  e3100004          TST      r0,#4                 ;964
001198  0a000004          BEQ      |L1.4528|
00119c  e51f37dc          LDR      r3,|L1.2504|
0011a0  e51f07ac          LDR      r0,|L1.2556|
0011a4  e3a02ff1          MOV      r2,#0x3c4             ;964
0011a8  e28f1f93          ADR      r1,|L1.5116|
0011ac  ebfffffe          BL       sysprintf
                  |L1.4528|
0011b0  e5940070          LDR      r0,[r4,#0x70]         ;973
0011b4  e3500000          CMP      r0,#0                 ;973
0011b8  0a000013          BEQ      |L1.4620|
0011bc  e5d4101e          LDRB     r1,[r4,#0x1e]         ;973
0011c0  e3110044          TST      r1,#0x44              ;973
0011c4  1a000010          BNE      |L1.4620|
0011c8  e594006c          LDR      r0,[r4,#0x6c]         ;973
0011cc  e3500000          CMP      r0,#0                 ;973
0011d0  0a000006          BEQ      |L1.4592|
0011d4  e5902000          LDR      r2,[r0,#0]            ;973
0011d8  e3520000          CMP      r2,#0                 ;973
0011dc  1a00000a          BNE      |L1.4620|
0011e0  e1d000b8          LDRH     r0,[r0,#8]            ;973
0011e4  e1d423b6          LDRH     r2,[r4,#0x36]         ;973
0011e8  e1500002          CMP      r0,r2                 ;973
0011ec  2a000006          BCS      |L1.4620|
                  |L1.4592|
0011f0  e1d406b6          LDRH     r0,[r4,#0x66]         ;973
0011f4  e3500000          CMP      r0,#0                 ;973
0011f8  11d406b8          LDRHNE   r0,[r4,#0x68]         ;973
0011fc  13500008          CMPNE    r0,#8                 ;973
001200  2a000001          BCS      |L1.4620|
001204  e31100a0          TST      r1,#0xa0              ;974
001208  0a000067          BEQ      |L1.5036|
                  |L1.4620|
00120c  e5950000          LDR      r0,[r5,#0]            ;986
001210  e584006c          STR      r0,[r4,#0x6c]         ;986
001214  e5d40018          LDRB     r0,[r4,#0x18]         ;988
001218  e3500002          CMP      r0,#2                 ;988
00121c  0a00000d          BEQ      |L1.4696|
001220  e3a00010          MOV      r0,#0x10              ;989
001224  ebfffffe          BL       lwip_htons
001228  e1a01000          MOV      r1,r0                 ;989
00122c  e5950010          LDR      r0,[r5,#0x10]         ;989
001230  e5d0200d          LDRB     r2,[r0,#0xd]          ;989
001234  e5d0300c          LDRB     r3,[r0,#0xc]          ;989
001238  e1832402          ORR      r2,r3,r2,LSL #8       ;989
00123c  e1811002          ORR      r1,r1,r2              ;989
001240  e5c0100c          STRB     r1,[r0,#0xc]          ;989
001244  e1a01421          LSR      r1,r1,#8              ;989
001248  e5c0100d          STRB     r1,[r0,#0xd]          ;989
00124c  e5d4001e          LDRB     r0,[r4,#0x1e]         ;990
001250  e3c00003          BIC      r0,r0,#3              ;990
001254  e5c4001e          STRB     r0,[r4,#0x1e]         ;990
                  |L1.4696|
001258  e1a01004          MOV      r1,r4                 ;993
00125c  e1a00005          MOV      r0,r5                 ;993
001260  ebfffffe          BL       tcp_output_segment
001264  e5950010          LDR      r0,[r5,#0x10]         ;994
001268  e2800004          ADD      r0,r0,#4              ;994
00126c  ebfffffe          BL       __aeabi_uread4
001270  ebfffffe          BL       lwip_ntohl
001274  e1a06000          MOV      r6,r0                 ;994
001278  e5950010          LDR      r0,[r5,#0x10]         ;994
00127c  e5d0100d          LDRB     r1,[r0,#0xd]          ;994
001280  e5d0000c          LDRB     r0,[r0,#0xc]          ;994
001284  e1800401          ORR      r0,r0,r1,LSL #8       ;994
001288  ebfffffe          BL       lwip_ntohs
00128c  e1d510b8          LDRH     r1,[r5,#8]            ;994
001290  e2100003          ANDS     r0,r0,#3              ;994
001294  13a00001          MOVNE    r0,#1                 ;994
001298  e0800001          ADD      r0,r0,r1              ;994
00129c  e5941050          LDR      r1,[r4,#0x50]         ;995
0012a0  e0800006          ADD      r0,r0,r6              ;994
0012a4  e0511000          SUBS     r1,r1,r0              ;995
0012a8  45840050          STRMI    r0,[r4,#0x50]         ;996
0012ac  e5950010          LDR      r0,[r5,#0x10]         ;999
0012b0  e5d0100d          LDRB     r1,[r0,#0xd]          ;999
0012b4  e5d0000c          LDRB     r0,[r0,#0xc]          ;999
0012b8  e1800401          ORR      r0,r0,r1,LSL #8       ;999
0012bc  ebfffffe          BL       lwip_ntohs
0012c0  e1d510b8          LDRH     r1,[r5,#8]            ;999
0012c4  e2100003          ANDS     r0,r0,#3              ;999
0012c8  13a00001          MOVNE    r0,#1                 ;999
0012cc  e1700001          CMN      r0,r1                 ;999
0012d0  0a000026          BEQ      |L1.4976|
0012d4  e5859000          STR      r9,[r5,#0]            ;1002
0012d8  e5940070          LDR      r0,[r4,#0x70]         ;1002
0012dc  e3500000          CMP      r0,#0                 ;1002
0012e0  05845070          STREQ    r5,[r4,#0x70]         ;1003
0012e4  0a00001f          BEQ      |L1.4968|
0012e8  e5950010          LDR      r0,[r5,#0x10]         ;1010
0012ec  e2800004          ADD      r0,r0,#4              ;1010
0012f0  ebfffffe          BL       __aeabi_uread4
0012f4  ebfffffe          BL       lwip_ntohl
0012f8  e1a06000          MOV      r6,r0                 ;1010
0012fc  e5970010          LDR      r0,[r7,#0x10]         ;1010
001300  e2800004          ADD      r0,r0,#4              ;1010
001304  ebfffffe          BL       __aeabi_uread4
001308  ebfffffe          BL       lwip_ntohl
00130c  e0560000          SUBS     r0,r6,r0              ;1010
001310  42846070          ADDMI    r6,r4,#0x70           ;1012
001314  55875000          STRPL    r5,[r7,#0]            ;1021
001318  5a000012          BPL      |L1.4968|
                  |L1.4892|
00131c  e5960000          LDR      r0,[r6,#0]            ;1013
001320  e3500000          CMP      r0,#0                 ;1013
001324  0a00000b          BEQ      |L1.4952|
001328  e5900010          LDR      r0,[r0,#0x10]         ;1014
00132c  e2800004          ADD      r0,r0,#4              ;1014
001330  ebfffffe          BL       __aeabi_uread4
001334  ebfffffe          BL       lwip_ntohl
001338  e1a0a000          MOV      r10,r0                ;1014
00133c  e5950010          LDR      r0,[r5,#0x10]         ;1014
001340  e2800004          ADD      r0,r0,#4              ;1014
001344  ebfffffe          BL       __aeabi_uread4
001348  ebfffffe          BL       lwip_ntohl
00134c  e05a0000          SUBS     r0,r10,r0             ;1014
001350  45966000          LDRMI    r6,[r6,#0]            ;1015
001354  4afffff0          BMI      |L1.4892|
                  |L1.4952|
001358  e5960000          LDR      r0,[r6,#0]            ;1017
00135c  e5850000          STR      r0,[r5,#0]            ;1018
001360  e5865000          STR      r5,[r6,#0]            ;1018
001364  ea000003          B        |L1.4984|
                  |L1.4968|
001368  e1a07005          MOV      r7,r5                 ;1022
00136c  ea000001          B        |L1.4984|
                  |L1.4976|
001370  e1a00005          MOV      r0,r5                 ;1027
001374  ebfffffe          BL       tcp_seg_free
                  |L1.4984|
001378  e594506c          LDR      r5,[r4,#0x6c]         ;1029
                  |L1.4988|
00137c  e3550000          CMP      r5,#0                 ;962
001380  0a000009          BEQ      |L1.5036|
001384  e5950010          LDR      r0,[r5,#0x10]         ;963
001388  e2800004          ADD      r0,r0,#4              ;963
00138c  ebfffffe          BL       __aeabi_uread4
001390  ebfffffe          BL       lwip_ntohl
001394  e5941048          LDR      r1,[r4,#0x48]         ;963
001398  e0400001          SUB      r0,r0,r1              ;963
00139c  e1d510b8          LDRH     r1,[r5,#8]            ;963
0013a0  e0800001          ADD      r0,r0,r1              ;963
0013a4  e1500008          CMP      r0,r8                 ;963
0013a8  9affff74          BLS      |L1.4480|
                  |L1.5036|
0013ac  e594006c          LDR      r0,[r4,#0x6c]         ;1032
0013b0  e3500000          CMP      r0,#0                 ;1032
0013b4  01c496ba          STRHEQ   r9,[r4,#0x6a]         ;1034
0013b8  e5d4001e          LDRB     r0,[r4,#0x1e]         ;1038
0013bc  e3c00080          BIC      r0,r0,#0x80           ;1038
0013c0  e5c4001e          STRB     r0,[r4,#0x1e]         ;1038
0013c4  eaffff4b          B        |L1.4344|
                  |L1.5064|
                          DCD      tcp_ticks
                  |L1.5068|
                          DCD      0x0000038b
                  |L1.5072|
0013d0  646f6e27          DCB      "don't call tcp_output for listen-pcbs",0
0013d4  74206361
0013d8  6c6c2074
0013dc  63705f6f
0013e0  75747075
0013e4  7420666f
0013e8  72206c69
0013ec  7374656e
0013f0  2d706362
0013f4  7300    
0013f6  00                DCB      0
0013f7  00                DCB      0
                  |L1.5112|
                          DCD      tcp_input_pcb
                  |L1.5116|
0013fc  52535420          DCB      "RST not expected here!",0
001400  6e6f7420
001404  65787065
001408  63746564
00140c  20686572
001410  652100  
001413  00                DCB      0
                          ENDP

                  tcp_rst PROC
;;;1194   void
;;;1195   tcp_rst(u32_t seqno, u32_t ackno,
001414  e92d5ffc          PUSH     {r2-r12,lr}
;;;1196     ip_addr_t *local_ip, ip_addr_t *remote_ip,
;;;1197     u16_t local_port, u16_t remote_port)
;;;1198   {
001418  e1a07002          MOV      r7,r2
00141c  e1a08001          MOV      r8,r1
001420  e1a0b000          MOV      r11,r0
;;;1199     struct pbuf *p;
;;;1200     struct tcp_hdr *tcphdr;
;;;1201     p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
001424  e59d9034          LDR      r9,[sp,#0x34]
001428  e59da030          LDR      r10,[sp,#0x30]
00142c  e1a06003          MOV      r6,r3                 ;1198
001430  e3a02000          MOV      r2,#0
001434  e3a01014          MOV      r1,#0x14
001438  e3a00001          MOV      r0,#1
00143c  ebfffffe          BL       pbuf_alloc
001440  e1b05000          MOVS     r5,r0
;;;1202     if (p == NULL) {
001444  0a00003c          BEQ      |L1.5436|
;;;1203         LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
;;;1204         return;
;;;1205     }
;;;1206     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
001448  e1d500ba          LDRH     r0,[r5,#0xa]
00144c  e3500014          CMP      r0,#0x14
001450  2a000004          BCS      |L1.5224|
001454  e51f3a94          LDR      r3,|L1.2504|
001458  e59f2498          LDR      r2,|L1.6392|
00145c  e59f1498          LDR      r1,|L1.6396|
001460  e51f0a6c          LDR      r0,|L1.2556|
001464  ebfffffe          BL       sysprintf
                  |L1.5224|
;;;1207                 (p->len >= sizeof(struct tcp_hdr)));
;;;1208   
;;;1209     tcphdr = (struct tcp_hdr *)p->payload;
;;;1210     tcphdr->src = htons(local_port);
001468  e5954004          LDR      r4,[r5,#4]
00146c  e1a0000a          MOV      r0,r10
001470  ebfffffe          BL       lwip_htons
001474  e5c40000          STRB     r0,[r4,#0]
001478  e1a00420          LSR      r0,r0,#8
00147c  e5c40001          STRB     r0,[r4,#1]
;;;1211     tcphdr->dest = htons(remote_port);
001480  e1a00009          MOV      r0,r9
001484  ebfffffe          BL       lwip_htons
001488  e5c40002          STRB     r0,[r4,#2]
00148c  e1a00420          LSR      r0,r0,#8
001490  e5c40003          STRB     r0,[r4,#3]
;;;1212     tcphdr->seqno = htonl(seqno);
001494  e1a0000b          MOV      r0,r11
001498  ebfffffe          BL       lwip_htonl
00149c  e2841004          ADD      r1,r4,#4
0014a0  ebfffffe          BL       __aeabi_uwrite4
;;;1213     tcphdr->ackno = htonl(ackno);
0014a4  e1a00008          MOV      r0,r8
0014a8  ebfffffe          BL       lwip_htonl
0014ac  e2841008          ADD      r1,r4,#8
0014b0  ebfffffe          BL       __aeabi_uwrite4
;;;1214     TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
0014b4  e59f0444          LDR      r0,|L1.6400|
0014b8  ebfffffe          BL       lwip_htons
0014bc  e5c4000c          STRB     r0,[r4,#0xc]
0014c0  e1a00420          LSR      r0,r0,#8
0014c4  e5c4000d          STRB     r0,[r4,#0xd]
;;;1215     tcphdr->wnd = PP_HTONS(TCP_WND);
0014c8  e59f0434          LDR      r0,|L1.6404|
;;;1216     tcphdr->chksum = 0;
0014cc  e3a08000          MOV      r8,#0
0014d0  e5c4000e          STRB     r0,[r4,#0xe]          ;1215
0014d4  e1a00420          LSR      r0,r0,#8              ;1215
0014d8  e5c4000f          STRB     r0,[r4,#0xf]          ;1215
0014dc  e5c48010          STRB     r8,[r4,#0x10]
0014e0  e5c48011          STRB     r8,[r4,#0x11]
;;;1217     tcphdr->urgp = 0;
0014e4  e5c48012          STRB     r8,[r4,#0x12]
0014e8  e5c48013          STRB     r8,[r4,#0x13]
;;;1218   
;;;1219   #if CHECKSUM_GEN_TCP
;;;1220     tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
0014ec  e1d500b8          LDRH     r0,[r5,#8]
0014f0  e3a03006          MOV      r3,#6
0014f4  e1a02006          MOV      r2,r6
0014f8  e58d0000          STR      r0,[sp,#0]
0014fc  e1a01007          MOV      r1,r7
001500  e1a00005          MOV      r0,r5
001504  ebfffffe          BL       inet_chksum_pseudo
001508  e5c40010          STRB     r0,[r4,#0x10]
00150c  e1a00420          LSR      r0,r0,#8
001510  e5c40011          STRB     r0,[r4,#0x11]
;;;1221                 IP_PROTO_TCP, p->tot_len);
;;;1222   #endif
;;;1223     TCP_STATS_INC(tcp.xmit);
;;;1224     snmp_inc_tcpoutrsts();
;;;1225      /* Send output with hardcoded TTL since we have no access to the pcb */
;;;1226     ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
001514  e3a00006          MOV      r0,#6
001518  e58d0004          STR      r0,[sp,#4]
00151c  e3a030ff          MOV      r3,#0xff
001520  e1a02006          MOV      r2,r6
001524  e1a01007          MOV      r1,r7
001528  e1a00005          MOV      r0,r5
00152c  e58d8000          STR      r8,[sp,#0]
001530  ebfffffe          BL       ip_output
;;;1227     pbuf_free(p);
001534  e1a00005          MOV      r0,r5
001538  ebfffffe          BL       pbuf_free
                  |L1.5436|
;;;1228     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
;;;1229   }
00153c  e8bd9ffc          POP      {r2-r12,pc}
;;;1230   
                          ENDP

                  tcp_rexmit_rto PROC
;;;1238   void
;;;1239   tcp_rexmit_rto(struct tcp_pcb *pcb)
001540  e5901070          LDR      r1,[r0,#0x70]
;;;1240   {
;;;1241     struct tcp_seg *seg;
;;;1242   
;;;1243     if (pcb->unacked == NULL) {
001544  e3510000          CMP      r1,#0
;;;1244       return;
;;;1245     }
;;;1246   
;;;1247     /* Move all unacked segments to the head of the unsent queue */
;;;1248     for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
;;;1249     /* concatenate unsent queue after unacked queue */
;;;1250     seg->next = pcb->unsent;
;;;1251     /* unsent queue is the concatenated queue (of unacked, unsent) */
;;;1252     pcb->unsent = pcb->unacked;
;;;1253     /* unacked queue is now empty */
;;;1254     pcb->unacked = NULL;
;;;1255     /* last unsent hasn't changed, no need to reset unsent_oversize */
;;;1256   
;;;1257     /* increment number of retransmissions */
;;;1258     ++pcb->nrtx;
;;;1259   
;;;1260     /* Don't take any RTT measurements after retransmitting. */
;;;1261     pcb->rttest = 0;
;;;1262   
;;;1263     /* Do the actual retransmission */
;;;1264     tcp_output(pcb);
;;;1265   }
001548  012fff1e          BXEQ     lr
                  |L1.5452|
00154c  e5912000          LDR      r2,[r1,#0]            ;1248
001550  e3520000          CMP      r2,#0                 ;1248
001554  11a01002          MOVNE    r1,r2                 ;1248
001558  1afffffb          BNE      |L1.5452|
00155c  e590206c          LDR      r2,[r0,#0x6c]         ;1250
001560  e5812000          STR      r2,[r1,#0]            ;1252
001564  e5901070          LDR      r1,[r0,#0x70]         ;1252
001568  e580106c          STR      r1,[r0,#0x6c]         ;1252
00156c  e3a01000          MOV      r1,#0                 ;1254
001570  e5801070          STR      r1,[r0,#0x70]         ;1254
001574  e5d02046          LDRB     r2,[r0,#0x46]         ;1258
001578  e2822001          ADD      r2,r2,#1              ;1258
00157c  e5c02046          STRB     r2,[r0,#0x46]         ;1258
001580  e5801038          STR      r1,[r0,#0x38]         ;1261
001584  eafffffe          B        tcp_output
;;;1266   
                          ENDP

                  tcp_rexmit PROC
;;;1274   void
;;;1275   tcp_rexmit(struct tcp_pcb *pcb)
001588  e92d41f0          PUSH     {r4-r8,lr}
;;;1276   {
;;;1277     struct tcp_seg *seg;
;;;1278     struct tcp_seg **cur_seg;
;;;1279   
;;;1280     if (pcb->unacked == NULL) {
00158c  e5905070          LDR      r5,[r0,#0x70]
001590  e1a06000          MOV      r6,r0                 ;1276
001594  e3550000          CMP      r5,#0
;;;1281       return;
;;;1282     }
;;;1283   
;;;1284     /* Move the first unacked segment to the unsent queue */
;;;1285     /* Keep the unsent queue sorted. */
;;;1286     seg = pcb->unacked;
;;;1287     pcb->unacked = seg->next;
001598  15950000          LDRNE    r0,[r5,#0]
;;;1288   
;;;1289     cur_seg = &(pcb->unsent);
00159c  1286406c          ADDNE    r4,r6,#0x6c
0015a0  15860070          STRNE    r0,[r6,#0x70]         ;1287
;;;1290     while (*cur_seg &&
;;;1291       TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1292         cur_seg = &((*cur_seg)->next );
;;;1293     }
;;;1294     seg->next = *cur_seg;
;;;1295     *cur_seg = seg;
;;;1296   #if TCP_OVERSIZE
;;;1297     if (seg->next == NULL) {
;;;1298       /* the retransmitted segment is last in unsent, so reset unsent_oversize */
;;;1299       pcb->unsent_oversize = 0;
;;;1300     }
;;;1301   #endif /* TCP_OVERSIZE */
;;;1302   
;;;1303     ++pcb->nrtx;
;;;1304   
;;;1305     /* Don't take any rtt measurements after retransmitting. */
;;;1306     pcb->rttest = 0;
;;;1307   
;;;1308     /* Do the actual retransmission. */
;;;1309     snmp_inc_tcpretranssegs();
;;;1310     /* No need to call tcp_output: we are always called from tcp_input()
;;;1311        and thus tcp_output directly returns. */
;;;1312   }
0015a4  08bd81f0          POPEQ    {r4-r8,pc}
                  |L1.5544|
0015a8  e5940000          LDR      r0,[r4,#0]            ;1290
0015ac  e3500000          CMP      r0,#0                 ;1290
0015b0  0a00000b          BEQ      |L1.5604|
0015b4  e5900010          LDR      r0,[r0,#0x10]         ;1291
0015b8  e2800004          ADD      r0,r0,#4              ;1291
0015bc  ebfffffe          BL       __aeabi_uread4
0015c0  ebfffffe          BL       lwip_ntohl
0015c4  e1a07000          MOV      r7,r0                 ;1291
0015c8  e5950010          LDR      r0,[r5,#0x10]         ;1291
0015cc  e2800004          ADD      r0,r0,#4              ;1291
0015d0  ebfffffe          BL       __aeabi_uread4
0015d4  ebfffffe          BL       lwip_ntohl
0015d8  e0570000          SUBS     r0,r7,r0              ;1291
0015dc  45944000          LDRMI    r4,[r4,#0]            ;1292
0015e0  4afffff0          BMI      |L1.5544|
                  |L1.5604|
0015e4  e5940000          LDR      r0,[r4,#0]            ;1294
0015e8  e5850000          STR      r0,[r5,#0]            ;1295
0015ec  e5845000          STR      r5,[r4,#0]            ;1297
0015f0  e5951000          LDR      r1,[r5,#0]            ;1297
0015f4  e3a00000          MOV      r0,#0                 ;1297
0015f8  e3510000          CMP      r1,#0                 ;1297
0015fc  01c606ba          STRHEQ   r0,[r6,#0x6a]         ;1299
001600  e5d61046          LDRB     r1,[r6,#0x46]         ;1303
001604  e2811001          ADD      r1,r1,#1              ;1303
001608  e5c61046          STRB     r1,[r6,#0x46]         ;1303
00160c  e5860038          STR      r0,[r6,#0x38]         ;1306
001610  e8bd81f0          POP      {r4-r8,pc}
;;;1313   
                          ENDP

                  tcp_rexmit_fast PROC
;;;1320   void 
;;;1321   tcp_rexmit_fast(struct tcp_pcb *pcb)
001614  e92d4010          PUSH     {r4,lr}
;;;1322   {
001618  e1a04000          MOV      r4,r0
;;;1323     if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
00161c  e5900070          LDR      r0,[r0,#0x70]
001620  e3500000          CMP      r0,#0
;;;1324       /* This is fast retransmit. Retransmit the first unacked segment. */
;;;1325       LWIP_DEBUGF(TCP_FR_DEBUG, 
;;;1326                   ("tcp_receive: dupacks %"U16_F" (%"U32_F
;;;1327                    "), fast retransmit %"U32_F"\n",
;;;1328                    (u16_t)pcb->dupacks, pcb->lastack,
;;;1329                    ntohl(pcb->unacked->tcphdr->seqno)));
;;;1330       tcp_rexmit(pcb);
;;;1331   
;;;1332       /* Set ssthresh to half of the minimum of the current
;;;1333        * cwnd and the advertised window */
;;;1334       if (pcb->cwnd > pcb->snd_wnd) {
;;;1335         pcb->ssthresh = pcb->snd_wnd / 2;
;;;1336       } else {
;;;1337         pcb->ssthresh = pcb->cwnd / 2;
;;;1338       }
;;;1339       
;;;1340       /* The minimum value for ssthresh should be 2 MSS */
;;;1341       if (pcb->ssthresh < 2*pcb->mss) {
;;;1342         LWIP_DEBUGF(TCP_FR_DEBUG, 
;;;1343                     ("tcp_receive: The minimum value for ssthresh %"U16_F
;;;1344                      " should be min 2 mss %"U16_F"...\n",
;;;1345                      pcb->ssthresh, 2*pcb->mss));
;;;1346         pcb->ssthresh = 2*pcb->mss;
;;;1347       }
;;;1348       
;;;1349       pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
;;;1350       pcb->flags |= TF_INFR;
;;;1351     } 
;;;1352   }
001624  08bd8010          POPEQ    {r4,pc}
001628  e5d4001e          LDRB     r0,[r4,#0x1e]         ;1323
00162c  e3100004          TST      r0,#4                 ;1323
001630  18bd8010          POPNE    {r4,pc}
001634  e1a00004          MOV      r0,r4                 ;1330
001638  ebfffffe          BL       tcp_rexmit
00163c  e1d404bc          LDRH     r0,[r4,#0x4c]         ;1334
001640  e1d416b0          LDRH     r1,[r4,#0x60]         ;1334
001644  e1500001          CMP      r0,r1                 ;1334
001648  81a000a1          LSRHI    r0,r1,#1              ;1335
00164c  91a000a0          LSRLS    r0,r0,#1              ;1337
001650  e1a01800          LSL      r1,r0,#16             ;1341
001654  e1c404be          STRH     r0,[r4,#0x4e]         ;1337
001658  e1d403b6          LDRH     r0,[r4,#0x36]         ;1341
00165c  e1a01821          LSR      r1,r1,#16             ;1341
001660  e1510080          CMP      r1,r0,LSL #1          ;1341
001664  33e01801          MVNCC    r1,#0x10000           ;1346
001668  30011080          ANDCC    r1,r1,r0,LSL #1       ;1346
00166c  31c414be          STRHCC   r1,[r4,#0x4e]         ;1346
001670  e1a01801          LSL      r1,r1,#16             ;1349
001674  e1a01821          LSR      r1,r1,#16             ;1349
001678  e0800080          ADD      r0,r0,r0,LSL #1       ;1349
00167c  e0800001          ADD      r0,r0,r1              ;1349
001680  e1c404bc          STRH     r0,[r4,#0x4c]         ;1349
001684  e5d4001e          LDRB     r0,[r4,#0x1e]         ;1350
001688  e3800004          ORR      r0,r0,#4              ;1350
00168c  e5c4001e          STRB     r0,[r4,#0x1e]         ;1350
001690  e8bd8010          POP      {r4,pc}
;;;1353   
                          ENDP

                  tcp_keepalive PROC
;;;1363   void
;;;1364   tcp_keepalive(struct tcp_pcb *pcb)
001694  e92d407c          PUSH     {r2-r6,lr}
;;;1365   {
001698  e1a05000          MOV      r5,r0
;;;1366     struct pbuf *p;
;;;1367     struct tcp_hdr *tcphdr;
;;;1368   
;;;1369     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1370                             ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1371                             ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1372   
;;;1373     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1374                             tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1375      
;;;1376     p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
00169c  e5900050          LDR      r0,[r0,#0x50]
0016a0  e2400001          SUB      r0,r0,#1
0016a4  ebfffffe          BL       lwip_htonl
0016a8  e1a03000          MOV      r3,r0
0016ac  e3a02000          MOV      r2,#0
0016b0  e1a01002          MOV      r1,r2
0016b4  e1a00005          MOV      r0,r5
0016b8  ebfffffe          BL       tcp_output_alloc_header
0016bc  e1b04000          MOVS     r4,r0
;;;1377     if(p == NULL) {
0016c0  0a000014          BEQ      |L1.5912|
;;;1378       LWIP_DEBUGF(TCP_DEBUG, 
;;;1379                   ("tcp_keepalive: could not allocate memory for pbuf\n"));
;;;1380       return;
;;;1381     }
;;;1382     tcphdr = (struct tcp_hdr *)p->payload;
;;;1383   
;;;1384   #if CHECKSUM_GEN_TCP
;;;1385     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
0016c4  e1d400b8          LDRH     r0,[r4,#8]
0016c8  e5946004          LDR      r6,[r4,#4]            ;1382
0016cc  e3a03006          MOV      r3,#6
0016d0  e58d0000          STR      r0,[sp,#0]
0016d4  e2852004          ADD      r2,r5,#4
0016d8  e1a01005          MOV      r1,r5
0016dc  e1a00004          MOV      r0,r4
0016e0  ebfffffe          BL       inet_chksum_pseudo
0016e4  e5c60010          STRB     r0,[r6,#0x10]
0016e8  e1a00420          LSR      r0,r0,#8
0016ec  e5c60011          STRB     r0,[r6,#0x11]
;;;1386                                         IP_PROTO_TCP, p->tot_len);
;;;1387   #endif
;;;1388     TCP_STATS_INC(tcp.xmit);
;;;1389   
;;;1390     /* Send output to IP */
;;;1391   #if LWIP_NETIF_HWADDRHINT
;;;1392     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1393       &(pcb->addr_hint));
;;;1394   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1395     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
0016f0  e3a01006          MOV      r1,#6
0016f4  e3a00000          MOV      r0,#0
0016f8  e1cd00f0          STRD     r0,r1,[sp,#0]
0016fc  e5d5300a          LDRB     r3,[r5,#0xa]
001700  e2852004          ADD      r2,r5,#4
001704  e1a01005          MOV      r1,r5
001708  e1a00004          MOV      r0,r4
00170c  ebfffffe          BL       ip_output
;;;1396   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1397   
;;;1398     pbuf_free(p);
001710  e1a00004          MOV      r0,r4
001714  ebfffffe          BL       pbuf_free
                  |L1.5912|
;;;1399   
;;;1400     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
;;;1401                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1402   }
001718  e8bd807c          POP      {r2-r6,pc}
;;;1403   
                          ENDP

                  tcp_zero_window_probe PROC
;;;1413   void
;;;1414   tcp_zero_window_probe(struct tcp_pcb *pcb)
00171c  e92d41fc          PUSH     {r2-r8,lr}
;;;1415   {
;;;1416     struct pbuf *p;
;;;1417     struct tcp_hdr *tcphdr;
;;;1418     struct tcp_seg *seg;
;;;1419     u16_t len;
;;;1420     u8_t is_fin;
;;;1421   
;;;1422     LWIP_DEBUGF(TCP_DEBUG, 
;;;1423                 ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
;;;1424                  U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1425                  ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1426                  ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1427   
;;;1428     LWIP_DEBUGF(TCP_DEBUG, 
;;;1429                 ("tcp_zero_window_probe: tcp_ticks %"U32_F
;;;1430                  "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1431                  tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1432   
;;;1433     seg = pcb->unacked;
001720  e5904070          LDR      r4,[r0,#0x70]
001724  e1a05000          MOV      r5,r0                 ;1415
;;;1434   
;;;1435     if(seg == NULL) {
001728  e3540000          CMP      r4,#0
;;;1436       seg = pcb->unsent;
00172c  0595406c          LDREQ    r4,[r5,#0x6c]
;;;1437     }
;;;1438     if(seg == NULL) {
001730  03540000          CMPEQ    r4,#0
001734  0a000043          BEQ      |L1.6216|
;;;1439       return;
;;;1440     }
;;;1441   
;;;1442     is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
001738  e5940010          LDR      r0,[r4,#0x10]
00173c  e5d0100d          LDRB     r1,[r0,#0xd]
001740  e5d0000c          LDRB     r0,[r0,#0xc]
001744  e1800401          ORR      r0,r0,r1,LSL #8
001748  ebfffffe          BL       lwip_ntohs
00174c  e3100001          TST      r0,#1
001750  0a000003          BEQ      |L1.5988|
001754  e1d400b8          LDRH     r0,[r4,#8]
001758  e3500000          CMP      r0,#0
00175c  03a08001          MOVEQ    r8,#1
001760  0a000000          BEQ      |L1.5992|
                  |L1.5988|
001764  e3a08000          MOV      r8,#0
                  |L1.5992|
;;;1443     /* we want to send one seqno: either FIN or data (no options) */
;;;1444     len = is_fin ? 0 : 1;
;;;1445   
;;;1446     p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
001768  e5940010          LDR      r0,[r4,#0x10]
00176c  e3580000          CMP      r8,#0                 ;1444
001770  03a06001          MOVEQ    r6,#1                 ;1444
001774  13a06000          MOVNE    r6,#0                 ;1444
001778  e2800004          ADD      r0,r0,#4
00177c  ebfffffe          BL       __aeabi_uread4
001780  e1a03000          MOV      r3,r0
001784  e1a02006          MOV      r2,r6
001788  e3a01000          MOV      r1,#0
00178c  e1a00005          MOV      r0,r5
001790  ebfffffe          BL       tcp_output_alloc_header
001794  e1b07000          MOVS     r7,r0
;;;1447     if(p == NULL) {
001798  0a00002a          BEQ      |L1.6216|
;;;1448       LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
;;;1449       return;
;;;1450     }
;;;1451     tcphdr = (struct tcp_hdr *)p->payload;
;;;1452   
;;;1453     if (is_fin) {
00179c  e5976004          LDR      r6,[r7,#4]
0017a0  e3580000          CMP      r8,#0
0017a4  0a00000a          BEQ      |L1.6100|
;;;1454       /* FIN segment, no data */
;;;1455       TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
0017a8  e3a00011          MOV      r0,#0x11
0017ac  ebfffffe          BL       lwip_htons
0017b0  e5d6100d          LDRB     r1,[r6,#0xd]
0017b4  e5d6200c          LDRB     r2,[r6,#0xc]
0017b8  e1821401          ORR      r1,r2,r1,LSL #8
0017bc  e3c11c3f          BIC      r1,r1,#0x3f00
0017c0  e1800001          ORR      r0,r0,r1
0017c4  e5c6000c          STRB     r0,[r6,#0xc]
0017c8  e1a00420          LSR      r0,r0,#8
0017cc  e5c6000d          STRB     r0,[r6,#0xd]
0017d0  ea000008          B        |L1.6136|
                  |L1.6100|
;;;1456     } else {
;;;1457       /* Data segment, copy in one byte from the head of the unacked queue */
;;;1458       char *d = ((char *)p->payload + TCP_HLEN);
;;;1459       /* Depending on whether the segment has already been sent (unacked) or not
;;;1460          (unsent), seg->p->payload points to the IP header or TCP header.
;;;1461          Ensure we copy the first TCP data byte: */
;;;1462       pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
0017d4  e5940004          LDR      r0,[r4,#4]
0017d8  e1d430b8          LDRH     r3,[r4,#8]
0017dc  e1d020b8          LDRH     r2,[r0,#8]
0017e0  e2861014          ADD      r1,r6,#0x14           ;1458
0017e4  e0422003          SUB      r2,r2,r3
0017e8  e1a03802          LSL      r3,r2,#16
0017ec  e1a03823          LSR      r3,r3,#16
0017f0  e3a02001          MOV      r2,#1
0017f4  ebfffffe          BL       pbuf_copy_partial
                  |L1.6136|
;;;1463     }
;;;1464   
;;;1465   #if CHECKSUM_GEN_TCP
;;;1466     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
0017f8  e1d700b8          LDRH     r0,[r7,#8]
0017fc  e3a03006          MOV      r3,#6
001800  e2852004          ADD      r2,r5,#4
001804  e58d0000          STR      r0,[sp,#0]
001808  e1a01005          MOV      r1,r5
00180c  e1a00007          MOV      r0,r7
001810  ebfffffe          BL       inet_chksum_pseudo
001814  e5c60010          STRB     r0,[r6,#0x10]
001818  e1a00420          LSR      r0,r0,#8
00181c  e5c60011          STRB     r0,[r6,#0x11]
;;;1467                                         IP_PROTO_TCP, p->tot_len);
;;;1468   #endif
;;;1469     TCP_STATS_INC(tcp.xmit);
;;;1470   
;;;1471     /* Send output to IP */
;;;1472   #if LWIP_NETIF_HWADDRHINT
;;;1473     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1474       &(pcb->addr_hint));
;;;1475   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1476     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
001820  e3a01006          MOV      r1,#6
001824  e3a00000          MOV      r0,#0
001828  e1cd00f0          STRD     r0,r1,[sp,#0]
00182c  e5d5300a          LDRB     r3,[r5,#0xa]
001830  e2852004          ADD      r2,r5,#4
001834  e1a01005          MOV      r1,r5
001838  e1a00007          MOV      r0,r7
00183c  ebfffffe          BL       ip_output
;;;1477   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1478   
;;;1479     pbuf_free(p);
001840  e1a00007          MOV      r0,r7
001844  ebfffffe          BL       pbuf_free
                  |L1.6216|
;;;1480   
;;;1481     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
;;;1482                             " ackno %"U32_F".\n",
;;;1483                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1484   }
001848  e8bd81fc          POP      {r2-r8,pc}
;;;1485   #endif /* LWIP_TCP */
                          ENDP

                  tcp_write_checks PROC
;;;293    static err_t
;;;294    tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
00184c  e92d4010          PUSH     {r4,lr}
;;;295    {
;;;296      /* connection is in invalid state for data transmission? */
;;;297      if ((pcb->state != ESTABLISHED) &&
001850  e5d02018          LDRB     r2,[r0,#0x18]
001854  e3520004          CMP      r2,#4
;;;298          (pcb->state != CLOSE_WAIT) &&
001858  13520007          CMPNE    r2,#7
00185c  0a000003          BEQ      |L1.6256|
;;;299          (pcb->state != SYN_SENT) &&
001860  e3520002          CMP      r2,#2
;;;300          (pcb->state != SYN_RCVD)) {
001864  13520003          CMPNE    r2,#3
;;;301        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
;;;302        return ERR_CONN;
001868  13e0000c          MVNNE    r0,#0xc
;;;303      } else if (len == 0) {
;;;304        return ERR_OK;
;;;305      }
;;;306    
;;;307      /* fail on too much data */
;;;308      if (len > pcb->snd_buf) {
;;;309        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
;;;310          len, pcb->snd_buf));
;;;311        pcb->flags |= TF_NAGLEMEMERR;
;;;312        return ERR_MEM;
;;;313      }
;;;314    
;;;315      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;316    
;;;317      /* If total number of pbufs on the unsent/unacked queues exceeds the
;;;318       * configured maximum, return an error */
;;;319      /* check for configured max queuelen and possible overflow */
;;;320      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;321        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
;;;322          pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;323        TCP_STATS_INC(tcp.memerr);
;;;324        pcb->flags |= TF_NAGLEMEMERR;
;;;325        return ERR_MEM;
;;;326      }
;;;327      if (pcb->snd_queuelen != 0) {
;;;328        LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
;;;329          pcb->unacked != NULL || pcb->unsent != NULL);
;;;330      } else {
;;;331        LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
;;;332          pcb->unacked == NULL && pcb->unsent == NULL);
;;;333      }
;;;334      return ERR_OK;
;;;335    }
00186c  18bd8010          POPNE    {r4,pc}
                  |L1.6256|
001870  e3510000          CMP      r1,#0                 ;303
001874  0a00001d          BEQ      |L1.6384|
001878  e1d026b6          LDRH     r2,[r0,#0x66]         ;308
00187c  e1510002          CMP      r1,r2                 ;308
001880  91d016b8          LDRHLS   r1,[r0,#0x68]         ;320
001884  93510008          CMPLS    r1,#8                 ;320
001888  3a000004          BCC      |L1.6304|
00188c  e5d0101e          LDRB     r1,[r0,#0x1e]         ;324
001890  e3811080          ORR      r1,r1,#0x80           ;324
001894  e5c0101e          STRB     r1,[r0,#0x1e]         ;324
001898  e3e00000          MVN      r0,#0                 ;325
00189c  e8bd8010          POP      {r4,pc}
                  |L1.6304|
0018a0  e3510000          CMP      r1,#0                 ;327
0018a4  e5901070          LDR      r1,[r0,#0x70]         ;331
0018a8  0a000007          BEQ      |L1.6348|
0018ac  e3510000          CMP      r1,#0                 ;328
0018b0  0590006c          LDREQ    r0,[r0,#0x6c]         ;328
0018b4  03500000          CMPEQ    r0,#0                 ;328
0018b8  028f3048          ADREQ    r3,|L1.6408|
0018bc  03a02f52          MOVEQ    r2,#0x148             ;328
0018c0  028f1060          ADREQ    r1,|L1.6440|
0018c4  0a000007          BEQ      |L1.6376|
0018c8  ea000008          B        |L1.6384|
                  |L1.6348|
0018cc  e3510000          CMP      r1,#0                 ;331
0018d0  0590006c          LDREQ    r0,[r0,#0x6c]         ;331
0018d4  03500000          CMPEQ    r0,#0                 ;331
0018d8  159f2084          LDRNE    r2,|L1.6500|
0018dc  128f3024          ADRNE    r3,|L1.6408|
0018e0  128f1080          ADRNE    r1,|L1.6504|
0018e4  0a000001          BEQ      |L1.6384|
                  |L1.6376|
0018e8  e28f00ac          ADR      r0,|L1.6556|
0018ec  ebfffffe          BL       sysprintf
                  |L1.6384|
0018f0  e3a00000          MOV      r0,#0                 ;334
0018f4  e8bd8010          POP      {r4,pc}
;;;336    
                          ENDP

                  |L1.6392|
                          DCD      0x000004b6
                  |L1.6396|
                          DCD      ||.text||+0x238
                  |L1.6400|
                          DCD      0x00005014
                  |L1.6404|
                          DCD      0x0000a00f
                  |L1.6408|
001908  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_out.c",0
00190c  2d312e34
001910  2e315c73
001914  72635c63
001918  6f72655c
00191c  7463705f
001920  6f75742e
001924  6300    
001926  00                DCB      0
001927  00                DCB      0
                  |L1.6440|
001928  7463705f          DCB      "tcp_write: pbufs on queue => at least one queue non-emp"
00192c  77726974
001930  653a2070
001934  62756673
001938  206f6e20
00193c  71756575
001940  65203d3e
001944  20617420
001948  6c656173
00194c  74206f6e
001950  65207175
001954  65756520
001958  6e6f6e2d
00195c  656d70  
00195f  747900            DCB      "ty",0
001962  00                DCB      0
001963  00                DCB      0
                  |L1.6500|
                          DCD      0x0000014b
                  |L1.6504|
001968  7463705f          DCB      "tcp_write: no pbufs on queue => both queues empty",0
00196c  77726974
001970  653a206e
001974  6f207062
001978  75667320
00197c  6f6e2071
001980  75657565
001984  203d3e20
001988  626f7468
00198c  20717565
001990  75657320
001994  656d7074
001998  7900    
00199a  00                DCB      0
00199b  00                DCB      0
                  |L1.6556|
00199c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0019a0  7274696f
0019a4  6e202225
0019a8  73222066
0019ac  61696c65
0019b0  64206174
0019b4  206c696e
0019b8  65202564
0019bc  20696e20
0019c0  25730a00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7463705f          DCB      "tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in fl"
000004  656e7175
000008  6575655f
00000c  666c6167
000010  733a206e
000014  65656420
000018  65697468
00001c  65722054
000020  43505f53
000024  594e206f
000028  72205443
00002c  505f4649
000030  4e20696e
000034  20666c  
000037  61677320          DCB      "ags (programmer violates API)",0
00003b  2870726f
00003f  6772616d
000043  6d657220
000047  76696f6c
00004b  61746573
00004f  20415049
000053  2900    
