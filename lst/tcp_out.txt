; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tcp_out.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tcp_out.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\tcp_out.crf lwip-1.4.1\src\core\tcp_out.c]
                          ARM

                          AREA ||i.tcp_create_segment||, CODE, READONLY, ALIGN=2

                  tcp_create_segment PROC
;;;158    static struct tcp_seg *
;;;159    tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;160    {
000004  e1a07000          MOV      r7,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a09002          MOV      r9,r2
000010  e1a0a003          MOV      r10,r3
000014  e59d8028          LDR      r8,[sp,#0x28]
;;;161      struct tcp_seg *seg;
;;;162      u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
000018  e2080001          AND      r0,r8,#1
00001c  e3500000          CMP      r0,#0
000020  0a000001          BEQ      |L1.44|
000024  e3a00004          MOV      r0,#4
000028  ea000000          B        |L1.48|
                  |L1.44|
00002c  e3a00000          MOV      r0,#0
                  |L1.48|
000030  e2081002          AND      r1,r8,#2
000034  e3510000          CMP      r1,#0
000038  0a000001          BEQ      |L1.68|
00003c  e3a0100c          MOV      r1,#0xc
000040  ea000000          B        |L1.72|
                  |L1.68|
000044  e3a01000          MOV      r1,#0
                  |L1.72|
000048  e0805001          ADD      r5,r0,r1
;;;163    
;;;164      if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
00004c  e3a00003          MOV      r0,#3
000050  ebfffffe          BL       memp_malloc
000054  e2504000          SUBS     r4,r0,#0
000058  1a000003          BNE      |L1.108|
;;;165        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
;;;166        pbuf_free(p);
00005c  e1a00006          MOV      r0,r6
000060  ebfffffe          BL       pbuf_free
;;;167        return NULL;
000064  e3a00000          MOV      r0,#0
                  |L1.104|
;;;168      }
;;;169      seg->flags = optflags;
;;;170      seg->next = NULL;
;;;171      seg->p = p;
;;;172      seg->len = p->tot_len - optlen;
;;;173    #if TCP_OVERSIZE_DBGCHECK
;;;174      seg->oversize_left = 0;
;;;175    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;176    #if TCP_CHECKSUM_ON_COPY
;;;177      seg->chksum = 0;
;;;178      seg->chksum_swapped = 0;
;;;179      /* check optflags */
;;;180      LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
;;;181                  (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
;;;182    #endif /* TCP_CHECKSUM_ON_COPY */
;;;183    
;;;184      /* build TCP header */
;;;185      if (pbuf_header(p, TCP_HLEN)) {
;;;186        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
;;;187        TCP_STATS_INC(tcp.err);
;;;188        tcp_seg_free(seg);
;;;189        return NULL;
;;;190      }
;;;191      seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
;;;192      seg->tcphdr->src = htons(pcb->local_port);
;;;193      seg->tcphdr->dest = htons(pcb->remote_port);
;;;194      seg->tcphdr->seqno = htonl(seqno);
;;;195      /* ackno is set in tcp_output */
;;;196      TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
;;;197      /* wnd and chksum are set in tcp_output */
;;;198      seg->tcphdr->urgp = 0;
;;;199      return seg;
;;;200    } 
000068  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.108|
00006c  e5c4800c          STRB     r8,[r4,#0xc]          ;169
000070  e3a00000          MOV      r0,#0                 ;170
000074  e5840000          STR      r0,[r4,#0]            ;170
000078  e5846004          STR      r6,[r4,#4]            ;171
00007c  e1d600b8          LDRH     r0,[r6,#8]            ;172
000080  e0400005          SUB      r0,r0,r5              ;172
000084  e1c400b8          STRH     r0,[r4,#8]            ;172
000088  e3a00000          MOV      r0,#0                 ;174
00008c  e1c400ba          STRH     r0,[r4,#0xa]          ;174
000090  e3a01014          MOV      r1,#0x14              ;185
000094  e1a00006          MOV      r0,r6                 ;185
000098  ebfffffe          BL       pbuf_header
00009c  e3500000          CMP      r0,#0                 ;185
0000a0  0a000003          BEQ      |L1.180|
0000a4  e1a00004          MOV      r0,r4                 ;188
0000a8  ebfffffe          BL       tcp_seg_free
0000ac  e3a00000          MOV      r0,#0                 ;189
0000b0  eaffffec          B        |L1.104|
                  |L1.180|
0000b4  e5940004          LDR      r0,[r4,#4]            ;191
0000b8  e5900004          LDR      r0,[r0,#4]            ;191
0000bc  e5840010          STR      r0,[r4,#0x10]         ;191
0000c0  e1d701ba          LDRH     r0,[r7,#0x1a]         ;192
0000c4  ebfffffe          BL       lwip_htons
0000c8  e5941010          LDR      r1,[r4,#0x10]         ;192
0000cc  e5c10000          STRB     r0,[r1,#0]            ;192
0000d0  e1a00420          LSR      r0,r0,#8              ;192
0000d4  e5c10001          STRB     r0,[r1,#1]            ;192
0000d8  e1d701bc          LDRH     r0,[r7,#0x1c]         ;193
0000dc  ebfffffe          BL       lwip_htons
0000e0  e5941010          LDR      r1,[r4,#0x10]         ;193
0000e4  e5c10002          STRB     r0,[r1,#2]            ;193
0000e8  e1a00420          LSR      r0,r0,#8              ;193
0000ec  e5c10003          STRB     r0,[r1,#3]            ;193
0000f0  e1a0000a          MOV      r0,r10                ;194
0000f4  ebfffffe          BL       lwip_htonl
0000f8  e1a0b000          MOV      r11,r0                ;194
0000fc  e5940010          LDR      r0,[r4,#0x10]         ;194
000100  e2801004          ADD      r1,r0,#4              ;194
000104  e1a0000b          MOV      r0,r11                ;194
000108  ebfffffe          BL       __aeabi_uwrite4
00010c  e1a01fc5          ASR      r1,r5,#31             ;196
000110  e0851f21          ADD      r1,r5,r1,LSR #30      ;196
000114  e1a01141          ASR      r1,r1,#2              ;196
000118  e2811005          ADD      r1,r1,#5              ;196
00011c  e1891601          ORR      r1,r9,r1,LSL #12      ;196
000120  e1a00801          LSL      r0,r1,#16             ;196
000124  e1a00820          LSR      r0,r0,#16             ;196
000128  ebfffffe          BL       lwip_htons
00012c  e5941010          LDR      r1,[r4,#0x10]         ;196
000130  e5c1000c          STRB     r0,[r1,#0xc]          ;196
000134  e1a00420          LSR      r0,r0,#8              ;196
000138  e5c1000d          STRB     r0,[r1,#0xd]          ;196
00013c  e3a00000          MOV      r0,#0                 ;198
000140  e5941010          LDR      r1,[r4,#0x10]         ;198
000144  e5c10012          STRB     r0,[r1,#0x12]         ;198
000148  e5c10013          STRB     r0,[r1,#0x13]         ;198
00014c  e1a00004          MOV      r0,r4                 ;199
000150  eaffffc4          B        |L1.104|
;;;201    
                          ENDP


                          AREA ||i.tcp_enqueue_flags||, CODE, READONLY, ALIGN=2

                  tcp_enqueue_flags PROC
;;;721    err_t
;;;722    tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;723    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;724      struct pbuf *p;
;;;725      struct tcp_seg *seg;
;;;726      u8_t optflags = 0;
00000c  e3a08000          MOV      r8,#0
;;;727      u8_t optlen = 0;
000010  e3a09000          MOV      r9,#0
;;;728    
;;;729      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;730    
;;;731      LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
000014  e1a00000          MOV      r0,r0
000018  e2050003          AND      r0,r5,#3
00001c  e3500000          CMP      r0,#0
000020  1a000006          BNE      |L2.64|
000024  e1a00000          MOV      r0,r0
000028  e28f3f9f          ADR      r3,|L2.684|
00002c  e59f2298          LDR      r2,|L2.716|
000030  e59f1298          LDR      r1,|L2.720|
000034  e28f0fa6          ADR      r0,|L2.724|
000038  ebfffffe          BL       sysprintf
00003c  e1a00000          MOV      r0,r0
                  |L2.64|
000040  e1a00000          MOV      r0,r0
;;;732                  (flags & (TCP_SYN | TCP_FIN)) != 0);
;;;733    
;;;734      /* check for configured max queuelen and possible overflow */
;;;735      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
000044  e1d406b8          LDRH     r0,[r4,#0x68]
000048  e3500008          CMP      r0,#8
00004c  aa000003          BGE      |L2.96|
000050  e1d406b8          LDRH     r0,[r4,#0x68]
000054  e59f12a0          LDR      r1,|L2.764|
000058  e1500001          CMP      r0,r1
00005c  9a000004          BLS      |L2.116|
                  |L2.96|
;;;736        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
;;;737                                           pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;738        TCP_STATS_INC(tcp.memerr);
;;;739        pcb->flags |= TF_NAGLEMEMERR;
000060  e5d4001e          LDRB     r0,[r4,#0x1e]
000064  e3800080          ORR      r0,r0,#0x80
000068  e5c4001e          STRB     r0,[r4,#0x1e]
;;;740        return ERR_MEM;
00006c  e3e00000          MVN      r0,#0
                  |L2.112|
;;;741      }
;;;742    
;;;743      if (flags & TCP_SYN) {
;;;744        optflags = TF_SEG_OPTS_MSS;
;;;745      }
;;;746    #if LWIP_TCP_TIMESTAMPS
;;;747      if ((pcb->flags & TF_TIMESTAMP)) {
;;;748        optflags |= TF_SEG_OPTS_TS;
;;;749      }
;;;750    #endif /* LWIP_TCP_TIMESTAMPS */
;;;751      optlen = LWIP_TCP_OPT_LENGTH(optflags);
;;;752    
;;;753      /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
;;;754       * We need one available snd_buf byte to do that.
;;;755       * This means we can't send FIN while snd_buf==0. A better fix would be to
;;;756       * not include SYN and FIN sequence numbers in the snd_buf count. */
;;;757      if (pcb->snd_buf == 0) {
;;;758        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
;;;759        TCP_STATS_INC(tcp.memerr);
;;;760        return ERR_MEM;
;;;761      }
;;;762    
;;;763      /* Allocate pbuf with room for TCP header + options */
;;;764      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;765        pcb->flags |= TF_NAGLEMEMERR;
;;;766        TCP_STATS_INC(tcp.memerr);
;;;767        return ERR_MEM;
;;;768      }
;;;769      LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
;;;770                  (p->len >= optlen));
;;;771    
;;;772      /* Allocate memory for tcp_seg, and fill in fields. */
;;;773      if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
;;;774        pcb->flags |= TF_NAGLEMEMERR;
;;;775        TCP_STATS_INC(tcp.memerr);
;;;776        return ERR_MEM;
;;;777      }
;;;778      LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
;;;779      LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
;;;780    
;;;781      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
;;;782                  ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
;;;783                   ntohl(seg->tcphdr->seqno),
;;;784                   ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
;;;785                   (u16_t)flags));
;;;786    
;;;787      /* Now append seg to pcb->unsent queue */
;;;788      if (pcb->unsent == NULL) {
;;;789        pcb->unsent = seg;
;;;790      } else {
;;;791        struct tcp_seg *useg;
;;;792        for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
;;;793        useg->next = seg;
;;;794      }
;;;795    #if TCP_OVERSIZE
;;;796      /* The new unsent tail has no space */
;;;797      pcb->unsent_oversize = 0;
;;;798    #endif /* TCP_OVERSIZE */
;;;799    
;;;800      /* SYN and FIN bump the sequence number */
;;;801      if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
;;;802        pcb->snd_lbb++;
;;;803        /* optlen does not influence snd_buf */
;;;804        pcb->snd_buf--;
;;;805      }
;;;806      if (flags & TCP_FIN) {
;;;807        pcb->flags |= TF_FIN;
;;;808      }
;;;809    
;;;810      /* update number of segments on the queues */
;;;811      pcb->snd_queuelen += pbuf_clen(seg->p);
;;;812      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
;;;813      if (pcb->snd_queuelen != 0) {
;;;814        LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
;;;815          pcb->unacked != NULL || pcb->unsent != NULL);
;;;816      }
;;;817    
;;;818      return ERR_OK;
;;;819    }
000070  e8bd83f8          POP      {r3-r9,pc}
                  |L2.116|
000074  e2050002          AND      r0,r5,#2              ;743
000078  e3500000          CMP      r0,#0                 ;743
00007c  0a000000          BEQ      |L2.132|
000080  e3a08001          MOV      r8,#1                 ;744
                  |L2.132|
000084  e2080001          AND      r0,r8,#1              ;751
000088  e3500000          CMP      r0,#0                 ;751
00008c  0a000001          BEQ      |L2.152|
000090  e3a00004          MOV      r0,#4                 ;751
000094  ea000000          B        |L2.156|
                  |L2.152|
000098  e3a00000          MOV      r0,#0                 ;751
                  |L2.156|
00009c  e2081002          AND      r1,r8,#2              ;751
0000a0  e3510000          CMP      r1,#0                 ;751
0000a4  0a000001          BEQ      |L2.176|
0000a8  e3a0100c          MOV      r1,#0xc               ;751
0000ac  ea000000          B        |L2.180|
                  |L2.176|
0000b0  e3a01000          MOV      r1,#0                 ;751
                  |L2.180|
0000b4  e0809001          ADD      r9,r0,r1              ;751
0000b8  e1d406b6          LDRH     r0,[r4,#0x66]         ;757
0000bc  e3500000          CMP      r0,#0                 ;757
0000c0  1a000001          BNE      |L2.204|
0000c4  e3e00000          MVN      r0,#0                 ;760
0000c8  eaffffe8          B        |L2.112|
                  |L2.204|
0000cc  e3a02000          MOV      r2,#0                 ;764
0000d0  e1a01009          MOV      r1,r9                 ;764
0000d4  e1a00002          MOV      r0,r2                 ;764
0000d8  ebfffffe          BL       pbuf_alloc
0000dc  e2507000          SUBS     r7,r0,#0              ;764
0000e0  1a000004          BNE      |L2.248|
0000e4  e5d4001e          LDRB     r0,[r4,#0x1e]         ;765
0000e8  e3800080          ORR      r0,r0,#0x80           ;765
0000ec  e5c4001e          STRB     r0,[r4,#0x1e]         ;765
0000f0  e3e00000          MVN      r0,#0                 ;767
0000f4  eaffffdd          B        |L2.112|
                  |L2.248|
0000f8  e1a00000          MOV      r0,r0                 ;769
0000fc  e1d700ba          LDRH     r0,[r7,#0xa]          ;769
000100  e1500009          CMP      r0,r9                 ;769
000104  aa000006          BGE      |L2.292|
000108  e1a00000          MOV      r0,r0                 ;769
00010c  e28f3f66          ADR      r3,|L2.684|
000110  e59f21e8          LDR      r2,|L2.768|
000114  e28f1f7a          ADR      r1,|L2.772|
000118  e28f0f6d          ADR      r0,|L2.724|
00011c  ebfffffe          BL       sysprintf
000120  e1a00000          MOV      r0,r0                 ;769
                  |L2.292|
000124  e1a00000          MOV      r0,r0                 ;769
000128  e58d8000          STR      r8,[sp,#0]            ;773
00012c  e1a02005          MOV      r2,r5                 ;773
000130  e1a01007          MOV      r1,r7                 ;773
000134  e594305c          LDR      r3,[r4,#0x5c]         ;773
000138  e1a00004          MOV      r0,r4                 ;773
00013c  ebfffffe          BL       tcp_create_segment
000140  e2506000          SUBS     r6,r0,#0              ;773
000144  1a000004          BNE      |L2.348|
000148  e5d4001e          LDRB     r0,[r4,#0x1e]         ;774
00014c  e3800080          ORR      r0,r0,#0x80           ;774
000150  e5c4001e          STRB     r0,[r4,#0x1e]         ;774
000154  e3e00000          MVN      r0,#0                 ;776
000158  eaffffc4          B        |L2.112|
                  |L2.348|
00015c  e1a00000          MOV      r0,r0                 ;778
000160  e5d60010          LDRB     r0,[r6,#0x10]         ;778
000164  e2000003          AND      r0,r0,#3              ;778
000168  e3500000          CMP      r0,#0                 ;778
00016c  0a000006          BEQ      |L2.396|
000170  e1a00000          MOV      r0,r0                 ;778
000174  e28f3e13          ADR      r3,|L2.684|
000178  e59f21c0          LDR      r2,|L2.832|
00017c  e28f1d07          ADR      r1,|L2.836|
000180  e28f0f53          ADR      r0,|L2.724|
000184  ebfffffe          BL       sysprintf
000188  e1a00000          MOV      r0,r0                 ;778
                  |L2.396|
00018c  e1a00000          MOV      r0,r0                 ;778
000190  e1a00000          MOV      r0,r0                 ;779
000194  e1d600b8          LDRH     r0,[r6,#8]            ;779
000198  e3500000          CMP      r0,#0                 ;779
00019c  0a000006          BEQ      |L2.444|
0001a0  e1a00000          MOV      r0,r0                 ;779
0001a4  e28f3c01          ADR      r3,|L2.684|
0001a8  e59f21ac          LDR      r2,|L2.860|
0001ac  e28f1f6b          ADR      r1,|L2.864|
0001b0  e28f0f47          ADR      r0,|L2.724|
0001b4  ebfffffe          BL       sysprintf
0001b8  e1a00000          MOV      r0,r0                 ;779
                  |L2.444|
0001bc  e1a00000          MOV      r0,r0                 ;779
0001c0  e594006c          LDR      r0,[r4,#0x6c]         ;788
0001c4  e3500000          CMP      r0,#0                 ;788
0001c8  1a000001          BNE      |L2.468|
0001cc  e584606c          STR      r6,[r4,#0x6c]         ;789
0001d0  ea000007          B        |L2.500|
                  |L2.468|
0001d4  e594006c          LDR      r0,[r4,#0x6c]         ;792
0001d8  ea000000          B        |L2.480|
                  |L2.476|
0001dc  e5900000          LDR      r0,[r0,#0]            ;792
                  |L2.480|
0001e0  e5901000          LDR      r1,[r0,#0]            ;792
0001e4  e3510000          CMP      r1,#0                 ;792
0001e8  1afffffb          BNE      |L2.476|
0001ec  e5806000          STR      r6,[r0,#0]            ;793
0001f0  e1a00000          MOV      r0,r0                 ;794
                  |L2.500|
0001f4  e3a00000          MOV      r0,#0                 ;797
0001f8  e1c406ba          STRH     r0,[r4,#0x6a]         ;797
0001fc  e2050002          AND      r0,r5,#2              ;801
000200  e3500000          CMP      r0,#0                 ;801
000204  1a000002          BNE      |L2.532|
000208  e2050001          AND      r0,r5,#1              ;801
00020c  e3500000          CMP      r0,#0                 ;801
000210  0a000005          BEQ      |L2.556|
                  |L2.532|
000214  e594005c          LDR      r0,[r4,#0x5c]         ;802
000218  e2800001          ADD      r0,r0,#1              ;802
00021c  e584005c          STR      r0,[r4,#0x5c]         ;802
000220  e1d406b6          LDRH     r0,[r4,#0x66]         ;804
000224  e2400001          SUB      r0,r0,#1              ;804
000228  e1c406b6          STRH     r0,[r4,#0x66]         ;804
                  |L2.556|
00022c  e2050001          AND      r0,r5,#1              ;806
000230  e3500000          CMP      r0,#0                 ;806
000234  0a000002          BEQ      |L2.580|
000238  e5d4001e          LDRB     r0,[r4,#0x1e]         ;807
00023c  e3800020          ORR      r0,r0,#0x20           ;807
000240  e5c4001e          STRB     r0,[r4,#0x1e]         ;807
                  |L2.580|
000244  e5960004          LDR      r0,[r6,#4]            ;811
000248  ebfffffe          BL       pbuf_clen
00024c  e1d416b8          LDRH     r1,[r4,#0x68]         ;811
000250  e0800001          ADD      r0,r0,r1              ;811
000254  e3c00801          BIC      r0,r0,#0x10000        ;811
000258  e1c406b8          STRH     r0,[r4,#0x68]         ;811
00025c  e1d406b8          LDRH     r0,[r4,#0x68]         ;813
000260  e3500000          CMP      r0,#0                 ;813
000264  0a00000e          BEQ      |L2.676|
000268  e1a00000          MOV      r0,r0                 ;814
00026c  e5940070          LDR      r0,[r4,#0x70]         ;814
000270  e3500000          CMP      r0,#0                 ;814
000274  1a000009          BNE      |L2.672|
000278  e594006c          LDR      r0,[r4,#0x6c]         ;814
00027c  e3500000          CMP      r0,#0                 ;814
000280  1a000006          BNE      |L2.672|
000284  e1a00000          MOV      r0,r0                 ;814
000288  e28f301c          ADR      r3,|L2.684|
00028c  e59f20f8          LDR      r2,|L2.908|
000290  e28f10f8          ADR      r1,|L2.912|
000294  e28f0038          ADR      r0,|L2.724|
000298  ebfffffe          BL       sysprintf
00029c  e1a00000          MOV      r0,r0                 ;814
                  |L2.672|
0002a0  e1a00000          MOV      r0,r0                 ;814
                  |L2.676|
0002a4  e3a00000          MOV      r0,#0                 ;818
0002a8  eaffff70          B        |L2.112|
                  |L2.684|
0002ac  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_out.c",0
0002b0  2d312e34
0002b4  2e315c73
0002b8  72635c63
0002bc  6f72655c
0002c0  7463705f
0002c4  6f75742e
0002c8  6300    
0002ca  00                DCB      0
0002cb  00                DCB      0
                  |L2.716|
                          DCD      0x000002db
                  |L2.720|
                          DCD      ||.conststring||
                  |L2.724|
0002d4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0002d8  7274696f
0002dc  6e202225
0002e0  73222066
0002e4  61696c65
0002e8  64206174
0002ec  206c696e
0002f0  65202564
0002f4  20696e20
0002f8  25730a00
                  |L2.764|
                          DCD      0x0000fffc
                  |L2.768|
                          DCD      0x00000301
                  |L2.772|
000304  7463705f          DCB      "tcp_enqueue_flags: check that first pbuf can hold optle"
000308  656e7175
00030c  6575655f
000310  666c6167
000314  733a2063
000318  6865636b
00031c  20746861
000320  74206669
000324  72737420
000328  70627566
00032c  2063616e
000330  20686f6c
000334  64206f70
000338  746c65  
00033b  6e00              DCB      "n",0
00033d  00                DCB      0
00033e  00                DCB      0
00033f  00                DCB      0
                  |L2.832|
                          DCD      0x0000030a
                  |L2.836|
000344  7365672d          DCB      "seg->tcphdr not aligned",0
000348  3e746370
00034c  68647220
000350  6e6f7420
000354  616c6967
000358  6e656400
                  |L2.860|
                          DCD      0x0000030b
                  |L2.864|
000360  7463705f          DCB      "tcp_enqueue_flags: invalid segment length",0
000364  656e7175
000368  6575655f
00036c  666c6167
000370  733a2069
000374  6e76616c
000378  69642073
00037c  65676d65
000380  6e74206c
000384  656e6774
000388  6800    
00038a  00                DCB      0
00038b  00                DCB      0
                  |L2.908|
                          DCD      0x0000032e
                  |L2.912|
000390  7463705f          DCB      "tcp_enqueue_flags: invalid queue length",0
000394  656e7175
000398  6575655f
00039c  666c6167
0003a0  733a2069
0003a4  6e76616c
0003a8  69642071
0003ac  75657565
0003b0  206c656e
0003b4  67746800
                          ENDP


                          AREA ||i.tcp_keepalive||, CODE, READONLY, ALIGN=2

                  tcp_keepalive PROC
;;;1363   void
;;;1364   tcp_keepalive(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;1365   {
000004  e1a04000          MOV      r4,r0
;;;1366     struct pbuf *p;
;;;1367     struct tcp_hdr *tcphdr;
;;;1368   
;;;1369     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1370                             ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1371                             ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1372   
;;;1373     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1374                             tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1375      
;;;1376     p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
000008  e5941050          LDR      r1,[r4,#0x50]
00000c  e2410001          SUB      r0,r1,#1
000010  ebfffffe          BL       lwip_htonl
000014  e1a07000          MOV      r7,r0
000018  e1a03007          MOV      r3,r7
00001c  e3a02000          MOV      r2,#0
000020  e1a01002          MOV      r1,r2
000024  e1a00004          MOV      r0,r4
000028  ebfffffe          BL       tcp_output_alloc_header
00002c  e1a05000          MOV      r5,r0
;;;1377     if(p == NULL) {
000030  e3550000          CMP      r5,#0
000034  1a000000          BNE      |L3.60|
                  |L3.56|
;;;1378       LWIP_DEBUGF(TCP_DEBUG, 
;;;1379                   ("tcp_keepalive: could not allocate memory for pbuf\n"));
;;;1380       return;
;;;1381     }
;;;1382     tcphdr = (struct tcp_hdr *)p->payload;
;;;1383   
;;;1384   #if CHECKSUM_GEN_TCP
;;;1385     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1386                                         IP_PROTO_TCP, p->tot_len);
;;;1387   #endif
;;;1388     TCP_STATS_INC(tcp.xmit);
;;;1389   
;;;1390     /* Send output to IP */
;;;1391   #if LWIP_NETIF_HWADDRHINT
;;;1392     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1393       &(pcb->addr_hint));
;;;1394   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1395     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
;;;1396   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1397   
;;;1398     pbuf_free(p);
;;;1399   
;;;1400     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
;;;1401                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1402   }
000038  e8bd81fc          POP      {r2-r8,pc}
                  |L3.60|
00003c  e5956004          LDR      r6,[r5,#4]            ;1382
000040  e1d500b8          LDRH     r0,[r5,#8]            ;1385
000044  e3a03006          MOV      r3,#6                 ;1385
000048  e2842004          ADD      r2,r4,#4              ;1385
00004c  e1a01004          MOV      r1,r4                 ;1385
000050  e58d0000          STR      r0,[sp,#0]            ;1385
000054  e1a00005          MOV      r0,r5                 ;1385
000058  ebfffffe          BL       inet_chksum_pseudo
00005c  e5c60010          STRB     r0,[r6,#0x10]         ;1385
000060  e1a00420          LSR      r0,r0,#8              ;1385
000064  e5c60011          STRB     r0,[r6,#0x11]         ;1385
000068  e3a00006          MOV      r0,#6                 ;1395
00006c  e3a01000          MOV      r1,#0                 ;1395
000070  e58d0004          STR      r0,[sp,#4]            ;1395
000074  e58d1000          STR      r1,[sp,#0]            ;1395
000078  e5d4300a          LDRB     r3,[r4,#0xa]          ;1395
00007c  e2842004          ADD      r2,r4,#4              ;1395
000080  e1a01004          MOV      r1,r4                 ;1395
000084  e1a00005          MOV      r0,r5                 ;1395
000088  ebfffffe          BL       ip_output
00008c  e1a00005          MOV      r0,r5                 ;1398
000090  ebfffffe          BL       pbuf_free
000094  e1a00000          MOV      r0,r0
000098  eaffffe6          B        |L3.56|
;;;1403   
                          ENDP


                          AREA ||i.tcp_output||, CODE, READONLY, ALIGN=2

                  tcp_output PROC
;;;897    err_t
;;;898    tcp_output(struct tcp_pcb *pcb)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;899    {
000004  e1a04000          MOV      r4,r0
;;;900      struct tcp_seg *seg, *useg;
;;;901      u32_t wnd, snd_nxt;
;;;902    #if TCP_CWND_DEBUG
;;;903      s16_t i = 0;
;;;904    #endif /* TCP_CWND_DEBUG */
;;;905    
;;;906      /* pcb->state LISTEN not allowed here */
;;;907      LWIP_ASSERT("don't call tcp_output for listen-pcbs",
000008  e1a00000          MOV      r0,r0
00000c  e5d40018          LDRB     r0,[r4,#0x18]
000010  e3500001          CMP      r0,#1
000014  1a000006          BNE      |L4.52|
000018  e1a00000          MOV      r0,r0
00001c  e28f3faa          ADR      r3,|L4.716|
000020  e59f22c4          LDR      r2,|L4.748|
000024  e28f1fb1          ADR      r1,|L4.752|
000028  e28f0fba          ADR      r0,|L4.792|
00002c  ebfffffe          BL       sysprintf
000030  e1a00000          MOV      r0,r0
                  |L4.52|
000034  e1a00000          MOV      r0,r0
;;;908        pcb->state != LISTEN);
;;;909    
;;;910      /* First, check if we are invoked by the TCP input processing
;;;911         code. If so, we do not output anything. Instead, we rely on the
;;;912         input processing code to call us when input processing is done
;;;913         with. */
;;;914      if (tcp_input_pcb == pcb) {
000038  e59f0300          LDR      r0,|L4.832|
00003c  e5900000          LDR      r0,[r0,#0]  ; tcp_input_pcb
000040  e1500004          CMP      r0,r4
000044  1a000001          BNE      |L4.80|
;;;915        return ERR_OK;
000048  e3a00000          MOV      r0,#0
                  |L4.76|
;;;916      }
;;;917    
;;;918      wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
;;;919    
;;;920      seg = pcb->unsent;
;;;921    
;;;922      /* If the TF_ACK_NOW flag is set and no data will be sent (either
;;;923       * because the ->unsent queue is empty or because the window does
;;;924       * not allow it), construct an empty ACK segment and send it.
;;;925       *
;;;926       * If data is to be sent, we will just piggyback the ACK (see below).
;;;927       */
;;;928      if (pcb->flags & TF_ACK_NOW &&
;;;929         (seg == NULL ||
;;;930          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
;;;931         return tcp_send_empty_ack(pcb);
;;;932      }
;;;933    
;;;934      /* useg should point to last segment on unacked queue */
;;;935      useg = pcb->unacked;
;;;936      if (useg != NULL) {
;;;937        for (; useg->next != NULL; useg = useg->next);
;;;938      }
;;;939    
;;;940    #if TCP_OUTPUT_DEBUG
;;;941      if (seg == NULL) {
;;;942        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
;;;943                                       (void*)pcb->unsent));
;;;944      }
;;;945    #endif /* TCP_OUTPUT_DEBUG */
;;;946    #if TCP_CWND_DEBUG
;;;947      if (seg == NULL) {
;;;948        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F
;;;949                                     ", cwnd %"U16_F", wnd %"U32_F
;;;950                                     ", seg == NULL, ack %"U32_F"\n",
;;;951                                     pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
;;;952      } else {
;;;953        LWIP_DEBUGF(TCP_CWND_DEBUG, 
;;;954                    ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F
;;;955                     ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
;;;956                     pcb->snd_wnd, pcb->cwnd, wnd,
;;;957                     ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
;;;958                     ntohl(seg->tcphdr->seqno), pcb->lastack));
;;;959      }
;;;960    #endif /* TCP_CWND_DEBUG */
;;;961      /* data available and window allows it to be sent? */
;;;962      while (seg != NULL &&
;;;963             ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
;;;964        LWIP_ASSERT("RST not expected here!", 
;;;965                    (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
;;;966        /* Stop sending if the nagle algorithm would prevent it
;;;967         * Don't stop:
;;;968         * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
;;;969         * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
;;;970         *   either seg->next != NULL or pcb->unacked == NULL;
;;;971         *   RST is no sent using tcp_write/tcp_output.
;;;972         */
;;;973        if((tcp_do_output_nagle(pcb) == 0) &&
;;;974          ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
;;;975          break;
;;;976        }
;;;977    #if TCP_CWND_DEBUG
;;;978        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
;;;979                                pcb->snd_wnd, pcb->cwnd, wnd,
;;;980                                ntohl(seg->tcphdr->seqno) + seg->len -
;;;981                                pcb->lastack,
;;;982                                ntohl(seg->tcphdr->seqno), pcb->lastack, i));
;;;983        ++i;
;;;984    #endif /* TCP_CWND_DEBUG */
;;;985    
;;;986        pcb->unsent = seg->next;
;;;987    
;;;988        if (pcb->state != SYN_SENT) {
;;;989          TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
;;;990          pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;991        }
;;;992    
;;;993        tcp_output_segment(seg, pcb);
;;;994        snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;995        if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;996          pcb->snd_nxt = snd_nxt;
;;;997        }
;;;998        /* put segment on unacknowledged list if length > 0 */
;;;999        if (TCP_TCPLEN(seg) > 0) {
;;;1000         seg->next = NULL;
;;;1001         /* unacked list is empty? */
;;;1002         if (pcb->unacked == NULL) {
;;;1003           pcb->unacked = seg;
;;;1004           useg = seg;
;;;1005         /* unacked list is not empty? */
;;;1006         } else {
;;;1007           /* In the case of fast retransmit, the packet should not go to the tail
;;;1008            * of the unacked queue, but rather somewhere before it. We need to check for
;;;1009            * this case. -STJ Jul 27, 2004 */
;;;1010           if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
;;;1011             /* add segment to before tail of unacked list, keeping the list sorted */
;;;1012             struct tcp_seg **cur_seg = &(pcb->unacked);
;;;1013             while (*cur_seg &&
;;;1014               TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1015                 cur_seg = &((*cur_seg)->next );
;;;1016             }
;;;1017             seg->next = (*cur_seg);
;;;1018             (*cur_seg) = seg;
;;;1019           } else {
;;;1020             /* add segment to tail of unacked list */
;;;1021             useg->next = seg;
;;;1022             useg = useg->next;
;;;1023           }
;;;1024         }
;;;1025       /* do not queue empty segments on the unacked list */
;;;1026       } else {
;;;1027         tcp_seg_free(seg);
;;;1028       }
;;;1029       seg = pcb->unsent;
;;;1030     }
;;;1031   #if TCP_OVERSIZE
;;;1032     if (pcb->unsent == NULL) {
;;;1033       /* last unsent has been removed, reset unsent_oversize */
;;;1034       pcb->unsent_oversize = 0;
;;;1035     }
;;;1036   #endif /* TCP_OVERSIZE */
;;;1037   
;;;1038     pcb->flags &= ~TF_NAGLEMEMERR;
;;;1039     return ERR_OK;
;;;1040   }
00004c  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.80|
000050  e1d406b0          LDRH     r0,[r4,#0x60]         ;918
000054  e1d414bc          LDRH     r1,[r4,#0x4c]         ;918
000058  e1500001          CMP      r0,r1                 ;918
00005c  aa000001          BGE      |L4.104|
000060  e1d406b0          LDRH     r0,[r4,#0x60]         ;918
000064  ea000000          B        |L4.108|
                  |L4.104|
000068  e1d404bc          LDRH     r0,[r4,#0x4c]         ;918
                  |L4.108|
00006c  e1a09000          MOV      r9,r0                 ;918
000070  e594506c          LDR      r5,[r4,#0x6c]         ;920
000074  e5d4001e          LDRB     r0,[r4,#0x1e]         ;928
000078  e2000002          AND      r0,r0,#2              ;928
00007c  e3500000          CMP      r0,#0                 ;928
000080  0a00000f          BEQ      |L4.196|
000084  e3550000          CMP      r5,#0                 ;929
000088  0a00000a          BEQ      |L4.184|
00008c  e5951010          LDR      r1,[r5,#0x10]         ;930
000090  e2810004          ADD      r0,r1,#4              ;930
000094  ebfffffe          BL       __aeabi_uread4
000098  e1a07000          MOV      r7,r0                 ;930
00009c  ebfffffe          BL       lwip_ntohl
0000a0  e5941048          LDR      r1,[r4,#0x48]         ;930
0000a4  e0400001          SUB      r0,r0,r1              ;930
0000a8  e1d510b8          LDRH     r1,[r5,#8]            ;930
0000ac  e0800001          ADD      r0,r0,r1              ;930
0000b0  e1500009          CMP      r0,r9                 ;930
0000b4  9a000002          BLS      |L4.196|
                  |L4.184|
0000b8  e1a00004          MOV      r0,r4                 ;931
0000bc  ebfffffe          BL       tcp_send_empty_ack
0000c0  eaffffe1          B        |L4.76|
                  |L4.196|
0000c4  e5946070          LDR      r6,[r4,#0x70]         ;935
0000c8  e3560000          CMP      r6,#0                 ;936
0000cc  0a000004          BEQ      |L4.228|
0000d0  ea000000          B        |L4.216|
                  |L4.212|
0000d4  e5966000          LDR      r6,[r6,#0]            ;937
                  |L4.216|
0000d8  e5960000          LDR      r0,[r6,#0]            ;937
0000dc  e3500000          CMP      r0,#0                 ;937
0000e0  1afffffb          BNE      |L4.212|
                  |L4.228|
0000e4  ea0000c7          B        |L4.1032|
                  |L4.232|
0000e8  e1a00000          MOV      r0,r0                 ;964
0000ec  e5952010          LDR      r2,[r5,#0x10]         ;964
0000f0  e5d2100d          LDRB     r1,[r2,#0xd]          ;964
0000f4  e5d2200c          LDRB     r2,[r2,#0xc]          ;964
0000f8  e1820401          ORR      r0,r2,r1,LSL #8       ;964
0000fc  ebfffffe          BL       lwip_ntohs
000100  e2000004          AND      r0,r0,#4              ;964
000104  e3500000          CMP      r0,#0                 ;964
000108  0a000006          BEQ      |L4.296|
00010c  e1a00000          MOV      r0,r0                 ;964
000110  e28f3f6d          ADR      r3,|L4.716|
000114  e3a02ff1          MOV      r2,#0x3c4             ;964
000118  e28f1f89          ADR      r1,|L4.836|
00011c  e28f0f7d          ADR      r0,|L4.792|
000120  ebfffffe          BL       sysprintf
000124  e1a00000          MOV      r0,r0                 ;964
                  |L4.296|
000128  e1a00000          MOV      r0,r0                 ;964
00012c  e5940070          LDR      r0,[r4,#0x70]         ;973
000130  e3500000          CMP      r0,#0                 ;973
000134  0a000015          BEQ      |L4.400|
000138  e5d4001e          LDRB     r0,[r4,#0x1e]         ;973
00013c  e2000044          AND      r0,r0,#0x44           ;973
000140  e3500000          CMP      r0,#0                 ;973
000144  1a000011          BNE      |L4.400|
000148  e594006c          LDR      r0,[r4,#0x6c]         ;973
00014c  e3500000          CMP      r0,#0                 ;973
000150  0a000008          BEQ      |L4.376|
000154  e594006c          LDR      r0,[r4,#0x6c]         ;973
000158  e5900000          LDR      r0,[r0,#0]            ;973
00015c  e3500000          CMP      r0,#0                 ;973
000160  1a00000a          BNE      |L4.400|
000164  e594006c          LDR      r0,[r4,#0x6c]         ;973
000168  e1d000b8          LDRH     r0,[r0,#8]            ;973
00016c  e1d413b6          LDRH     r1,[r4,#0x36]         ;973
000170  e1500001          CMP      r0,r1                 ;973
000174  aa000005          BGE      |L4.400|
                  |L4.376|
000178  e1d406b6          LDRH     r0,[r4,#0x66]         ;973
00017c  e3500000          CMP      r0,#0                 ;973
000180  0a000002          BEQ      |L4.400|
000184  e1d406b8          LDRH     r0,[r4,#0x68]         ;973
000188  e3500008          CMP      r0,#8                 ;973
00018c  ba000001          BLT      |L4.408|
                  |L4.400|
000190  e3a00001          MOV      r0,#1                 ;973
000194  ea000000          B        |L4.412|
                  |L4.408|
000198  e3a00000          MOV      r0,#0                 ;973
                  |L4.412|
00019c  e3500000          CMP      r0,#0                 ;973
0001a0  1a000004          BNE      |L4.440|
0001a4  e5d4001e          LDRB     r0,[r4,#0x1e]         ;974
0001a8  e20000a0          AND      r0,r0,#0xa0           ;974
0001ac  e3500000          CMP      r0,#0                 ;974
0001b0  1a000000          BNE      |L4.440|
0001b4  ea0000a0          B        |L4.1084|
                  |L4.440|
0001b8  e5950000          LDR      r0,[r5,#0]            ;986
0001bc  e584006c          STR      r0,[r4,#0x6c]         ;986
0001c0  e5d40018          LDRB     r0,[r4,#0x18]         ;988
0001c4  e3500002          CMP      r0,#2                 ;988
0001c8  0a00000d          BEQ      |L4.516|
0001cc  e3a00010          MOV      r0,#0x10              ;989
0001d0  ebfffffe          BL       lwip_htons
0001d4  e5952010          LDR      r2,[r5,#0x10]         ;989
0001d8  e5d2100d          LDRB     r1,[r2,#0xd]          ;989
0001dc  e5d2200c          LDRB     r2,[r2,#0xc]          ;989
0001e0  e1821401          ORR      r1,r2,r1,LSL #8       ;989
0001e4  e1800001          ORR      r0,r0,r1              ;989
0001e8  e5951010          LDR      r1,[r5,#0x10]         ;989
0001ec  e5c1000c          STRB     r0,[r1,#0xc]          ;989
0001f0  e1a00420          LSR      r0,r0,#8              ;989
0001f4  e5c1000d          STRB     r0,[r1,#0xd]          ;989
0001f8  e5d4001e          LDRB     r0,[r4,#0x1e]         ;990
0001fc  e3c00003          BIC      r0,r0,#3              ;990
000200  e5c4001e          STRB     r0,[r4,#0x1e]         ;990
                  |L4.516|
000204  e1a01004          MOV      r1,r4                 ;993
000208  e1a00005          MOV      r0,r5                 ;993
00020c  ebfffffe          BL       tcp_output_segment
000210  e5951010          LDR      r1,[r5,#0x10]         ;994
000214  e2810004          ADD      r0,r1,#4              ;994
000218  ebfffffe          BL       __aeabi_uread4
00021c  e1a07000          MOV      r7,r0                 ;994
000220  ebfffffe          BL       lwip_ntohl
000224  e1a0a000          MOV      r10,r0                ;994
000228  e5952010          LDR      r2,[r5,#0x10]         ;994
00022c  e5d2100d          LDRB     r1,[r2,#0xd]          ;994
000230  e5d2200c          LDRB     r2,[r2,#0xc]          ;994
000234  e1820401          ORR      r0,r2,r1,LSL #8       ;994
000238  ebfffffe          BL       lwip_ntohs
00023c  e2000003          AND      r0,r0,#3              ;994
000240  e3500000          CMP      r0,#0                 ;994
000244  0a000001          BEQ      |L4.592|
000248  e3a00001          MOV      r0,#1                 ;994
00024c  ea000000          B        |L4.596|
                  |L4.592|
000250  e3a00000          MOV      r0,#0                 ;994
                  |L4.596|
000254  e1d510b8          LDRH     r1,[r5,#8]            ;994
000258  e0800001          ADD      r0,r0,r1              ;994
00025c  e08a8000          ADD      r8,r10,r0             ;994
000260  e5940050          LDR      r0,[r4,#0x50]         ;995
000264  e0500008          SUBS     r0,r0,r8              ;995
000268  5a000000          BPL      |L4.624|
00026c  e5848050          STR      r8,[r4,#0x50]         ;996
                  |L4.624|
000270  e5951010          LDR      r1,[r5,#0x10]         ;999
000274  e5d1200d          LDRB     r2,[r1,#0xd]          ;999
000278  e5d1100c          LDRB     r1,[r1,#0xc]          ;999
00027c  e1810402          ORR      r0,r1,r2,LSL #8       ;999
000280  ebfffffe          BL       lwip_ntohs
000284  e2000003          AND      r0,r0,#3              ;999
000288  e3500000          CMP      r0,#0                 ;999
00028c  0a000001          BEQ      |L4.664|
000290  e3a00001          MOV      r0,#1                 ;999
000294  ea000000          B        |L4.668|
                  |L4.664|
000298  e3a00000          MOV      r0,#0                 ;999
                  |L4.668|
00029c  e1d510b8          LDRH     r1,[r5,#8]            ;999
0002a0  e0800001          ADD      r0,r0,r1              ;999
0002a4  e3500000          CMP      r0,#0                 ;999
0002a8  da000053          BLE      |L4.1020|
0002ac  e3a00000          MOV      r0,#0                 ;1000
0002b0  e5850000          STR      r0,[r5,#0]            ;1000
0002b4  e5940070          LDR      r0,[r4,#0x70]         ;1002
0002b8  e3500000          CMP      r0,#0                 ;1002
0002bc  1a000026          BNE      |L4.860|
0002c0  e5845070          STR      r5,[r4,#0x70]         ;1003
0002c4  e1a06005          MOV      r6,r5                 ;1004
0002c8  ea00004d          B        |L4.1028|
                  |L4.716|
0002cc  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_out.c",0
0002d0  2d312e34
0002d4  2e315c73
0002d8  72635c63
0002dc  6f72655c
0002e0  7463705f
0002e4  6f75742e
0002e8  6300    
0002ea  00                DCB      0
0002eb  00                DCB      0
                  |L4.748|
                          DCD      0x0000038b
                  |L4.752|
0002f0  646f6e27          DCB      "don't call tcp_output for listen-pcbs",0
0002f4  74206361
0002f8  6c6c2074
0002fc  63705f6f
000300  75747075
000304  7420666f
000308  72206c69
00030c  7374656e
000310  2d706362
000314  7300    
000316  00                DCB      0
000317  00                DCB      0
                  |L4.792|
000318  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00031c  7274696f
000320  6e202225
000324  73222066
000328  61696c65
00032c  64206174
000330  206c696e
000334  65202564
000338  20696e20
00033c  25730a00
                  |L4.832|
                          DCD      tcp_input_pcb
                  |L4.836|
000344  52535420          DCB      "RST not expected here!",0
000348  6e6f7420
00034c  65787065
000350  63746564
000354  20686572
000358  652100  
00035b  00                DCB      0
                  |L4.860|
00035c  e5951010          LDR      r1,[r5,#0x10]         ;1010
000360  e2810004          ADD      r0,r1,#4              ;1010
000364  ebfffffe          BL       __aeabi_uread4
000368  e1a07000          MOV      r7,r0                 ;1010
00036c  ebfffffe          BL       lwip_ntohl
000370  e1a0a000          MOV      r10,r0                ;1010
000374  e5961010          LDR      r1,[r6,#0x10]         ;1010
000378  e2810004          ADD      r0,r1,#4              ;1010
00037c  ebfffffe          BL       __aeabi_uread4
000380  e1a07000          MOV      r7,r0                 ;1010
000384  ebfffffe          BL       lwip_ntohl
000388  e05a0000          SUBS     r0,r10,r0             ;1010
00038c  5a000017          BPL      |L4.1008|
000390  e2847070          ADD      r7,r4,#0x70           ;1012
000394  ea000000          B        |L4.924|
                  |L4.920|
000398  e5977000          LDR      r7,[r7,#0]            ;1015
                  |L4.924|
00039c  e5970000          LDR      r0,[r7,#0]            ;1013
0003a0  e3500000          CMP      r0,#0                 ;1013
0003a4  0a00000d          BEQ      |L4.992|
0003a8  e5971000          LDR      r1,[r7,#0]            ;1014
0003ac  e5911010          LDR      r1,[r1,#0x10]         ;1014
0003b0  e2810004          ADD      r0,r1,#4              ;1014
0003b4  ebfffffe          BL       __aeabi_uread4
0003b8  e1a0a000          MOV      r10,r0                ;1014
0003bc  ebfffffe          BL       lwip_ntohl
0003c0  e1a0b000          MOV      r11,r0                ;1014
0003c4  e5951010          LDR      r1,[r5,#0x10]         ;1014
0003c8  e2810004          ADD      r0,r1,#4              ;1014
0003cc  ebfffffe          BL       __aeabi_uread4
0003d0  e1a0a000          MOV      r10,r0                ;1014
0003d4  ebfffffe          BL       lwip_ntohl
0003d8  e05b0000          SUBS     r0,r11,r0             ;1014
0003dc  4affffed          BMI      |L4.920|
                  |L4.992|
0003e0  e5970000          LDR      r0,[r7,#0]            ;1017
0003e4  e5850000          STR      r0,[r5,#0]            ;1017
0003e8  e5875000          STR      r5,[r7,#0]            ;1018
0003ec  ea000004          B        |L4.1028|
                  |L4.1008|
0003f0  e5865000          STR      r5,[r6,#0]            ;1021
0003f4  e5966000          LDR      r6,[r6,#0]            ;1022
0003f8  ea000001          B        |L4.1028|
                  |L4.1020|
0003fc  e1a00005          MOV      r0,r5                 ;1027
000400  ebfffffe          BL       tcp_seg_free
                  |L4.1028|
000404  e594506c          LDR      r5,[r4,#0x6c]         ;1029
                  |L4.1032|
000408  e3550000          CMP      r5,#0                 ;962
00040c  0a00000a          BEQ      |L4.1084|
000410  e5951010          LDR      r1,[r5,#0x10]         ;963
000414  e2810004          ADD      r0,r1,#4              ;963
000418  ebfffffe          BL       __aeabi_uread4
00041c  e1a07000          MOV      r7,r0                 ;963
000420  ebfffffe          BL       lwip_ntohl
000424  e5941048          LDR      r1,[r4,#0x48]         ;963
000428  e0400001          SUB      r0,r0,r1              ;963
00042c  e1d510b8          LDRH     r1,[r5,#8]            ;963
000430  e0800001          ADD      r0,r0,r1              ;963
000434  e1500009          CMP      r0,r9                 ;963
000438  9affff2a          BLS      |L4.232|
                  |L4.1084|
00043c  e1a00000          MOV      r0,r0                 ;975
000440  e594006c          LDR      r0,[r4,#0x6c]         ;1032
000444  e3500000          CMP      r0,#0                 ;1032
000448  1a000001          BNE      |L4.1108|
00044c  e3a00000          MOV      r0,#0                 ;1034
000450  e1c406ba          STRH     r0,[r4,#0x6a]         ;1034
                  |L4.1108|
000454  e5d4001e          LDRB     r0,[r4,#0x1e]         ;1038
000458  e3c00080          BIC      r0,r0,#0x80           ;1038
00045c  e5c4001e          STRB     r0,[r4,#0x1e]         ;1038
000460  e3a00000          MOV      r0,#0                 ;1039
000464  eafffef8          B        |L4.76|
;;;1041   
                          ENDP


                          AREA ||i.tcp_output_alloc_header||, CODE, READONLY, ALIGN=2

                  tcp_output_alloc_header PROC
;;;93     static struct pbuf *
;;;94     tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;95                           u32_t seqno_be /* already in network byte order */)
;;;96     {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a08002          MOV      r8,r2
000010  e1a09003          MOV      r9,r3
;;;97       struct tcp_hdr *tcphdr;
;;;98       struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
000014  e2860014          ADD      r0,r6,#0x14
000018  e0800008          ADD      r0,r0,r8
00001c  e1a01800          LSL      r1,r0,#16
000020  e1a01821          LSR      r1,r1,#16
000024  e3a02000          MOV      r2,#0
000028  e3a00001          MOV      r0,#1
00002c  ebfffffe          BL       pbuf_alloc
000030  e1a07000          MOV      r7,r0
;;;99       if (p != NULL) {
000034  e3570000          CMP      r7,#0
000038  0a000039          BEQ      |L5.292|
;;;100        LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
00003c  e1a00000          MOV      r0,r0
000040  e1d700ba          LDRH     r0,[r7,#0xa]
000044  e2861014          ADD      r1,r6,#0x14
000048  e1500001          CMP      r0,r1
00004c  aa000006          BGE      |L5.108|
000050  e1a00000          MOV      r0,r0
000054  e28f30d0          ADR      r3,|L5.300|
000058  e3a02064          MOV      r2,#0x64
00005c  e28f10e8          ADR      r1,|L5.332|
000060  e28f0f45          ADR      r0,|L5.380|
000064  ebfffffe          BL       sysprintf
000068  e1a00000          MOV      r0,r0
                  |L5.108|
00006c  e1a00000          MOV      r0,r0
;;;101                     (p->len >= TCP_HLEN + optlen));
;;;102        tcphdr = (struct tcp_hdr *)p->payload;
000070  e5974004          LDR      r4,[r7,#4]
;;;103        tcphdr->src = htons(pcb->local_port);
000074  e1d501ba          LDRH     r0,[r5,#0x1a]
000078  ebfffffe          BL       lwip_htons
00007c  e5c40000          STRB     r0,[r4,#0]
000080  e1a00420          LSR      r0,r0,#8
000084  e5c40001          STRB     r0,[r4,#1]
;;;104        tcphdr->dest = htons(pcb->remote_port);
000088  e1d501bc          LDRH     r0,[r5,#0x1c]
00008c  ebfffffe          BL       lwip_htons
000090  e5c40002          STRB     r0,[r4,#2]
000094  e1a00420          LSR      r0,r0,#8
000098  e5c40003          STRB     r0,[r4,#3]
;;;105        tcphdr->seqno = seqno_be;
00009c  e2841004          ADD      r1,r4,#4
0000a0  e1a00009          MOV      r0,r9
0000a4  ebfffffe          BL       __aeabi_uwrite4
;;;106        tcphdr->ackno = htonl(pcb->rcv_nxt);
0000a8  e5950028          LDR      r0,[r5,#0x28]
0000ac  ebfffffe          BL       lwip_htonl
0000b0  e1a0a000          MOV      r10,r0
0000b4  e2841008          ADD      r1,r4,#8
0000b8  ebfffffe          BL       __aeabi_uwrite4
;;;107        TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
0000bc  e1a01fc6          ASR      r1,r6,#31
0000c0  e0861f21          ADD      r1,r6,r1,LSR #30
0000c4  e1a01141          ASR      r1,r1,#2
0000c8  e2811005          ADD      r1,r1,#5
0000cc  e3a02010          MOV      r2,#0x10
0000d0  e1821601          ORR      r1,r2,r1,LSL #12
0000d4  e1a00801          LSL      r0,r1,#16
0000d8  e1a00820          LSR      r0,r0,#16
0000dc  ebfffffe          BL       lwip_htons
0000e0  e5c4000c          STRB     r0,[r4,#0xc]
0000e4  e1a00420          LSR      r0,r0,#8
0000e8  e5c4000d          STRB     r0,[r4,#0xd]
;;;108        tcphdr->wnd = htons(pcb->rcv_ann_wnd);
0000ec  e1d502be          LDRH     r0,[r5,#0x2e]
0000f0  ebfffffe          BL       lwip_htons
0000f4  e5c4000e          STRB     r0,[r4,#0xe]
0000f8  e1a00420          LSR      r0,r0,#8
0000fc  e5c4000f          STRB     r0,[r4,#0xf]
;;;109        tcphdr->chksum = 0;
000100  e3a00000          MOV      r0,#0
000104  e5c40010          STRB     r0,[r4,#0x10]
000108  e5c40011          STRB     r0,[r4,#0x11]
;;;110        tcphdr->urgp = 0;
00010c  e5c40012          STRB     r0,[r4,#0x12]
000110  e5c40013          STRB     r0,[r4,#0x13]
;;;111    
;;;112        /* If we're sending a packet, update the announced right window edge */
;;;113        pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
000114  e5950028          LDR      r0,[r5,#0x28]
000118  e1d512be          LDRH     r1,[r5,#0x2e]
00011c  e0800001          ADD      r0,r0,r1
000120  e5850030          STR      r0,[r5,#0x30]
                  |L5.292|
;;;114      }
;;;115      return p;
000124  e1a00007          MOV      r0,r7
;;;116    }
000128  e8bd87f0          POP      {r4-r10,pc}
;;;117    
                          ENDP

                  |L5.300|
00012c  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_out.c",0
000130  2d312e34
000134  2e315c73
000138  72635c63
00013c  6f72655c
000140  7463705f
000144  6f75742e
000148  6300    
00014a  00                DCB      0
00014b  00                DCB      0
                  |L5.332|
00014c  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
000150  6b207468
000154  61742066
000158  69727374
00015c  20706275
000160  66206361
000164  6e20686f
000168  6c642073
00016c  74727563
000170  74207463
000174  705f6864
000178  7200    
00017a  00                DCB      0
00017b  00                DCB      0
                  |L5.380|
00017c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000180  7274696f
000184  6e202225
000188  73222066
00018c  61696c65
000190  64206174
000194  206c696e
000198  65202564
00019c  20696e20
0001a0  25730a00

                          AREA ||i.tcp_output_segment||, CODE, READONLY, ALIGN=2

                  tcp_output_segment PROC
;;;1048   static void
;;;1049   tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1050   {
000004  e1a05000          MOV      r5,r0
000008  e1a04001          MOV      r4,r1
;;;1051     u16_t len;
;;;1052     struct netif *netif;
;;;1053     u32_t *opts;
;;;1054   
;;;1055     /** @bug Exclude retransmitted segments from this count. */
;;;1056     snmp_inc_tcpoutsegs();
;;;1057   
;;;1058     /* The TCP header has already been constructed, but the ackno and
;;;1059      wnd fields remain. */
;;;1060     seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
00000c  e5940028          LDR      r0,[r4,#0x28]
000010  ebfffffe          BL       lwip_htonl
000014  e1a09000          MOV      r9,r0
000018  e5950010          LDR      r0,[r5,#0x10]
00001c  e2801008          ADD      r1,r0,#8
000020  e1a00009          MOV      r0,r9
000024  ebfffffe          BL       __aeabi_uwrite4
;;;1061   
;;;1062     /* advertise our receive window size in this TCP segment */
;;;1063     seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
000028  e1d402be          LDRH     r0,[r4,#0x2e]
00002c  ebfffffe          BL       lwip_htons
000030  e5951010          LDR      r1,[r5,#0x10]
000034  e5c1000e          STRB     r0,[r1,#0xe]
000038  e1a00420          LSR      r0,r0,#8
00003c  e5c1000f          STRB     r0,[r1,#0xf]
;;;1064   
;;;1065     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
000040  e5940028          LDR      r0,[r4,#0x28]
000044  e1d412be          LDRH     r1,[r4,#0x2e]
000048  e0800001          ADD      r0,r0,r1
00004c  e5840030          STR      r0,[r4,#0x30]
;;;1066   
;;;1067     /* Add any requested options.  NB MSS option is only set on SYN
;;;1068        packets, so ignore it here */
;;;1069     opts = (u32_t *)(void *)(seg->tcphdr + 1);
000050  e5950010          LDR      r0,[r5,#0x10]
000054  e2808014          ADD      r8,r0,#0x14
;;;1070     if (seg->flags & TF_SEG_OPTS_MSS) {
000058  e5d5000c          LDRB     r0,[r5,#0xc]
00005c  e2000001          AND      r0,r0,#1
000060  e3500000          CMP      r0,#0
000064  0a000008          BEQ      |L6.140|
;;;1071       u16_t mss;
;;;1072   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1073       mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
000068  e2841004          ADD      r1,r4,#4
00006c  e3a00ffa          MOV      r0,#0x3e8
000070  ebfffffe          BL       tcp_eff_send_mss
000074  e1a09000          MOV      r9,r0
;;;1074   #else /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1075       mss = TCP_MSS;
;;;1076   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1077       *opts = TCP_BUILD_MSS_OPTION(mss);
000078  e3890781          ORR      r0,r9,#0x2040000
00007c  ebfffffe          BL       lwip_htonl
000080  e5880000          STR      r0,[r8,#0]
;;;1078       opts += 1;
000084  e2888004          ADD      r8,r8,#4
;;;1079     }
000088  e1a00000          MOV      r0,r0
                  |L6.140|
;;;1080   #if LWIP_TCP_TIMESTAMPS
;;;1081     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;1082   
;;;1083     if (seg->flags & TF_SEG_OPTS_TS) {
;;;1084       tcp_build_timestamp_option(pcb, opts);
;;;1085       opts += 3;
;;;1086     }
;;;1087   #endif
;;;1088   
;;;1089     /* Set retransmission timer running if it is not currently enabled 
;;;1090        This must be set before checking the route. */
;;;1091     if (pcb->rtime == -1) {
00008c  e1d403f4          LDRSH    r0,[r4,#0x34]
000090  e3700001          CMN      r0,#1
000094  1a000001          BNE      |L6.160|
;;;1092       pcb->rtime = 0;
000098  e3a00000          MOV      r0,#0
00009c  e1c403b4          STRH     r0,[r4,#0x34]
                  |L6.160|
;;;1093     }
;;;1094   
;;;1095     /* If we don't have a local IP address, we get one by
;;;1096        calling ip_route(). */
;;;1097     if (ip_addr_isany(&(pcb->local_ip))) {
0000a0  e3540000          CMP      r4,#0
0000a4  0a000002          BEQ      |L6.180|
0000a8  e5940000          LDR      r0,[r4,#0]
0000ac  e3500000          CMP      r0,#0
0000b0  1a000007          BNE      |L6.212|
                  |L6.180|
;;;1098       netif = ip_route(&(pcb->remote_ip));
0000b4  e2840004          ADD      r0,r4,#4
0000b8  ebfffffe          BL       ip_route
0000bc  e1a07000          MOV      r7,r0
;;;1099       if (netif == NULL) {
0000c0  e3570000          CMP      r7,#0
0000c4  1a000000          BNE      |L6.204|
                  |L6.200|
;;;1100         return;
;;;1101       }
;;;1102       ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;1103     }
;;;1104   
;;;1105     if (pcb->rttest == 0) {
;;;1106       pcb->rttest = tcp_ticks;
;;;1107       pcb->rtseq = ntohl(seg->tcphdr->seqno);
;;;1108   
;;;1109       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
;;;1110     }
;;;1111     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
;;;1112             htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
;;;1113             seg->len));
;;;1114   
;;;1115     len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
;;;1116   
;;;1117     seg->p->len -= len;
;;;1118     seg->p->tot_len -= len;
;;;1119   
;;;1120     seg->p->payload = seg->tcphdr;
;;;1121   
;;;1122     seg->tcphdr->chksum = 0;
;;;1123   #if CHECKSUM_GEN_TCP
;;;1124   #if TCP_CHECKSUM_ON_COPY
;;;1125     {
;;;1126       u32_t acc;
;;;1127   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1128       u16_t chksum_slow = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1129              &(pcb->remote_ip),
;;;1130              IP_PROTO_TCP, seg->p->tot_len);
;;;1131   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1132       if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
;;;1133         LWIP_ASSERT("data included but not checksummed",
;;;1134           seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
;;;1135       }
;;;1136   
;;;1137       /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
;;;1138       acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
;;;1139                &(pcb->remote_ip),
;;;1140                IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
;;;1141       /* add payload checksum */
;;;1142       if (seg->chksum_swapped) {
;;;1143         seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1144         seg->chksum_swapped = 0;
;;;1145       }
;;;1146       acc += (u16_t)~(seg->chksum);
;;;1147       seg->tcphdr->chksum = FOLD_U32T(acc);
;;;1148   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1149       if (chksum_slow != seg->tcphdr->chksum) {
;;;1150         LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1151                     ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
;;;1152                     seg->tcphdr->chksum, chksum_slow));
;;;1153         seg->tcphdr->chksum = chksum_slow;
;;;1154       }
;;;1155   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1156     }
;;;1157   #else /* TCP_CHECKSUM_ON_COPY */
;;;1158     seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1159            &(pcb->remote_ip),
;;;1160            IP_PROTO_TCP, seg->p->tot_len);
;;;1161   #endif /* TCP_CHECKSUM_ON_COPY */
;;;1162   #endif /* CHECKSUM_GEN_TCP */
;;;1163     TCP_STATS_INC(tcp.xmit);
;;;1164   
;;;1165   #if LWIP_NETIF_HWADDRHINT
;;;1166     ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1167         IP_PROTO_TCP, &(pcb->addr_hint));
;;;1168   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1169     ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1170         IP_PROTO_TCP);
;;;1171   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1172   }
0000c8  e8bd87fc          POP      {r2-r10,pc}
                  |L6.204|
0000cc  e5970004          LDR      r0,[r7,#4]            ;1102
0000d0  e5840000          STR      r0,[r4,#0]            ;1102
                  |L6.212|
0000d4  e5940038          LDR      r0,[r4,#0x38]         ;1105
0000d8  e3500000          CMP      r0,#0                 ;1105
0000dc  1a000008          BNE      |L6.260|
0000e0  e59f00c8          LDR      r0,|L6.432|
0000e4  e5900000          LDR      r0,[r0,#0]            ;1106  ; tcp_ticks
0000e8  e5840038          STR      r0,[r4,#0x38]         ;1106
0000ec  e5951010          LDR      r1,[r5,#0x10]         ;1107
0000f0  e2810004          ADD      r0,r1,#4              ;1107
0000f4  ebfffffe          BL       __aeabi_uread4
0000f8  e1a09000          MOV      r9,r0                 ;1107
0000fc  ebfffffe          BL       lwip_ntohl
000100  e584003c          STR      r0,[r4,#0x3c]         ;1107
                  |L6.260|
000104  e1d501b0          LDRH     r0,[r5,#0x10]         ;1115
000108  e5951004          LDR      r1,[r5,#4]            ;1115
00010c  e1d110b4          LDRH     r1,[r1,#4]            ;1115
000110  e0406001          SUB      r6,r0,r1              ;1115
000114  e5950004          LDR      r0,[r5,#4]            ;1117
000118  e1d000ba          LDRH     r0,[r0,#0xa]          ;1117
00011c  e0400006          SUB      r0,r0,r6              ;1117
000120  e5951004          LDR      r1,[r5,#4]            ;1117
000124  e1c100ba          STRH     r0,[r1,#0xa]          ;1117
000128  e5950004          LDR      r0,[r5,#4]            ;1118
00012c  e1d000b8          LDRH     r0,[r0,#8]            ;1118
000130  e0400006          SUB      r0,r0,r6              ;1118
000134  e5951004          LDR      r1,[r5,#4]            ;1118
000138  e1c100b8          STRH     r0,[r1,#8]            ;1118
00013c  e5950010          LDR      r0,[r5,#0x10]         ;1120
000140  e5951004          LDR      r1,[r5,#4]            ;1120
000144  e5810004          STR      r0,[r1,#4]            ;1120
000148  e3a00000          MOV      r0,#0                 ;1122
00014c  e5951010          LDR      r1,[r5,#0x10]         ;1122
000150  e5c10010          STRB     r0,[r1,#0x10]         ;1122
000154  e5c10011          STRB     r0,[r1,#0x11]         ;1122
000158  e5950004          LDR      r0,[r5,#4]            ;1158
00015c  e1d000b8          LDRH     r0,[r0,#8]            ;1158
000160  e58d0000          STR      r0,[sp,#0]            ;1158
000164  e3a03006          MOV      r3,#6                 ;1158
000168  e2842004          ADD      r2,r4,#4              ;1158
00016c  e1a01004          MOV      r1,r4                 ;1158
000170  e5950004          LDR      r0,[r5,#4]            ;1158
000174  ebfffffe          BL       inet_chksum_pseudo
000178  e5951010          LDR      r1,[r5,#0x10]         ;1158
00017c  e5c10010          STRB     r0,[r1,#0x10]         ;1158
000180  e1a00420          LSR      r0,r0,#8              ;1158
000184  e5c10011          STRB     r0,[r1,#0x11]         ;1158
000188  e3a01006          MOV      r1,#6                 ;1169
00018c  e5d40009          LDRB     r0,[r4,#9]            ;1169
000190  e1cd00f0          STRD     r0,r1,[sp,#0]         ;1169
000194  e5d4300a          LDRB     r3,[r4,#0xa]          ;1169
000198  e2842004          ADD      r2,r4,#4              ;1169
00019c  e1a01004          MOV      r1,r4                 ;1169
0001a0  e5950004          LDR      r0,[r5,#4]            ;1169
0001a4  ebfffffe          BL       ip_output
0001a8  e1a00000          MOV      r0,r0
0001ac  eaffffc5          B        |L6.200|
;;;1173   
                          ENDP

                  |L6.432|
                          DCD      tcp_ticks

                          AREA ||i.tcp_pbuf_prealloc||, CODE, READONLY, ALIGN=2

                  tcp_pbuf_prealloc PROC
;;;218    static struct pbuf *
;;;219    tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;220                      u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
;;;221                      u8_t first_seg)
;;;222    {
000004  e1a04001          MOV      r4,r1
000008  e1a06002          MOV      r6,r2
00000c  e1a08003          MOV      r8,r3
000010  e28db038          ADD      r11,sp,#0x38
000014  e89b0c80          LDM      r11,{r7,r10,r11}
;;;223      struct pbuf *p;
;;;224      u16_t alloc = length;
000018  e1a09004          MOV      r9,r4
;;;225    
;;;226    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;227      LWIP_UNUSED_ARG(max_length);
;;;228      LWIP_UNUSED_ARG(pcb);
;;;229      LWIP_UNUSED_ARG(apiflags);
;;;230      LWIP_UNUSED_ARG(first_seg);
;;;231      /* always create MSS-sized pbufs */
;;;232      alloc = max_length;
;;;233    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;234      if (length < max_length) {
00001c  e1540006          CMP      r4,r6
000020  aa00001a          BGE      |L7.144|
;;;235        /* Should we allocate an oversized pbuf, or just the minimum
;;;236         * length required? If tcp_write is going to be called again
;;;237         * before this segment is transmitted, we want the oversized
;;;238         * buffer. If the segment will be transmitted immediately, we can
;;;239         * save memory by allocating only length. We use a simple
;;;240         * heuristic based on the following information:
;;;241         *
;;;242         * Did the user set TCP_WRITE_FLAG_MORE?
;;;243         *
;;;244         * Will the Nagle algorithm defer transmission of this segment?
;;;245         */
;;;246        if ((apiflags & TCP_WRITE_FLAG_MORE) ||
000024  e20a0002          AND      r0,r10,#2
000028  e3500000          CMP      r0,#0
00002c  1a00000b          BNE      |L7.96|
;;;247            (!(pcb->flags & TF_NODELAY) &&
000030  e5d7001e          LDRB     r0,[r7,#0x1e]
000034  e2000040          AND      r0,r0,#0x40
000038  e3500000          CMP      r0,#0
00003c  1a000013          BNE      |L7.144|
;;;248             (!first_seg ||
000040  e35b0000          CMP      r11,#0
000044  0a000005          BEQ      |L7.96|
;;;249              pcb->unsent != NULL ||
000048  e597006c          LDR      r0,[r7,#0x6c]
00004c  e3500000          CMP      r0,#0
000050  1a000002          BNE      |L7.96|
;;;250              pcb->unacked != NULL))) {
000054  e5970070          LDR      r0,[r7,#0x70]
000058  e3500000          CMP      r0,#0
00005c  0a00000b          BEQ      |L7.144|
                  |L7.96|
;;;251          alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
000060  e2840c03          ADD      r0,r4,#0x300
000064  e28000eb          ADD      r0,r0,#0xeb
000068  e3c00003          BIC      r0,r0,#3
00006c  e1500006          CMP      r0,r6
000070  da000001          BLE      |L7.124|
000074  e1a00006          MOV      r0,r6
000078  ea000002          B        |L7.136|
                  |L7.124|
00007c  e2840c03          ADD      r0,r4,#0x300
000080  e28000eb          ADD      r0,r0,#0xeb
000084  e3c00003          BIC      r0,r0,#3
                  |L7.136|
000088  e1a09800          LSL      r9,r0,#16
00008c  e1a09829          LSR      r9,r9,#16
                  |L7.144|
;;;252        }
;;;253      }
;;;254    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;255      p = pbuf_alloc(layer, alloc, PBUF_RAM);
000090  e3a02000          MOV      r2,#0
000094  e1a01009          MOV      r1,r9
000098  e59d0000          LDR      r0,[sp,#0]
00009c  ebfffffe          BL       pbuf_alloc
0000a0  e1a05000          MOV      r5,r0
;;;256      if (p == NULL) {
0000a4  e3550000          CMP      r5,#0
0000a8  1a000002          BNE      |L7.184|
;;;257        return NULL;
0000ac  e3a00000          MOV      r0,#0
                  |L7.176|
0000b0  e28dd010          ADD      sp,sp,#0x10
;;;258      }
;;;259      LWIP_ASSERT("need unchained pbuf", p->next == NULL);
;;;260      *oversize = p->len - length;
;;;261      /* trim p->len to the currently used size */
;;;262      p->len = p->tot_len = length;
;;;263      return p;
;;;264    }
0000b4  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.184|
0000b8  e1a00000          MOV      r0,r0                 ;259
0000bc  e5950000          LDR      r0,[r5,#0]            ;259
0000c0  e3500000          CMP      r0,#0                 ;259
0000c4  0a000006          BEQ      |L7.228|
0000c8  e1a00000          MOV      r0,r0                 ;259
0000cc  e28f3030          ADR      r3,|L7.260|
0000d0  e59f204c          LDR      r2,|L7.292|
0000d4  e28f104c          ADR      r1,|L7.296|
0000d8  e28f005c          ADR      r0,|L7.316|
0000dc  ebfffffe          BL       sysprintf
0000e0  e1a00000          MOV      r0,r0                 ;259
                  |L7.228|
0000e4  e1a00000          MOV      r0,r0                 ;259
0000e8  e1d500ba          LDRH     r0,[r5,#0xa]          ;260
0000ec  e0400004          SUB      r0,r0,r4              ;260
0000f0  e1c800b0          STRH     r0,[r8,#0]            ;260
0000f4  e1c540b8          STRH     r4,[r5,#8]            ;262
0000f8  e1c540ba          STRH     r4,[r5,#0xa]          ;262
0000fc  e1a00005          MOV      r0,r5                 ;263
000100  eaffffea          B        |L7.176|
;;;265    #else /* TCP_OVERSIZE */
                          ENDP

                  |L7.260|
000104  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_out.c",0
000108  2d312e34
00010c  2e315c73
000110  72635c63
000114  6f72655c
000118  7463705f
00011c  6f75742e
000120  6300    
000122  00                DCB      0
000123  00                DCB      0
                  |L7.292|
                          DCD      0x00000103
                  |L7.296|
000128  6e656564          DCB      "need unchained pbuf",0
00012c  20756e63
000130  6861696e
000134  65642070
000138  62756600
                  |L7.316|
00013c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000140  7274696f
000144  6e202225
000148  73222066
00014c  61696c65
000150  64206174
000154  206c696e
000158  65202564
00015c  20696e20
000160  25730a00

                          AREA ||i.tcp_rexmit||, CODE, READONLY, ALIGN=2

                  tcp_rexmit PROC
;;;1274   void
;;;1275   tcp_rexmit(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1276   {
000004  e1a04000          MOV      r4,r0
;;;1277     struct tcp_seg *seg;
;;;1278     struct tcp_seg **cur_seg;
;;;1279   
;;;1280     if (pcb->unacked == NULL) {
000008  e5940070          LDR      r0,[r4,#0x70]
00000c  e3500000          CMP      r0,#0
000010  1a000000          BNE      |L8.24|
                  |L8.20|
;;;1281       return;
;;;1282     }
;;;1283   
;;;1284     /* Move the first unacked segment to the unsent queue */
;;;1285     /* Keep the unsent queue sorted. */
;;;1286     seg = pcb->unacked;
;;;1287     pcb->unacked = seg->next;
;;;1288   
;;;1289     cur_seg = &(pcb->unsent);
;;;1290     while (*cur_seg &&
;;;1291       TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1292         cur_seg = &((*cur_seg)->next );
;;;1293     }
;;;1294     seg->next = *cur_seg;
;;;1295     *cur_seg = seg;
;;;1296   #if TCP_OVERSIZE
;;;1297     if (seg->next == NULL) {
;;;1298       /* the retransmitted segment is last in unsent, so reset unsent_oversize */
;;;1299       pcb->unsent_oversize = 0;
;;;1300     }
;;;1301   #endif /* TCP_OVERSIZE */
;;;1302   
;;;1303     ++pcb->nrtx;
;;;1304   
;;;1305     /* Don't take any rtt measurements after retransmitting. */
;;;1306     pcb->rttest = 0;
;;;1307   
;;;1308     /* Do the actual retransmission. */
;;;1309     snmp_inc_tcpretranssegs();
;;;1310     /* No need to call tcp_output: we are always called from tcp_input()
;;;1311        and thus tcp_output directly returns. */
;;;1312   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L8.24|
000018  e5945070          LDR      r5,[r4,#0x70]         ;1286
00001c  e5950000          LDR      r0,[r5,#0]            ;1287
000020  e5840070          STR      r0,[r4,#0x70]         ;1287
000024  e284606c          ADD      r6,r4,#0x6c           ;1289
000028  ea000000          B        |L8.48|
                  |L8.44|
00002c  e5966000          LDR      r6,[r6,#0]            ;1292
                  |L8.48|
000030  e5960000          LDR      r0,[r6,#0]            ;1290
000034  e3500000          CMP      r0,#0                 ;1290
000038  0a00000d          BEQ      |L8.116|
00003c  e5961000          LDR      r1,[r6,#0]            ;1291
000040  e5911010          LDR      r1,[r1,#0x10]         ;1291
000044  e2810004          ADD      r0,r1,#4              ;1291
000048  ebfffffe          BL       __aeabi_uread4
00004c  e1a07000          MOV      r7,r0                 ;1291
000050  ebfffffe          BL       lwip_ntohl
000054  e1a08000          MOV      r8,r0                 ;1291
000058  e5951010          LDR      r1,[r5,#0x10]         ;1291
00005c  e2810004          ADD      r0,r1,#4              ;1291
000060  ebfffffe          BL       __aeabi_uread4
000064  e1a07000          MOV      r7,r0                 ;1291
000068  ebfffffe          BL       lwip_ntohl
00006c  e0580000          SUBS     r0,r8,r0              ;1291
000070  4affffed          BMI      |L8.44|
                  |L8.116|
000074  e5960000          LDR      r0,[r6,#0]            ;1294
000078  e5850000          STR      r0,[r5,#0]            ;1294
00007c  e5865000          STR      r5,[r6,#0]            ;1295
000080  e5950000          LDR      r0,[r5,#0]            ;1297
000084  e3500000          CMP      r0,#0                 ;1297
000088  1a000001          BNE      |L8.148|
00008c  e3a00000          MOV      r0,#0                 ;1299
000090  e1c406ba          STRH     r0,[r4,#0x6a]         ;1299
                  |L8.148|
000094  e5d40046          LDRB     r0,[r4,#0x46]         ;1303
000098  e2800001          ADD      r0,r0,#1              ;1303
00009c  e5c40046          STRB     r0,[r4,#0x46]         ;1303
0000a0  e3a00000          MOV      r0,#0                 ;1306
0000a4  e5840038          STR      r0,[r4,#0x38]         ;1306
0000a8  e1a00000          MOV      r0,r0
0000ac  eaffffd8          B        |L8.20|
;;;1313   
                          ENDP


                          AREA ||i.tcp_rexmit_fast||, CODE, READONLY, ALIGN=2

                  tcp_rexmit_fast PROC
;;;1320   void 
;;;1321   tcp_rexmit_fast(struct tcp_pcb *pcb)
000000  e92d4010          PUSH     {r4,lr}
;;;1322   {
000004  e1a04000          MOV      r4,r0
;;;1323     if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
000008  e5940070          LDR      r0,[r4,#0x70]
00000c  e3500000          CMP      r0,#0
000010  0a000024          BEQ      |L9.168|
000014  e5d4001e          LDRB     r0,[r4,#0x1e]
000018  e2000004          AND      r0,r0,#4
00001c  e3500000          CMP      r0,#0
000020  1a000020          BNE      |L9.168|
;;;1324       /* This is fast retransmit. Retransmit the first unacked segment. */
;;;1325       LWIP_DEBUGF(TCP_FR_DEBUG, 
;;;1326                   ("tcp_receive: dupacks %"U16_F" (%"U32_F
;;;1327                    "), fast retransmit %"U32_F"\n",
;;;1328                    (u16_t)pcb->dupacks, pcb->lastack,
;;;1329                    ntohl(pcb->unacked->tcphdr->seqno)));
;;;1330       tcp_rexmit(pcb);
000024  e1a00004          MOV      r0,r4
000028  ebfffffe          BL       tcp_rexmit
;;;1331   
;;;1332       /* Set ssthresh to half of the minimum of the current
;;;1333        * cwnd and the advertised window */
;;;1334       if (pcb->cwnd > pcb->snd_wnd) {
00002c  e1d404bc          LDRH     r0,[r4,#0x4c]
000030  e1d416b0          LDRH     r1,[r4,#0x60]
000034  e1500001          CMP      r0,r1
000038  da000004          BLE      |L9.80|
;;;1335         pcb->ssthresh = pcb->snd_wnd / 2;
00003c  e1d406b0          LDRH     r0,[r4,#0x60]
000040  e0801fa0          ADD      r1,r0,r0,LSR #31
000044  e1a010c1          ASR      r1,r1,#1
000048  e1c414be          STRH     r1,[r4,#0x4e]
00004c  ea000003          B        |L9.96|
                  |L9.80|
;;;1336       } else {
;;;1337         pcb->ssthresh = pcb->cwnd / 2;
000050  e1d404bc          LDRH     r0,[r4,#0x4c]
000054  e0801fa0          ADD      r1,r0,r0,LSR #31
000058  e1a010c1          ASR      r1,r1,#1
00005c  e1c414be          STRH     r1,[r4,#0x4e]
                  |L9.96|
;;;1338       }
;;;1339       
;;;1340       /* The minimum value for ssthresh should be 2 MSS */
;;;1341       if (pcb->ssthresh < 2*pcb->mss) {
000060  e1d404be          LDRH     r0,[r4,#0x4e]
000064  e1d413b6          LDRH     r1,[r4,#0x36]
000068  e1a01081          LSL      r1,r1,#1
00006c  e1500001          CMP      r0,r1
000070  aa000003          BGE      |L9.132|
;;;1342         LWIP_DEBUGF(TCP_FR_DEBUG, 
;;;1343                     ("tcp_receive: The minimum value for ssthresh %"U16_F
;;;1344                      " should be min 2 mss %"U16_F"...\n",
;;;1345                      pcb->ssthresh, 2*pcb->mss));
;;;1346         pcb->ssthresh = 2*pcb->mss;
000074  e1d403b6          LDRH     r0,[r4,#0x36]
000078  e1a00080          LSL      r0,r0,#1
00007c  e3c00801          BIC      r0,r0,#0x10000
000080  e1c404be          STRH     r0,[r4,#0x4e]
                  |L9.132|
;;;1347       }
;;;1348       
;;;1349       pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
000084  e1d404be          LDRH     r0,[r4,#0x4e]
000088  e1d413b6          LDRH     r1,[r4,#0x36]
00008c  e3a02003          MOV      r2,#3
000090  e0200192          MLA      r0,r2,r1,r0
000094  e3c00807          BIC      r0,r0,#0x70000
000098  e1c404bc          STRH     r0,[r4,#0x4c]
;;;1350       pcb->flags |= TF_INFR;
00009c  e5d4001e          LDRB     r0,[r4,#0x1e]
0000a0  e3800004          ORR      r0,r0,#4
0000a4  e5c4001e          STRB     r0,[r4,#0x1e]
                  |L9.168|
;;;1351     } 
;;;1352   }
0000a8  e8bd8010          POP      {r4,pc}
;;;1353   
                          ENDP


                          AREA ||i.tcp_rexmit_rto||, CODE, READONLY, ALIGN=2

                  tcp_rexmit_rto PROC
;;;1238   void
;;;1239   tcp_rexmit_rto(struct tcp_pcb *pcb)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1240   {
000004  e1a04000          MOV      r4,r0
;;;1241     struct tcp_seg *seg;
;;;1242   
;;;1243     if (pcb->unacked == NULL) {
000008  e5940070          LDR      r0,[r4,#0x70]
00000c  e3500000          CMP      r0,#0
000010  1a000000          BNE      |L10.24|
                  |L10.20|
;;;1244       return;
;;;1245     }
;;;1246   
;;;1247     /* Move all unacked segments to the head of the unsent queue */
;;;1248     for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
;;;1249     /* concatenate unsent queue after unacked queue */
;;;1250     seg->next = pcb->unsent;
;;;1251     /* unsent queue is the concatenated queue (of unacked, unsent) */
;;;1252     pcb->unsent = pcb->unacked;
;;;1253     /* unacked queue is now empty */
;;;1254     pcb->unacked = NULL;
;;;1255     /* last unsent hasn't changed, no need to reset unsent_oversize */
;;;1256   
;;;1257     /* increment number of retransmissions */
;;;1258     ++pcb->nrtx;
;;;1259   
;;;1260     /* Don't take any RTT measurements after retransmitting. */
;;;1261     pcb->rttest = 0;
;;;1262   
;;;1263     /* Do the actual retransmission */
;;;1264     tcp_output(pcb);
;;;1265   }
000014  e8bd8070          POP      {r4-r6,pc}
                  |L10.24|
000018  e5945070          LDR      r5,[r4,#0x70]         ;1248
00001c  ea000000          B        |L10.36|
                  |L10.32|
000020  e5955000          LDR      r5,[r5,#0]            ;1248
                  |L10.36|
000024  e5950000          LDR      r0,[r5,#0]            ;1248
000028  e3500000          CMP      r0,#0                 ;1248
00002c  1afffffb          BNE      |L10.32|
000030  e594006c          LDR      r0,[r4,#0x6c]         ;1250
000034  e5850000          STR      r0,[r5,#0]            ;1250
000038  e5940070          LDR      r0,[r4,#0x70]         ;1252
00003c  e584006c          STR      r0,[r4,#0x6c]         ;1252
000040  e3a00000          MOV      r0,#0                 ;1254
000044  e5840070          STR      r0,[r4,#0x70]         ;1254
000048  e5d40046          LDRB     r0,[r4,#0x46]         ;1258
00004c  e2800001          ADD      r0,r0,#1              ;1258
000050  e5c40046          STRB     r0,[r4,#0x46]         ;1258
000054  e3a00000          MOV      r0,#0                 ;1261
000058  e5840038          STR      r0,[r4,#0x38]         ;1261
00005c  e1a00004          MOV      r0,r4                 ;1264
000060  ebfffffe          BL       tcp_output
000064  e1a00000          MOV      r0,r0
000068  eaffffe9          B        |L10.20|
;;;1266   
                          ENDP


                          AREA ||i.tcp_rst||, CODE, READONLY, ALIGN=2

                  tcp_rst PROC
;;;1194   void
;;;1195   tcp_rst(u32_t seqno, u32_t ackno,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1196     ip_addr_t *local_ip, ip_addr_t *remote_ip,
;;;1197     u16_t local_port, u16_t remote_port)
;;;1198   {
000004  e1a09000          MOV      r9,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a07002          MOV      r7,r2
000010  e1a08003          MOV      r8,r3
000014  e1cda3d0          LDRD     r10,r11,[sp,#0x30]
;;;1199     struct pbuf *p;
;;;1200     struct tcp_hdr *tcphdr;
;;;1201     p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
000018  e3a02000          MOV      r2,#0
00001c  e3a01014          MOV      r1,#0x14
000020  e3a00001          MOV      r0,#1
000024  ebfffffe          BL       pbuf_alloc
000028  e1a05000          MOV      r5,r0
;;;1202     if (p == NULL) {
00002c  e3550000          CMP      r5,#0
000030  1a000000          BNE      |L11.56|
                  |L11.52|
;;;1203         LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
;;;1204         return;
;;;1205     }
;;;1206     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
;;;1207                 (p->len >= sizeof(struct tcp_hdr)));
;;;1208   
;;;1209     tcphdr = (struct tcp_hdr *)p->payload;
;;;1210     tcphdr->src = htons(local_port);
;;;1211     tcphdr->dest = htons(remote_port);
;;;1212     tcphdr->seqno = htonl(seqno);
;;;1213     tcphdr->ackno = htonl(ackno);
;;;1214     TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
;;;1215     tcphdr->wnd = PP_HTONS(TCP_WND);
;;;1216     tcphdr->chksum = 0;
;;;1217     tcphdr->urgp = 0;
;;;1218   
;;;1219   #if CHECKSUM_GEN_TCP
;;;1220     tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
;;;1221                 IP_PROTO_TCP, p->tot_len);
;;;1222   #endif
;;;1223     TCP_STATS_INC(tcp.xmit);
;;;1224     snmp_inc_tcpoutrsts();
;;;1225      /* Send output with hardcoded TTL since we have no access to the pcb */
;;;1226     ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
;;;1227     pbuf_free(p);
;;;1228     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
;;;1229   }
000034  e8bd9ffc          POP      {r2-r12,pc}
                  |L11.56|
000038  e1a00000          MOV      r0,r0                 ;1206
00003c  e1d500ba          LDRH     r0,[r5,#0xa]          ;1206
000040  e3500014          CMP      r0,#0x14              ;1206
000044  2a000006          BCS      |L11.100|
000048  e1a00000          MOV      r0,r0                 ;1206
00004c  e28f30fc          ADR      r3,|L11.336|
000050  e59f2118          LDR      r2,|L11.368|
000054  e28f1f46          ADR      r1,|L11.372|
000058  e28f0f51          ADR      r0,|L11.420|
00005c  ebfffffe          BL       sysprintf
000060  e1a00000          MOV      r0,r0                 ;1206
                  |L11.100|
000064  e1a00000          MOV      r0,r0                 ;1206
000068  e5954004          LDR      r4,[r5,#4]            ;1209
00006c  e1a0000a          MOV      r0,r10                ;1210
000070  ebfffffe          BL       lwip_htons
000074  e5c40000          STRB     r0,[r4,#0]            ;1210
000078  e1a00420          LSR      r0,r0,#8              ;1210
00007c  e5c40001          STRB     r0,[r4,#1]            ;1210
000080  e1a0000b          MOV      r0,r11                ;1211
000084  ebfffffe          BL       lwip_htons
000088  e5c40002          STRB     r0,[r4,#2]            ;1211
00008c  e1a00420          LSR      r0,r0,#8              ;1211
000090  e5c40003          STRB     r0,[r4,#3]            ;1211
000094  e1a00009          MOV      r0,r9                 ;1212
000098  ebfffffe          BL       lwip_htonl
00009c  e2841004          ADD      r1,r4,#4              ;1212
0000a0  e58d0004          STR      r0,[sp,#4]            ;1212
0000a4  ebfffffe          BL       __aeabi_uwrite4
0000a8  e1a00006          MOV      r0,r6                 ;1213
0000ac  ebfffffe          BL       lwip_htonl
0000b0  e2841008          ADD      r1,r4,#8              ;1213
0000b4  e58d0004          STR      r0,[sp,#4]            ;1213
0000b8  ebfffffe          BL       __aeabi_uwrite4
0000bc  e59f0108          LDR      r0,|L11.460|
0000c0  ebfffffe          BL       lwip_htons
0000c4  e5c4000c          STRB     r0,[r4,#0xc]          ;1214
0000c8  e1a00420          LSR      r0,r0,#8              ;1214
0000cc  e5c4000d          STRB     r0,[r4,#0xd]          ;1214
0000d0  e59f00f8          LDR      r0,|L11.464|
0000d4  e5c4000e          STRB     r0,[r4,#0xe]          ;1215
0000d8  e1a00420          LSR      r0,r0,#8              ;1215
0000dc  e5c4000f          STRB     r0,[r4,#0xf]          ;1215
0000e0  e3a00000          MOV      r0,#0                 ;1216
0000e4  e5c40010          STRB     r0,[r4,#0x10]         ;1216
0000e8  e5c40011          STRB     r0,[r4,#0x11]         ;1216
0000ec  e5c40012          STRB     r0,[r4,#0x12]         ;1217
0000f0  e5c40013          STRB     r0,[r4,#0x13]         ;1217
0000f4  e1d500b8          LDRH     r0,[r5,#8]            ;1220
0000f8  e3a03006          MOV      r3,#6                 ;1220
0000fc  e1a02008          MOV      r2,r8                 ;1220
000100  e1a01007          MOV      r1,r7                 ;1220
000104  e58d0000          STR      r0,[sp,#0]            ;1220
000108  e1a00005          MOV      r0,r5                 ;1220
00010c  ebfffffe          BL       inet_chksum_pseudo
000110  e5c40010          STRB     r0,[r4,#0x10]         ;1220
000114  e1a00420          LSR      r0,r0,#8              ;1220
000118  e5c40011          STRB     r0,[r4,#0x11]         ;1220
00011c  e3a00006          MOV      r0,#6                 ;1226
000120  e3a01000          MOV      r1,#0                 ;1226
000124  e3a030ff          MOV      r3,#0xff              ;1226
000128  e1a02008          MOV      r2,r8                 ;1226
00012c  e58d1000          STR      r1,[sp,#0]            ;1226
000130  e1a01007          MOV      r1,r7                 ;1226
000134  e58d0004          STR      r0,[sp,#4]            ;1226
000138  e1a00005          MOV      r0,r5                 ;1226
00013c  ebfffffe          BL       ip_output
000140  e1a00005          MOV      r0,r5                 ;1227
000144  ebfffffe          BL       pbuf_free
000148  e1a00000          MOV      r0,r0
00014c  eaffffb8          B        |L11.52|
;;;1230   
                          ENDP

                  |L11.336|
000150  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_out.c",0
000154  2d312e34
000158  2e315c73
00015c  72635c63
000160  6f72655c
000164  7463705f
000168  6f75742e
00016c  6300    
00016e  00                DCB      0
00016f  00                DCB      0
                  |L11.368|
                          DCD      0x000004b6
                  |L11.372|
000174  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
000178  6b207468
00017c  61742066
000180  69727374
000184  20706275
000188  66206361
00018c  6e20686f
000190  6c642073
000194  74727563
000198  74207463
00019c  705f6864
0001a0  7200    
0001a2  00                DCB      0
0001a3  00                DCB      0
                  |L11.420|
0001a4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001a8  7274696f
0001ac  6e202225
0001b0  73222066
0001b4  61696c65
0001b8  64206174
0001bc  206c696e
0001c0  65202564
0001c4  20696e20
0001c8  25730a00
                  |L11.460|
                          DCD      0x00005014
                  |L11.464|
                          DCD      0x0000a00f

                          AREA ||i.tcp_send_empty_ack||, CODE, READONLY, ALIGN=2

                  tcp_send_empty_ack PROC
;;;841    err_t
;;;842    tcp_send_empty_ack(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;843    {
000004  e1a04000          MOV      r4,r0
;;;844      struct pbuf *p;
;;;845      struct tcp_hdr *tcphdr;
;;;846      u8_t optlen = 0;
000008  e3a07000          MOV      r7,#0
;;;847    
;;;848    #if LWIP_TCP_TIMESTAMPS
;;;849      if (pcb->flags & TF_TIMESTAMP) {
;;;850        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;851      }
;;;852    #endif
;;;853    
;;;854      p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
00000c  e5940050          LDR      r0,[r4,#0x50]
000010  ebfffffe          BL       lwip_htonl
000014  e1a08000          MOV      r8,r0
000018  e1a03008          MOV      r3,r8
00001c  e3a02000          MOV      r2,#0
000020  e1a01007          MOV      r1,r7
000024  e1a00004          MOV      r0,r4
000028  ebfffffe          BL       tcp_output_alloc_header
00002c  e1a05000          MOV      r5,r0
;;;855      if (p == NULL) {
000030  e3550000          CMP      r5,#0
000034  1a000001          BNE      |L12.64|
;;;856        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
;;;857        return ERR_BUF;
000038  e3e00001          MVN      r0,#1
                  |L12.60|
;;;858      }
;;;859      tcphdr = (struct tcp_hdr *)p->payload;
;;;860      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
;;;861                  ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
;;;862      /* remove ACK flags from the PCB, as we send an empty ACK now */
;;;863      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;864    
;;;865      /* NB. MSS option is only sent on SYNs, so ignore it here */
;;;866    #if LWIP_TCP_TIMESTAMPS
;;;867      pcb->ts_lastacksent = pcb->rcv_nxt;
;;;868    
;;;869      if (pcb->flags & TF_TIMESTAMP) {
;;;870        tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
;;;871      }
;;;872    #endif 
;;;873    
;;;874    #if CHECKSUM_GEN_TCP
;;;875      tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
;;;876            IP_PROTO_TCP, p->tot_len);
;;;877    #endif
;;;878    #if LWIP_NETIF_HWADDRHINT
;;;879      ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;880          IP_PROTO_TCP, &(pcb->addr_hint));
;;;881    #else /* LWIP_NETIF_HWADDRHINT*/
;;;882      ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;883          IP_PROTO_TCP);
;;;884    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;885      pbuf_free(p);
;;;886    
;;;887      return ERR_OK;
;;;888    }
00003c  e8bd81fc          POP      {r2-r8,pc}
                  |L12.64|
000040  e5956004          LDR      r6,[r5,#4]            ;859
000044  e5d4001e          LDRB     r0,[r4,#0x1e]         ;863
000048  e3c00003          BIC      r0,r0,#3              ;863
00004c  e5c4001e          STRB     r0,[r4,#0x1e]         ;863
000050  e1d500b8          LDRH     r0,[r5,#8]            ;875
000054  e3a03006          MOV      r3,#6                 ;875
000058  e2842004          ADD      r2,r4,#4              ;875
00005c  e1a01004          MOV      r1,r4                 ;875
000060  e58d0000          STR      r0,[sp,#0]            ;875
000064  e1a00005          MOV      r0,r5                 ;875
000068  ebfffffe          BL       inet_chksum_pseudo
00006c  e5c60010          STRB     r0,[r6,#0x10]         ;875
000070  e1a00420          LSR      r0,r0,#8              ;875
000074  e5c60011          STRB     r0,[r6,#0x11]         ;875
000078  e3a01006          MOV      r1,#6                 ;882
00007c  e5d40009          LDRB     r0,[r4,#9]            ;882
000080  e1cd00f0          STRD     r0,r1,[sp,#0]         ;882
000084  e5d4300a          LDRB     r3,[r4,#0xa]          ;882
000088  e2842004          ADD      r2,r4,#4              ;882
00008c  e1a01004          MOV      r1,r4                 ;882
000090  e1a00005          MOV      r0,r5                 ;882
000094  ebfffffe          BL       ip_output
000098  e1a00005          MOV      r0,r5                 ;885
00009c  ebfffffe          BL       pbuf_free
0000a0  e3a00000          MOV      r0,#0                 ;887
0000a4  eaffffe4          B        |L12.60|
;;;889    
                          ENDP


                          AREA ||i.tcp_send_fin||, CODE, READONLY, ALIGN=2

                  tcp_send_fin PROC
;;;124    err_t
;;;125    tcp_send_fin(struct tcp_pcb *pcb)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;126    {
000004  e1a04000          MOV      r4,r0
;;;127      /* first, try to add the fin to the last unsent segment */
;;;128      if (pcb->unsent != NULL) {
000008  e594006c          LDR      r0,[r4,#0x6c]
00000c  e3500000          CMP      r0,#0
000010  0a00001e          BEQ      |L13.144|
;;;129        struct tcp_seg *last_unsent;
;;;130        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
000014  e594506c          LDR      r5,[r4,#0x6c]
000018  ea000000          B        |L13.32|
                  |L13.28|
;;;131             last_unsent = last_unsent->next);
00001c  e5955000          LDR      r5,[r5,#0]
                  |L13.32|
000020  e5950000          LDR      r0,[r5,#0]            ;130
000024  e3500000          CMP      r0,#0                 ;130
000028  1afffffb          BNE      |L13.28|
;;;132    
;;;133        if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
00002c  e5951010          LDR      r1,[r5,#0x10]
000030  e5d1200d          LDRB     r2,[r1,#0xd]
000034  e5d1100c          LDRB     r1,[r1,#0xc]
000038  e1810402          ORR      r0,r1,r2,LSL #8
00003c  ebfffffe          BL       lwip_ntohs
000040  e2000007          AND      r0,r0,#7
000044  e3500000          CMP      r0,#0
000048  1a00000f          BNE      |L13.140|
;;;134          /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
;;;135          TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
00004c  e3a00001          MOV      r0,#1
000050  ebfffffe          BL       lwip_htons
000054  e5952010          LDR      r2,[r5,#0x10]
000058  e5d2100d          LDRB     r1,[r2,#0xd]
00005c  e5d2200c          LDRB     r2,[r2,#0xc]
000060  e1821401          ORR      r1,r2,r1,LSL #8
000064  e1800001          ORR      r0,r0,r1
000068  e5951010          LDR      r1,[r5,#0x10]
00006c  e5c1000c          STRB     r0,[r1,#0xc]
000070  e1a00420          LSR      r0,r0,#8
000074  e5c1000d          STRB     r0,[r1,#0xd]
;;;136          pcb->flags |= TF_FIN;
000078  e5d4001e          LDRB     r0,[r4,#0x1e]
00007c  e3800020          ORR      r0,r0,#0x20
000080  e5c4001e          STRB     r0,[r4,#0x1e]
;;;137          return ERR_OK;
000084  e3a00000          MOV      r0,#0
                  |L13.136|
;;;138        }
;;;139      }
;;;140      /* no data, no length, flags, copy=1, no optdata */
;;;141      return tcp_enqueue_flags(pcb, TCP_FIN);
;;;142    }
000088  e8bd8070          POP      {r4-r6,pc}
                  |L13.140|
00008c  e1a00000          MOV      r0,r0                 ;139
                  |L13.144|
000090  e3a01001          MOV      r1,#1                 ;141
000094  e1a00004          MOV      r0,r4                 ;141
000098  ebfffffe          BL       tcp_enqueue_flags
00009c  eafffff9          B        |L13.136|
;;;143    
                          ENDP


                          AREA ||i.tcp_write||, CODE, READONLY, ALIGN=2

                  tcp_write PROC
;;;353    err_t
;;;354    tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;355    {
000004  e24dd03c          SUB      sp,sp,#0x3c
000008  e1a04000          MOV      r4,r0
00000c  e1a07002          MOV      r7,r2
;;;356      struct pbuf *concat_p = NULL;
000010  e3a0b000          MOV      r11,#0
;;;357      struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
000014  e3a05000          MOV      r5,#0
000018  e3a0a000          MOV      r10,#0
00001c  e3a00000          MOV      r0,#0
000020  e58d0038          STR      r0,[sp,#0x38]
000024  e58d0034          STR      r0,[sp,#0x34]
;;;358      u16_t pos = 0; /* position in 'arg' data */
000028  e3a06000          MOV      r6,#0
;;;359      u16_t queuelen;
;;;360      u8_t optlen = 0;
00002c  e58d002c          STR      r0,[sp,#0x2c]
;;;361      u8_t optflags = 0;
000030  e58d0028          STR      r0,[sp,#0x28]
;;;362    #if TCP_OVERSIZE
;;;363      u16_t oversize = 0;
000034  e58d0024          STR      r0,[sp,#0x24]
;;;364      u16_t oversize_used = 0;
000038  e1a08000          MOV      r8,r0
;;;365    #endif /* TCP_OVERSIZE */
;;;366    #if TCP_CHECKSUM_ON_COPY
;;;367      u16_t concat_chksum = 0;
;;;368      u8_t concat_chksum_swapped = 0;
;;;369      u16_t concat_chksummed = 0;
;;;370    #endif /* TCP_CHECKSUM_ON_COPY */
;;;371      err_t err;
;;;372      /* don't allocate segments bigger than half the maximum window we ever received */
;;;373      u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
00003c  e1d416b2          LDRH     r1,[r4,#0x62]
000040  e0812fa1          ADD      r2,r1,r1,LSR #31
000044  e1a020c2          ASR      r2,r2,#1
000048  e1d433b6          LDRH     r3,[r4,#0x36]
00004c  e1520003          CMP      r2,r3
000050  da000001          BLE      |L14.92|
000054  e1d423b6          LDRH     r2,[r4,#0x36]
000058  ea000002          B        |L14.104|
                  |L14.92|
00005c  e1d406b2          LDRH     r0,[r4,#0x62]
000060  e0802fa0          ADD      r2,r0,r0,LSR #31
000064  e1a020c2          ASR      r2,r2,#1
                  |L14.104|
000068  e1a02802          LSL      r2,r2,#16
00006c  e1a02822          LSR      r2,r2,#16
000070  e58d201c          STR      r2,[sp,#0x1c]
;;;374    
;;;375    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;376      /* Always copy to try to create single pbufs for TX */
;;;377      apiflags |= TCP_WRITE_FLAG_COPY;
;;;378    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;379    
;;;380      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
;;;381        (void *)pcb, arg, len, (u16_t)apiflags));
;;;382      LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
000074  e1a00000          MOV      r0,r0
000078  e59d0040          LDR      r0,[sp,#0x40]
00007c  e3500000          CMP      r0,#0
000080  1a000009          BNE      |L14.172|
000084  e1a00000          MOV      r0,r0
000088  e28f3e29          ADR      r3,|L14.800|
00008c  e59f22ac          LDR      r2,|L14.832|
000090  e28f1fab          ADR      r1,|L14.836|
000094  e28f0fb7          ADR      r0,|L14.888|
000098  ebfffffe          BL       sysprintf
00009c  e1a00000          MOV      r0,r0
0000a0  e3e0000d          MVN      r0,#0xd
                  |L14.164|
0000a4  e28dd04c          ADD      sp,sp,#0x4c
;;;383                 arg != NULL, return ERR_ARG;);
;;;384    
;;;385      err = tcp_write_checks(pcb, len);
;;;386      if (err != ERR_OK) {
;;;387        return err;
;;;388      }
;;;389      queuelen = pcb->snd_queuelen;
;;;390    
;;;391    #if LWIP_TCP_TIMESTAMPS
;;;392      if ((pcb->flags & TF_TIMESTAMP)) {
;;;393        optflags = TF_SEG_OPTS_TS;
;;;394        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;395      }
;;;396    #endif /* LWIP_TCP_TIMESTAMPS */
;;;397    
;;;398    
;;;399      /*
;;;400       * TCP segmentation is done in three phases with increasing complexity:
;;;401       *
;;;402       * 1. Copy data directly into an oversized pbuf.
;;;403       * 2. Chain a new pbuf to the end of pcb->unsent.
;;;404       * 3. Create new segments.
;;;405       *
;;;406       * We may run out of memory at any point. In that case we must
;;;407       * return ERR_MEM and not change anything in pcb. Therefore, all
;;;408       * changes are recorded in local variables and committed at the end
;;;409       * of the function. Some pcb fields are maintained in local copies:
;;;410       *
;;;411       * queuelen = pcb->snd_queuelen
;;;412       * oversize = pcb->unsent_oversize
;;;413       *
;;;414       * These variables are set consistently by the phases:
;;;415       *
;;;416       * seg points to the last segment tampered with.
;;;417       *
;;;418       * pos records progress as data is segmented.
;;;419       */
;;;420    
;;;421      /* Find the tail of the unsent queue. */
;;;422      if (pcb->unsent != NULL) {
;;;423        u16_t space;
;;;424        u16_t unsent_optlen;
;;;425    
;;;426        /* @todo: this could be sped up by keeping last_unsent in the pcb */
;;;427        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
;;;428             last_unsent = last_unsent->next);
;;;429    
;;;430        /* Usable space at the end of the last unsent segment */
;;;431        unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
;;;432        space = mss_local - (last_unsent->len + unsent_optlen);
;;;433    
;;;434        /*
;;;435         * Phase 1: Copy data directly into an oversized pbuf.
;;;436         *
;;;437         * The number of bytes copied is recorded in the oversize_used
;;;438         * variable. The actual copying is done at the bottom of the
;;;439         * function.
;;;440         */
;;;441    #if TCP_OVERSIZE
;;;442    #if TCP_OVERSIZE_DBGCHECK
;;;443        /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
;;;444        LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
;;;445                    pcb->unsent_oversize == last_unsent->oversize_left);
;;;446    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;447        oversize = pcb->unsent_oversize;
;;;448        if (oversize > 0) {
;;;449          LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
;;;450          seg = last_unsent;
;;;451          oversize_used = oversize < len ? oversize : len;
;;;452          pos += oversize_used;
;;;453          oversize -= oversize_used;
;;;454          space -= oversize_used;
;;;455        }
;;;456        /* now we are either finished or oversize is zero */
;;;457        LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
;;;458    #endif /* TCP_OVERSIZE */
;;;459    
;;;460        /*
;;;461         * Phase 2: Chain a new pbuf to the end of pcb->unsent.
;;;462         *
;;;463         * We don't extend segments containing SYN/FIN flags or options
;;;464         * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
;;;465         * the end.
;;;466         */
;;;467        if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
;;;468          u16_t seglen = space < len - pos ? space : len - pos;
;;;469          seg = last_unsent;
;;;470    
;;;471          /* Create a pbuf with a copy or reference to seglen bytes. We
;;;472           * can use PBUF_RAW here since the data appears in the middle of
;;;473           * a segment. A header will never be prepended. */
;;;474          if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;475            /* Data is copied */
;;;476            if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
;;;477              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;478                          ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
;;;479                           seglen));
;;;480              goto memerr;
;;;481            }
;;;482    #if TCP_OVERSIZE_DBGCHECK
;;;483            last_unsent->oversize_left += oversize;
;;;484    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;485            TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
;;;486    #if TCP_CHECKSUM_ON_COPY
;;;487            concat_chksummed += seglen;
;;;488    #endif /* TCP_CHECKSUM_ON_COPY */
;;;489          } else {
;;;490            /* Data is not copied */
;;;491            if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
;;;492              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;493                          ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;494              goto memerr;
;;;495            }
;;;496    #if TCP_CHECKSUM_ON_COPY
;;;497            /* calculate the checksum of nocopy-data */
;;;498            tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
;;;499              &concat_chksum, &concat_chksum_swapped);
;;;500            concat_chksummed += seglen;
;;;501    #endif /* TCP_CHECKSUM_ON_COPY */
;;;502            /* reference the non-volatile payload data */
;;;503            concat_p->payload = (u8_t*)arg + pos;
;;;504          }
;;;505    
;;;506          pos += seglen;
;;;507          queuelen += pbuf_clen(concat_p);
;;;508        }
;;;509      } else {
;;;510    #if TCP_OVERSIZE
;;;511        LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
;;;512                    pcb->unsent_oversize == 0);
;;;513    #endif /* TCP_OVERSIZE */
;;;514      }
;;;515    
;;;516      /*
;;;517       * Phase 3: Create new segments.
;;;518       *
;;;519       * The new segments are chained together in the local 'queue'
;;;520       * variable, ready to be appended to pcb->unsent.
;;;521       */
;;;522      while (pos < len) {
;;;523        struct pbuf *p;
;;;524        u16_t left = len - pos;
;;;525        u16_t max_len = mss_local - optlen;
;;;526        u16_t seglen = left > max_len ? max_len : left;
;;;527    #if TCP_CHECKSUM_ON_COPY
;;;528        u16_t chksum = 0;
;;;529        u8_t chksum_swapped = 0;
;;;530    #endif /* TCP_CHECKSUM_ON_COPY */
;;;531    
;;;532        if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;533          /* If copy is set, memory should be allocated and data copied
;;;534           * into pbuf */
;;;535          if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
;;;536            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
;;;537            goto memerr;
;;;538          }
;;;539          LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
;;;540                      (p->len >= seglen));
;;;541          TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
;;;542        } else {
;;;543          /* Copy is not set: First allocate a pbuf for holding the data.
;;;544           * Since the referenced data is available at least until it is
;;;545           * sent out on the link (as it has to be ACKed by the remote
;;;546           * party) we can safely use PBUF_ROM instead of PBUF_REF here.
;;;547           */
;;;548          struct pbuf *p2;
;;;549    #if TCP_OVERSIZE
;;;550          LWIP_ASSERT("oversize == 0", oversize == 0);
;;;551    #endif /* TCP_OVERSIZE */
;;;552          if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
;;;553            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;554            goto memerr;
;;;555          }
;;;556    #if TCP_CHECKSUM_ON_COPY
;;;557          /* calculate the checksum of nocopy-data */
;;;558          chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
;;;559    #endif /* TCP_CHECKSUM_ON_COPY */
;;;560          /* reference the non-volatile payload data */
;;;561          p2->payload = (u8_t*)arg + pos;
;;;562    
;;;563          /* Second, allocate a pbuf for the headers. */
;;;564          if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;565            /* If allocation fails, we have to deallocate the data pbuf as
;;;566             * well. */
;;;567            pbuf_free(p2);
;;;568            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
;;;569            goto memerr;
;;;570          }
;;;571          /* Concatenate the headers and data pbufs together. */
;;;572          pbuf_cat(p/*header*/, p2/*data*/);
;;;573        }
;;;574    
;;;575        queuelen += pbuf_clen(p);
;;;576    
;;;577        /* Now that there are more segments queued, we check again if the
;;;578         * length of the queue exceeds the configured maximum or
;;;579         * overflows. */
;;;580        if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;581          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
;;;582          pbuf_free(p);
;;;583          goto memerr;
;;;584        }
;;;585    
;;;586        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
;;;587          goto memerr;
;;;588        }
;;;589    #if TCP_OVERSIZE_DBGCHECK
;;;590        seg->oversize_left = oversize;
;;;591    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;592    #if TCP_CHECKSUM_ON_COPY
;;;593        seg->chksum = chksum;
;;;594        seg->chksum_swapped = chksum_swapped;
;;;595        seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;596    #endif /* TCP_CHECKSUM_ON_COPY */
;;;597    
;;;598        /* first segment of to-be-queued data? */
;;;599        if (queue == NULL) {
;;;600          queue = seg;
;;;601        } else {
;;;602          /* Attach the segment to the end of the queued segments */
;;;603          LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
;;;604          prev_seg->next = seg;
;;;605        }
;;;606        /* remember last segment of to-be-queued data for next iteration */
;;;607        prev_seg = seg;
;;;608    
;;;609        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
;;;610          ntohl(seg->tcphdr->seqno),
;;;611          ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
;;;612    
;;;613        pos += seglen;
;;;614      }
;;;615    
;;;616      /*
;;;617       * All three segmentation phases were successful. We can commit the
;;;618       * transaction.
;;;619       */
;;;620    
;;;621      /*
;;;622       * Phase 1: If data has been added to the preallocated tail of
;;;623       * last_unsent, we update the length fields of the pbuf chain.
;;;624       */
;;;625    #if TCP_OVERSIZE
;;;626      if (oversize_used > 0) {
;;;627        struct pbuf *p;
;;;628        /* Bump tot_len of whole chain, len of tail */
;;;629        for (p = last_unsent->p; p; p = p->next) {
;;;630          p->tot_len += oversize_used;
;;;631          if (p->next == NULL) {
;;;632            TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
;;;633            p->len += oversize_used;
;;;634          }
;;;635        }
;;;636        last_unsent->len += oversize_used;
;;;637    #if TCP_OVERSIZE_DBGCHECK
;;;638        LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
;;;639                    last_unsent->oversize_left >= oversize_used);
;;;640        last_unsent->oversize_left -= oversize_used;
;;;641    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;642      }
;;;643      pcb->unsent_oversize = oversize;
;;;644    #endif /* TCP_OVERSIZE */
;;;645    
;;;646      /*
;;;647       * Phase 2: concat_p can be concatenated onto last_unsent->p
;;;648       */
;;;649      if (concat_p != NULL) {
;;;650        LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
;;;651          (last_unsent != NULL));
;;;652        pbuf_cat(last_unsent->p, concat_p);
;;;653        last_unsent->len += concat_p->tot_len;
;;;654    #if TCP_CHECKSUM_ON_COPY
;;;655        if (concat_chksummed) {
;;;656          tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
;;;657            &last_unsent->chksum_swapped);
;;;658          last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;659        }
;;;660    #endif /* TCP_CHECKSUM_ON_COPY */
;;;661      }
;;;662    
;;;663      /*
;;;664       * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
;;;665       * is harmless
;;;666       */
;;;667      if (last_unsent == NULL) {
;;;668        pcb->unsent = queue;
;;;669      } else {
;;;670        last_unsent->next = queue;
;;;671      }
;;;672    
;;;673      /*
;;;674       * Finally update the pcb state.
;;;675       */
;;;676      pcb->snd_lbb += len;
;;;677      pcb->snd_buf -= len;
;;;678      pcb->snd_queuelen = queuelen;
;;;679    
;;;680      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
;;;681        pcb->snd_queuelen));
;;;682      if (pcb->snd_queuelen != 0) {
;;;683        LWIP_ASSERT("tcp_write: valid queue length",
;;;684                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;685      }
;;;686    
;;;687      /* Set the PSH flag in the last segment that we enqueued. */
;;;688      if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
;;;689        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
;;;690      }
;;;691    
;;;692      return ERR_OK;
;;;693    memerr:
;;;694      pcb->flags |= TF_NAGLEMEMERR;
;;;695      TCP_STATS_INC(tcp.memerr);
;;;696    
;;;697      if (concat_p != NULL) {
;;;698        pbuf_free(concat_p);
;;;699      }
;;;700      if (queue != NULL) {
;;;701        tcp_segs_free(queue);
;;;702      }
;;;703      if (pcb->snd_queuelen != 0) {
;;;704        LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
;;;705          pcb->unsent != NULL);
;;;706      }
;;;707      LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
;;;708      return ERR_MEM;
;;;709    }
0000a8  e8bd8ff0          POP      {r4-r11,pc}
                  |L14.172|
0000ac  e1a00000          MOV      r0,r0                 ;382
0000b0  e1a01007          MOV      r1,r7                 ;385
0000b4  e1a00004          MOV      r0,r4                 ;385
0000b8  ebfffffe          BL       tcp_write_checks
0000bc  e58d0020          STR      r0,[sp,#0x20]         ;385
0000c0  e59d0020          LDR      r0,[sp,#0x20]         ;386
0000c4  e3500000          CMP      r0,#0                 ;386
0000c8  0a000001          BEQ      |L14.212|
0000cc  e59d0020          LDR      r0,[sp,#0x20]         ;387
0000d0  eafffff3          B        |L14.164|
                  |L14.212|
0000d4  e1d406b8          LDRH     r0,[r4,#0x68]         ;389
0000d8  e58d0030          STR      r0,[sp,#0x30]         ;389
0000dc  e594006c          LDR      r0,[r4,#0x6c]         ;422
0000e0  e3500000          CMP      r0,#0                 ;422
0000e4  0a0000db          BEQ      |L14.1112|
0000e8  e594506c          LDR      r5,[r4,#0x6c]         ;427
0000ec  ea000000          B        |L14.244|
                  |L14.240|
0000f0  e5955000          LDR      r5,[r5,#0]            ;428
                  |L14.244|
0000f4  e5950000          LDR      r0,[r5,#0]            ;427
0000f8  e3500000          CMP      r0,#0                 ;427
0000fc  1afffffb          BNE      |L14.240|
000100  e5d5000c          LDRB     r0,[r5,#0xc]          ;431
000104  e2000001          AND      r0,r0,#1              ;431
000108  e3500000          CMP      r0,#0                 ;431
00010c  0a000001          BEQ      |L14.280|
000110  e3a00004          MOV      r0,#4                 ;431
000114  ea000000          B        |L14.284|
                  |L14.280|
000118  e3a00000          MOV      r0,#0                 ;431
                  |L14.284|
00011c  e5d5100c          LDRB     r1,[r5,#0xc]          ;431
000120  e2011002          AND      r1,r1,#2              ;431
000124  e3510000          CMP      r1,#0                 ;431
000128  0a000001          BEQ      |L14.308|
00012c  e3a0100c          MOV      r1,#0xc               ;431
000130  ea000000          B        |L14.312|
                  |L14.308|
000134  e3a01000          MOV      r1,#0                 ;431
                  |L14.312|
000138  e0800001          ADD      r0,r0,r1              ;431
00013c  e58d0018          STR      r0,[sp,#0x18]         ;431
000140  e1d510b8          LDRH     r1,[r5,#8]            ;432
000144  e59d0018          LDR      r0,[sp,#0x18]         ;432
000148  e0811000          ADD      r1,r1,r0              ;432
00014c  e59d001c          LDR      r0,[sp,#0x1c]         ;432
000150  e0400001          SUB      r0,r0,r1              ;432
000154  e1a09800          LSL      r9,r0,#16             ;432
000158  e1a09829          LSR      r9,r9,#16             ;432
00015c  e1a00000          MOV      r0,r0                 ;444
000160  e1d406ba          LDRH     r0,[r4,#0x6a]         ;444
000164  e1d510ba          LDRH     r1,[r5,#0xa]          ;444
000168  e1500001          CMP      r0,r1                 ;444
00016c  0a000006          BEQ      |L14.396|
000170  e1a00000          MOV      r0,r0                 ;444
000174  e28f3f69          ADR      r3,|L14.800|
000178  e3a02f6f          MOV      r2,#0x1bc             ;444
00017c  e28f1f87          ADR      r1,|L14.928|
000180  e28f0e1f          ADR      r0,|L14.888|
000184  ebfffffe          BL       sysprintf
000188  e1a00000          MOV      r0,r0                 ;444
                  |L14.396|
00018c  e1a00000          MOV      r0,r0                 ;444
000190  e1d406ba          LDRH     r0,[r4,#0x6a]         ;447
000194  e58d0024          STR      r0,[sp,#0x24]         ;447
000198  e1dd02b4          LDRH     r0,[sp,#0x24]         ;448
00019c  e3500000          CMP      r0,#0                 ;448
0001a0  da00001d          BLE      |L14.540|
0001a4  e1a00000          MOV      r0,r0                 ;449
0001a8  e1580009          CMP      r8,r9                 ;449
0001ac  da000006          BLE      |L14.460|
0001b0  e1a00000          MOV      r0,r0                 ;449
0001b4  e28f3f59          ADR      r3,|L14.800|
0001b8  e59f2210          LDR      r2,|L14.976|
0001bc  e28f1e21          ADR      r1,|L14.980|
0001c0  e28f0e1b          ADR      r0,|L14.888|
0001c4  ebfffffe          BL       sysprintf
0001c8  e1a00000          MOV      r0,r0                 ;449
                  |L14.460|
0001cc  e1a00000          MOV      r0,r0                 ;449
0001d0  e1a0a005          MOV      r10,r5                ;450
0001d4  e1dd02b4          LDRH     r0,[sp,#0x24]         ;451
0001d8  e1500007          CMP      r0,r7                 ;451
0001dc  aa000001          BGE      |L14.488|
0001e0  e1dd02b4          LDRH     r0,[sp,#0x24]         ;451
0001e4  ea000000          B        |L14.492|
                  |L14.488|
0001e8  e1a00007          MOV      r0,r7                 ;451
                  |L14.492|
0001ec  e1a08000          MOV      r8,r0                 ;451
0001f0  e0860008          ADD      r0,r6,r8              ;452
0001f4  e1a06800          LSL      r6,r0,#16             ;452
0001f8  e1a06826          LSR      r6,r6,#16             ;452
0001fc  e1dd02b4          LDRH     r0,[sp,#0x24]         ;453
000200  e0400008          SUB      r0,r0,r8              ;453
000204  e1a00800          LSL      r0,r0,#16             ;453
000208  e1a00820          LSR      r0,r0,#16             ;453
00020c  e58d0024          STR      r0,[sp,#0x24]         ;453
000210  e0490008          SUB      r0,r9,r8              ;454
000214  e1a09800          LSL      r9,r0,#16             ;454
000218  e1a09829          LSR      r9,r9,#16             ;454
                  |L14.540|
00021c  e1a00000          MOV      r0,r0                 ;457
000220  e1dd02b4          LDRH     r0,[sp,#0x24]         ;457
000224  e3500000          CMP      r0,#0                 ;457
000228  0a000008          BEQ      |L14.592|
00022c  e1560007          CMP      r6,r7                 ;457
000230  0a000006          BEQ      |L14.592|
000234  e1a00000          MOV      r0,r0                 ;457
000238  e28f30e0          ADR      r3,|L14.800|
00023c  e59f21b0          LDR      r2,|L14.1012|
000240  e28f1e1b          ADR      r1,|L14.1016|
000244  e28f0f4b          ADR      r0,|L14.888|
000248  ebfffffe          BL       sysprintf
00024c  e1a00000          MOV      r0,r0                 ;457
                  |L14.592|
000250  e1a00000          MOV      r0,r0                 ;457
000254  e1560007          CMP      r6,r7                 ;467
000258  aa00007d          BGE      |L14.1108|
00025c  e3590000          CMP      r9,#0                 ;467
000260  da00007b          BLE      |L14.1108|
000264  e1d500b8          LDRH     r0,[r5,#8]            ;467
000268  e3500000          CMP      r0,#0                 ;467
00026c  da000078          BLE      |L14.1108|
000270  e0470006          SUB      r0,r7,r6              ;468
000274  e1500009          CMP      r0,r9                 ;468
000278  da000001          BLE      |L14.644|
00027c  e1a00009          MOV      r0,r9                 ;468
000280  ea000000          B        |L14.648|
                  |L14.644|
000284  e0470006          SUB      r0,r7,r6              ;468
                  |L14.648|
000288  e1a00800          LSL      r0,r0,#16             ;468
00028c  e1a00820          LSR      r0,r0,#16             ;468
000290  e58d0014          STR      r0,[sp,#0x14]         ;468
000294  e1a0a005          MOV      r10,r5                ;469
000298  e59d0048          LDR      r0,[sp,#0x48]         ;474
00029c  e2000001          AND      r0,r0,#1              ;474
0002a0  e3500000          CMP      r0,#0                 ;474
0002a4  0a000016          BEQ      |L14.772|
0002a8  e3a01001          MOV      r1,#1                 ;476
0002ac  e59d0048          LDR      r0,[sp,#0x48]         ;476
0002b0  e98d0003          STMIB    sp,{r0,r1}            ;476
0002b4  e58d4000          STR      r4,[sp,#0]            ;476
0002b8  e28d3024          ADD      r3,sp,#0x24           ;476
0002bc  e1a02009          MOV      r2,r9                 ;476
0002c0  e3a00003          MOV      r0,#3                 ;476
0002c4  e59d1014          LDR      r1,[sp,#0x14]         ;476
0002c8  ebfffffe          BL       tcp_pbuf_prealloc
0002cc  e250b000          SUBS     r11,r0,#0             ;476
0002d0  1a000000          BNE      |L14.728|
0002d4  ea0001c9          B        |L14.2560|
                  |L14.728|
0002d8  e1d500ba          LDRH     r0,[r5,#0xa]          ;483
0002dc  e1dd12b4          LDRH     r1,[sp,#0x24]         ;483
0002e0  e0800001          ADD      r0,r0,r1              ;483
0002e4  e3c00801          BIC      r0,r0,#0x10000        ;483
0002e8  e1c500ba          STRH     r0,[r5,#0xa]          ;483
0002ec  e59d2040          LDR      r2,[sp,#0x40]         ;485
0002f0  e0821006          ADD      r1,r2,r6              ;485
0002f4  e59b0004          LDR      r0,[r11,#4]           ;485
0002f8  e59d2014          LDR      r2,[sp,#0x14]         ;485
0002fc  ebfffffe          BL       __aeabi_memcpy
000300  ea000047          B        |L14.1060|
                  |L14.772|
000304  e3a02001          MOV      r2,#1                 ;491
000308  e3a00003          MOV      r0,#3                 ;491
00030c  e59d1014          LDR      r1,[sp,#0x14]         ;491
000310  ebfffffe          BL       pbuf_alloc
000314  e250b000          SUBS     r11,r0,#0             ;491
000318  1a00003e          BNE      |L14.1048|
00031c  ea0001b7          B        |L14.2560|
                  |L14.800|
000320  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_out.c",0
000324  2d312e34
000328  2e315c73
00032c  72635c63
000330  6f72655c
000334  7463705f
000338  6f75742e
00033c  6300    
00033e  00                DCB      0
00033f  00                DCB      0
                  |L14.832|
                          DCD      0x0000017e
                  |L14.836|
000344  7463705f          DCB      "tcp_write: arg == NULL (programmer violates API)",0
000348  77726974
00034c  653a2061
000350  7267203d
000354  3d204e55
000358  4c4c2028
00035c  70726f67
000360  72616d6d
000364  65722076
000368  696f6c61
00036c  74657320
000370  41504929
000374  00      
000375  00                DCB      0
000376  00                DCB      0
000377  00                DCB      0
                  |L14.888|
000378  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00037c  7274696f
000380  6e202225
000384  73222066
000388  61696c65
00038c  64206174
000390  206c696e
000394  65202564
000398  20696e20
00039c  25730a00
                  |L14.928|
0003a0  756e7365          DCB      "unsent_oversize mismatch (pcb vs. last_unsent)",0
0003a4  6e745f6f
0003a8  76657273
0003ac  697a6520
0003b0  6d69736d
0003b4  61746368
0003b8  20287063
0003bc  62207673
0003c0  2e206c61
0003c4  73745f75
0003c8  6e73656e
0003cc  742900  
0003cf  00                DCB      0
                  |L14.976|
                          DCD      0x000001c1
                  |L14.980|
0003d4  696e636f          DCB      "inconsistent oversize vs. space",0
0003d8  6e736973
0003dc  74656e74
0003e0  206f7665
0003e4  7273697a
0003e8  65207673
0003ec  2e207370
0003f0  61636500
                  |L14.1012|
                          DCD      0x000001c9
                  |L14.1016|
0003f8  696e636f          DCB      "inconsistend oversize vs. len",0
0003fc  6e736973
000400  74656e64
000404  206f7665
000408  7273697a
00040c  65207673
000410  2e206c65
000414  6e00    
000416  00                DCB      0
000417  00                DCB      0
                  |L14.1048|
000418  e59d0040          LDR      r0,[sp,#0x40]         ;503
00041c  e0800006          ADD      r0,r0,r6              ;503
000420  e58b0004          STR      r0,[r11,#4]           ;503
                  |L14.1060|
000424  e59d0014          LDR      r0,[sp,#0x14]         ;506
000428  e0800006          ADD      r0,r0,r6              ;506
00042c  e1a06800          LSL      r6,r0,#16             ;506
000430  e1a06826          LSR      r6,r6,#16             ;506
000434  e1a0000b          MOV      r0,r11                ;507
000438  ebfffffe          BL       pbuf_clen
00043c  e59d1030          LDR      r1,[sp,#0x30]         ;507
000440  e0800001          ADD      r0,r0,r1              ;507
000444  e1a00800          LSL      r0,r0,#16             ;507
000448  e1a00820          LSR      r0,r0,#16             ;507
00044c  e58d0030          STR      r0,[sp,#0x30]         ;507
000450  e1a00000          MOV      r0,r0                 ;508
                  |L14.1108|
000454  ea00000b          B        |L14.1160|
                  |L14.1112|
000458  e1a00000          MOV      r0,r0                 ;511
00045c  e1d406ba          LDRH     r0,[r4,#0x6a]         ;511
000460  e3500000          CMP      r0,#0                 ;511
000464  0a000006          BEQ      |L14.1156|
000468  e1a00000          MOV      r0,r0                 ;511
00046c  e24f3f55          ADR      r3,|L14.800|
000470  e59f2398          LDR      r2,|L14.2064|
000474  e28f1fe6          ADR      r1,|L14.2068|
000478  e24f0f42          ADR      r0,|L14.888|
00047c  ebfffffe          BL       sysprintf
000480  e1a00000          MOV      r0,r0                 ;511
                  |L14.1156|
000484  e1a00000          MOV      r0,r0                 ;511
                  |L14.1160|
000488  ea00009b          B        |L14.1788|
                  |L14.1164|
00048c  e0470006          SUB      r0,r7,r6              ;524
000490  e1a00800          LSL      r0,r0,#16             ;524
000494  e1a00820          LSR      r0,r0,#16             ;524
000498  e58d0018          STR      r0,[sp,#0x18]         ;524
00049c  e59d001c          LDR      r0,[sp,#0x1c]         ;525
0004a0  e59d102c          LDR      r1,[sp,#0x2c]         ;525
0004a4  e0400001          SUB      r0,r0,r1              ;525
0004a8  e1a00800          LSL      r0,r0,#16             ;525
0004ac  e1a00820          LSR      r0,r0,#16             ;525
0004b0  e58d0014          STR      r0,[sp,#0x14]         ;525
0004b4  e59d0018          LDR      r0,[sp,#0x18]         ;526
0004b8  e59d1014          LDR      r1,[sp,#0x14]         ;526
0004bc  e1500001          CMP      r0,r1                 ;526
0004c0  da000001          BLE      |L14.1228|
0004c4  e59d0014          LDR      r0,[sp,#0x14]         ;526
0004c8  ea000000          B        |L14.1232|
                  |L14.1228|
0004cc  e59d0018          LDR      r0,[sp,#0x18]         ;526
                  |L14.1232|
0004d0  e58d0010          STR      r0,[sp,#0x10]         ;526
0004d4  e59d0048          LDR      r0,[sp,#0x48]         ;532
0004d8  e2000001          AND      r0,r0,#1              ;532
0004dc  e3500000          CMP      r0,#0                 ;532
0004e0  0a000029          BEQ      |L14.1420|
0004e4  e59d0034          LDR      r0,[sp,#0x34]         ;535
0004e8  e3500000          CMP      r0,#0                 ;535
0004ec  1a000001          BNE      |L14.1272|
0004f0  e3a01001          MOV      r1,#1                 ;535
0004f4  ea000000          B        |L14.1276|
                  |L14.1272|
0004f8  e3a01000          MOV      r1,#0                 ;535
                  |L14.1276|
0004fc  e59d0048          LDR      r0,[sp,#0x48]         ;535
000500  e98d0003          STMIB    sp,{r0,r1}            ;535
000504  e58d4000          STR      r4,[sp,#0]            ;535
000508  e59d0010          LDR      r0,[sp,#0x10]         ;535
00050c  e59d202c          LDR      r2,[sp,#0x2c]         ;535
000510  e0800002          ADD      r0,r0,r2              ;535
000514  e1a01800          LSL      r1,r0,#16             ;535
000518  e1a01821          LSR      r1,r1,#16             ;535
00051c  e28d3024          ADD      r3,sp,#0x24           ;535
000520  e3a00000          MOV      r0,#0                 ;535
000524  e59d201c          LDR      r2,[sp,#0x1c]         ;535
000528  ebfffffe          BL       tcp_pbuf_prealloc
00052c  e2509000          SUBS     r9,r0,#0              ;535
000530  1a000000          BNE      |L14.1336|
000534  ea000131          B        |L14.2560|
                  |L14.1336|
000538  e1a00000          MOV      r0,r0                 ;539
00053c  e1d910ba          LDRH     r1,[r9,#0xa]          ;539
000540  e59d0010          LDR      r0,[sp,#0x10]         ;539
000544  e1510000          CMP      r1,r0                 ;539
000548  aa000006          BGE      |L14.1384|
00054c  e1a00000          MOV      r0,r0                 ;539
000550  e24f3f8e          ADR      r3,|L14.800|
000554  e59f22e8          LDR      r2,|L14.2116|
000558  e28f1fba          ADR      r1,|L14.2120|
00055c  e24f0f7b          ADR      r0,|L14.888|
000560  ebfffffe          BL       sysprintf
000564  e1a00000          MOV      r0,r0                 ;539
                  |L14.1384|
000568  e1a00000          MOV      r0,r0                 ;539
00056c  e59d2040          LDR      r2,[sp,#0x40]         ;541
000570  e0821006          ADD      r1,r2,r6              ;541
000574  e5993004          LDR      r3,[r9,#4]            ;541
000578  e59d202c          LDR      r2,[sp,#0x2c]         ;541
00057c  e0830002          ADD      r0,r3,r2              ;541
000580  e59d2010          LDR      r2,[sp,#0x10]         ;541
000584  ebfffffe          BL       __aeabi_memcpy
000588  ea000024          B        |L14.1568|
                  |L14.1420|
00058c  e1a00000          MOV      r0,r0                 ;550
000590  e1dd02b4          LDRH     r0,[sp,#0x24]         ;550
000594  e3500000          CMP      r0,#0                 ;550
000598  0a000006          BEQ      |L14.1464|
00059c  e1a00000          MOV      r0,r0                 ;550
0005a0  e24f3fa2          ADR      r3,|L14.800|
0005a4  e59f22dc          LDR      r2,|L14.2184|
0005a8  e28f1fb7          ADR      r1,|L14.2188|
0005ac  e24f0f8f          ADR      r0,|L14.888|
0005b0  ebfffffe          BL       sysprintf
0005b4  e1a00000          MOV      r0,r0                 ;550
                  |L14.1464|
0005b8  e1a00000          MOV      r0,r0                 ;550
0005bc  e3a02001          MOV      r2,#1                 ;552
0005c0  e3a00000          MOV      r0,#0                 ;552
0005c4  e59d1010          LDR      r1,[sp,#0x10]         ;552
0005c8  ebfffffe          BL       pbuf_alloc
0005cc  e58d000c          STR      r0,[sp,#0xc]          ;552
0005d0  e3500000          CMP      r0,#0                 ;552
0005d4  1a000000          BNE      |L14.1500|
0005d8  ea000108          B        |L14.2560|
                  |L14.1500|
0005dc  e59d0040          LDR      r0,[sp,#0x40]         ;561
0005e0  e0801006          ADD      r1,r0,r6              ;561
0005e4  e59d000c          LDR      r0,[sp,#0xc]          ;561
0005e8  e5801004          STR      r1,[r0,#4]            ;561
0005ec  e3a02000          MOV      r2,#0                 ;564
0005f0  e1a00002          MOV      r0,r2                 ;564
0005f4  e59d102c          LDR      r1,[sp,#0x2c]         ;564
0005f8  ebfffffe          BL       pbuf_alloc
0005fc  e2509000          SUBS     r9,r0,#0              ;564
000600  1a000002          BNE      |L14.1552|
000604  e59d000c          LDR      r0,[sp,#0xc]          ;567
000608  ebfffffe          BL       pbuf_free
00060c  ea0000fb          B        |L14.2560|
                  |L14.1552|
000610  e1a00009          MOV      r0,r9                 ;572
000614  e59d100c          LDR      r1,[sp,#0xc]          ;572
000618  ebfffffe          BL       pbuf_cat
00061c  e1a00000          MOV      r0,r0                 ;573
                  |L14.1568|
000620  e1a00009          MOV      r0,r9                 ;575
000624  ebfffffe          BL       pbuf_clen
000628  e59d1030          LDR      r1,[sp,#0x30]         ;575
00062c  e0800001          ADD      r0,r0,r1              ;575
000630  e1a00800          LSL      r0,r0,#16             ;575
000634  e1a00820          LSR      r0,r0,#16             ;575
000638  e58d0030          STR      r0,[sp,#0x30]         ;575
00063c  e59d0030          LDR      r0,[sp,#0x30]         ;580
000640  e3500008          CMP      r0,#8                 ;580
000644  ca000003          BGT      |L14.1624|
000648  e59d0030          LDR      r0,[sp,#0x30]         ;580
00064c  e59f1248          LDR      r1,|L14.2204|
000650  e1500001          CMP      r0,r1                 ;580
000654  9a000002          BLS      |L14.1636|
                  |L14.1624|
000658  e1a00009          MOV      r0,r9                 ;582
00065c  ebfffffe          BL       pbuf_free
000660  ea0000e6          B        |L14.2560|
                  |L14.1636|
000664  e59d0028          LDR      r0,[sp,#0x28]         ;586
000668  e58d0000          STR      r0,[sp,#0]            ;586
00066c  e594005c          LDR      r0,[r4,#0x5c]         ;586
000670  e0803006          ADD      r3,r0,r6              ;586
000674  e3a02000          MOV      r2,#0                 ;586
000678  e1a01009          MOV      r1,r9                 ;586
00067c  e1a00004          MOV      r0,r4                 ;586
000680  ebfffffe          BL       tcp_create_segment
000684  e250a000          SUBS     r10,r0,#0             ;586
000688  1a000000          BNE      |L14.1680|
00068c  ea0000db          B        |L14.2560|
                  |L14.1680|
000690  e1dd02b4          LDRH     r0,[sp,#0x24]         ;590
000694  e1ca00ba          STRH     r0,[r10,#0xa]         ;590
000698  e59d0034          LDR      r0,[sp,#0x34]         ;599
00069c  e3500000          CMP      r0,#0                 ;599
0006a0  1a000001          BNE      |L14.1708|
0006a4  e58da034          STR      r10,[sp,#0x34]        ;600
0006a8  ea00000d          B        |L14.1764|
                  |L14.1708|
0006ac  e1a00000          MOV      r0,r0                 ;603
0006b0  e59d0038          LDR      r0,[sp,#0x38]         ;603
0006b4  e3500000          CMP      r0,#0                 ;603
0006b8  1a000006          BNE      |L14.1752|
0006bc  e1a00000          MOV      r0,r0                 ;603
0006c0  e24f3fea          ADR      r3,|L14.800|
0006c4  e59f21d4          LDR      r2,|L14.2208|
0006c8  e28f1f75          ADR      r1,|L14.2212|
0006cc  e24f0fd7          ADR      r0,|L14.888|
0006d0  ebfffffe          BL       sysprintf
0006d4  e1a00000          MOV      r0,r0                 ;603
                  |L14.1752|
0006d8  e1a00000          MOV      r0,r0                 ;603
0006dc  e59d0038          LDR      r0,[sp,#0x38]         ;604
0006e0  e580a000          STR      r10,[r0,#0]           ;604
                  |L14.1764|
0006e4  e58da038          STR      r10,[sp,#0x38]        ;607
0006e8  e59d0010          LDR      r0,[sp,#0x10]         ;613
0006ec  e0800006          ADD      r0,r0,r6              ;613
0006f0  e1a06800          LSL      r6,r0,#16             ;613
0006f4  e1a06826          LSR      r6,r6,#16             ;613
0006f8  e1a00000          MOV      r0,r0                 ;614
                  |L14.1788|
0006fc  e1560007          CMP      r6,r7                 ;522
000700  baffff61          BLT      |L14.1164|
000704  e3580000          CMP      r8,#0                 ;626
000708  da000026          BLE      |L14.1960|
00070c  e5959004          LDR      r9,[r5,#4]            ;629
000710  ea00000f          B        |L14.1876|
                  |L14.1812|
000714  e1d900b8          LDRH     r0,[r9,#8]            ;630
000718  e0800008          ADD      r0,r0,r8              ;630
00071c  e1c900b8          STRH     r0,[r9,#8]            ;630
000720  e5990000          LDR      r0,[r9,#0]            ;631
000724  e3500000          CMP      r0,#0                 ;631
000728  1a000008          BNE      |L14.1872|
00072c  e5991004          LDR      r1,[r9,#4]            ;632
000730  e1d920ba          LDRH     r2,[r9,#0xa]          ;632
000734  e0810002          ADD      r0,r1,r2              ;632
000738  e1a02008          MOV      r2,r8                 ;632
00073c  e59d1040          LDR      r1,[sp,#0x40]         ;632
000740  ebfffffe          BL       __aeabi_memcpy
000744  e1d900ba          LDRH     r0,[r9,#0xa]          ;633
000748  e0800008          ADD      r0,r0,r8              ;633
00074c  e1c900ba          STRH     r0,[r9,#0xa]          ;633
                  |L14.1872|
000750  e5999000          LDR      r9,[r9,#0]            ;629
                  |L14.1876|
000754  e3590000          CMP      r9,#0                 ;629
000758  1affffed          BNE      |L14.1812|
00075c  e1d500b8          LDRH     r0,[r5,#8]            ;636
000760  e0800008          ADD      r0,r0,r8              ;636
000764  e1c500b8          STRH     r0,[r5,#8]            ;636
000768  e1a00000          MOV      r0,r0                 ;638
00076c  e1d500ba          LDRH     r0,[r5,#0xa]          ;638
000770  e1500008          CMP      r0,r8                 ;638
000774  aa000006          BGE      |L14.1940|
000778  e1a00000          MOV      r0,r0                 ;638
00077c  e59f3134          LDR      r3,|L14.2232|
000780  e59f2134          LDR      r2,|L14.2236|
000784  e28f1f4d          ADR      r1,|L14.2240|
000788  e59f015c          LDR      r0,|L14.2284|
00078c  ebfffffe          BL       sysprintf
000790  e1a00000          MOV      r0,r0                 ;638
                  |L14.1940|
000794  e1a00000          MOV      r0,r0                 ;638
000798  e1d500ba          LDRH     r0,[r5,#0xa]          ;640
00079c  e0400008          SUB      r0,r0,r8              ;640
0007a0  e1c500ba          STRH     r0,[r5,#0xa]          ;640
0007a4  e1a00000          MOV      r0,r0                 ;642
                  |L14.1960|
0007a8  e1dd02b4          LDRH     r0,[sp,#0x24]         ;643
0007ac  e1c406ba          STRH     r0,[r4,#0x6a]         ;643
0007b0  e35b0000          CMP      r11,#0                ;649
0007b4  0a000012          BEQ      |L14.2052|
0007b8  e1a00000          MOV      r0,r0                 ;650
0007bc  e3550000          CMP      r5,#0                 ;650
0007c0  1a000006          BNE      |L14.2016|
0007c4  e1a00000          MOV      r0,r0                 ;650
0007c8  e59f30e8          LDR      r3,|L14.2232|
0007cc  e59f211c          LDR      r2,|L14.2288|
0007d0  e28f1f47          ADR      r1,|L14.2292|
0007d4  e59f0110          LDR      r0,|L14.2284|
0007d8  ebfffffe          BL       sysprintf
0007dc  e1a00000          MOV      r0,r0                 ;650
                  |L14.2016|
0007e0  e1a00000          MOV      r0,r0                 ;650
0007e4  e1a0100b          MOV      r1,r11                ;652
0007e8  e5950004          LDR      r0,[r5,#4]            ;652
0007ec  ebfffffe          BL       pbuf_cat
0007f0  e1d500b8          LDRH     r0,[r5,#8]            ;653
0007f4  e1db10b8          LDRH     r1,[r11,#8]           ;653
0007f8  e0800001          ADD      r0,r0,r1              ;653
0007fc  e3c00801          BIC      r0,r0,#0x10000        ;653
000800  e1c500b8          STRH     r0,[r5,#8]            ;653
                  |L14.2052|
000804  e3550000          CMP      r5,#0                 ;667
000808  1a00004a          BNE      |L14.2360|
00080c  ea000046          B        |L14.2348|
                  |L14.2064|
                          DCD      0x000001ff
                  |L14.2068|
000814  756e7365          DCB      "unsent_oversize mismatch (pcb->unsent is NULL)",0
000818  6e745f6f
00081c  76657273
000820  697a6520
000824  6d69736d
000828  61746368
00082c  20287063
000830  622d3e75
000834  6e73656e
000838  74206973
00083c  204e554c
000840  4c2900  
000843  00                DCB      0
                  |L14.2116|
                          DCD      0x0000021b
                  |L14.2120|
000848  7463705f          DCB      "tcp_write: check that first pbuf can hold the complete "
00084c  77726974
000850  653a2063
000854  6865636b
000858  20746861
00085c  74206669
000860  72737420
000864  70627566
000868  2063616e
00086c  20686f6c
000870  64207468
000874  6520636f
000878  6d706c65
00087c  746520  
00087f  7365676c          DCB      "seglen",0
000883  656e00  
000886  00                DCB      0
000887  00                DCB      0
                  |L14.2184|
                          DCD      0x00000226
                  |L14.2188|
00088c  6f766572          DCB      "oversize == 0",0
000890  73697a65
000894  203d3d20
000898  3000    
00089a  00                DCB      0
00089b  00                DCB      0
                  |L14.2204|
                          DCD      0x0000fffc
                  |L14.2208|
                          DCD      0x0000025b
                  |L14.2212|
0008a4  70726576          DCB      "prev_seg != NULL",0
0008a8  5f736567
0008ac  20213d20
0008b0  4e554c4c
0008b4  00      
0008b5  00                DCB      0
0008b6  00                DCB      0
0008b7  00                DCB      0
                  |L14.2232|
                          DCD      ||i.tcp_write||+0x320
                  |L14.2236|
                          DCD      0x0000027e
                  |L14.2240|
0008c0  6c617374          DCB      "last_unsent->oversize_left >= oversize_used",0
0008c4  5f756e73
0008c8  656e742d
0008cc  3e6f7665
0008d0  7273697a
0008d4  655f6c65
0008d8  6674203e
0008dc  3d206f76
0008e0  65727369
0008e4  7a655f75
0008e8  73656400
                  |L14.2284|
                          DCD      ||i.tcp_write||+0x378
                  |L14.2288|
                          DCD      0x0000028a
                  |L14.2292|
0008f4  7463705f          DCB      "tcp_write: cannot concatenate when pcb->unsent is empty"
0008f8  77726974
0008fc  653a2063
000900  616e6e6f
000904  7420636f
000908  6e636174
00090c  656e6174
000910  65207768
000914  656e2070
000918  63622d3e
00091c  756e7365
000920  6e742069
000924  7320656d
000928  707479  
00092b  00                DCB      0
                  |L14.2348|
00092c  e59d0034          LDR      r0,[sp,#0x34]         ;668
000930  e584006c          STR      r0,[r4,#0x6c]         ;668
000934  ea000001          B        |L14.2368|
                  |L14.2360|
000938  e59d0034          LDR      r0,[sp,#0x34]         ;670
00093c  e5850000          STR      r0,[r5,#0]            ;670
                  |L14.2368|
000940  e594005c          LDR      r0,[r4,#0x5c]         ;676
000944  e0800007          ADD      r0,r0,r7              ;676
000948  e584005c          STR      r0,[r4,#0x5c]         ;676
00094c  e1d406b6          LDRH     r0,[r4,#0x66]         ;677
000950  e0400007          SUB      r0,r0,r7              ;677
000954  e1c406b6          STRH     r0,[r4,#0x66]         ;677
000958  e59d0030          LDR      r0,[sp,#0x30]         ;678
00095c  e1c406b8          STRH     r0,[r4,#0x68]         ;678
000960  e1d406b8          LDRH     r0,[r4,#0x68]         ;682
000964  e3500000          CMP      r0,#0                 ;682
000968  0a00000e          BEQ      |L14.2472|
00096c  e1a00000          MOV      r0,r0                 ;683
000970  e5940070          LDR      r0,[r4,#0x70]         ;683
000974  e3500000          CMP      r0,#0                 ;683
000978  1a000009          BNE      |L14.2468|
00097c  e594006c          LDR      r0,[r4,#0x6c]         ;683
000980  e3500000          CMP      r0,#0                 ;683
000984  1a000006          BNE      |L14.2468|
000988  e1a00000          MOV      r0,r0                 ;683
00098c  e51f30dc          LDR      r3,|L14.2232|
000990  e59f20ec          LDR      r2,|L14.2692|
000994  e28f10ec          ADR      r1,|L14.2696|
000998  e51f00b4          LDR      r0,|L14.2284|
00099c  ebfffffe          BL       sysprintf
0009a0  e1a00000          MOV      r0,r0                 ;683
                  |L14.2468|
0009a4  e1a00000          MOV      r0,r0                 ;683
                  |L14.2472|
0009a8  e35a0000          CMP      r10,#0                ;688
0009ac  0a000011          BEQ      |L14.2552|
0009b0  e59a0010          LDR      r0,[r10,#0x10]        ;688
0009b4  e3500000          CMP      r0,#0                 ;688
0009b8  0a00000e          BEQ      |L14.2552|
0009bc  e59d0048          LDR      r0,[sp,#0x48]         ;688
0009c0  e2000002          AND      r0,r0,#2              ;688
0009c4  e3500000          CMP      r0,#0                 ;688
0009c8  1a00000a          BNE      |L14.2552|
0009cc  e3a00008          MOV      r0,#8                 ;689
0009d0  ebfffffe          BL       lwip_htons
0009d4  e59a2010          LDR      r2,[r10,#0x10]        ;689
0009d8  e5d2100d          LDRB     r1,[r2,#0xd]          ;689
0009dc  e5d2200c          LDRB     r2,[r2,#0xc]          ;689
0009e0  e1821401          ORR      r1,r2,r1,LSL #8       ;689
0009e4  e1800001          ORR      r0,r0,r1              ;689
0009e8  e59a1010          LDR      r1,[r10,#0x10]        ;689
0009ec  e5c1000c          STRB     r0,[r1,#0xc]          ;689
0009f0  e1a00420          LSR      r0,r0,#8              ;689
0009f4  e5c1000d          STRB     r0,[r1,#0xd]          ;689
                  |L14.2552|
0009f8  e3a00000          MOV      r0,#0                 ;692
0009fc  eafffda8          B        |L14.164|
                  |L14.2560|
000a00  e1a00000          MOV      r0,r0                 ;693
000a04  e5d4001e          LDRB     r0,[r4,#0x1e]         ;694
000a08  e3800080          ORR      r0,r0,#0x80           ;694
000a0c  e5c4001e          STRB     r0,[r4,#0x1e]         ;694
000a10  e35b0000          CMP      r11,#0                ;697
000a14  0a000001          BEQ      |L14.2592|
000a18  e1a0000b          MOV      r0,r11                ;698
000a1c  ebfffffe          BL       pbuf_free
                  |L14.2592|
000a20  e59d0034          LDR      r0,[sp,#0x34]         ;700
000a24  e3500000          CMP      r0,#0                 ;700
000a28  0a000001          BEQ      |L14.2612|
000a2c  e59d0034          LDR      r0,[sp,#0x34]         ;701
000a30  ebfffffe          BL       tcp_segs_free
                  |L14.2612|
000a34  e1d406b8          LDRH     r0,[r4,#0x68]         ;703
000a38  e3500000          CMP      r0,#0                 ;703
000a3c  0a00000e          BEQ      |L14.2684|
000a40  e1a00000          MOV      r0,r0                 ;704
000a44  e5940070          LDR      r0,[r4,#0x70]         ;704
000a48  e3500000          CMP      r0,#0                 ;704
000a4c  1a000009          BNE      |L14.2680|
000a50  e594006c          LDR      r0,[r4,#0x6c]         ;704
000a54  e3500000          CMP      r0,#0                 ;704
000a58  1a000006          BNE      |L14.2680|
000a5c  e1a00000          MOV      r0,r0                 ;704
000a60  e51f31b0          LDR      r3,|L14.2232|
000a64  e3a02d0b          MOV      r2,#0x2c0             ;704
000a68  e28f1018          ADR      r1,|L14.2696|
000a6c  e51f0188          LDR      r0,|L14.2284|
000a70  ebfffffe          BL       sysprintf
000a74  e1a00000          MOV      r0,r0                 ;704
                  |L14.2680|
000a78  e1a00000          MOV      r0,r0                 ;704
                  |L14.2684|
000a7c  e3e00000          MVN      r0,#0                 ;708
000a80  eafffd87          B        |L14.164|
;;;710    
                          ENDP

                  |L14.2692|
                          DCD      0x000002ab
                  |L14.2696|
000a88  7463705f          DCB      "tcp_write: valid queue length",0
000a8c  77726974
000a90  653a2076
000a94  616c6964
000a98  20717565
000a9c  7565206c
000aa0  656e6774
000aa4  6800    
000aa6  00                DCB      0
000aa7  00                DCB      0

                          AREA ||i.tcp_write_checks||, CODE, READONLY, ALIGN=2

                  tcp_write_checks PROC
;;;293    static err_t
;;;294    tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;295    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;296      /* connection is in invalid state for data transmission? */
;;;297      if ((pcb->state != ESTABLISHED) &&
00000c  e5d40018          LDRB     r0,[r4,#0x18]
000010  e3500004          CMP      r0,#4
000014  0a00000a          BEQ      |L15.68|
;;;298          (pcb->state != CLOSE_WAIT) &&
000018  e5d40018          LDRB     r0,[r4,#0x18]
00001c  e3500007          CMP      r0,#7
000020  0a000007          BEQ      |L15.68|
;;;299          (pcb->state != SYN_SENT) &&
000024  e5d40018          LDRB     r0,[r4,#0x18]
000028  e3500002          CMP      r0,#2
00002c  0a000004          BEQ      |L15.68|
;;;300          (pcb->state != SYN_RCVD)) {
000030  e5d40018          LDRB     r0,[r4,#0x18]
000034  e3500003          CMP      r0,#3
000038  0a000001          BEQ      |L15.68|
;;;301        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
;;;302        return ERR_CONN;
00003c  e3e0000c          MVN      r0,#0xc
                  |L15.64|
;;;303      } else if (len == 0) {
;;;304        return ERR_OK;
;;;305      }
;;;306    
;;;307      /* fail on too much data */
;;;308      if (len > pcb->snd_buf) {
;;;309        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
;;;310          len, pcb->snd_buf));
;;;311        pcb->flags |= TF_NAGLEMEMERR;
;;;312        return ERR_MEM;
;;;313      }
;;;314    
;;;315      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;316    
;;;317      /* If total number of pbufs on the unsent/unacked queues exceeds the
;;;318       * configured maximum, return an error */
;;;319      /* check for configured max queuelen and possible overflow */
;;;320      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;321        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
;;;322          pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;323        TCP_STATS_INC(tcp.memerr);
;;;324        pcb->flags |= TF_NAGLEMEMERR;
;;;325        return ERR_MEM;
;;;326      }
;;;327      if (pcb->snd_queuelen != 0) {
;;;328        LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
;;;329          pcb->unacked != NULL || pcb->unsent != NULL);
;;;330      } else {
;;;331        LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
;;;332          pcb->unacked == NULL && pcb->unsent == NULL);
;;;333      }
;;;334      return ERR_OK;
;;;335    }
000040  e8bd8070          POP      {r4-r6,pc}
                  |L15.68|
000044  e3550000          CMP      r5,#0                 ;303
000048  1a000001          BNE      |L15.84|
00004c  e3a00000          MOV      r0,#0                 ;304
000050  eafffffa          B        |L15.64|
                  |L15.84|
000054  e1d406b6          LDRH     r0,[r4,#0x66]         ;308
000058  e1500005          CMP      r0,r5                 ;308
00005c  aa000004          BGE      |L15.116|
000060  e5d4001e          LDRB     r0,[r4,#0x1e]         ;311
000064  e3800080          ORR      r0,r0,#0x80           ;311
000068  e5c4001e          STRB     r0,[r4,#0x1e]         ;311
00006c  e3e00000          MVN      r0,#0                 ;312
000070  eafffff2          B        |L15.64|
                  |L15.116|
000074  e1d406b8          LDRH     r0,[r4,#0x68]         ;320
000078  e3500008          CMP      r0,#8                 ;320
00007c  aa000003          BGE      |L15.144|
000080  e1d406b8          LDRH     r0,[r4,#0x68]         ;320
000084  e59f10a4          LDR      r1,|L15.304|
000088  e1500001          CMP      r0,r1                 ;320
00008c  9a000004          BLS      |L15.164|
                  |L15.144|
000090  e5d4001e          LDRB     r0,[r4,#0x1e]         ;324
000094  e3800080          ORR      r0,r0,#0x80           ;324
000098  e5c4001e          STRB     r0,[r4,#0x1e]         ;324
00009c  e3e00000          MVN      r0,#0                 ;325
0000a0  eaffffe6          B        |L15.64|
                  |L15.164|
0000a4  e1d406b8          LDRH     r0,[r4,#0x68]         ;327
0000a8  e3500000          CMP      r0,#0                 ;327
0000ac  0a00000e          BEQ      |L15.236|
0000b0  e1a00000          MOV      r0,r0                 ;328
0000b4  e5940070          LDR      r0,[r4,#0x70]         ;328
0000b8  e3500000          CMP      r0,#0                 ;328
0000bc  1a000009          BNE      |L15.232|
0000c0  e594006c          LDR      r0,[r4,#0x6c]         ;328
0000c4  e3500000          CMP      r0,#0                 ;328
0000c8  1a000006          BNE      |L15.232|
0000cc  e1a00000          MOV      r0,r0                 ;328
0000d0  e28f305c          ADR      r3,|L15.308|
0000d4  e3a02f52          MOV      r2,#0x148             ;328
0000d8  e28f1074          ADR      r1,|L15.340|
0000dc  e28f00ac          ADR      r0,|L15.400|
0000e0  ebfffffe          BL       sysprintf
0000e4  e1a00000          MOV      r0,r0                 ;328
                  |L15.232|
0000e8  ea00000e          B        |L15.296|
                  |L15.236|
0000ec  e1a00000          MOV      r0,r0                 ;331
0000f0  e5940070          LDR      r0,[r4,#0x70]         ;331
0000f4  e3500000          CMP      r0,#0                 ;331
0000f8  1a000002          BNE      |L15.264|
0000fc  e594006c          LDR      r0,[r4,#0x6c]         ;331
000100  e3500000          CMP      r0,#0                 ;331
000104  0a000006          BEQ      |L15.292|
                  |L15.264|
000108  e1a00000          MOV      r0,r0                 ;331
00010c  e28f3020          ADR      r3,|L15.308|
000110  e59f20a0          LDR      r2,|L15.440|
000114  e28f10a0          ADR      r1,|L15.444|
000118  e28f0070          ADR      r0,|L15.400|
00011c  ebfffffe          BL       sysprintf
000120  e1a00000          MOV      r0,r0                 ;331
                  |L15.292|
000124  e1a00000          MOV      r0,r0                 ;331
                  |L15.296|
000128  e3a00000          MOV      r0,#0                 ;334
00012c  eaffffc3          B        |L15.64|
;;;336    
                          ENDP

                  |L15.304|
                          DCD      0x0000fffc
                  |L15.308|
000134  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_out.c",0
000138  2d312e34
00013c  2e315c73
000140  72635c63
000144  6f72655c
000148  7463705f
00014c  6f75742e
000150  6300    
000152  00                DCB      0
000153  00                DCB      0
                  |L15.340|
000154  7463705f          DCB      "tcp_write: pbufs on queue => at least one queue non-emp"
000158  77726974
00015c  653a2070
000160  62756673
000164  206f6e20
000168  71756575
00016c  65203d3e
000170  20617420
000174  6c656173
000178  74206f6e
00017c  65207175
000180  65756520
000184  6e6f6e2d
000188  656d70  
00018b  747900            DCB      "ty",0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L15.400|
000190  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000194  7274696f
000198  6e202225
00019c  73222066
0001a0  61696c65
0001a4  64206174
0001a8  206c696e
0001ac  65202564
0001b0  20696e20
0001b4  25730a00
                  |L15.440|
                          DCD      0x0000014b
                  |L15.444|
0001bc  7463705f          DCB      "tcp_write: no pbufs on queue => both queues empty",0
0001c0  77726974
0001c4  653a206e
0001c8  6f207062
0001cc  75667320
0001d0  6f6e2071
0001d4  75657565
0001d8  203d3e20
0001dc  626f7468
0001e0  20717565
0001e4  75657320
0001e8  656d7074
0001ec  7900    
0001ee  00                DCB      0
0001ef  00                DCB      0

                          AREA ||i.tcp_zero_window_probe||, CODE, READONLY, ALIGN=2

                  tcp_zero_window_probe PROC
;;;1413   void
;;;1414   tcp_zero_window_probe(struct tcp_pcb *pcb)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1415   {
000004  e1a05000          MOV      r5,r0
;;;1416     struct pbuf *p;
;;;1417     struct tcp_hdr *tcphdr;
;;;1418     struct tcp_seg *seg;
;;;1419     u16_t len;
;;;1420     u8_t is_fin;
;;;1421   
;;;1422     LWIP_DEBUGF(TCP_DEBUG, 
;;;1423                 ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
;;;1424                  U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1425                  ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1426                  ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1427   
;;;1428     LWIP_DEBUGF(TCP_DEBUG, 
;;;1429                 ("tcp_zero_window_probe: tcp_ticks %"U32_F
;;;1430                  "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1431                  tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1432   
;;;1433     seg = pcb->unacked;
000008  e5954070          LDR      r4,[r5,#0x70]
;;;1434   
;;;1435     if(seg == NULL) {
00000c  e3540000          CMP      r4,#0
000010  1a000000          BNE      |L16.24|
;;;1436       seg = pcb->unsent;
000014  e595406c          LDR      r4,[r5,#0x6c]
                  |L16.24|
;;;1437     }
;;;1438     if(seg == NULL) {
000018  e3540000          CMP      r4,#0
00001c  1a000000          BNE      |L16.36|
                  |L16.32|
;;;1439       return;
;;;1440     }
;;;1441   
;;;1442     is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
;;;1443     /* we want to send one seqno: either FIN or data (no options) */
;;;1444     len = is_fin ? 0 : 1;
;;;1445   
;;;1446     p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
;;;1447     if(p == NULL) {
;;;1448       LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
;;;1449       return;
;;;1450     }
;;;1451     tcphdr = (struct tcp_hdr *)p->payload;
;;;1452   
;;;1453     if (is_fin) {
;;;1454       /* FIN segment, no data */
;;;1455       TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
;;;1456     } else {
;;;1457       /* Data segment, copy in one byte from the head of the unacked queue */
;;;1458       char *d = ((char *)p->payload + TCP_HLEN);
;;;1459       /* Depending on whether the segment has already been sent (unacked) or not
;;;1460          (unsent), seg->p->payload points to the IP header or TCP header.
;;;1461          Ensure we copy the first TCP data byte: */
;;;1462       pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
;;;1463     }
;;;1464   
;;;1465   #if CHECKSUM_GEN_TCP
;;;1466     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1467                                         IP_PROTO_TCP, p->tot_len);
;;;1468   #endif
;;;1469     TCP_STATS_INC(tcp.xmit);
;;;1470   
;;;1471     /* Send output to IP */
;;;1472   #if LWIP_NETIF_HWADDRHINT
;;;1473     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1474       &(pcb->addr_hint));
;;;1475   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1476     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
;;;1477   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1478   
;;;1479     pbuf_free(p);
;;;1480   
;;;1481     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
;;;1482                             " ackno %"U32_F".\n",
;;;1483                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1484   }
000020  e8bd87fc          POP      {r2-r10,pc}
                  |L16.36|
000024  e5942010          LDR      r2,[r4,#0x10]         ;1442
000028  e5d2100d          LDRB     r1,[r2,#0xd]          ;1442
00002c  e5d2200c          LDRB     r2,[r2,#0xc]          ;1442
000030  e1820401          ORR      r0,r2,r1,LSL #8       ;1442
000034  ebfffffe          BL       lwip_ntohs
000038  e2000001          AND      r0,r0,#1              ;1442
00003c  e3500000          CMP      r0,#0                 ;1442
000040  0a000004          BEQ      |L16.88|
000044  e1d400b8          LDRH     r0,[r4,#8]            ;1442
000048  e3500000          CMP      r0,#0                 ;1442
00004c  1a000001          BNE      |L16.88|
000050  e3a00001          MOV      r0,#1                 ;1442
000054  ea000000          B        |L16.92|
                  |L16.88|
000058  e3a00000          MOV      r0,#0                 ;1442
                  |L16.92|
00005c  e1a08000          MOV      r8,r0                 ;1442
000060  e3580000          CMP      r8,#0                 ;1444
000064  1a000001          BNE      |L16.112|
000068  e3a00001          MOV      r0,#1                 ;1444
00006c  ea000000          B        |L16.116|
                  |L16.112|
000070  e3a00000          MOV      r0,#0                 ;1444
                  |L16.116|
000074  e1a09000          MOV      r9,r0                 ;1444
000078  e5941010          LDR      r1,[r4,#0x10]         ;1446
00007c  e2810004          ADD      r0,r1,#4              ;1446
000080  ebfffffe          BL       __aeabi_uread4
000084  e1a0a000          MOV      r10,r0                ;1446
000088  e1a0300a          MOV      r3,r10                ;1446
00008c  e1a02009          MOV      r2,r9                 ;1446
000090  e3a01000          MOV      r1,#0                 ;1446
000094  e1a00005          MOV      r0,r5                 ;1446
000098  ebfffffe          BL       tcp_output_alloc_header
00009c  e1a06000          MOV      r6,r0                 ;1446
0000a0  e3560000          CMP      r6,#0                 ;1447
0000a4  1a000000          BNE      |L16.172|
0000a8  eaffffdc          B        |L16.32|
                  |L16.172|
0000ac  e5967004          LDR      r7,[r6,#4]            ;1451
0000b0  e3580000          CMP      r8,#0                 ;1453
0000b4  0a00000b          BEQ      |L16.232|
0000b8  e3a00011          MOV      r0,#0x11              ;1455
0000bc  ebfffffe          BL       lwip_htons
0000c0  e5d7100d          LDRB     r1,[r7,#0xd]          ;1455
0000c4  e5d7200c          LDRB     r2,[r7,#0xc]          ;1455
0000c8  e1821401          ORR      r1,r2,r1,LSL #8       ;1455
0000cc  e59f20a4          LDR      r2,|L16.376|
0000d0  e0011002          AND      r1,r1,r2              ;1455
0000d4  e1800001          ORR      r0,r0,r1              ;1455
0000d8  e5c7000c          STRB     r0,[r7,#0xc]          ;1455
0000dc  e1a00420          LSR      r0,r0,#8              ;1455
0000e0  e5c7000d          STRB     r0,[r7,#0xd]          ;1455
0000e4  ea00000c          B        |L16.284|
                  |L16.232|
0000e8  e5960004          LDR      r0,[r6,#4]            ;1458
0000ec  e280a014          ADD      r10,r0,#0x14          ;1458
0000f0  e5941004          LDR      r1,[r4,#4]            ;1462
0000f4  e1d110b8          LDRH     r1,[r1,#8]            ;1462
0000f8  e1d420b8          LDRH     r2,[r4,#8]            ;1462
0000fc  e0411002          SUB      r1,r1,r2              ;1462
000100  e1a03801          LSL      r3,r1,#16             ;1462
000104  e1a03823          LSR      r3,r3,#16             ;1462
000108  e3a02001          MOV      r2,#1                 ;1462
00010c  e1a0100a          MOV      r1,r10                ;1462
000110  e5940004          LDR      r0,[r4,#4]            ;1462
000114  ebfffffe          BL       pbuf_copy_partial
000118  e1a00000          MOV      r0,r0                 ;1463
                  |L16.284|
00011c  e1d600b8          LDRH     r0,[r6,#8]            ;1466
000120  e3a03006          MOV      r3,#6                 ;1466
000124  e2852004          ADD      r2,r5,#4              ;1466
000128  e1a01005          MOV      r1,r5                 ;1466
00012c  e58d0000          STR      r0,[sp,#0]            ;1466
000130  e1a00006          MOV      r0,r6                 ;1466
000134  ebfffffe          BL       inet_chksum_pseudo
000138  e5c70010          STRB     r0,[r7,#0x10]         ;1466
00013c  e1a00420          LSR      r0,r0,#8              ;1466
000140  e5c70011          STRB     r0,[r7,#0x11]         ;1466
000144  e3a00006          MOV      r0,#6                 ;1476
000148  e3a01000          MOV      r1,#0                 ;1476
00014c  e58d0004          STR      r0,[sp,#4]            ;1476
000150  e58d1000          STR      r1,[sp,#0]            ;1476
000154  e5d5300a          LDRB     r3,[r5,#0xa]          ;1476
000158  e2852004          ADD      r2,r5,#4              ;1476
00015c  e1a01005          MOV      r1,r5                 ;1476
000160  e1a00006          MOV      r0,r6                 ;1476
000164  ebfffffe          BL       ip_output
000168  e1a00006          MOV      r0,r6                 ;1479
00016c  ebfffffe          BL       pbuf_free
000170  e1a00000          MOV      r0,r0
000174  eaffffa9          B        |L16.32|
;;;1485   #endif /* LWIP_TCP */
                          ENDP

                  |L16.376|
                          DCD      0x0000c0ff

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7463705f          DCB      "tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in fl"
000004  656e7175
000008  6575655f
00000c  666c6167
000010  733a206e
000014  65656420
000018  65697468
00001c  65722054
000020  43505f53
000024  594e206f
000028  72205443
00002c  505f4649
000030  4e20696e
000034  20666c  
000037  61677320          DCB      "ags (programmer violates API)",0
00003b  2870726f
00003f  6772616d
000043  6d657220
000047  76696f6c
00004b  61746573
00004f  20415049
000053  2900    
