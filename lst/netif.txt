; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\netif.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\netif.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\netif.crf lwip-1.4.1\src\core\netif.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  netif_init PROC
;;;105    void
;;;106    netif_init(void)
000000  e12fff1e          BX       lr
;;;107    {
;;;108    #if LWIP_HAVE_LOOPIF
;;;109      ip_addr_t loop_ipaddr, loop_netmask, loop_gw;
;;;110      IP4_ADDR(&loop_gw, 127,0,0,1);
;;;111      IP4_ADDR(&loop_ipaddr, 127,0,0,1);
;;;112      IP4_ADDR(&loop_netmask, 255,0,0,0);
;;;113    
;;;114    #if NO_SYS
;;;115      netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, ip_input);
;;;116    #else  /* NO_SYS */
;;;117      netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
;;;118    #endif /* NO_SYS */
;;;119      netif_set_up(&loop_netif);
;;;120    
;;;121    #endif /* LWIP_HAVE_LOOPIF */
;;;122    }
;;;123    
                          ENDP

                  netif_set_gw PROC
;;;387    void
;;;388    netif_set_gw(struct netif *netif, ip_addr_t *gw)
000004  e3510000          CMP      r1,#0
;;;389    {
;;;390      ip_addr_set(&(netif->gw), gw);
000008  15911000          LDRNE    r1,[r1,#0]
00000c  e580100c          STR      r1,[r0,#0xc]
;;;391      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: GW address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;392        netif->name[0], netif->name[1],
;;;393        ip4_addr1_16(&netif->gw),
;;;394        ip4_addr2_16(&netif->gw),
;;;395        ip4_addr3_16(&netif->gw),
;;;396        ip4_addr4_16(&netif->gw)));
;;;397    }
000010  e12fff1e          BX       lr
;;;398    
                          ENDP

                  netif_set_netmask PROC
;;;408    void
;;;409    netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
000014  e3510000          CMP      r1,#0
;;;410    {
;;;411      snmp_delete_iprteidx_tree(0, netif);
;;;412      /* set new netmask to netif */
;;;413      ip_addr_set(&(netif->netmask), netmask);
000018  15911000          LDRNE    r1,[r1,#0]
00001c  e5801008          STR      r1,[r0,#8]
;;;414      snmp_insert_iprteidx_tree(0, netif);
;;;415      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: netmask of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;416        netif->name[0], netif->name[1],
;;;417        ip4_addr1_16(&netif->netmask),
;;;418        ip4_addr2_16(&netif->netmask),
;;;419        ip4_addr3_16(&netif->netmask),
;;;420        ip4_addr4_16(&netif->netmask)));
;;;421    }
000020  e12fff1e          BX       lr
;;;422    
                          ENDP

                  netif_set_ipaddr PROC
;;;322    void
;;;323    netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
000024  e92d4070          PUSH     {r4-r6,lr}
;;;324    {
000028  e1b04001          MOVS     r4,r1
00002c  e1a05000          MOV      r5,r0
000030  0a000025          BEQ      |L1.204|
;;;325      /* TODO: Handling of obsolete pcbs */
;;;326      /* See:  http://mail.gnu.org/archive/html/lwip-users/2003-03/msg00118.html */
;;;327    #if LWIP_TCP
;;;328      struct tcp_pcb *pcb;
;;;329      struct tcp_pcb_listen *lpcb;
;;;330    
;;;331      /* address is actually being changed? */
;;;332      if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
000034  e5940000          LDR      r0,[r4,#0]
000038  e5951004          LDR      r1,[r5,#4]
00003c  e1500001          CMP      r0,r1
;;;333        /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
;;;334        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
;;;335        pcb = tcp_active_pcbs;
000040  159f02c0          LDRNE    r0,|L1.776|
000044  15900000          LDRNE    r0,[r0,#0]  ; tcp_active_pcbs
000048  0a00001c          BEQ      |L1.192|
00004c  ea000007          B        |L1.112|
                  |L1.80|
;;;336        while (pcb != NULL) {
;;;337          /* PCB bound to current local interface address? */
;;;338          if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
000050  e5901000          LDR      r1,[r0,#0]
000054  e5952004          LDR      r2,[r5,#4]
000058  e1510002          CMP      r1,r2
;;;339    #if LWIP_AUTOIP
;;;340            /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
;;;341            && !ip_addr_islinklocal(&(pcb->local_ip))
;;;342    #endif /* LWIP_AUTOIP */
;;;343            ) {
;;;344            /* this connection must be aborted */
;;;345            struct tcp_pcb *next = pcb->next;
;;;346            LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
;;;347            tcp_abort(pcb);
;;;348            pcb = next;
;;;349          } else {
;;;350            pcb = pcb->next;
00005c  1590000c          LDRNE    r0,[r0,#0xc]
000060  1a000002          BNE      |L1.112|
000064  e590600c          LDR      r6,[r0,#0xc]          ;345
000068  ebfffffe          BL       tcp_abort
00006c  e1a00006          MOV      r0,r6                 ;348
                  |L1.112|
000070  e3500000          CMP      r0,#0                 ;336
;;;351          }
;;;352        }
;;;353        for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
000074  059f0290          LDREQ    r0,|L1.780|
000078  05900000          LDREQ    r0,[r0,#0]  ; tcp_listen_pcbs
00007c  1afffff3          BNE      |L1.80|
000080  ea00000a          B        |L1.176|
                  |L1.132|
;;;354          /* PCB bound to current local interface address? */
;;;355          if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
000084  e5901000          LDR      r1,[r0,#0]
000088  e3510000          CMP      r1,#0
00008c  0a000006          BEQ      |L1.172|
;;;356              (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
000090  e5952004          LDR      r2,[r5,#4]
000094  e1510002          CMP      r1,r2
000098  1a000003          BNE      |L1.172|
;;;357            /* The PCB is listening to the old ipaddr and
;;;358             * is set to listen to the new one instead */
;;;359            ip_addr_set(&(lpcb->local_ip), ipaddr);
00009c  e3540000          CMP      r4,#0
0000a0  15941000          LDRNE    r1,[r4,#0]
0000a4  03a01000          MOVEQ    r1,#0
0000a8  e5801000          STR      r1,[r0,#0]
                  |L1.172|
0000ac  e590000c          LDR      r0,[r0,#0xc]          ;353
                  |L1.176|
0000b0  e3500000          CMP      r0,#0                 ;353
0000b4  1afffff2          BNE      |L1.132|
;;;360          }
;;;361        }
;;;362      }
;;;363    #endif
;;;364      snmp_delete_ipaddridx_tree(netif);
;;;365      snmp_delete_iprteidx_tree(0,netif);
;;;366      /* set new IP address to netif */
;;;367      ip_addr_set(&(netif->ip_addr), ipaddr);
0000b8  e3540000          CMP      r4,#0
0000bc  0a000002          BEQ      |L1.204|
                  |L1.192|
0000c0  e5940000          LDR      r0,[r4,#0]
                  |L1.196|
0000c4  e5850004          STR      r0,[r5,#4]
;;;368      snmp_insert_ipaddridx_tree(netif);
;;;369      snmp_insert_iprteidx_tree(0,netif);
;;;370    
;;;371      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: IP address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;372        netif->name[0], netif->name[1],
;;;373        ip4_addr1_16(&netif->ip_addr),
;;;374        ip4_addr2_16(&netif->ip_addr),
;;;375        ip4_addr3_16(&netif->ip_addr),
;;;376        ip4_addr4_16(&netif->ip_addr)));
;;;377    }
0000c8  e8bd8070          POP      {r4-r6,pc}
                  |L1.204|
0000cc  e3a00000          MOV      r0,#0                 ;367
0000d0  eafffffb          B        |L1.196|
;;;378    
                          ENDP

                  netif_set_addr PROC
;;;220    void
;;;221    netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
0000d4  e92d4070          PUSH     {r4-r6,lr}
;;;222        ip_addr_t *gw)
;;;223    {
0000d8  e1a05003          MOV      r5,r3
0000dc  e1a06002          MOV      r6,r2
0000e0  e1a04000          MOV      r4,r0
;;;224      netif_set_ipaddr(netif, ipaddr);
0000e4  ebfffffe          BL       netif_set_ipaddr
;;;225      netif_set_netmask(netif, netmask);
0000e8  e1a01006          MOV      r1,r6
0000ec  e1a00004          MOV      r0,r4
0000f0  ebfffffe          BL       netif_set_netmask
;;;226      netif_set_gw(netif, gw);
0000f4  e1a01005          MOV      r1,r5
0000f8  e1a00004          MOV      r0,r4
0000fc  e8bd4070          POP      {r4-r6,lr}
000100  eafffffe          B        netif_set_gw
;;;227    }
;;;228    
                          ENDP

                  netif_add PROC
;;;138    struct netif *
;;;139    netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
000104  e92d47f0          PUSH     {r4-r10,lr}
;;;140      ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
;;;141    {
000108  e59d5024          LDR      r5,[sp,#0x24]
00010c  e59d6028          LDR      r6,[sp,#0x28]
;;;142    
;;;143      LWIP_ASSERT("No init function given", init != NULL);
000110  e59da020          LDR      r10,[sp,#0x20]
000114  e3550000          CMP      r5,#0
000118  e1a07003          MOV      r7,r3                 ;141
00011c  e1a08002          MOV      r8,r2                 ;141
000120  e1a09001          MOV      r9,r1                 ;141
000124  e1a04000          MOV      r4,r0                 ;141
000128  1a000004          BNE      |L1.320|
00012c  e28f3f77          ADR      r3,|L1.784|
000130  e3a0208f          MOV      r2,#0x8f
000134  e28f1e1f          ADR      r1,|L1.812|
000138  e28f0f81          ADR      r0,|L1.836|
00013c  ebfffffe          BL       sysprintf
                  |L1.320|
;;;144    
;;;145      /* reset new interface configuration state */
;;;146      ip_addr_set_zero(&netif->ip_addr);
000140  e3a00000          MOV      r0,#0
;;;147      ip_addr_set_zero(&netif->netmask);
000144  e5840004          STR      r0,[r4,#4]
;;;148      ip_addr_set_zero(&netif->gw);
000148  e5840008          STR      r0,[r4,#8]
00014c  e584000c          STR      r0,[r4,#0xc]
;;;149      netif->flags = 0;
000150  e5c4002d          STRB     r0,[r4,#0x2d]
;;;150    #if LWIP_DHCP
;;;151      /* netif not under DHCP control by default */
;;;152      netif->dhcp = NULL;
;;;153    #endif /* LWIP_DHCP */
;;;154    #if LWIP_AUTOIP
;;;155      /* netif not under AutoIP control by default */
;;;156      netif->autoip = NULL;
;;;157    #endif /* LWIP_AUTOIP */
;;;158    #if LWIP_NETIF_STATUS_CALLBACK
;;;159      netif->status_callback = NULL;
;;;160    #endif /* LWIP_NETIF_STATUS_CALLBACK */
;;;161    #if LWIP_NETIF_LINK_CALLBACK
;;;162      netif->link_callback = NULL;
;;;163    #endif /* LWIP_NETIF_LINK_CALLBACK */
;;;164    #if LWIP_IGMP
;;;165      netif->igmp_mac_filter = NULL;
;;;166    #endif /* LWIP_IGMP */
;;;167    #if ENABLE_LOOPBACK
;;;168      netif->loop_first = NULL;
;;;169      netif->loop_last = NULL;
;;;170    #endif /* ENABLE_LOOPBACK */
;;;171    
;;;172      /* remember netif specific state information data */
;;;173      netif->state = state;
000154  e584a01c          STR      r10,[r4,#0x1c]
;;;174      netif->num = netif_num++;
000158  e59fa20c          LDR      r10,|L1.876|
00015c  e5840020          STR      r0,[r4,#0x20]
000160  e5da0000          LDRB     r0,[r10,#0]  ; netif_num
;;;175      netif->input = input;
;;;176      NETIF_SET_HWADDRHINT(netif, NULL);
;;;177    #if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
;;;178      netif->loop_cnt_current = 0;
;;;179    #endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */
;;;180    
;;;181      netif_set_addr(netif, ipaddr, netmask, gw);
000164  e1a03007          MOV      r3,r7
000168  e1a02008          MOV      r2,r8
00016c  e5c40030          STRB     r0,[r4,#0x30]         ;174
000170  e2800001          ADD      r0,r0,#1              ;174
000174  e5ca0000          STRB     r0,[r10,#0]           ;174  ; netif_num
000178  e1a01009          MOV      r1,r9
00017c  e1a00004          MOV      r0,r4
000180  e5846010          STR      r6,[r4,#0x10]
000184  ebfffffe          BL       netif_set_addr
;;;182    
;;;183      /* call user specified initialization function for netif */
;;;184      if (init(netif) != ERR_OK) {
000188  e1a00004          MOV      r0,r4
00018c  e12fff35          BLX      r5
000190  e3500000          CMP      r0,#0
;;;185        return NULL;
;;;186      }
;;;187    
;;;188      /* add this netif to the list */
;;;189      netif->next = netif_list;
000194  059a0004          LDREQ    r0,[r10,#4]  ; netif_list
000198  13a00000          MOVNE    r0,#0                 ;185
00019c  05840000          STREQ    r0,[r4,#0]
;;;190      netif_list = netif;
;;;191      snmp_inc_iflist();
;;;192    
;;;193    #if LWIP_IGMP
;;;194      /* start IGMP processing */
;;;195      if (netif->flags & NETIF_FLAG_IGMP) {
;;;196        igmp_start(netif);
;;;197      }
;;;198    #endif /* LWIP_IGMP */
;;;199    
;;;200      LWIP_DEBUGF(NETIF_DEBUG, ("netif: added interface %c%c IP addr ",
;;;201        netif->name[0], netif->name[1]));
;;;202      ip_addr_debug_print(NETIF_DEBUG, ipaddr);
;;;203      LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
;;;204      ip_addr_debug_print(NETIF_DEBUG, netmask);
;;;205      LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
;;;206      ip_addr_debug_print(NETIF_DEBUG, gw);
;;;207      LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
;;;208      return netif;
0001a0  01a00004          MOVEQ    r0,r4
0001a4  058a4004          STREQ    r4,[r10,#4]           ;190  ; netif_list
;;;209    }
0001a8  e8bd87f0          POP      {r4-r10,pc}
;;;210    
                          ENDP

                  netif_set_default PROC
;;;429    void
;;;430    netif_set_default(struct netif *netif)
0001ac  e59f11b8          LDR      r1,|L1.876|
;;;431    {
;;;432      if (netif == NULL) {
;;;433        /* remove default route */
;;;434        snmp_delete_iprteidx_tree(1, netif);
;;;435      } else {
;;;436        /* install default route */
;;;437        snmp_insert_iprteidx_tree(1, netif);
;;;438      }
;;;439      netif_default = netif;
0001b0  e5810008          STR      r0,[r1,#8]  ; netif_default
;;;440      LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
;;;441               netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
;;;442    }
0001b4  e12fff1e          BX       lr
;;;443    
                          ENDP

                  netif_set_down PROC
;;;489     */ 
;;;490    void netif_set_down(struct netif *netif)
0001b8  e5d0102d          LDRB     r1,[r0,#0x2d]
;;;491    {
;;;492      if (netif->flags & NETIF_FLAG_UP) {
0001bc  e3110001          TST      r1,#1
;;;493        netif->flags &= ~NETIF_FLAG_UP;
0001c0  13c11001          BICNE    r1,r1,#1
0001c4  15c0102d          STRBNE   r1,[r0,#0x2d]
;;;494    #if LWIP_SNMP
;;;495        snmp_get_sysuptime(&netif->ts);
;;;496    #endif
;;;497    
;;;498    #if LWIP_ARP
;;;499        if (netif->flags & NETIF_FLAG_ETHARP) {
0001c8  13110020          TSTNE    r1,#0x20
;;;500          etharp_cleanup_netif(netif);
;;;501        }
;;;502    #endif /* LWIP_ARP */
;;;503        NETIF_STATUS_CALLBACK(netif);
;;;504      }
;;;505    }
0001cc  012fff1e          BXEQ     lr
0001d0  eafffffe          B        etharp_cleanup_netif
;;;506    
                          ENDP

                  netif_remove PROC
;;;234    void
;;;235    netif_remove(struct netif *netif)
0001d4  e92d4010          PUSH     {r4,lr}
;;;236    {
0001d8  e1b04000          MOVS     r4,r0
;;;237      if (netif == NULL) {
;;;238        return;
;;;239      }
;;;240    
;;;241    #if LWIP_IGMP
;;;242      /* stop IGMP processing */
;;;243      if (netif->flags & NETIF_FLAG_IGMP) {
;;;244        igmp_stop(netif);
;;;245      }
;;;246    #endif /* LWIP_IGMP */
;;;247      if (netif_is_up(netif)) {
;;;248        /* set netif down before removing (call callback function) */
;;;249        netif_set_down(netif);
;;;250      }
;;;251    
;;;252      snmp_delete_ipaddridx_tree(netif);
;;;253    
;;;254      /*  is it the first netif? */
;;;255      if (netif_list == netif) {
;;;256        netif_list = netif->next;
;;;257      } else {
;;;258        /*  look for netif further down the list */
;;;259        struct netif * tmpNetif;
;;;260        for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
;;;261          if (tmpNetif->next == netif) {
;;;262            tmpNetif->next = netif->next;
;;;263            break;
;;;264          }
;;;265        }
;;;266        if (tmpNetif == NULL)
;;;267          return; /*  we didn't find any netif today */
;;;268      }
;;;269      snmp_dec_iflist();
;;;270      /* this netif is default? */
;;;271      if (netif_default == netif) {
;;;272        /* reset default netif */
;;;273        netif_set_default(NULL);
;;;274      }
;;;275    #if LWIP_NETIF_REMOVE_CALLBACK
;;;276      if (netif->remove_callback) {
;;;277        netif->remove_callback(netif);
;;;278      }
;;;279    #endif /* LWIP_NETIF_REMOVE_CALLBACK */
;;;280      LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
;;;281    }
0001dc  08bd8010          POPEQ    {r4,pc}
0001e0  e5d4002d          LDRB     r0,[r4,#0x2d]         ;247
0001e4  e3100001          TST      r0,#1                 ;247
0001e8  11a00004          MOVNE    r0,r4                 ;249
0001ec  1bfffffe          BLNE     netif_set_down
0001f0  e59f2174          LDR      r2,|L1.876|
0001f4  e5921004          LDR      r1,[r2,#4]            ;255  ; netif_list
0001f8  e1510004          CMP      r1,r4                 ;255
0001fc  05940000          LDREQ    r0,[r4,#0]            ;256
000200  05820004          STREQ    r0,[r2,#4]            ;256  ; netif_list
000204  0a000009          BEQ      |L1.560|
                  |L1.520|
000208  e3510000          CMP      r1,#0                 ;260
00020c  08bd8010          POPEQ    {r4,pc}
000210  e5910000          LDR      r0,[r1,#0]            ;261
000214  e1500004          CMP      r0,r4                 ;261
000218  11a01000          MOVNE    r1,r0                 ;260
00021c  1afffff9          BNE      |L1.520|
000220  e5940000          LDR      r0,[r4,#0]            ;262
000224  e3510000          CMP      r1,#0                 ;266
000228  e5810000          STR      r0,[r1,#0]            ;262
00022c  08bd8010          POPEQ    {r4,pc}
                  |L1.560|
000230  e5920008          LDR      r0,[r2,#8]            ;271  ; netif_default
000234  e1500004          CMP      r0,r4                 ;271
000238  03a00000          MOVEQ    r0,#0                 ;273
00023c  05820008          STREQ    r0,[r2,#8]            ;273  ; netif_default
000240  e8bd8010          POP      {r4,pc}
;;;282    
                          ENDP

                  netif_find PROC
;;;289    struct netif *
;;;290    netif_find(char *name)
000244  e1b01000          MOVS     r1,r0
;;;291    {
;;;292      struct netif *netif;
;;;293      u8_t num;
;;;294    
;;;295      if (name == NULL) {
;;;296        return NULL;
;;;297      }
;;;298    
;;;299      num = name[2] - '0';
000248  15d10002          LDRBNE   r0,[r1,#2]
00024c  12400030          SUBNE    r0,r0,#0x30
000250  120020ff          ANDNE    r2,r0,#0xff
;;;300    
;;;301      for(netif = netif_list; netif != NULL; netif = netif->next) {
000254  159f0110          LDRNE    r0,|L1.876|
000258  15900004          LDRNE    r0,[r0,#4]  ; netif_list
;;;302        if (num == netif->num &&
;;;303           name[0] == netif->name[0] &&
;;;304           name[1] == netif->name[1]) {
;;;305          LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
;;;306          return netif;
;;;307        }
;;;308      }
;;;309      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
;;;310      return NULL;
;;;311    }
00025c  012fff1e          BXEQ     lr
                  |L1.608|
000260  e3500000          CMP      r0,#0                 ;301
000264  012fff1e          BXEQ     lr
000268  e5d03030          LDRB     r3,[r0,#0x30]         ;302
00026c  e1530002          CMP      r3,r2                 ;302
000270  05d13000          LDRBEQ   r3,[r1,#0]            ;303
000274  05d0c02e          LDRBEQ   r12,[r0,#0x2e]        ;303
000278  0153000c          CMPEQ    r3,r12                ;303
00027c  05d13001          LDRBEQ   r3,[r1,#1]            ;304
000280  05d0c02f          LDRBEQ   r12,[r0,#0x2f]        ;304
000284  0153000c          CMPEQ    r3,r12                ;304
000288  15900000          LDRNE    r0,[r0,#0]            ;301
00028c  1afffff3          BNE      |L1.608|
000290  e12fff1e          BX       lr
;;;312    
                          ENDP

                  netif_set_up PROC
;;;452     */ 
;;;453    void netif_set_up(struct netif *netif)
000294  e5d0102d          LDRB     r1,[r0,#0x2d]
;;;454    {
;;;455      if (!(netif->flags & NETIF_FLAG_UP)) {
000298  e3110001          TST      r1,#1
;;;456        netif->flags |= NETIF_FLAG_UP;
;;;457        
;;;458    #if LWIP_SNMP
;;;459        snmp_get_sysuptime(&netif->ts);
;;;460    #endif /* LWIP_SNMP */
;;;461    
;;;462        NETIF_STATUS_CALLBACK(netif);
;;;463    
;;;464        if (netif->flags & NETIF_FLAG_LINK_UP) {
;;;465    #if LWIP_ARP
;;;466          /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
;;;467          if (netif->flags & (NETIF_FLAG_ETHARP)) {
;;;468            etharp_gratuitous(netif);
;;;469          }
;;;470    #endif /* LWIP_ARP */
;;;471    
;;;472    #if LWIP_IGMP
;;;473          /* resend IGMP memberships */
;;;474          if (netif->flags & NETIF_FLAG_IGMP) {
;;;475            igmp_report_groups( netif);
;;;476          }
;;;477    #endif /* LWIP_IGMP */
;;;478        }
;;;479      }
;;;480    }
00029c  112fff1e          BXNE     lr
0002a0  e3811001          ORR      r1,r1,#1              ;456
0002a4  e3110010          TST      r1,#0x10              ;464
0002a8  13110020          TSTNE    r1,#0x20              ;467
0002ac  e5c0102d          STRB     r1,[r0,#0x2d]         ;456
0002b0  012fff1e          BXEQ     lr
0002b4  e2801004          ADD      r1,r0,#4              ;468
0002b8  eafffffe          B        etharp_request
;;;481    
                          ENDP

                  netif_set_link_up PROC
;;;534     */
;;;535    void netif_set_link_up(struct netif *netif )
0002bc  e92d4010          PUSH     {r4,lr}
;;;536    {
0002c0  e1a04000          MOV      r4,r0
;;;537      if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
0002c4  e5d0002d          LDRB     r0,[r0,#0x2d]
0002c8  e3100010          TST      r0,#0x10
;;;538        netif->flags |= NETIF_FLAG_LINK_UP;
;;;539    
;;;540    #if LWIP_DHCP
;;;541        if (netif->dhcp) {
;;;542          dhcp_network_changed(netif);
;;;543        }
;;;544    #endif /* LWIP_DHCP */
;;;545    
;;;546    #if LWIP_AUTOIP
;;;547        if (netif->autoip) {
;;;548          autoip_network_changed(netif);
;;;549        }
;;;550    #endif /* LWIP_AUTOIP */
;;;551    
;;;552        if (netif->flags & NETIF_FLAG_UP) {
;;;553    #if LWIP_ARP
;;;554          /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
;;;555          if (netif->flags & NETIF_FLAG_ETHARP) {
;;;556            etharp_gratuitous(netif);
;;;557          }
;;;558    #endif /* LWIP_ARP */
;;;559    
;;;560    #if LWIP_IGMP
;;;561          /* resend IGMP memberships */
;;;562          if (netif->flags & NETIF_FLAG_IGMP) {
;;;563            igmp_report_groups( netif);
;;;564          }
;;;565    #endif /* LWIP_IGMP */
;;;566        }
;;;567        NETIF_LINK_CALLBACK(netif);
;;;568      }
;;;569    }
0002cc  18bd8010          POPNE    {r4,pc}
0002d0  e3800010          ORR      r0,r0,#0x10           ;538
0002d4  e5c4002d          STRB     r0,[r4,#0x2d]         ;538
0002d8  e5940020          LDR      r0,[r4,#0x20]         ;541
0002dc  e3500000          CMP      r0,#0                 ;541
0002e0  11a00004          MOVNE    r0,r4                 ;542
0002e4  1bfffffe          BLNE     dhcp_network_changed
0002e8  e5d4002d          LDRB     r0,[r4,#0x2d]         ;552
0002ec  e3100001          TST      r0,#1                 ;552
0002f0  13100020          TSTNE    r0,#0x20              ;555
0002f4  08bd8010          POPEQ    {r4,pc}
0002f8  e2841004          ADD      r1,r4,#4              ;556
0002fc  e1a00004          MOV      r0,r4                 ;556
000300  e8bd4010          POP      {r4,lr}               ;556
000304  eafffffe          B        etharp_request
                  |L1.776|
                          DCD      tcp_active_pcbs
                  |L1.780|
                          DCD      tcp_listen_pcbs
                  |L1.784|
000310  6c776970          DCB      "lwip-1.4.1\\src\\core\\netif.c",0
000314  2d312e34
000318  2e315c73
00031c  72635c63
000320  6f72655c
000324  6e657469
000328  662e6300
                  |L1.812|
00032c  4e6f2069          DCB      "No init function given",0
000330  6e697420
000334  66756e63
000338  74696f6e
00033c  20676976
000340  656e00  
000343  00                DCB      0
                  |L1.836|
000344  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000348  7274696f
00034c  6e202225
000350  73222066
000354  61696c65
000358  64206174
00035c  206c696e
000360  65202564
000364  20696e20
000368  25730a00
                  |L1.876|
                          DCD      ||.data||
                          ENDP

                  netif_set_link_down PROC
;;;573     */
;;;574    void netif_set_link_down(struct netif *netif )
000370  e5d0102d          LDRB     r1,[r0,#0x2d]
;;;575    {
;;;576      if (netif->flags & NETIF_FLAG_LINK_UP) {
000374  e3110010          TST      r1,#0x10
;;;577        netif->flags &= ~NETIF_FLAG_LINK_UP;
000378  13c11010          BICNE    r1,r1,#0x10
00037c  15c0102d          STRBNE   r1,[r0,#0x2d]
;;;578        NETIF_LINK_CALLBACK(netif);
;;;579      }
;;;580    }
000380  e12fff1e          BX       lr
;;;581    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  netif_num
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  netif_list
                          DCD      0x00000000
                  netif_default
                          DCD      0x00000000
