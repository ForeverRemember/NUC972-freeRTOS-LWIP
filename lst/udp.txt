; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\udp.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\udp.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -D__UVISION_VERSION=524 --omf_browse=.\obj\udp.crf lwip-1.4.1\src\core\udp.c]
                          ARM

                          AREA ||i.udp_bind||, CODE, READONLY, ALIGN=2

                  udp_bind PROC
;;;765    err_t
;;;766    udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;767    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a07002          MOV      r7,r2
;;;768      struct udp_pcb *ipcb;
;;;769      u8_t rebind;
;;;770    
;;;771      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
;;;772      ip_addr_debug_print(UDP_DEBUG, ipaddr);
;;;773      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));
;;;774    
;;;775      rebind = 0;
000010  e3a08000          MOV      r8,#0
;;;776      /* Check for double bind and rebind of the same pcb */
;;;777      for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
000014  e59f00f8          LDR      r0,|L1.276|
000018  e5904000          LDR      r4,[r0,#0]  ; udp_pcbs
00001c  ea000022          B        |L1.172|
                  |L1.32|
;;;778        /* is this UDP PCB already on active list? */
;;;779        if (pcb == ipcb) {
000020  e1550004          CMP      r5,r4
000024  1a00000c          BNE      |L1.92|
;;;780          /* pcb may occur at most once in active list */
;;;781          LWIP_ASSERT("rebind == 0", rebind == 0);
000028  e1a00000          MOV      r0,r0
00002c  e3580000          CMP      r8,#0
000030  0a000006          BEQ      |L1.80|
000034  e1a00000          MOV      r0,r0
000038  e28f30d8          ADR      r3,|L1.280|
00003c  e59f20f0          LDR      r2,|L1.308|
000040  e28f10f0          ADR      r1,|L1.312|
000044  e28f00f8          ADR      r0,|L1.324|
000048  ebfffffe          BL       sysprintf
00004c  e1a00000          MOV      r0,r0
                  |L1.80|
000050  e1a00000          MOV      r0,r0
;;;782          /* pcb already in list, just rebind */
;;;783          rebind = 1;
000054  e3a08001          MOV      r8,#1
000058  ea000012          B        |L1.168|
                  |L1.92|
;;;784        }
;;;785    
;;;786        /* By default, we don't allow to bind to a port that any other udp
;;;787           PCB is alread bound to, unless *all* PCBs with that port have tha
;;;788           REUSEADDR flag set. */
;;;789    #if SO_REUSE
;;;790        else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
;;;791                 !ip_get_option(ipcb, SOF_REUSEADDR)) {
;;;792    #else /* SO_REUSE */
;;;793        /* port matches that of PCB in list and REUSEADDR not set -> reject */
;;;794        else {
;;;795    #endif /* SO_REUSE */
;;;796          if ((ipcb->local_port == port) &&
00005c  e1d401b2          LDRH     r0,[r4,#0x12]
000060  e1500007          CMP      r0,r7
000064  1a00000f          BNE      |L1.168|
;;;797              /* IP address matches, or one is IP_ADDR_ANY? */
;;;798              (ip_addr_isany(&(ipcb->local_ip)) ||
000068  e3540000          CMP      r4,#0
00006c  0a00000b          BEQ      |L1.160|
000070  e5940000          LDR      r0,[r4,#0]
000074  e3500000          CMP      r0,#0
000078  0a000008          BEQ      |L1.160|
;;;799               ip_addr_isany(ipaddr) ||
00007c  e3560000          CMP      r6,#0
000080  0a000006          BEQ      |L1.160|
000084  e5960000          LDR      r0,[r6,#0]
000088  e3500000          CMP      r0,#0
00008c  0a000003          BEQ      |L1.160|
;;;800               ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
000090  e5940000          LDR      r0,[r4,#0]
000094  e5961000          LDR      r1,[r6,#0]
000098  e1500001          CMP      r0,r1
00009c  1a000001          BNE      |L1.168|
                  |L1.160|
;;;801            /* other PCB already binds to this local IP and port */
;;;802            LWIP_DEBUGF(UDP_DEBUG,
;;;803                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
;;;804            return ERR_USE;
0000a0  e3e00007          MVN      r0,#7
                  |L1.164|
;;;805          }
;;;806        }
;;;807      }
;;;808    
;;;809      ip_addr_set(&pcb->local_ip, ipaddr);
;;;810    
;;;811      /* no port specified? */
;;;812      if (port == 0) {
;;;813        port = udp_new_port();
;;;814        if (port == 0) {
;;;815          /* no more ports available in local range */
;;;816          LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
;;;817          return ERR_USE;
;;;818        }
;;;819      }
;;;820      pcb->local_port = port;
;;;821      snmp_insert_udpidx_tree(pcb);
;;;822      /* pcb not active yet? */
;;;823      if (rebind == 0) {
;;;824        /* place the PCB on the active list if not already there */
;;;825        pcb->next = udp_pcbs;
;;;826        udp_pcbs = pcb;
;;;827      }
;;;828      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
;;;829                  ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
;;;830                   ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
;;;831                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
;;;832                   pcb->local_port));
;;;833      return ERR_OK;
;;;834    }
0000a4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.168|
0000a8  e594400c          LDR      r4,[r4,#0xc]          ;777
                  |L1.172|
0000ac  e3540000          CMP      r4,#0                 ;777
0000b0  1affffda          BNE      |L1.32|
0000b4  e3560000          CMP      r6,#0                 ;809
0000b8  1a000001          BNE      |L1.196|
0000bc  e3a00000          MOV      r0,#0                 ;809
0000c0  ea000000          B        |L1.200|
                  |L1.196|
0000c4  e5960000          LDR      r0,[r6,#0]            ;809
                  |L1.200|
0000c8  e5850000          STR      r0,[r5,#0]            ;809
0000cc  e3570000          CMP      r7,#0                 ;812
0000d0  1a000005          BNE      |L1.236|
0000d4  ebfffffe          BL       udp_new_port
0000d8  e1a07000          MOV      r7,r0                 ;813
0000dc  e3570000          CMP      r7,#0                 ;814
0000e0  1a000001          BNE      |L1.236|
0000e4  e3e00007          MVN      r0,#7                 ;817
0000e8  eaffffed          B        |L1.164|
                  |L1.236|
0000ec  e1c571b2          STRH     r7,[r5,#0x12]         ;820
0000f0  e3580000          CMP      r8,#0                 ;823
0000f4  1a000004          BNE      |L1.268|
0000f8  e59f0014          LDR      r0,|L1.276|
0000fc  e5900000          LDR      r0,[r0,#0]            ;825  ; udp_pcbs
000100  e585000c          STR      r0,[r5,#0xc]          ;825
000104  e59f0008          LDR      r0,|L1.276|
000108  e5805000          STR      r5,[r0,#0]            ;826  ; udp_pcbs
                  |L1.268|
00010c  e3a00000          MOV      r0,#0                 ;833
000110  eaffffe3          B        |L1.164|
;;;835    /**
                          ENDP

                  |L1.276|
                          DCD      udp_pcbs
                  |L1.280|
000118  6c776970          DCB      "lwip-1.4.1\\src\\core\\udp.c",0
00011c  2d312e34
000120  2e315c73
000124  72635c63
000128  6f72655c
00012c  7564702e
000130  6300    
000132  00                DCB      0
000133  00                DCB      0
                  |L1.308|
                          DCD      0x0000030d
                  |L1.312|
000138  72656269          DCB      "rebind == 0",0
00013c  6e64203d
000140  3d203000
                  |L1.324|
000144  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000148  7274696f
00014c  6e202225
000150  73222066
000154  61696c65
000158  64206174
00015c  206c696e
000160  65202564
000164  20696e20
000168  25730a00

                          AREA ||i.udp_connect||, CODE, READONLY, ALIGN=2

                  udp_connect PROC
;;;852    err_t
;;;853    udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;854    {
000004  e1a04000          MOV      r4,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a07002          MOV      r7,r2
;;;855      struct udp_pcb *ipcb;
;;;856    
;;;857      if (pcb->local_port == 0) {
000010  e1d401b2          LDRH     r0,[r4,#0x12]
000014  e3500000          CMP      r0,#0
000018  1a000009          BNE      |L2.68|
;;;858        err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
00001c  e1d421b2          LDRH     r2,[r4,#0x12]
000020  e1a01004          MOV      r1,r4
000024  e1a00004          MOV      r0,r4
000028  ebfffffe          BL       udp_bind
00002c  e1a08000          MOV      r8,r0
;;;859        if (err != ERR_OK) {
000030  e3580000          CMP      r8,#0
000034  0a000001          BEQ      |L2.64|
;;;860          return err;
000038  e1a00008          MOV      r0,r8
                  |L2.60|
;;;861        }
;;;862      }
;;;863    
;;;864      ip_addr_set(&pcb->remote_ip, ipaddr);
;;;865      pcb->remote_port = port;
;;;866      pcb->flags |= UDP_FLAGS_CONNECTED;
;;;867    /** TODO: this functionality belongs in upper layers */
;;;868    #ifdef LWIP_UDP_TODO
;;;869      /* Nail down local IP for netconn_addr()/getsockname() */
;;;870      if (ip_addr_isany(&pcb->local_ip) && !ip_addr_isany(&pcb->remote_ip)) {
;;;871        struct netif *netif;
;;;872    
;;;873        if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {
;;;874          LWIP_DEBUGF(UDP_DEBUG, ("udp_connect: No route to 0x%lx\n", pcb->remote_ip.addr));
;;;875          UDP_STATS_INC(udp.rterr);
;;;876          return ERR_RTE;
;;;877        }
;;;878        /** TODO: this will bind the udp pcb locally, to the interface which
;;;879            is used to route output packets to the remote address. However, we
;;;880            might want to accept incoming packets on any interface! */
;;;881        pcb->local_ip = netif->ip_addr;
;;;882      } else if (ip_addr_isany(&pcb->remote_ip)) {
;;;883        pcb->local_ip.addr = 0;
;;;884      }
;;;885    #endif
;;;886      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
;;;887                  ("udp_connect: connected to %"U16_F".%"U16_F".%"U16_F".%"U16_F",port %"U16_F"\n",
;;;888                   ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
;;;889                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
;;;890                   pcb->local_port));
;;;891    
;;;892      /* Insert UDP PCB into the list of active UDP PCBs. */
;;;893      for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
;;;894        if (pcb == ipcb) {
;;;895          /* already on the list, just return */
;;;896          return ERR_OK;
;;;897        }
;;;898      }
;;;899      /* PCB not yet on the list, add PCB now */
;;;900      pcb->next = udp_pcbs;
;;;901      udp_pcbs = pcb;
;;;902      return ERR_OK;
;;;903    }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L2.64|
000040  e1a00000          MOV      r0,r0                 ;862
                  |L2.68|
000044  e3560000          CMP      r6,#0                 ;864
000048  1a000001          BNE      |L2.84|
00004c  e3a00000          MOV      r0,#0                 ;864
000050  ea000000          B        |L2.88|
                  |L2.84|
000054  e5960000          LDR      r0,[r6,#0]            ;864
                  |L2.88|
000058  e5840004          STR      r0,[r4,#4]            ;864
00005c  e1c471b4          STRH     r7,[r4,#0x14]         ;865
000060  e5d40010          LDRB     r0,[r4,#0x10]         ;866
000064  e3800004          ORR      r0,r0,#4              ;866
000068  e5c40010          STRB     r0,[r4,#0x10]         ;866
00006c  e59f003c          LDR      r0,|L2.176|
000070  e5905000          LDR      r5,[r0,#0]            ;893  ; udp_pcbs
000074  ea000004          B        |L2.140|
                  |L2.120|
000078  e1540005          CMP      r4,r5                 ;894
00007c  1a000001          BNE      |L2.136|
000080  e3a00000          MOV      r0,#0                 ;896
000084  eaffffec          B        |L2.60|
                  |L2.136|
000088  e595500c          LDR      r5,[r5,#0xc]          ;893
                  |L2.140|
00008c  e3550000          CMP      r5,#0                 ;893
000090  1afffff8          BNE      |L2.120|
000094  e59f0014          LDR      r0,|L2.176|
000098  e5900000          LDR      r0,[r0,#0]            ;900  ; udp_pcbs
00009c  e584000c          STR      r0,[r4,#0xc]          ;900
0000a0  e59f0008          LDR      r0,|L2.176|
0000a4  e5804000          STR      r4,[r0,#0]            ;901  ; udp_pcbs
0000a8  e3a00000          MOV      r0,#0                 ;902
0000ac  eaffffe2          B        |L2.60|
;;;904    
                          ENDP

                  |L2.176|
                          DCD      udp_pcbs

                          AREA ||i.udp_disconnect||, CODE, READONLY, ALIGN=2

                  udp_disconnect PROC
;;;910    void
;;;911    udp_disconnect(struct udp_pcb *pcb)
000000  e3a01000          MOV      r1,#0
;;;912    {
;;;913      /* reset remote address association */
;;;914      ip_addr_set_any(&pcb->remote_ip);
000004  e5801004          STR      r1,[r0,#4]
;;;915      pcb->remote_port = 0;
000008  e1c011b4          STRH     r1,[r0,#0x14]
;;;916      /* mark PCB as unconnected */
;;;917      pcb->flags &= ~UDP_FLAGS_CONNECTED;
00000c  e5d01010          LDRB     r1,[r0,#0x10]
000010  e3c11004          BIC      r1,r1,#4
000014  e5c01010          STRB     r1,[r0,#0x10]
;;;918    }
000018  e12fff1e          BX       lr
;;;919    
                          ENDP


                          AREA ||i.udp_init||, CODE, READONLY, ALIGN=2

                  udp_init PROC
;;;85     void
;;;86     udp_init(void)
000000  e12fff1e          BX       lr
;;;87     {
;;;88     #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;89       udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;90     #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;91     }
;;;92     
                          ENDP


                          AREA ||i.udp_input||, CODE, READONLY, ALIGN=2

                  udp_input PROC
;;;150    void
;;;151    udp_input(struct pbuf *p, struct netif *inp)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;152    {
000004  e1a06000          MOV      r6,r0
000008  e1a05001          MOV      r5,r1
;;;153      struct udp_hdr *udphdr;
;;;154      struct udp_pcb *pcb, *prev;
;;;155      struct udp_pcb *uncon_pcb;
;;;156      struct ip_hdr *iphdr;
;;;157      u16_t src, dest;
;;;158      u8_t local_match;
;;;159      u8_t broadcast;
;;;160    
;;;161      PERF_START;
;;;162    
;;;163      UDP_STATS_INC(udp.recv);
;;;164    
;;;165      iphdr = (struct ip_hdr *)p->payload;
00000c  e5969004          LDR      r9,[r6,#4]
;;;166    
;;;167      /* Check minimum length (IP header + UDP header)
;;;168       * and move payload pointer to UDP header */
;;;169      if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
000010  e1d610b8          LDRH     r1,[r6,#8]
000014  e5d90000          LDRB     r0,[r9,#0]
000018  e200000f          AND      r0,r0,#0xf
00001c  e3a02008          MOV      r2,#8
000020  e0820100          ADD      r0,r2,r0,LSL #2
000024  e1510000          CMP      r1,r0
000028  ba000007          BLT      |L5.76|
00002c  e5d90000          LDRB     r0,[r9,#0]
000030  e1a00e00          LSL      r0,r0,#28
000034  e1a00d20          LSR      r0,r0,#26
000038  e2601000          RSB      r1,r0,#0
00003c  e1a00006          MOV      r0,r6
000040  ebfffffe          BL       pbuf_header
000044  e3500000          CMP      r0,#0
000048  0a000002          BEQ      |L5.88|
                  |L5.76|
;;;170        /* drop short packets */
;;;171        LWIP_DEBUGF(UDP_DEBUG,
;;;172                    ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
;;;173        UDP_STATS_INC(udp.lenerr);
;;;174        UDP_STATS_INC(udp.drop);
;;;175        snmp_inc_udpinerrors();
;;;176        pbuf_free(p);
00004c  e1a00006          MOV      r0,r6
000050  ebfffffe          BL       pbuf_free
;;;177        goto end;
000054  ea0000e2          B        |L5.996|
                  |L5.88|
;;;178      }
;;;179    
;;;180      udphdr = (struct udp_hdr *)p->payload;
000058  e5967004          LDR      r7,[r6,#4]
;;;181    
;;;182      /* is broadcast packet ? */
;;;183      broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
00005c  e59f1384          LDR      r1,|L5.1000|
000060  e5910000          LDR      r0,[r1,#0]  ; current_iphdr_dest
000064  e1a01005          MOV      r1,r5
000068  ebfffffe          BL       ip4_addr_isbroadcast
00006c  e58d0004          STR      r0,[sp,#4]
;;;184    
;;;185      LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));
;;;186    
;;;187      /* convert src and dest ports to host byte order */
;;;188      src = ntohs(udphdr->src);
000070  e5d71001          LDRB     r1,[r7,#1]
000074  e5d72000          LDRB     r2,[r7,#0]
000078  e1820401          ORR      r0,r2,r1,LSL #8
00007c  ebfffffe          BL       lwip_ntohs
000080  e1a0a000          MOV      r10,r0
;;;189      dest = ntohs(udphdr->dest);
000084  e5d71003          LDRB     r1,[r7,#3]
000088  e5d72002          LDRB     r2,[r7,#2]
00008c  e1820401          ORR      r0,r2,r1,LSL #8
000090  ebfffffe          BL       lwip_ntohs
000094  e1a0b000          MOV      r11,r0
;;;190    
;;;191      udp_debug_print(udphdr);
;;;192    
;;;193      /* print the UDP source and destination */
;;;194      LWIP_DEBUGF(UDP_DEBUG,
;;;195                  ("udp (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") <-- "
;;;196                   "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
;;;197                   ip4_addr1_16(&iphdr->dest), ip4_addr2_16(&iphdr->dest),
;;;198                   ip4_addr3_16(&iphdr->dest), ip4_addr4_16(&iphdr->dest), ntohs(udphdr->dest),
;;;199                   ip4_addr1_16(&iphdr->src), ip4_addr2_16(&iphdr->src),
;;;200                   ip4_addr3_16(&iphdr->src), ip4_addr4_16(&iphdr->src), ntohs(udphdr->src)));
;;;201    
;;;202    #if LWIP_DHCP
;;;203      pcb = NULL;
000098  e3a04000          MOV      r4,#0
;;;204      /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
;;;205         the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
;;;206      if (dest == DHCP_CLIENT_PORT) {
00009c  e35b0044          CMP      r11,#0x44
0000a0  1a00001c          BNE      |L5.280|
;;;207        /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
;;;208        if (src == DHCP_SERVER_PORT) {
0000a4  e35a0043          CMP      r10,#0x43
0000a8  1a000071          BNE      |L5.628|
;;;209          if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
0000ac  e5950020          LDR      r0,[r5,#0x20]
0000b0  e3500000          CMP      r0,#0
0000b4  0a00006e          BEQ      |L5.628|
0000b8  e5950020          LDR      r0,[r5,#0x20]
0000bc  e5900004          LDR      r0,[r0,#4]
0000c0  e3500000          CMP      r0,#0
0000c4  0a00006a          BEQ      |L5.628|
;;;210            /* accept the packe if 
;;;211               (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
;;;212               - inp->dhcp->pcb->remote == ANY or iphdr->src */
;;;213            if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
0000c8  e5950020          LDR      r0,[r5,#0x20]
0000cc  e5900004          LDR      r0,[r0,#4]
0000d0  e2800004          ADD      r0,r0,#4
0000d4  e3500000          CMP      r0,#0
0000d8  0a00000b          BEQ      |L5.268|
0000dc  e5950020          LDR      r0,[r5,#0x20]
0000e0  e5900004          LDR      r0,[r0,#4]
0000e4  e5900004          LDR      r0,[r0,#4]
0000e8  e3500000          CMP      r0,#0
0000ec  0a000006          BEQ      |L5.268|
;;;214               ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
0000f0  e5950020          LDR      r0,[r5,#0x20]
0000f4  e5900004          LDR      r0,[r0,#4]
0000f8  e5900004          LDR      r0,[r0,#4]
0000fc  e59f12e8          LDR      r1,|L5.1004|
000100  e5911000          LDR      r1,[r1,#0]  ; current_iphdr_src
000104  e1500001          CMP      r0,r1
000108  1a000059          BNE      |L5.628|
                  |L5.268|
;;;215              pcb = inp->dhcp->pcb;
00010c  e5950020          LDR      r0,[r5,#0x20]
000110  e5904004          LDR      r4,[r0,#4]
000114  ea000056          B        |L5.628|
                  |L5.280|
;;;216            }
;;;217          }
;;;218        }
;;;219      } else
;;;220    #endif /* LWIP_DHCP */
;;;221      {
;;;222        prev = NULL;
000118  e3a08000          MOV      r8,#0
;;;223        local_match = 0;
00011c  e3a00000          MOV      r0,#0
000120  e58d0008          STR      r0,[sp,#8]
;;;224        uncon_pcb = NULL;
000124  e58d000c          STR      r0,[sp,#0xc]
;;;225        /* Iterate through the UDP pcb list for a matching pcb.
;;;226         * 'Perfect match' pcbs (connected to the remote port & ip address) are
;;;227         * preferred. If no perfect match is found, the first unconnected pcb that
;;;228         * matches the local port and ip address gets the datagram. */
;;;229        for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
000128  e59f02c0          LDR      r0,|L5.1008|
00012c  e5904000          LDR      r4,[r0,#0]  ; udp_pcbs
000130  ea000049          B        |L5.604|
                  |L5.308|
;;;230          local_match = 0;
000134  e3a00000          MOV      r0,#0
000138  e58d0008          STR      r0,[sp,#8]
;;;231          /* print the PCB local and remote address */
;;;232          LWIP_DEBUGF(UDP_DEBUG,
;;;233                      ("pcb (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") --- "
;;;234                       "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
;;;235                       ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
;;;236                       ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
;;;237                       ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;238                       ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));
;;;239    
;;;240          /* compare PCB local addr+port to UDP destination addr+port */
;;;241          if (pcb->local_port == dest) {
00013c  e1d401b2          LDRH     r0,[r4,#0x12]
000140  e150000b          CMP      r0,r11
000144  1a000027          BNE      |L5.488|
;;;242            if (
000148  e59d0004          LDR      r0,[sp,#4]
00014c  e3500000          CMP      r0,#0
000150  1a000004          BNE      |L5.360|
;;;243               (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
000154  e3540000          CMP      r4,#0
000158  0a000018          BEQ      |L5.448|
00015c  e5940000          LDR      r0,[r4,#0]
000160  e3500000          CMP      r0,#0
000164  0a000015          BEQ      |L5.448|
                  |L5.360|
;;;244               ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
000168  e59f1278          LDR      r1,|L5.1000|
00016c  e5940000          LDR      r0,[r4,#0]
000170  e5911000          LDR      r1,[r1,#0]  ; current_iphdr_dest
000174  e1500001          CMP      r0,r1
000178  0a000010          BEQ      |L5.448|
;;;245    #if LWIP_IGMP
;;;246               ip_addr_ismulticast(&current_iphdr_dest) ||
;;;247    #endif /* LWIP_IGMP */
;;;248    #if IP_SOF_BROADCAST_RECV
;;;249                (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
;;;250                 (ip_addr_isany(&pcb->local_ip) ||
;;;251                  ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
;;;252    #else /* IP_SOF_BROADCAST_RECV */
;;;253                (broadcast &&
00017c  e59d0004          LDR      r0,[sp,#4]
000180  e3500000          CMP      r0,#0
000184  0a000017          BEQ      |L5.488|
;;;254                 (ip_addr_isany(&pcb->local_ip) ||
000188  e3540000          CMP      r4,#0
00018c  0a00000b          BEQ      |L5.448|
000190  e5940000          LDR      r0,[r4,#0]
000194  e3500000          CMP      r0,#0
000198  0a000008          BEQ      |L5.448|
;;;255                  ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
00019c  e5940000          LDR      r0,[r4,#0]
0001a0  e5951008          LDR      r1,[r5,#8]
0001a4  e0000001          AND      r0,r0,r1
0001a8  e59f1238          LDR      r1,|L5.1000|
0001ac  e5911000          LDR      r1,[r1,#0]  ; current_iphdr_dest
0001b0  e5952008          LDR      r2,[r5,#8]
0001b4  e0011002          AND      r1,r1,r2
0001b8  e1500001          CMP      r0,r1
0001bc  1a000009          BNE      |L5.488|
                  |L5.448|
;;;256    #endif /* IP_SOF_BROADCAST_RECV */ 
;;;257              local_match = 1;
0001c0  e3a00001          MOV      r0,#1
0001c4  e58d0008          STR      r0,[sp,#8]
;;;258              if ((uncon_pcb == NULL) && 
0001c8  e59d000c          LDR      r0,[sp,#0xc]
0001cc  e3500000          CMP      r0,#0
0001d0  1a000004          BNE      |L5.488|
;;;259                  ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
0001d4  e5d40010          LDRB     r0,[r4,#0x10]
0001d8  e2000004          AND      r0,r0,#4
0001dc  e3500000          CMP      r0,#0
0001e0  1a000000          BNE      |L5.488|
;;;260                /* the first unconnected matching PCB */
;;;261                uncon_pcb = pcb;
0001e4  e58d400c          STR      r4,[sp,#0xc]
                  |L5.488|
;;;262              }
;;;263            }
;;;264          }
;;;265          /* compare PCB remote addr+port to UDP source addr+port */
;;;266          if ((local_match != 0) &&
0001e8  e59d0008          LDR      r0,[sp,#8]
0001ec  e3500000          CMP      r0,#0
0001f0  0a000017          BEQ      |L5.596|
;;;267              (pcb->remote_port == src) &&
0001f4  e1d401b4          LDRH     r0,[r4,#0x14]
0001f8  e150000a          CMP      r0,r10
0001fc  1a000014          BNE      |L5.596|
;;;268              (ip_addr_isany(&pcb->remote_ip) ||
000200  e2840004          ADD      r0,r4,#4
000204  e3500000          CMP      r0,#0
000208  0a000007          BEQ      |L5.556|
00020c  e5940004          LDR      r0,[r4,#4]
000210  e3500000          CMP      r0,#0
000214  0a000004          BEQ      |L5.556|
;;;269               ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
000218  e59f11cc          LDR      r1,|L5.1004|
00021c  e5940004          LDR      r0,[r4,#4]
000220  e5911000          LDR      r1,[r1,#0]  ; current_iphdr_src
000224  e1500001          CMP      r0,r1
000228  1a000009          BNE      |L5.596|
                  |L5.556|
;;;270            /* the first fully matching PCB */
;;;271            if (prev != NULL) {
00022c  e3580000          CMP      r8,#0
000230  0a000006          BEQ      |L5.592|
;;;272              /* move the pcb to the front of udp_pcbs so that is
;;;273                 found faster next time */
;;;274              prev->next = pcb->next;
000234  e594000c          LDR      r0,[r4,#0xc]
000238  e588000c          STR      r0,[r8,#0xc]
;;;275              pcb->next = udp_pcbs;
00023c  e59f01ac          LDR      r0,|L5.1008|
000240  e5900000          LDR      r0,[r0,#0]  ; udp_pcbs
000244  e584000c          STR      r0,[r4,#0xc]
;;;276              udp_pcbs = pcb;
000248  e59f01a0          LDR      r0,|L5.1008|
00024c  e5804000          STR      r4,[r0,#0]  ; udp_pcbs
                  |L5.592|
;;;277            } else {
;;;278              UDP_STATS_INC(udp.cachehit);
;;;279            }
;;;280            break;
000250  ea000003          B        |L5.612|
                  |L5.596|
;;;281          }
;;;282          prev = pcb;
000254  e1a08004          MOV      r8,r4
000258  e594400c          LDR      r4,[r4,#0xc]          ;229
                  |L5.604|
00025c  e3540000          CMP      r4,#0                 ;229
000260  1affffb3          BNE      |L5.308|
                  |L5.612|
000264  e1a00000          MOV      r0,r0                 ;280
;;;283        }
;;;284        /* no fully matching pcb found? then look for an unconnected pcb */
;;;285        if (pcb == NULL) {
000268  e3540000          CMP      r4,#0
00026c  1a000000          BNE      |L5.628|
;;;286          pcb = uncon_pcb;
000270  e59d400c          LDR      r4,[sp,#0xc]
                  |L5.628|
;;;287        }
;;;288      }
;;;289    
;;;290      /* Check checksum if this is a match or if it was directed at us. */
;;;291      if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
000274  e3540000          CMP      r4,#0
000278  1a000004          BNE      |L5.656|
00027c  e59f1164          LDR      r1,|L5.1000|
000280  e5950004          LDR      r0,[r5,#4]
000284  e5911000          LDR      r1,[r1,#0]  ; current_iphdr_dest
000288  e1500001          CMP      r0,r1
00028c  1a000051          BNE      |L5.984|
                  |L5.656|
;;;292        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
;;;293    #if LWIP_UDPLITE
;;;294        if (IPH_PROTO(iphdr) == IP_PROTO_UDPLITE) {
;;;295          /* Do the UDP Lite checksum */
;;;296    #if CHECKSUM_CHECK_UDP
;;;297          u16_t chklen = ntohs(udphdr->len);
;;;298          if (chklen < sizeof(struct udp_hdr)) {
;;;299            if (chklen == 0) {
;;;300              /* For UDP-Lite, checksum length of 0 means checksum
;;;301                 over the complete packet (See RFC 3828 chap. 3.1) */
;;;302              chklen = p->tot_len;
;;;303            } else {
;;;304              /* At least the UDP-Lite header must be covered by the
;;;305                 checksum! (Again, see RFC 3828 chap. 3.1) */
;;;306              UDP_STATS_INC(udp.chkerr);
;;;307              UDP_STATS_INC(udp.drop);
;;;308              snmp_inc_udpinerrors();
;;;309              pbuf_free(p);
;;;310              goto end;
;;;311            }
;;;312          }
;;;313          if (inet_chksum_pseudo_partial(p, &current_iphdr_src, &current_iphdr_dest,
;;;314                                 IP_PROTO_UDPLITE, p->tot_len, chklen) != 0) {
;;;315           LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;316                       ("udp_input: UDP Lite datagram discarded due to failing checksum\n"));
;;;317            UDP_STATS_INC(udp.chkerr);
;;;318            UDP_STATS_INC(udp.drop);
;;;319            snmp_inc_udpinerrors();
;;;320            pbuf_free(p);
;;;321            goto end;
;;;322          }
;;;323    #endif /* CHECKSUM_CHECK_UDP */
;;;324        } else
;;;325    #endif /* LWIP_UDPLITE */
;;;326        {
;;;327    #if CHECKSUM_CHECK_UDP
;;;328          if (udphdr->chksum != 0) {
000290  e5d70007          LDRB     r0,[r7,#7]
000294  e5d71006          LDRB     r1,[r7,#6]
000298  e1810400          ORR      r0,r1,r0,LSL #8
00029c  e3500000          CMP      r0,#0
0002a0  0a00000b          BEQ      |L5.724|
;;;329            if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
0002a4  e1d600b8          LDRH     r0,[r6,#8]
0002a8  e3a03011          MOV      r3,#0x11
0002ac  e59f2134          LDR      r2,|L5.1000|
0002b0  e59f1134          LDR      r1,|L5.1004|
0002b4  e58d0000          STR      r0,[sp,#0]
0002b8  e1a00006          MOV      r0,r6
0002bc  ebfffffe          BL       inet_chksum_pseudo
0002c0  e3500000          CMP      r0,#0
0002c4  0a000002          BEQ      |L5.724|
;;;330                                   IP_PROTO_UDP, p->tot_len) != 0) {
;;;331              LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;332                          ("udp_input: UDP datagram discarded due to failing checksum\n"));
;;;333              UDP_STATS_INC(udp.chkerr);
;;;334              UDP_STATS_INC(udp.drop);
;;;335              snmp_inc_udpinerrors();
;;;336              pbuf_free(p);
0002c8  e1a00006          MOV      r0,r6
0002cc  ebfffffe          BL       pbuf_free
;;;337              goto end;
0002d0  ea000043          B        |L5.996|
                  |L5.724|
;;;338            }
;;;339          }
;;;340    #endif /* CHECKSUM_CHECK_UDP */
;;;341        }
;;;342        if(pbuf_header(p, -UDP_HLEN)) {
0002d4  e3e01007          MVN      r1,#7
0002d8  e1a00006          MOV      r0,r6
0002dc  ebfffffe          BL       pbuf_header
0002e0  e3500000          CMP      r0,#0
0002e4  0a00000b          BEQ      |L5.792|
;;;343          /* Can we cope with this failing? Just assert for now */
;;;344          LWIP_ASSERT("pbuf_header failed\n", 0);
0002e8  e1a00000          MOV      r0,r0
0002ec  e1a00000          MOV      r0,r0
0002f0  e28f30fc          ADR      r3,|L5.1012|
0002f4  e3a02f56          MOV      r2,#0x158
0002f8  e28f1e11          ADR      r1,|L5.1040|
0002fc  e28f0e12          ADR      r0,|L5.1060|
000300  ebfffffe          BL       sysprintf
000304  e1a00000          MOV      r0,r0
000308  e1a00000          MOV      r0,r0
;;;345          UDP_STATS_INC(udp.drop);
;;;346          snmp_inc_udpinerrors();
;;;347          pbuf_free(p);
00030c  e1a00006          MOV      r0,r6
000310  ebfffffe          BL       pbuf_free
;;;348          goto end;
000314  ea000032          B        |L5.996|
                  |L5.792|
;;;349        }
;;;350        if (pcb != NULL) {
000318  e3540000          CMP      r4,#0
00031c  0a00000d          BEQ      |L5.856|
;;;351          snmp_inc_udpindatagrams();
;;;352    #if SO_REUSE && SO_REUSE_RXTOALL
;;;353          if ((broadcast || ip_addr_ismulticast(&current_iphdr_dest)) &&
;;;354              ip_get_option(pcb, SOF_REUSEADDR)) {
;;;355            /* pass broadcast- or multicast packets to all multicast pcbs
;;;356               if SOF_REUSEADDR is set on the first match */
;;;357            struct udp_pcb *mpcb;
;;;358            u8_t p_header_changed = 0;
;;;359            for (mpcb = udp_pcbs; mpcb != NULL; mpcb = mpcb->next) {
;;;360              if (mpcb != pcb) {
;;;361                /* compare PCB local addr+port to UDP destination addr+port */
;;;362                if ((mpcb->local_port == dest) &&
;;;363                    ((!broadcast && ip_addr_isany(&mpcb->local_ip)) ||
;;;364                     ip_addr_cmp(&(mpcb->local_ip), &current_iphdr_dest) ||
;;;365    #if LWIP_IGMP
;;;366                     ip_addr_ismulticast(&current_iphdr_dest) ||
;;;367    #endif /* LWIP_IGMP */
;;;368    #if IP_SOF_BROADCAST_RECV
;;;369                     (broadcast && ip_get_option(mpcb, SOF_BROADCAST)))) {
;;;370    #else  /* IP_SOF_BROADCAST_RECV */
;;;371                     (broadcast))) {
;;;372    #endif /* IP_SOF_BROADCAST_RECV */
;;;373                  /* pass a copy of the packet to all local matches */
;;;374                  if (mpcb->recv != NULL) {
;;;375                    struct pbuf *q;
;;;376                    /* for that, move payload to IP header again */
;;;377                    if (p_header_changed == 0) {
;;;378                      pbuf_header(p, (s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
;;;379                      p_header_changed = 1;
;;;380                    }
;;;381                    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;382                    if (q != NULL) {
;;;383                      err_t err = pbuf_copy(q, p);
;;;384                      if (err == ERR_OK) {
;;;385                        /* move payload to UDP data */
;;;386                        pbuf_header(q, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
;;;387                        mpcb->recv(mpcb->recv_arg, mpcb, q, ip_current_src_addr(), src);
;;;388                      }
;;;389                    }
;;;390                  }
;;;391                }
;;;392              }
;;;393            }
;;;394            if (p_header_changed) {
;;;395              /* and move payload to UDP data again */
;;;396              pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
;;;397            }
;;;398          }
;;;399    #endif /* SO_REUSE && SO_REUSE_RXTOALL */
;;;400          /* callback */
;;;401          if (pcb->recv != NULL) {
000320  e5940018          LDR      r0,[r4,#0x18]
000324  e3500000          CMP      r0,#0
000328  0a000007          BEQ      |L5.844|
;;;402            /* now the recv function is responsible for freeing p */
;;;403            pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
00032c  e58da000          STR      r10,[sp,#0]
000330  e59f30b4          LDR      r3,|L5.1004|
000334  e1a02006          MOV      r2,r6
000338  e594001c          LDR      r0,[r4,#0x1c]
00033c  e594c018          LDR      r12,[r4,#0x18]
000340  e1a01004          MOV      r1,r4
000344  e12fff3c          BLX      r12
000348  ea000024          B        |L5.992|
                  |L5.844|
;;;404          } else {
;;;405            /* no recv function registered? then we have to free the pbuf! */
;;;406            pbuf_free(p);
00034c  e1a00006          MOV      r0,r6
000350  ebfffffe          BL       pbuf_free
;;;407            goto end;
000354  ea000022          B        |L5.996|
                  |L5.856|
;;;408          }
;;;409        } else {
;;;410          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
;;;411    
;;;412    #if LWIP_ICMP
;;;413          /* No match was found, send ICMP destination port unreachable unless
;;;414             destination address was broadcast/multicast. */
;;;415          if (!broadcast &&
000358  e59d0004          LDR      r0,[sp,#4]
00035c  e3500000          CMP      r0,#0
000360  1a000019          BNE      |L5.972|
;;;416              !ip_addr_ismulticast(&current_iphdr_dest)) {
000364  e59f007c          LDR      r0,|L5.1000|
000368  e5d00000          LDRB     r0,[r0,#0]  ; current_iphdr_dest
00036c  e20000f0          AND      r0,r0,#0xf0
000370  e35000e0          CMP      r0,#0xe0
000374  0a000014          BEQ      |L5.972|
;;;417            /* move payload pointer back to ip header */
;;;418            pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
000378  e5d90000          LDRB     r0,[r9,#0]
00037c  e200000f          AND      r0,r0,#0xf
000380  e3a02008          MOV      r2,#8
000384  e0821100          ADD      r1,r2,r0,LSL #2
000388  e1a00006          MOV      r0,r6
00038c  ebfffffe          BL       pbuf_header
;;;419            LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
000390  e1a00000          MOV      r0,r0
000394  e5960004          LDR      r0,[r6,#4]
000398  e1500009          CMP      r0,r9
00039c  0a000006          BEQ      |L5.956|
0003a0  e1a00000          MOV      r0,r0
0003a4  e28f3048          ADR      r3,|L5.1012|
0003a8  e59f209c          LDR      r2,|L5.1100|
0003ac  e28f109c          ADR      r1,|L5.1104|
0003b0  e28f006c          ADR      r0,|L5.1060|
0003b4  ebfffffe          BL       sysprintf
0003b8  e1a00000          MOV      r0,r0
                  |L5.956|
0003bc  e1a00000          MOV      r0,r0
;;;420            icmp_dest_unreach(p, ICMP_DUR_PORT);
0003c0  e3a01003          MOV      r1,#3
0003c4  e1a00006          MOV      r0,r6
0003c8  ebfffffe          BL       icmp_dest_unreach
                  |L5.972|
;;;421          }
;;;422    #endif /* LWIP_ICMP */
;;;423          UDP_STATS_INC(udp.proterr);
;;;424          UDP_STATS_INC(udp.drop);
;;;425          snmp_inc_udpnoports();
;;;426          pbuf_free(p);
0003cc  e1a00006          MOV      r0,r6
0003d0  ebfffffe          BL       pbuf_free
0003d4  ea000001          B        |L5.992|
                  |L5.984|
;;;427        }
;;;428      } else {
;;;429        pbuf_free(p);
0003d8  e1a00006          MOV      r0,r6
0003dc  ebfffffe          BL       pbuf_free
                  |L5.992|
;;;430      }
;;;431    end:
0003e0  e1a00000          MOV      r0,r0
                  |L5.996|
;;;432      PERF_STOP("udp_input");
;;;433    }
0003e4  e8bd9fff          POP      {r0-r12,pc}
;;;434    
                          ENDP

                  |L5.1000|
                          DCD      current_iphdr_dest
                  |L5.1004|
                          DCD      current_iphdr_src
                  |L5.1008|
                          DCD      udp_pcbs
                  |L5.1012|
0003f4  6c776970          DCB      "lwip-1.4.1\\src\\core\\udp.c",0
0003f8  2d312e34
0003fc  2e315c73
000400  72635c63
000404  6f72655c
000408  7564702e
00040c  6300    
00040e  00                DCB      0
00040f  00                DCB      0
                  |L5.1040|
000410  70627566          DCB      "pbuf_header failed\n",0
000414  5f686561
000418  64657220
00041c  6661696c
000420  65640a00
                  |L5.1060|
000424  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000428  7274696f
00042c  6e202225
000430  73222066
000434  61696c65
000438  64206174
00043c  206c696e
000440  65202564
000444  20696e20
000448  25730a00
                  |L5.1100|
                          DCD      0x000001a3
                  |L5.1104|
000450  702d3e70          DCB      "p->payload == iphdr",0
000454  61796c6f
000458  6164203d
00045c  3d206970
000460  68647200

                          AREA ||i.udp_new||, CODE, READONLY, ALIGN=2

                  udp_new PROC
;;;976    struct udp_pcb *
;;;977    udp_new(void)
000000  e92d4010          PUSH     {r4,lr}
;;;978    {
;;;979      struct udp_pcb *pcb;
;;;980      pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
000004  e3a00000          MOV      r0,#0
000008  ebfffffe          BL       memp_malloc
00000c  e1a04000          MOV      r4,r0
;;;981      /* could allocate UDP PCB? */
;;;982      if (pcb != NULL) {
000010  e3540000          CMP      r4,#0
000014  0a000004          BEQ      |L6.44|
;;;983        /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
;;;984         * which means checksum is generated over the whole datagram per default
;;;985         * (recommended as default by RFC 3828). */
;;;986        /* initialize PCB to all zeroes */
;;;987        memset(pcb, 0, sizeof(struct udp_pcb));
000018  e3a01020          MOV      r1,#0x20
00001c  e1a00004          MOV      r0,r4
000020  ebfffffe          BL       __aeabi_memclr4
;;;988        pcb->ttl = UDP_TTL;
000024  e3a000ff          MOV      r0,#0xff
000028  e5c4000a          STRB     r0,[r4,#0xa]
                  |L6.44|
;;;989      }
;;;990      return pcb;
00002c  e1a00004          MOV      r0,r4
;;;991    }
000030  e8bd8010          POP      {r4,pc}
;;;992    
                          ENDP


                          AREA ||i.udp_new_port||, CODE, READONLY, ALIGN=2

                  udp_new_port PROC
;;;98     static u16_t
;;;99     udp_new_port(void)
000000  e3a02000          MOV      r2,#0
;;;100    {
;;;101      u16_t n = 0;
;;;102      struct udp_pcb *pcb;
;;;103      
;;;104    again:
000004  e1a00000          MOV      r0,r0
                  |L7.8|
;;;105      if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
000008  e59f008c          LDR      r0,|L7.156|
00000c  e1d000b0          LDRH     r0,[r0,#0]  ; udp_port
000010  e59f3084          LDR      r3,|L7.156|
000014  e1d330b0          LDRH     r3,[r3,#0]  ; udp_port
000018  e2833001          ADD      r3,r3,#1
00001c  e3c33801          BIC      r3,r3,#0x10000
000020  e59fc074          LDR      r12,|L7.156|
000024  e1cc30b0          STRH     r3,[r12,#0]  ; udp_port
000028  e59f3070          LDR      r3,|L7.160|
00002c  e1500003          CMP      r0,r3
000030  1a000002          BNE      |L7.64|
;;;106        udp_port = UDP_LOCAL_PORT_RANGE_START;
000034  e3a00903          MOV      r0,#0xc000
000038  e28c3000          ADD      r3,r12,#0
00003c  e1c300b0          STRH     r0,[r3,#0]  ; udp_port
                  |L7.64|
;;;107      }
;;;108      /* Check all PCBs. */
;;;109      for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
000040  e59f005c          LDR      r0,|L7.164|
000044  e5901000          LDR      r1,[r0,#0]  ; udp_pcbs
000048  ea00000e          B        |L7.136|
                  |L7.76|
;;;110        if (pcb->local_port == udp_port) {
00004c  e1d101b2          LDRH     r0,[r1,#0x12]
000050  e59f3044          LDR      r3,|L7.156|
000054  e1d330b0          LDRH     r3,[r3,#0]  ; udp_port
000058  e1500003          CMP      r0,r3
00005c  1a000008          BNE      |L7.132|
;;;111          if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
000060  e2820001          ADD      r0,r2,#1
000064  e1a00800          LSL      r0,r0,#16
000068  e1a00820          LSR      r0,r0,#16
00006c  e1a02000          MOV      r2,r0
000070  e3500901          CMP      r0,#0x4000
000074  ba000001          BLT      |L7.128|
;;;112            return 0;
000078  e3a00000          MOV      r0,#0
                  |L7.124|
;;;113          }
;;;114          goto again;
;;;115        }
;;;116      }
;;;117      return udp_port;
;;;118    #if 0
;;;119      struct udp_pcb *ipcb = udp_pcbs;
;;;120      while ((ipcb != NULL) && (udp_port != UDP_LOCAL_PORT_RANGE_END)) {
;;;121        if (ipcb->local_port == udp_port) {
;;;122          /* port is already used by another udp_pcb */
;;;123          udp_port++;
;;;124          /* restart scanning all udp pcbs */
;;;125          ipcb = udp_pcbs;
;;;126        } else {
;;;127          /* go on with next udp pcb */
;;;128          ipcb = ipcb->next;
;;;129        }
;;;130      }
;;;131      if (ipcb != NULL) {
;;;132        return 0;
;;;133      }
;;;134      return udp_port;
;;;135    #endif
;;;136    }
00007c  e12fff1e          BX       lr
                  |L7.128|
000080  eaffffe0          B        |L7.8|
                  |L7.132|
000084  e591100c          LDR      r1,[r1,#0xc]          ;109
                  |L7.136|
000088  e3510000          CMP      r1,#0                 ;109
00008c  1affffee          BNE      |L7.76|
000090  e59f0004          LDR      r0,|L7.156|
000094  e1d000b0          LDRH     r0,[r0,#0]            ;117  ; udp_port
000098  eafffff7          B        |L7.124|
;;;137    
                          ENDP

                  |L7.156|
                          DCD      udp_port
                  |L7.160|
                          DCD      0x0000ffff
                  |L7.164|
                          DCD      udp_pcbs

                          AREA ||i.udp_recv||, CODE, READONLY, ALIGN=2

                  udp_recv PROC
;;;929    void
;;;930    udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
000000  e5801018          STR      r1,[r0,#0x18]
;;;931    {
;;;932      /* remember recv() callback and user data */
;;;933      pcb->recv = recv;
;;;934      pcb->recv_arg = recv_arg;
000004  e580201c          STR      r2,[r0,#0x1c]
;;;935    }
000008  e12fff1e          BX       lr
;;;936    
                          ENDP


                          AREA ||i.udp_remove||, CODE, READONLY, ALIGN=2

                  udp_remove PROC
;;;945    void
;;;946    udp_remove(struct udp_pcb *pcb)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;947    {
000004  e1a05000          MOV      r5,r0
;;;948      struct udp_pcb *pcb2;
;;;949    
;;;950      snmp_delete_udpidx_tree(pcb);
;;;951      /* pcb to be removed is first in list? */
;;;952      if (udp_pcbs == pcb) {
000008  e59f0068          LDR      r0,|L9.120|
00000c  e5900000          LDR      r0,[r0,#0]  ; udp_pcbs
000010  e1500005          CMP      r0,r5
000014  1a000005          BNE      |L9.48|
;;;953        /* make list start at 2nd pcb */
;;;954        udp_pcbs = udp_pcbs->next;
000018  e59f0058          LDR      r0,|L9.120|
00001c  e5900000          LDR      r0,[r0,#0]  ; udp_pcbs
000020  e590000c          LDR      r0,[r0,#0xc]
000024  e59f104c          LDR      r1,|L9.120|
000028  e5810000          STR      r0,[r1,#0]  ; udp_pcbs
00002c  ea00000d          B        |L9.104|
                  |L9.48|
;;;955        /* pcb not 1st in list */
;;;956      } else {
;;;957        for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
000030  e59f0040          LDR      r0,|L9.120|
000034  e5904000          LDR      r4,[r0,#0]  ; udp_pcbs
000038  ea000008          B        |L9.96|
                  |L9.60|
;;;958          /* find pcb in udp_pcbs list */
;;;959          if (pcb2->next != NULL && pcb2->next == pcb) {
00003c  e594000c          LDR      r0,[r4,#0xc]
000040  e3500000          CMP      r0,#0
000044  0a000004          BEQ      |L9.92|
000048  e594000c          LDR      r0,[r4,#0xc]
00004c  e1500005          CMP      r0,r5
000050  1a000001          BNE      |L9.92|
;;;960            /* remove pcb from list */
;;;961            pcb2->next = pcb->next;
000054  e595000c          LDR      r0,[r5,#0xc]
000058  e584000c          STR      r0,[r4,#0xc]
                  |L9.92|
00005c  e594400c          LDR      r4,[r4,#0xc]          ;957
                  |L9.96|
000060  e3540000          CMP      r4,#0                 ;957
000064  1afffff4          BNE      |L9.60|
                  |L9.104|
;;;962          }
;;;963        }
;;;964      }
;;;965      memp_free(MEMP_UDP_PCB, pcb);
000068  e1a01005          MOV      r1,r5
00006c  e3a00000          MOV      r0,#0
000070  ebfffffe          BL       memp_free
;;;966    }
000074  e8bd8070          POP      {r4-r6,pc}
;;;967    
                          ENDP

                  |L9.120|
                          DCD      udp_pcbs

                          AREA ||i.udp_send||, CODE, READONLY, ALIGN=2

                  udp_send PROC
;;;453    err_t
;;;454    udp_send(struct udp_pcb *pcb, struct pbuf *p)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;455    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;456      /* send to the packet using remote ip and port stored in the pcb */
;;;457      return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
00000c  e1d431b4          LDRH     r3,[r4,#0x14]
000010  e2842004          ADD      r2,r4,#4
000014  e1a01005          MOV      r1,r5
000018  e1a00004          MOV      r0,r4
00001c  ebfffffe          BL       udp_sendto
;;;458    }
000020  e8bd8070          POP      {r4-r6,pc}
;;;459    
                          ENDP


                          AREA ||i.udp_sendto||, CODE, READONLY, ALIGN=2

                  udp_sendto PROC
;;;490    err_t
;;;491    udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;492      ip_addr_t *dst_ip, u16_t dst_port)
;;;493    {
000004  e1a06000          MOV      r6,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a04002          MOV      r4,r2
000010  e1a08003          MOV      r8,r3
;;;494    #if LWIP_CHECKSUM_ON_COPY
;;;495      return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
;;;496    }
;;;497    
;;;498    /** Same as udp_sendto(), but with checksum */
;;;499    err_t
;;;500    udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
;;;501                      u16_t dst_port, u8_t have_chksum, u16_t chksum)
;;;502    {
;;;503    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;504      struct netif *netif;
;;;505    
;;;506      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));
;;;507    
;;;508      /* find the outgoing network interface for this packet */
;;;509    #if LWIP_IGMP
;;;510      netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
;;;511    #else
;;;512      netif = ip_route(dst_ip);
000014  e1a00004          MOV      r0,r4
000018  ebfffffe          BL       ip_route
00001c  e1a05000          MOV      r5,r0
;;;513    #endif /* LWIP_IGMP */
;;;514    
;;;515      /* no outgoing network interface could be found? */
;;;516      if (netif == NULL) {
000020  e3550000          CMP      r5,#0
000024  1a000001          BNE      |L11.48|
;;;517        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;518          ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
;;;519        UDP_STATS_INC(udp.rterr);
;;;520        return ERR_RTE;
000028  e3e00003          MVN      r0,#3
                  |L11.44|
;;;521      }
;;;522    #if LWIP_CHECKSUM_ON_COPY
;;;523      return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
;;;524    #else /* LWIP_CHECKSUM_ON_COPY */
;;;525      return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
;;;526    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;527    }
00002c  e8bd83f8          POP      {r3-r9,pc}
                  |L11.48|
000030  e1a03008          MOV      r3,r8                 ;525
000034  e1a02004          MOV      r2,r4                 ;525
000038  e1a01007          MOV      r1,r7                 ;525
00003c  e1a00006          MOV      r0,r6                 ;525
000040  e58d5000          STR      r5,[sp,#0]            ;525
000044  ebfffffe          BL       udp_sendto_if
000048  eafffff7          B        |L11.44|
;;;528    
                          ENDP


                          AREA ||i.udp_sendto_if||, CODE, READONLY, ALIGN=2

                  udp_sendto_if PROC
;;;548    err_t
;;;549    udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;550      ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
;;;551    {
000004  e24dd00c          SUB      sp,sp,#0xc
000008  e1a04000          MOV      r4,r0
00000c  e1a06001          MOV      r6,r1
000010  e59d8040          LDR      r8,[sp,#0x40]
;;;552    #if LWIP_CHECKSUM_ON_COPY
;;;553      return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
;;;554    }
;;;555    
;;;556    /** Same as udp_sendto_if(), but with checksum */
;;;557    err_t
;;;558    udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
;;;559                         u16_t dst_port, struct netif *netif, u8_t have_chksum,
;;;560                         u16_t chksum)
;;;561    {
;;;562    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;563      struct udp_hdr *udphdr;
;;;564      ip_addr_t *src_ip;
;;;565      err_t err;
;;;566      struct pbuf *q; /* q will be sent down the stack */
;;;567    
;;;568    #if IP_SOF_BROADCAST
;;;569      /* broadcast filter? */
;;;570      if (!ip_get_option(pcb, SOF_BROADCAST) && ip_addr_isbroadcast(dst_ip, netif)) {
;;;571        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;572          ("udp_sendto_if: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
;;;573        return ERR_VAL;
;;;574      }
;;;575    #endif /* IP_SOF_BROADCAST */
;;;576    
;;;577      /* if the PCB is not yet bound to a port, bind it here */
;;;578      if (pcb->local_port == 0) {
000014  e1d401b2          LDRH     r0,[r4,#0x12]
000018  e3500000          CMP      r0,#0
00001c  1a000009          BNE      |L12.72|
;;;579        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
;;;580        err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
000020  e1d421b2          LDRH     r2,[r4,#0x12]
000024  e1a01004          MOV      r1,r4
000028  e1a00004          MOV      r0,r4
00002c  ebfffffe          BL       udp_bind
000030  e1a0a000          MOV      r10,r0
;;;581        if (err != ERR_OK) {
000034  e35a0000          CMP      r10,#0
000038  0a000002          BEQ      |L12.72|
;;;582          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
;;;583          return err;
00003c  e1a0000a          MOV      r0,r10
                  |L12.64|
000040  e28dd01c          ADD      sp,sp,#0x1c
;;;584        }
;;;585      }
;;;586    
;;;587      /* not enough space to add an UDP header to first pbuf in given p chain? */
;;;588      if (pbuf_header(p, UDP_HLEN)) {
;;;589        /* allocate header in a separate new pbuf */
;;;590        q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
;;;591        /* new header pbuf could not be allocated? */
;;;592        if (q == NULL) {
;;;593          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
;;;594          return ERR_MEM;
;;;595        }
;;;596        if (p->tot_len != 0) {
;;;597          /* chain header q in front of given pbuf p (only if p contains data) */
;;;598          pbuf_chain(q, p);
;;;599        }
;;;600        /* first pbuf q points to header pbuf */
;;;601        LWIP_DEBUGF(UDP_DEBUG,
;;;602                    ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
;;;603      } else {
;;;604        /* adding space for header within p succeeded */
;;;605        /* first pbuf q equals given pbuf */
;;;606        q = p;
;;;607        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
;;;608      }
;;;609      LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
;;;610                  (q->len >= sizeof(struct udp_hdr)));
;;;611      /* q now represents the packet to be sent */
;;;612      udphdr = (struct udp_hdr *)q->payload;
;;;613      udphdr->src = htons(pcb->local_port);
;;;614      udphdr->dest = htons(dst_port);
;;;615      /* in UDP, 0 checksum means 'no checksum' */
;;;616      udphdr->chksum = 0x0000; 
;;;617    
;;;618      /* Multicast Loop? */
;;;619    #if LWIP_IGMP
;;;620      if (ip_addr_ismulticast(dst_ip) && ((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0)) {
;;;621        q->flags |= PBUF_FLAG_MCASTLOOP;
;;;622      }
;;;623    #endif /* LWIP_IGMP */
;;;624    
;;;625    
;;;626      /* PCB local address is IP_ANY_ADDR? */
;;;627      if (ip_addr_isany(&pcb->local_ip)) {
;;;628        /* use outgoing network interface IP address as source address */
;;;629        src_ip = &(netif->ip_addr);
;;;630      } else {
;;;631        /* check if UDP PCB local IP address is correct
;;;632         * this could be an old address if netif->ip_addr has changed */
;;;633        if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
;;;634          /* local_ip doesn't match, drop the packet */
;;;635          if (q != p) {
;;;636            /* free the header pbuf */
;;;637            pbuf_free(q);
;;;638            q = NULL;
;;;639            /* p is still referenced by the caller, and will live on */
;;;640          }
;;;641          return ERR_VAL;
;;;642        }
;;;643        /* use UDP PCB local IP address as source address */
;;;644        src_ip = &(pcb->local_ip);
;;;645      }
;;;646    
;;;647      LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));
;;;648    
;;;649    #if LWIP_UDPLITE
;;;650      /* UDP Lite protocol? */
;;;651      if (pcb->flags & UDP_FLAGS_UDPLITE) {
;;;652        u16_t chklen, chklen_hdr;
;;;653        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %"U16_F"\n", q->tot_len));
;;;654        /* set UDP message length in UDP header */
;;;655        chklen_hdr = chklen = pcb->chksum_len_tx;
;;;656        if ((chklen < sizeof(struct udp_hdr)) || (chklen > q->tot_len)) {
;;;657          if (chklen != 0) {
;;;658            LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"U16_F"\n", chklen));
;;;659          }
;;;660          /* For UDP-Lite, checksum length of 0 means checksum
;;;661             over the complete packet. (See RFC 3828 chap. 3.1)
;;;662             At least the UDP-Lite header must be covered by the
;;;663             checksum, therefore, if chksum_len has an illegal
;;;664             value, we generate the checksum over the complete
;;;665             packet to be safe. */
;;;666          chklen_hdr = 0;
;;;667          chklen = q->tot_len;
;;;668        }
;;;669        udphdr->len = htons(chklen_hdr);
;;;670        /* calculate checksum */
;;;671    #if CHECKSUM_GEN_UDP
;;;672        udphdr->chksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip,
;;;673          IP_PROTO_UDPLITE, q->tot_len,
;;;674    #if !LWIP_CHECKSUM_ON_COPY
;;;675          chklen);
;;;676    #else /* !LWIP_CHECKSUM_ON_COPY */
;;;677          (have_chksum ? UDP_HLEN : chklen));
;;;678        if (have_chksum) {
;;;679          u32_t acc;
;;;680          acc = udphdr->chksum + (u16_t)~(chksum);
;;;681          udphdr->chksum = FOLD_U32T(acc);
;;;682        }
;;;683    #endif /* !LWIP_CHECKSUM_ON_COPY */
;;;684    
;;;685        /* chksum zero must become 0xffff, as zero means 'no checksum' */
;;;686        if (udphdr->chksum == 0x0000) {
;;;687          udphdr->chksum = 0xffff;
;;;688        }
;;;689    #endif /* CHECKSUM_GEN_UDP */
;;;690        /* output to IP */
;;;691        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDPLITE,)\n"));
;;;692        NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
;;;693        err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDPLITE, netif);
;;;694        NETIF_SET_HWADDRHINT(netif, NULL);
;;;695      } else
;;;696    #endif /* LWIP_UDPLITE */
;;;697      {      /* UDP */
;;;698        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
;;;699        udphdr->len = htons(q->tot_len);
;;;700        /* calculate checksum */
;;;701    #if CHECKSUM_GEN_UDP
;;;702        if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
;;;703          u16_t udpchksum;
;;;704    #if LWIP_CHECKSUM_ON_COPY
;;;705          if (have_chksum) {
;;;706            u32_t acc;
;;;707            udpchksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip, IP_PROTO_UDP,
;;;708              q->tot_len, UDP_HLEN);
;;;709            acc = udpchksum + (u16_t)~(chksum);
;;;710            udpchksum = FOLD_U32T(acc);
;;;711          } else
;;;712    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;713          {
;;;714            udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
;;;715          }
;;;716    
;;;717          /* chksum zero must become 0xffff, as zero means 'no checksum' */
;;;718          if (udpchksum == 0x0000) {
;;;719            udpchksum = 0xffff;
;;;720          }
;;;721          udphdr->chksum = udpchksum;
;;;722        }
;;;723    #endif /* CHECKSUM_GEN_UDP */
;;;724        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
;;;725        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
;;;726        /* output to IP */
;;;727        NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
;;;728        err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
;;;729        NETIF_SET_HWADDRHINT(netif, NULL);
;;;730      }
;;;731      /* TODO: must this be increased even if error occured? */
;;;732      snmp_inc_udpoutdatagrams();
;;;733    
;;;734      /* did we chain a separate header pbuf earlier? */
;;;735      if (q != p) {
;;;736        /* free the header pbuf */
;;;737        pbuf_free(q);
;;;738        q = NULL;
;;;739        /* p is still referenced by the caller, and will live on */
;;;740      }
;;;741    
;;;742      UDP_STATS_INC(udp.xmit);
;;;743      return err;
;;;744    }
000044  e8bd8ff0          POP      {r4-r11,pc}
                  |L12.72|
000048  e3a01008          MOV      r1,#8                 ;588
00004c  e1a00006          MOV      r0,r6                 ;588
000050  ebfffffe          BL       pbuf_header
000054  e3500000          CMP      r0,#0                 ;588
000058  0a00000f          BEQ      |L12.156|
00005c  e3a02000          MOV      r2,#0                 ;590
000060  e3a01008          MOV      r1,#8                 ;590
000064  e3a00001          MOV      r0,#1                 ;590
000068  ebfffffe          BL       pbuf_alloc
00006c  e1a05000          MOV      r5,r0                 ;590
000070  e3550000          CMP      r5,#0                 ;592
000074  1a000001          BNE      |L12.128|
000078  e3e00000          MVN      r0,#0                 ;594
00007c  eaffffef          B        |L12.64|
                  |L12.128|
000080  e1d600b8          LDRH     r0,[r6,#8]            ;596
000084  e3500000          CMP      r0,#0                 ;596
000088  0a000004          BEQ      |L12.160|
00008c  e1a01006          MOV      r1,r6                 ;598
000090  e1a00005          MOV      r0,r5                 ;598
000094  ebfffffe          BL       pbuf_chain
000098  ea000000          B        |L12.160|
                  |L12.156|
00009c  e1a05006          MOV      r5,r6                 ;606
                  |L12.160|
0000a0  e1a00000          MOV      r0,r0                 ;609
0000a4  e1d500ba          LDRH     r0,[r5,#0xa]          ;609
0000a8  e3500008          CMP      r0,#8                 ;609
0000ac  2a000006          BCS      |L12.204|
0000b0  e1a00000          MOV      r0,r0                 ;609
0000b4  e28f3f4e          ADR      r3,|L12.500|
0000b8  e59f2150          LDR      r2,|L12.528|
0000bc  e28f1e15          ADR      r1,|L12.532|
0000c0  e28f0f5f          ADR      r0,|L12.580|
0000c4  ebfffffe          BL       sysprintf
0000c8  e1a00000          MOV      r0,r0                 ;609
                  |L12.204|
0000cc  e1a00000          MOV      r0,r0                 ;609
0000d0  e5957004          LDR      r7,[r5,#4]            ;612
0000d4  e1d401b2          LDRH     r0,[r4,#0x12]         ;613
0000d8  ebfffffe          BL       lwip_htons
0000dc  e5c70000          STRB     r0,[r7,#0]            ;613
0000e0  e1a00420          LSR      r0,r0,#8              ;613
0000e4  e5c70001          STRB     r0,[r7,#1]            ;613
0000e8  e59d0018          LDR      r0,[sp,#0x18]         ;614
0000ec  ebfffffe          BL       lwip_htons
0000f0  e5c70002          STRB     r0,[r7,#2]            ;614
0000f4  e1a00420          LSR      r0,r0,#8              ;614
0000f8  e5c70003          STRB     r0,[r7,#3]            ;614
0000fc  e3a00000          MOV      r0,#0                 ;616
000100  e5c70006          STRB     r0,[r7,#6]            ;616
000104  e5c70007          STRB     r0,[r7,#7]            ;616
000108  e3540000          CMP      r4,#0                 ;627
00010c  0a000002          BEQ      |L12.284|
000110  e5940000          LDR      r0,[r4,#0]            ;627
000114  e3500000          CMP      r0,#0                 ;627
000118  1a000001          BNE      |L12.292|
                  |L12.284|
00011c  e2889004          ADD      r9,r8,#4              ;629
000120  ea00000b          B        |L12.340|
                  |L12.292|
000124  e5940000          LDR      r0,[r4,#0]            ;633
000128  e5981004          LDR      r1,[r8,#4]            ;633
00012c  e1500001          CMP      r0,r1                 ;633
000130  0a000006          BEQ      |L12.336|
000134  e1550006          CMP      r5,r6                 ;635
000138  0a000002          BEQ      |L12.328|
00013c  e1a00005          MOV      r0,r5                 ;637
000140  ebfffffe          BL       pbuf_free
000144  e3a05000          MOV      r5,#0                 ;638
                  |L12.328|
000148  e3e00005          MVN      r0,#5                 ;641
00014c  eaffffbb          B        |L12.64|
                  |L12.336|
000150  e1a09004          MOV      r9,r4                 ;644
                  |L12.340|
000154  e1d500b8          LDRH     r0,[r5,#8]            ;699
000158  ebfffffe          BL       lwip_htons
00015c  e5c70004          STRB     r0,[r7,#4]            ;699
000160  e1a00420          LSR      r0,r0,#8              ;699
000164  e5c70005          STRB     r0,[r7,#5]            ;699
000168  e5d40010          LDRB     r0,[r4,#0x10]         ;702
00016c  e2000001          AND      r0,r0,#1              ;702
000170  e3500000          CMP      r0,#0                 ;702
000174  1a00000e          BNE      |L12.436|
000178  e1d500b8          LDRH     r0,[r5,#8]            ;714
00017c  e3a03011          MOV      r3,#0x11              ;714
000180  e58d0000          STR      r0,[sp,#0]            ;714
000184  e1a01009          MOV      r1,r9                 ;714
000188  e1a00005          MOV      r0,r5                 ;714
00018c  e59d2014          LDR      r2,[sp,#0x14]         ;714
000190  ebfffffe          BL       inet_chksum_pseudo
000194  e1a0b000          MOV      r11,r0                ;714
000198  e35b0000          CMP      r11,#0                ;718
00019c  1a000000          BNE      |L12.420|
0001a0  e59fb0c4          LDR      r11,|L12.620|
                  |L12.420|
0001a4  e5c7b006          STRB     r11,[r7,#6]           ;721
0001a8  e1a0042b          LSR      r0,r11,#8             ;721
0001ac  e5c70007          STRB     r0,[r7,#7]            ;721
0001b0  e1a00000          MOV      r0,r0                 ;722
                  |L12.436|
0001b4  e3a01011          MOV      r1,#0x11              ;728
0001b8  e5d40009          LDRB     r0,[r4,#9]            ;728
0001bc  e88d0103          STM      sp,{r0,r1,r8}         ;728
0001c0  e5d4300a          LDRB     r3,[r4,#0xa]          ;728
0001c4  e1a01009          MOV      r1,r9                 ;728
0001c8  e1a00005          MOV      r0,r5                 ;728
0001cc  e59d2014          LDR      r2,[sp,#0x14]         ;728
0001d0  ebfffffe          BL       ip_output_if
0001d4  e1a0a000          MOV      r10,r0                ;728
0001d8  e1550006          CMP      r5,r6                 ;735
0001dc  0a000002          BEQ      |L12.492|
0001e0  e1a00005          MOV      r0,r5                 ;737
0001e4  ebfffffe          BL       pbuf_free
0001e8  e3a05000          MOV      r5,#0                 ;738
                  |L12.492|
0001ec  e1a0000a          MOV      r0,r10                ;743
0001f0  eaffff92          B        |L12.64|
;;;745    
                          ENDP

                  |L12.500|
0001f4  6c776970          DCB      "lwip-1.4.1\\src\\core\\udp.c",0
0001f8  2d312e34
0001fc  2e315c73
000200  72635c63
000204  6f72655c
000208  7564702e
00020c  6300    
00020e  00                DCB      0
00020f  00                DCB      0
                  |L12.528|
                          DCD      0x00000261
                  |L12.532|
000214  63686563          DCB      "check that first pbuf can hold struct udp_hdr",0
000218  6b207468
00021c  61742066
000220  69727374
000224  20706275
000228  66206361
00022c  6e20686f
000230  6c642073
000234  74727563
000238  74207564
00023c  705f6864
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L12.580|
000244  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000248  7274696f
00024c  6e202225
000250  73222066
000254  61696c65
000258  64206174
00025c  206c696e
000260  65202564
000264  20696e20
000268  25730a00
                  |L12.620|
                          DCD      0x0000ffff

                          AREA ||.data||, DATA, ALIGN=2

                  udp_port
000000  c000              DCW      0xc000
000002  0000              DCB      0x00,0x00
                  udp_pcbs
                          DCD      0x00000000
