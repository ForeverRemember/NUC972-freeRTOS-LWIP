; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\event_groups.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\event_groups.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\event_groups.crf FreeRTOS\Source\event_groups.c]
                          ARM

                          AREA ||i.prvTestWaitCondition||, CODE, READONLY, ALIGN=2

                  prvTestWaitCondition PROC
;;;681    
;;;682    static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
000000  e1a03000          MOV      r3,r0
;;;683    {
;;;684    BaseType_t xWaitConditionMet = pdFALSE;
000004  e3a00000          MOV      r0,#0
;;;685    
;;;686    	if( xWaitForAllBits == pdFALSE )
000008  e3520000          CMP      r2,#0
00000c  1a000004          BNE      |L1.36|
;;;687    	{
;;;688    		/* Task only has to wait for one bit within uxBitsToWaitFor to be
;;;689    		set.  Is one already set? */
;;;690    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
000010  e003c001          AND      r12,r3,r1
000014  e35c0000          CMP      r12,#0
000018  0a000005          BEQ      |L1.52|
;;;691    		{
;;;692    			xWaitConditionMet = pdTRUE;
00001c  e3a00001          MOV      r0,#1
000020  ea000003          B        |L1.52|
                  |L1.36|
;;;693    		}
;;;694    		else
;;;695    		{
;;;696    			mtCOVERAGE_TEST_MARKER();
;;;697    		}
;;;698    	}
;;;699    	else
;;;700    	{
;;;701    		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
;;;702    		Are they set already? */
;;;703    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
000024  e003c001          AND      r12,r3,r1
000028  e15c0001          CMP      r12,r1
00002c  1a000000          BNE      |L1.52|
;;;704    		{
;;;705    			xWaitConditionMet = pdTRUE;
000030  e3a00001          MOV      r0,#1
                  |L1.52|
;;;706    		}
;;;707    		else
;;;708    		{
;;;709    			mtCOVERAGE_TEST_MARKER();
;;;710    		}
;;;711    	}
;;;712    
;;;713    	return xWaitConditionMet;
;;;714    }
000034  e12fff1e          BX       lr
;;;715    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxEventGroupGetNumber||, CODE, READONLY, ALIGN=2

                  uxEventGroupGetNumber PROC
;;;733    
;;;734    	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
000000  e1a01000          MOV      r1,r0
;;;735    	{
;;;736    	UBaseType_t xReturn;
;;;737    	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000004  e1a02001          MOV      r2,r1
;;;738    
;;;739    		if( xEventGroup == NULL )
000008  e3510000          CMP      r1,#0
00000c  1a000001          BNE      |L2.24|
;;;740    		{
;;;741    			xReturn = 0;
000010  e3a00000          MOV      r0,#0
000014  ea000000          B        |L2.28|
                  |L2.24|
;;;742    		}
;;;743    		else
;;;744    		{
;;;745    			xReturn = pxEventBits->uxEventGroupNumber;
000018  e5920018          LDR      r0,[r2,#0x18]
                  |L2.28|
;;;746    		}
;;;747    
;;;748    		return xReturn;
;;;749    	}
00001c  e12fff1e          BX       lr
;;;750    
                          ENDP


                          AREA ||i.vEventGroupClearBitsCallback||, CODE, READONLY, ALIGN=2

                  vEventGroupClearBitsCallback PROC
;;;675    an interrupt. */
;;;676    void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;677    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;678    	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
00000c  e1a01005          MOV      r1,r5
000010  e1a00004          MOV      r0,r4
000014  ebfffffe          BL       xEventGroupClearBits
;;;679    }
000018  e8bd8070          POP      {r4-r6,pc}
;;;680    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupDelete||, CODE, READONLY, ALIGN=2

                  vEventGroupDelete PROC
;;;623    
;;;624    void vEventGroupDelete( EventGroupHandle_t xEventGroup )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;625    {
000004  e1a05000          MOV      r5,r0
;;;626    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000008  e1a06005          MOV      r6,r5
;;;627    const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
00000c  e2864004          ADD      r4,r6,#4
;;;628    
;;;629    	vTaskSuspendAll();
000010  ebfffffe          BL       vTaskSuspendAll
;;;630    	{
;;;631    		traceEVENT_GROUP_DELETE( xEventGroup );
;;;632    
;;;633    		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
000014  ea000011          B        |L4.96|
                  |L4.24|
;;;634    		{
;;;635    			/* Unblock the task, returning 0 as the event list is being deleted
;;;636    			and	cannot therefore have any bits set. */
;;;637    			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
000018  e594000c          LDR      r0,[r4,#0xc]
00001c  e2841008          ADD      r1,r4,#8
000020  e1500001          CMP      r0,r1
000024  0a000001          BEQ      |L4.48|
000028  e3a00001          MOV      r0,#1
00002c  ea000000          B        |L4.52|
                  |L4.48|
000030  e3a00000          MOV      r0,#0
                  |L4.52|
000034  e3500000          CMP      r0,#0
000038  1a000005          BNE      |L4.84|
00003c  e1a00000          MOV      r0,r0
000040  e28f2034          ADR      r2,|L4.124|
000044  e59f1050          LDR      r1,|L4.156|
000048  e28f0050          ADR      r0,|L4.160|
00004c  ebfffffe          BL       sysprintf
000050  e1a00000          MOV      r0,r0
                  |L4.84|
;;;638    			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
000054  e3a01402          MOV      r1,#0x2000000
000058  e594000c          LDR      r0,[r4,#0xc]
00005c  ebfffffe          BL       xTaskRemoveFromUnorderedEventList
                  |L4.96|
000060  e5940000          LDR      r0,[r4,#0]            ;633
000064  e3500000          CMP      r0,#0                 ;633
000068  1affffea          BNE      |L4.24|
;;;639    		}
;;;640    
;;;641    		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;642    		{
;;;643    			/* The event group can only have been allocated dynamically - free
;;;644    			it again. */
;;;645    			vPortFree( pxEventBits );
00006c  e1a00006          MOV      r0,r6
000070  ebfffffe          BL       vPortFree
;;;646    		}
;;;647    		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;648    		{
;;;649    			/* The event group could have been allocated statically or
;;;650    			dynamically, so check before attempting to free the memory. */
;;;651    			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;652    			{
;;;653    				vPortFree( pxEventBits );
;;;654    			}
;;;655    			else
;;;656    			{
;;;657    				mtCOVERAGE_TEST_MARKER();
;;;658    			}
;;;659    		}
;;;660    		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;661    	}
;;;662    	( void ) xTaskResumeAll();
000074  ebfffffe          BL       xTaskResumeAll
;;;663    }
000078  e8bd8070          POP      {r4-r6,pc}
;;;664    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.124|
00007c  46726565          DCB      "FreeRTOS\\Source\\event_groups.c",0
000080  52544f53
000084  5c536f75
000088  7263655c
00008c  6576656e
000090  745f6772
000094  6f757073
000098  2e6300  
00009b  00                DCB      0
                  |L4.156|
                          DCD      0x0000027d
                  |L4.160|
0000a0  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000a4  7274696f
0000a8  6e202220
0000ac  3f3f3f20
0000b0  22206661
0000b4  696c6564
0000b8  20617420
0000bc  6c696e65
0000c0  20256420
0000c4  696e2025
0000c8  730a00  
0000cb  00                DCB      0

                          AREA ||i.vEventGroupSetBitsCallback||, CODE, READONLY, ALIGN=2

                  vEventGroupSetBitsCallback PROC
;;;667    an interrupt. */
;;;668    void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;669    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;670    	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
00000c  e1a01005          MOV      r1,r5
000010  e1a00004          MOV      r0,r4
000014  ebfffffe          BL       xEventGroupSetBits
;;;671    }
000018  e8bd8070          POP      {r4-r6,pc}
;;;672    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupClearBits||, CODE, READONLY, ALIGN=2

                  xEventGroupClearBits PROC
;;;471    
;;;472    EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;473    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;474    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
00000c  e1a04005          MOV      r4,r5
;;;475    EventBits_t uxReturn;
;;;476    
;;;477    	/* Check the user is not attempting to clear the bits used by the kernel
;;;478    	itself. */
;;;479    	configASSERT( xEventGroup );
000010  e3550000          CMP      r5,#0
000014  1a000005          BNE      |L6.48|
000018  e1a00000          MOV      r0,r0
00001c  e28f2064          ADR      r2,|L6.136|
000020  e59f1080          LDR      r1,|L6.168|
000024  e28f0080          ADR      r0,|L6.172|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L6.48|
;;;480    	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000030  e20604ff          AND      r0,r6,#0xff000000
000034  e3500000          CMP      r0,#0
000038  1a000001          BNE      |L6.68|
00003c  e3a00001          MOV      r0,#1
000040  ea000000          B        |L6.72|
                  |L6.68|
000044  e3a00000          MOV      r0,#0
                  |L6.72|
000048  e3500000          CMP      r0,#0
00004c  1a000005          BNE      |L6.104|
000050  e1a00000          MOV      r0,r0
000054  e28f202c          ADR      r2,|L6.136|
000058  e3a01e1e          MOV      r1,#0x1e0
00005c  e28f0048          ADR      r0,|L6.172|
000060  ebfffffe          BL       sysprintf
000064  e1a00000          MOV      r0,r0
                  |L6.104|
;;;481    
;;;482    	taskENTER_CRITICAL();
000068  ebfffffe          BL       vPortEnterCritical
;;;483    	{
;;;484    		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
;;;485    
;;;486    		/* The value returned is the event group value prior to the bits being
;;;487    		cleared. */
;;;488    		uxReturn = pxEventBits->uxEventBits;
00006c  e5947000          LDR      r7,[r4,#0]
;;;489    
;;;490    		/* Clear the bits. */
;;;491    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000070  e5940000          LDR      r0,[r4,#0]
000074  e1c00006          BIC      r0,r0,r6
000078  e5840000          STR      r0,[r4,#0]
;;;492    	}
;;;493    	taskEXIT_CRITICAL();
00007c  ebfffffe          BL       vPortExitCritical
;;;494    
;;;495    	return uxReturn;
000080  e1a00007          MOV      r0,r7
;;;496    }
000084  e8bd81f0          POP      {r4-r8,pc}
;;;497    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.136|
000088  46726565          DCB      "FreeRTOS\\Source\\event_groups.c",0
00008c  52544f53
000090  5c536f75
000094  7263655c
000098  6576656e
00009c  745f6772
0000a0  6f757073
0000a4  2e6300  
0000a7  00                DCB      0
                  |L6.168|
                          DCD      0x000001df
                  |L6.172|
0000ac  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000b0  7274696f
0000b4  6e202220
0000b8  3f3f3f20
0000bc  22206661
0000c0  696c6564
0000c4  20617420
0000c8  6c696e65
0000cc  20256420
0000d0  696e2025
0000d4  730a00  
0000d7  00                DCB      0

                          AREA ||i.xEventGroupCreate||, CODE, READONLY, ALIGN=2

                  xEventGroupCreate PROC
;;;173    
;;;174    	EventGroupHandle_t xEventGroupCreate( void )
000000  e92d4010          PUSH     {r4,lr}
;;;175    	{
;;;176    	EventGroup_t *pxEventBits;
;;;177    
;;;178    		/* Allocate the event group. */
;;;179    		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
000004  e3a0001c          MOV      r0,#0x1c
000008  ebfffffe          BL       pvPortMalloc
00000c  e1a04000          MOV      r4,r0
;;;180    
;;;181    		if( pxEventBits != NULL )
000010  e3540000          CMP      r4,#0
000014  0a000003          BEQ      |L7.40|
;;;182    		{
;;;183    			pxEventBits->uxEventBits = 0;
000018  e3a00000          MOV      r0,#0
00001c  e5840000          STR      r0,[r4,#0]
;;;184    			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
000020  e2840004          ADD      r0,r4,#4
000024  ebfffffe          BL       vListInitialise
                  |L7.40|
;;;185    
;;;186    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;187    			{
;;;188    				/* Both static and dynamic allocation can be used, so note this
;;;189    				event group was allocated statically in case the event group is
;;;190    				later deleted. */
;;;191    				pxEventBits->ucStaticallyAllocated = pdFALSE;
;;;192    			}
;;;193    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;194    
;;;195    			traceEVENT_GROUP_CREATE( pxEventBits );
;;;196    		}
;;;197    		else
;;;198    		{
;;;199    			traceEVENT_GROUP_CREATE_FAILED();
;;;200    		}
;;;201    
;;;202    		return ( EventGroupHandle_t ) pxEventBits;
000028  e1a00004          MOV      r0,r4
;;;203    	}
00002c  e8bd8010          POP      {r4,pc}
;;;204    
                          ENDP


                          AREA ||i.xEventGroupGetBitsFromISR||, CODE, READONLY, ALIGN=2

                  xEventGroupGetBitsFromISR PROC
;;;513    
;;;514    EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
000000  e1a01000          MOV      r1,r0
;;;515    {
;;;516    UBaseType_t uxSavedInterruptStatus;
;;;517    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000004  e1a02001          MOV      r2,r1
;;;518    EventBits_t uxReturn;
;;;519    
;;;520    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000008  e3a03000          MOV      r3,#0
;;;521    	{
;;;522    		uxReturn = pxEventBits->uxEventBits;
00000c  e5920000          LDR      r0,[r2,#0]
;;;523    	}
;;;524    	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;525    
;;;526    	return uxReturn;
;;;527    }
000010  e12fff1e          BX       lr
;;;528    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupSetBits||, CODE, READONLY, ALIGN=2

                  xEventGroupSetBits PROC
;;;529    
;;;530    EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;531    {
000004  e1a07000          MOV      r7,r0
000008  e1a08001          MOV      r8,r1
;;;532    ListItem_t *pxListItem, *pxNext;
;;;533    ListItem_t const *pxListEnd;
;;;534    List_t *pxList;
;;;535    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
00000c  e3a00000          MOV      r0,#0
000010  e58d0004          STR      r0,[sp,#4]
;;;536    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000014  e1a04007          MOV      r4,r7
;;;537    BaseType_t xMatchFound = pdFALSE;
000018  e58d0000          STR      r0,[sp,#0]
;;;538    
;;;539    	/* Check the user is not attempting to set the bits used by the kernel
;;;540    	itself. */
;;;541    	configASSERT( xEventGroup );
00001c  e3570000          CMP      r7,#0
000020  1a000005          BNE      |L9.60|
000024  e1a00000          MOV      r0,r0
000028  e28f2e12          ADR      r2,|L9.336|
00002c  e59f113c          LDR      r1,|L9.368|
000030  e28f0f4f          ADR      r0,|L9.372|
000034  ebfffffe          BL       sysprintf
000038  e1a00000          MOV      r0,r0
                  |L9.60|
;;;542    	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
00003c  e20804ff          AND      r0,r8,#0xff000000
000040  e3500000          CMP      r0,#0
000044  1a000001          BNE      |L9.80|
000048  e3a00001          MOV      r0,#1
00004c  ea000000          B        |L9.84|
                  |L9.80|
000050  e3a00000          MOV      r0,#0
                  |L9.84|
000054  e3500000          CMP      r0,#0
000058  1a000005          BNE      |L9.116|
00005c  e1a00000          MOV      r0,r0
000060  e28f20e8          ADR      r2,|L9.336|
000064  e59f1134          LDR      r1,|L9.416|
000068  e28f0f41          ADR      r0,|L9.372|
00006c  ebfffffe          BL       sysprintf
000070  e1a00000          MOV      r0,r0
                  |L9.116|
;;;543    
;;;544    	pxList = &( pxEventBits->xTasksWaitingForBits );
000074  e2849004          ADD      r9,r4,#4
;;;545    	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
000078  e2890008          ADD      r0,r9,#8
00007c  e58d0008          STR      r0,[sp,#8]
;;;546    	vTaskSuspendAll();
000080  ebfffffe          BL       vTaskSuspendAll
;;;547    	{
;;;548    		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
;;;549    
;;;550    		pxListItem = listGET_HEAD_ENTRY( pxList );
000084  e599600c          LDR      r6,[r9,#0xc]
;;;551    
;;;552    		/* Set the bits. */
;;;553    		pxEventBits->uxEventBits |= uxBitsToSet;
000088  e5940000          LDR      r0,[r4,#0]
00008c  e1800008          ORR      r0,r0,r8
000090  e5840000          STR      r0,[r4,#0]
;;;554    
;;;555    		/* See if the new bit value should unblock any tasks. */
;;;556    		while( pxListItem != pxListEnd )
000094  ea000023          B        |L9.296|
                  |L9.152|
;;;557    		{
;;;558    			pxNext = listGET_NEXT( pxListItem );
000098  e596b004          LDR      r11,[r6,#4]
;;;559    			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
00009c  e5965000          LDR      r5,[r6,#0]
;;;560    			xMatchFound = pdFALSE;
0000a0  e3a00000          MOV      r0,#0
0000a4  e58d0000          STR      r0,[sp,#0]
;;;561    
;;;562    			/* Split the bits waited for from the control bits. */
;;;563    			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
0000a8  e205a4ff          AND      r10,r5,#0xff000000
;;;564    			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
0000ac  e3c554ff          BIC      r5,r5,#0xff000000
;;;565    
;;;566    			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
0000b0  e20a0301          AND      r0,r10,#0x4000000
0000b4  e3500000          CMP      r0,#0
0000b8  1a000006          BNE      |L9.216|
;;;567    			{
;;;568    				/* Just looking for single bit being set. */
;;;569    				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
0000bc  e5940000          LDR      r0,[r4,#0]
0000c0  e0000005          AND      r0,r0,r5
0000c4  e3500000          CMP      r0,#0
0000c8  0a000008          BEQ      |L9.240|
;;;570    				{
;;;571    					xMatchFound = pdTRUE;
0000cc  e3a00001          MOV      r0,#1
0000d0  e58d0000          STR      r0,[sp,#0]
0000d4  ea000005          B        |L9.240|
                  |L9.216|
;;;572    				}
;;;573    				else
;;;574    				{
;;;575    					mtCOVERAGE_TEST_MARKER();
;;;576    				}
;;;577    			}
;;;578    			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
0000d8  e5940000          LDR      r0,[r4,#0]
0000dc  e0000005          AND      r0,r0,r5
0000e0  e1500005          CMP      r0,r5
0000e4  1a000001          BNE      |L9.240|
;;;579    			{
;;;580    				/* All bits are set. */
;;;581    				xMatchFound = pdTRUE;
0000e8  e3a00001          MOV      r0,#1
0000ec  e58d0000          STR      r0,[sp,#0]
                  |L9.240|
;;;582    			}
;;;583    			else
;;;584    			{
;;;585    				/* Need all bits to be set, but not all the bits were set. */
;;;586    			}
;;;587    
;;;588    			if( xMatchFound != pdFALSE )
0000f0  e59d0000          LDR      r0,[sp,#0]
0000f4  e3500000          CMP      r0,#0
0000f8  0a000009          BEQ      |L9.292|
;;;589    			{
;;;590    				/* The bits match.  Should the bits be cleared on exit? */
;;;591    				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
0000fc  e20a0401          AND      r0,r10,#0x1000000
000100  e3500000          CMP      r0,#0
000104  0a000002          BEQ      |L9.276|
;;;592    				{
;;;593    					uxBitsToClear |= uxBitsWaitedFor;
000108  e59d0004          LDR      r0,[sp,#4]
00010c  e1800005          ORR      r0,r0,r5
000110  e58d0004          STR      r0,[sp,#4]
                  |L9.276|
;;;594    				}
;;;595    				else
;;;596    				{
;;;597    					mtCOVERAGE_TEST_MARKER();
;;;598    				}
;;;599    
;;;600    				/* Store the actual event flag value in the task's event list
;;;601    				item before removing the task from the event list.  The
;;;602    				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
;;;603    				that is was unblocked due to its required bits matching, rather
;;;604    				than because it timed out. */
;;;605    				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
000114  e5940000          LDR      r0,[r4,#0]
000118  e3801402          ORR      r1,r0,#0x2000000
00011c  e1a00006          MOV      r0,r6
000120  ebfffffe          BL       xTaskRemoveFromUnorderedEventList
                  |L9.292|
;;;606    			}
;;;607    
;;;608    			/* Move onto the next list item.  Note pxListItem->pxNext is not
;;;609    			used here as the list item may have been removed from the event list
;;;610    			and inserted into the ready/pending reading list. */
;;;611    			pxListItem = pxNext;
000124  e1a0600b          MOV      r6,r11
                  |L9.296|
000128  e59d0008          LDR      r0,[sp,#8]            ;556
00012c  e1560000          CMP      r6,r0                 ;556
000130  1affffd8          BNE      |L9.152|
;;;612    		}
;;;613    
;;;614    		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
;;;615    		bit was set in the control word. */
;;;616    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000134  e5941000          LDR      r1,[r4,#0]
000138  e59d0004          LDR      r0,[sp,#4]
00013c  e1c10000          BIC      r0,r1,r0
000140  e5840000          STR      r0,[r4,#0]
;;;617    	}
;;;618    	( void ) xTaskResumeAll();
000144  ebfffffe          BL       xTaskResumeAll
;;;619    
;;;620    	return pxEventBits->uxEventBits;
000148  e5940000          LDR      r0,[r4,#0]
;;;621    }
00014c  e8bd8ffe          POP      {r1-r11,pc}
;;;622    /*-----------------------------------------------------------*/
                          ENDP

                  |L9.336|
000150  46726565          DCB      "FreeRTOS\\Source\\event_groups.c",0
000154  52544f53
000158  5c536f75
00015c  7263655c
000160  6576656e
000164  745f6772
000168  6f757073
00016c  2e6300  
00016f  00                DCB      0
                  |L9.368|
                          DCD      0x0000021d
                  |L9.372|
000174  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000178  7274696f
00017c  6e202220
000180  3f3f3f20
000184  22206661
000188  696c6564
00018c  20617420
000190  6c696e65
000194  20256420
000198  696e2025
00019c  730a00  
00019f  00                DCB      0
                  |L9.416|
                          DCD      0x0000021e

                          AREA ||i.xEventGroupSync||, CODE, READONLY, ALIGN=2

                  xEventGroupSync PROC
;;;207    
;;;208    EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;209    {
000004  e1a0b000          MOV      r11,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a04002          MOV      r4,r2
000010  e1a07003          MOV      r7,r3
;;;210    EventBits_t uxOriginalBitValue, uxReturn;
;;;211    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000014  e1a0500b          MOV      r5,r11
;;;212    BaseType_t xAlreadyYielded;
;;;213    BaseType_t xTimeoutOccurred = pdFALSE;
000018  e3a00000          MOV      r0,#0
00001c  e58d0000          STR      r0,[sp,#0]
;;;214    
;;;215    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000020  e20404ff          AND      r0,r4,#0xff000000
000024  e3500000          CMP      r0,#0
000028  1a000001          BNE      |L10.52|
00002c  e3a00001          MOV      r0,#1
000030  ea000000          B        |L10.56|
                  |L10.52|
000034  e3a00000          MOV      r0,#0
                  |L10.56|
000038  e3500000          CMP      r0,#0
00003c  1a000005          BNE      |L10.88|
000040  e1a00000          MOV      r0,r0
000044  e28f2f52          ADR      r2,|L10.404|
000048  e3a010d7          MOV      r1,#0xd7
00004c  e28f0e16          ADR      r0,|L10.436|
000050  ebfffffe          BL       sysprintf
000054  e1a00000          MOV      r0,r0
                  |L10.88|
;;;216    	configASSERT( uxBitsToWaitFor != 0 );
000058  e3540000          CMP      r4,#0
00005c  0a000001          BEQ      |L10.104|
000060  e3a00001          MOV      r0,#1
000064  ea000000          B        |L10.108|
                  |L10.104|
000068  e3a00000          MOV      r0,#0
                  |L10.108|
00006c  e3500000          CMP      r0,#0
000070  1a000005          BNE      |L10.140|
000074  e1a00000          MOV      r0,r0
000078  e28f2f45          ADR      r2,|L10.404|
00007c  e3a010d8          MOV      r1,#0xd8
000080  e28f0f4b          ADR      r0,|L10.436|
000084  ebfffffe          BL       sysprintf
000088  e1a00000          MOV      r0,r0
                  |L10.140|
;;;217    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;218    	{
;;;219    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00008c  ebfffffe          BL       xTaskGetSchedulerState
000090  e3500000          CMP      r0,#0
000094  1a000001          BNE      |L10.160|
000098  e3570000          CMP      r7,#0
00009c  1a000001          BNE      |L10.168|
                  |L10.160|
0000a0  e3a00001          MOV      r0,#1
0000a4  ea000000          B        |L10.172|
                  |L10.168|
0000a8  e3a00000          MOV      r0,#0
                  |L10.172|
0000ac  e3500000          CMP      r0,#0
0000b0  1a000005          BNE      |L10.204|
0000b4  e1a00000          MOV      r0,r0
0000b8  e28f20d4          ADR      r2,|L10.404|
0000bc  e3a010db          MOV      r1,#0xdb
0000c0  e28f00ec          ADR      r0,|L10.436|
0000c4  ebfffffe          BL       sysprintf
0000c8  e1a00000          MOV      r0,r0
                  |L10.204|
;;;220    	}
;;;221    	#endif
;;;222    
;;;223    	vTaskSuspendAll();
0000cc  ebfffffe          BL       vTaskSuspendAll
;;;224    	{
;;;225    		uxOriginalBitValue = pxEventBits->uxEventBits;
0000d0  e5959000          LDR      r9,[r5,#0]
;;;226    
;;;227    		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
0000d4  e1a01008          MOV      r1,r8
0000d8  e1a0000b          MOV      r0,r11
0000dc  ebfffffe          BL       xEventGroupSetBits
;;;228    
;;;229    		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
0000e0  e1890008          ORR      r0,r9,r8
0000e4  e0000004          AND      r0,r0,r4
0000e8  e1500004          CMP      r0,r4
0000ec  1a000005          BNE      |L10.264|
;;;230    		{
;;;231    			/* All the rendezvous bits are now set - no need to block. */
;;;232    			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
0000f0  e1896008          ORR      r6,r9,r8
;;;233    
;;;234    			/* Rendezvous always clear the bits.  They will have been cleared
;;;235    			already unless this is the only task in the rendezvous. */
;;;236    			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
0000f4  e5950000          LDR      r0,[r5,#0]
0000f8  e1c00004          BIC      r0,r0,r4
0000fc  e5850000          STR      r0,[r5,#0]
;;;237    
;;;238    			xTicksToWait = 0;
000100  e3a07000          MOV      r7,#0
000104  ea000008          B        |L10.300|
                  |L10.264|
;;;239    		}
;;;240    		else
;;;241    		{
;;;242    			if( xTicksToWait != ( TickType_t ) 0 )
000108  e3570000          CMP      r7,#0
00010c  0a000005          BEQ      |L10.296|
;;;243    			{
;;;244    				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
;;;245    
;;;246    				/* Store the bits that the calling task is waiting for in the
;;;247    				task's event list item so the kernel knows when a match is
;;;248    				found.  Then enter the blocked state. */
;;;249    				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
000110  e3841405          ORR      r1,r4,#0x5000000
000114  e1a02007          MOV      r2,r7
000118  e2850004          ADD      r0,r5,#4
00011c  ebfffffe          BL       vTaskPlaceOnUnorderedEventList
;;;250    
;;;251    				/* This assignment is obsolete as uxReturn will get set after
;;;252    				the task unblocks, but some compilers mistakenly generate a
;;;253    				warning about uxReturn being returned without being set if the
;;;254    				assignment is omitted. */
;;;255    				uxReturn = 0;
000120  e3a06000          MOV      r6,#0
000124  ea000000          B        |L10.300|
                  |L10.296|
;;;256    			}
;;;257    			else
;;;258    			{
;;;259    				/* The rendezvous bits were not set, but no block time was
;;;260    				specified - just return the current event bit value. */
;;;261    				uxReturn = pxEventBits->uxEventBits;
000128  e5956000          LDR      r6,[r5,#0]
                  |L10.300|
;;;262    			}
;;;263    		}
;;;264    	}
;;;265    	xAlreadyYielded = xTaskResumeAll();
00012c  ebfffffe          BL       xTaskResumeAll
000130  e1a0a000          MOV      r10,r0
;;;266    
;;;267    	if( xTicksToWait != ( TickType_t ) 0 )
000134  e3570000          CMP      r7,#0
000138  0a000013          BEQ      |L10.396|
;;;268    	{
;;;269    		if( xAlreadyYielded == pdFALSE )
00013c  e35a0000          CMP      r10,#0
000140  1a000000          BNE      |L10.328|
;;;270    		{
;;;271    			portYIELD_WITHIN_API();
000144  ebfffffe          BL       vPortYield
                  |L10.328|
;;;272    		}
;;;273    		else
;;;274    		{
;;;275    			mtCOVERAGE_TEST_MARKER();
;;;276    		}
;;;277    
;;;278    		/* The task blocked to wait for its required bits to be set - at this
;;;279    		point either the required bits were set or the block time expired.  If
;;;280    		the required bits were set they will have been stored in the task's
;;;281    		event list item, and they should now be retrieved then cleared. */
;;;282    		uxReturn = uxTaskResetEventItemValue();
000148  ebfffffe          BL       uxTaskResetEventItemValue
00014c  e1a06000          MOV      r6,r0
;;;283    
;;;284    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
000150  e2060402          AND      r0,r6,#0x2000000
000154  e3500000          CMP      r0,#0
000158  1a00000a          BNE      |L10.392|
;;;285    		{
;;;286    			/* The task timed out, just return the current event bit value. */
;;;287    			taskENTER_CRITICAL();
00015c  ebfffffe          BL       vPortEnterCritical
;;;288    			{
;;;289    				uxReturn = pxEventBits->uxEventBits;
000160  e5956000          LDR      r6,[r5,#0]
;;;290    
;;;291    				/* Although the task got here because it timed out before the
;;;292    				bits it was waiting for were set, it is possible that since it
;;;293    				unblocked another task has set the bits.  If this is the case
;;;294    				then it needs to clear the bits before exiting. */
;;;295    				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
000164  e0060004          AND      r0,r6,r4
000168  e1500004          CMP      r0,r4
00016c  1a000002          BNE      |L10.380|
;;;296    				{
;;;297    					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
000170  e5950000          LDR      r0,[r5,#0]
000174  e1c00004          BIC      r0,r0,r4
000178  e5850000          STR      r0,[r5,#0]
                  |L10.380|
;;;298    				}
;;;299    				else
;;;300    				{
;;;301    					mtCOVERAGE_TEST_MARKER();
;;;302    				}
;;;303    			}
;;;304    			taskEXIT_CRITICAL();
00017c  ebfffffe          BL       vPortExitCritical
;;;305    
;;;306    			xTimeoutOccurred = pdTRUE;
000180  e3a00001          MOV      r0,#1
000184  e58d0000          STR      r0,[sp,#0]
                  |L10.392|
;;;307    		}
;;;308    		else
;;;309    		{
;;;310    			/* The task unblocked because the bits were set. */
;;;311    		}
;;;312    
;;;313    		/* Control bits might be set as the task had blocked should not be
;;;314    		returned. */
;;;315    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
000188  e3c664ff          BIC      r6,r6,#0xff000000
                  |L10.396|
;;;316    	}
;;;317    
;;;318    	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
;;;319    
;;;320    	return uxReturn;
00018c  e1a00006          MOV      r0,r6
;;;321    }
000190  e8bd8ff8          POP      {r3-r11,pc}
;;;322    /*-----------------------------------------------------------*/
                          ENDP

                  |L10.404|
000194  46726565          DCB      "FreeRTOS\\Source\\event_groups.c",0
000198  52544f53
00019c  5c536f75
0001a0  7263655c
0001a4  6576656e
0001a8  745f6772
0001ac  6f757073
0001b0  2e6300  
0001b3  00                DCB      0
                  |L10.436|
0001b4  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0001b8  7274696f
0001bc  6e202220
0001c0  3f3f3f20
0001c4  22206661
0001c8  696c6564
0001cc  20617420
0001d0  6c696e65
0001d4  20256420
0001d8  696e2025
0001dc  730a00  
0001df  00                DCB      0

                          AREA ||i.xEventGroupWaitBits||, CODE, READONLY, ALIGN=2

                  xEventGroupWaitBits PROC
;;;323    
;;;324    EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;325    {
000004  e24dd00c          SUB      sp,sp,#0xc
000008  e1a09000          MOV      r9,r0
00000c  e1a05001          MOV      r5,r1
000010  e1a07002          MOV      r7,r2
000014  e59d8040          LDR      r8,[sp,#0x40]
;;;326    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000018  e1a04009          MOV      r4,r9
;;;327    EventBits_t uxReturn, uxControlBits = 0;
00001c  e3a0a000          MOV      r10,#0
;;;328    BaseType_t xWaitConditionMet, xAlreadyYielded;
;;;329    BaseType_t xTimeoutOccurred = pdFALSE;
000020  e3a00000          MOV      r0,#0
000024  e58d0004          STR      r0,[sp,#4]
;;;330    
;;;331    	/* Check the user is not attempting to wait on the bits used by the kernel
;;;332    	itself, and that at least one bit is being requested. */
;;;333    	configASSERT( xEventGroup );
000028  e3590000          CMP      r9,#0
00002c  1a000005          BNE      |L11.72|
000030  e1a00000          MOV      r0,r0
000034  e28f2f71          ADR      r2,|L11.512|
000038  e59f11e0          LDR      r1,|L11.544|
00003c  e28f0e1e          ADR      r0,|L11.548|
000040  ebfffffe          BL       sysprintf
000044  e1a00000          MOV      r0,r0
                  |L11.72|
;;;334    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000048  e20504ff          AND      r0,r5,#0xff000000
00004c  e3500000          CMP      r0,#0
000050  1a000001          BNE      |L11.92|
000054  e3a00001          MOV      r0,#1
000058  ea000000          B        |L11.96|
                  |L11.92|
00005c  e3a00000          MOV      r0,#0
                  |L11.96|
000060  e3500000          CMP      r0,#0
000064  1a000005          BNE      |L11.128|
000068  e1a00000          MOV      r0,r0
00006c  e28f2f63          ADR      r2,|L11.512|
000070  e59f11d8          LDR      r1,|L11.592|
000074  e28f0f6a          ADR      r0,|L11.548|
000078  ebfffffe          BL       sysprintf
00007c  e1a00000          MOV      r0,r0
                  |L11.128|
;;;335    	configASSERT( uxBitsToWaitFor != 0 );
000080  e3550000          CMP      r5,#0
000084  0a000001          BEQ      |L11.144|
000088  e3a00001          MOV      r0,#1
00008c  ea000000          B        |L11.148|
                  |L11.144|
000090  e3a00000          MOV      r0,#0
                  |L11.148|
000094  e3500000          CMP      r0,#0
000098  1a000005          BNE      |L11.180|
00009c  e1a00000          MOV      r0,r0
0000a0  e28f2f56          ADR      r2,|L11.512|
0000a4  e59f11a8          LDR      r1,|L11.596|
0000a8  e28f0f5d          ADR      r0,|L11.548|
0000ac  ebfffffe          BL       sysprintf
0000b0  e1a00000          MOV      r0,r0
                  |L11.180|
;;;336    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;337    	{
;;;338    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
0000b4  ebfffffe          BL       xTaskGetSchedulerState
0000b8  e3500000          CMP      r0,#0
0000bc  1a000001          BNE      |L11.200|
0000c0  e3580000          CMP      r8,#0
0000c4  1a000001          BNE      |L11.208|
                  |L11.200|
0000c8  e3a00001          MOV      r0,#1
0000cc  ea000000          B        |L11.212|
                  |L11.208|
0000d0  e3a00000          MOV      r0,#0
                  |L11.212|
0000d4  e3500000          CMP      r0,#0
0000d8  1a000005          BNE      |L11.244|
0000dc  e1a00000          MOV      r0,r0
0000e0  e28f2f46          ADR      r2,|L11.512|
0000e4  e59f116c          LDR      r1,|L11.600|
0000e8  e28f0f4d          ADR      r0,|L11.548|
0000ec  ebfffffe          BL       sysprintf
0000f0  e1a00000          MOV      r0,r0
                  |L11.244|
;;;339    	}
;;;340    	#endif
;;;341    
;;;342    	vTaskSuspendAll();
0000f4  ebfffffe          BL       vTaskSuspendAll
;;;343    	{
;;;344    		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
0000f8  e5940000          LDR      r0,[r4,#0]
0000fc  e58d0000          STR      r0,[sp,#0]
;;;345    
;;;346    		/* Check to see if the wait condition is already met or not. */
;;;347    		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
000100  e1a01005          MOV      r1,r5
000104  e59d0000          LDR      r0,[sp,#0]
000108  e59d2018          LDR      r2,[sp,#0x18]
00010c  ebfffffe          BL       prvTestWaitCondition
000110  e58d0008          STR      r0,[sp,#8]
;;;348    
;;;349    		if( xWaitConditionMet != pdFALSE )
000114  e59d0008          LDR      r0,[sp,#8]
000118  e3500000          CMP      r0,#0
00011c  0a000007          BEQ      |L11.320|
;;;350    		{
;;;351    			/* The wait condition has already been met so there is no need to
;;;352    			block. */
;;;353    			uxReturn = uxCurrentEventBits;
000120  e59d6000          LDR      r6,[sp,#0]
;;;354    			xTicksToWait = ( TickType_t ) 0;
000124  e3a08000          MOV      r8,#0
;;;355    
;;;356    			/* Clear the wait bits if requested to do so. */
;;;357    			if( xClearOnExit != pdFALSE )
000128  e3570000          CMP      r7,#0
00012c  0a000013          BEQ      |L11.384|
;;;358    			{
;;;359    				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
000130  e5940000          LDR      r0,[r4,#0]
000134  e1c00005          BIC      r0,r0,r5
000138  e5840000          STR      r0,[r4,#0]
00013c  ea00000f          B        |L11.384|
                  |L11.320|
;;;360    			}
;;;361    			else
;;;362    			{
;;;363    				mtCOVERAGE_TEST_MARKER();
;;;364    			}
;;;365    		}
;;;366    		else if( xTicksToWait == ( TickType_t ) 0 )
000140  e3580000          CMP      r8,#0
000144  1a000001          BNE      |L11.336|
;;;367    		{
;;;368    			/* The wait condition has not been met, but no block time was
;;;369    			specified, so just return the current value. */
;;;370    			uxReturn = uxCurrentEventBits;
000148  e59d6000          LDR      r6,[sp,#0]
00014c  ea00000b          B        |L11.384|
                  |L11.336|
;;;371    		}
;;;372    		else
;;;373    		{
;;;374    			/* The task is going to block to wait for its required bits to be
;;;375    			set.  uxControlBits are used to remember the specified behaviour of
;;;376    			this call to xEventGroupWaitBits() - for use when the event bits
;;;377    			unblock the task. */
;;;378    			if( xClearOnExit != pdFALSE )
000150  e3570000          CMP      r7,#0
000154  0a000000          BEQ      |L11.348|
;;;379    			{
;;;380    				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
000158  e38aa401          ORR      r10,r10,#0x1000000
                  |L11.348|
;;;381    			}
;;;382    			else
;;;383    			{
;;;384    				mtCOVERAGE_TEST_MARKER();
;;;385    			}
;;;386    
;;;387    			if( xWaitForAllBits != pdFALSE )
00015c  e59d0018          LDR      r0,[sp,#0x18]
000160  e3500000          CMP      r0,#0
000164  0a000000          BEQ      |L11.364|
;;;388    			{
;;;389    				uxControlBits |= eventWAIT_FOR_ALL_BITS;
000168  e38aa301          ORR      r10,r10,#0x4000000
                  |L11.364|
;;;390    			}
;;;391    			else
;;;392    			{
;;;393    				mtCOVERAGE_TEST_MARKER();
;;;394    			}
;;;395    
;;;396    			/* Store the bits that the calling task is waiting for in the
;;;397    			task's event list item so the kernel knows when a match is
;;;398    			found.  Then enter the blocked state. */
;;;399    			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
00016c  e185100a          ORR      r1,r5,r10
000170  e1a02008          MOV      r2,r8
000174  e2840004          ADD      r0,r4,#4
000178  ebfffffe          BL       vTaskPlaceOnUnorderedEventList
;;;400    
;;;401    			/* This is obsolete as it will get set after the task unblocks, but
;;;402    			some compilers mistakenly generate a warning about the variable
;;;403    			being returned without being set if it is not done. */
;;;404    			uxReturn = 0;
00017c  e3a06000          MOV      r6,#0
                  |L11.384|
;;;405    
;;;406    			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
;;;407    		}
;;;408    	}
;;;409    	xAlreadyYielded = xTaskResumeAll();
000180  ebfffffe          BL       xTaskResumeAll
000184  e1a0b000          MOV      r11,r0
;;;410    
;;;411    	if( xTicksToWait != ( TickType_t ) 0 )
000188  e3580000          CMP      r8,#0
00018c  0a000018          BEQ      |L11.500|
;;;412    	{
;;;413    		if( xAlreadyYielded == pdFALSE )
000190  e35b0000          CMP      r11,#0
000194  1a000000          BNE      |L11.412|
;;;414    		{
;;;415    			portYIELD_WITHIN_API();
000198  ebfffffe          BL       vPortYield
                  |L11.412|
;;;416    		}
;;;417    		else
;;;418    		{
;;;419    			mtCOVERAGE_TEST_MARKER();
;;;420    		}
;;;421    
;;;422    		/* The task blocked to wait for its required bits to be set - at this
;;;423    		point either the required bits were set or the block time expired.  If
;;;424    		the required bits were set they will have been stored in the task's
;;;425    		event list item, and they should now be retrieved then cleared. */
;;;426    		uxReturn = uxTaskResetEventItemValue();
00019c  ebfffffe          BL       uxTaskResetEventItemValue
0001a0  e1a06000          MOV      r6,r0
;;;427    
;;;428    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
0001a4  e2060402          AND      r0,r6,#0x2000000
0001a8  e3500000          CMP      r0,#0
0001ac  1a00000f          BNE      |L11.496|
;;;429    		{
;;;430    			taskENTER_CRITICAL();
0001b0  ebfffffe          BL       vPortEnterCritical
;;;431    			{
;;;432    				/* The task timed out, just return the current event bit value. */
;;;433    				uxReturn = pxEventBits->uxEventBits;
0001b4  e5946000          LDR      r6,[r4,#0]
;;;434    
;;;435    				/* It is possible that the event bits were updated between this
;;;436    				task leaving the Blocked state and running again. */
;;;437    				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
0001b8  e1a01005          MOV      r1,r5
0001bc  e1a00006          MOV      r0,r6
0001c0  e59d2018          LDR      r2,[sp,#0x18]
0001c4  ebfffffe          BL       prvTestWaitCondition
0001c8  e3500000          CMP      r0,#0
0001cc  0a000004          BEQ      |L11.484|
;;;438    				{
;;;439    					if( xClearOnExit != pdFALSE )
0001d0  e3570000          CMP      r7,#0
0001d4  0a000002          BEQ      |L11.484|
;;;440    					{
;;;441    						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
0001d8  e5940000          LDR      r0,[r4,#0]
0001dc  e1c00005          BIC      r0,r0,r5
0001e0  e5840000          STR      r0,[r4,#0]
                  |L11.484|
;;;442    					}
;;;443    					else
;;;444    					{
;;;445    						mtCOVERAGE_TEST_MARKER();
;;;446    					}
;;;447    				}
;;;448    				else
;;;449    				{
;;;450    					mtCOVERAGE_TEST_MARKER();
;;;451    				}
;;;452    			}
;;;453    			taskEXIT_CRITICAL();
0001e4  ebfffffe          BL       vPortExitCritical
;;;454    
;;;455    			/* Prevent compiler warnings when trace macros are not used. */
;;;456    			xTimeoutOccurred = pdFALSE;
0001e8  e3a00000          MOV      r0,#0
0001ec  e58d0004          STR      r0,[sp,#4]
                  |L11.496|
;;;457    		}
;;;458    		else
;;;459    		{
;;;460    			/* The task unblocked because the bits were set. */
;;;461    		}
;;;462    
;;;463    		/* The task blocked so control bits may have been set. */
;;;464    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0001f0  e3c664ff          BIC      r6,r6,#0xff000000
                  |L11.500|
;;;465    	}
;;;466    	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
;;;467    
;;;468    	return uxReturn;
0001f4  e1a00006          MOV      r0,r6
0001f8  e28dd01c          ADD      sp,sp,#0x1c
;;;469    }
0001fc  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.512|
000200  46726565          DCB      "FreeRTOS\\Source\\event_groups.c",0
000204  52544f53
000208  5c536f75
00020c  7263655c
000210  6576656e
000214  745f6772
000218  6f757073
00021c  2e6300  
00021f  00                DCB      0
                  |L11.544|
                          DCD      0x0000014d
                  |L11.548|
000224  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000228  7274696f
00022c  6e202220
000230  3f3f3f20
000234  22206661
000238  696c6564
00023c  20617420
000240  6c696e65
000244  20256420
000248  696e2025
00024c  730a00  
00024f  00                DCB      0
                  |L11.592|
                          DCD      0x0000014e
                  |L11.596|
                          DCD      0x0000014f
                  |L11.600|
                          DCD      0x00000152
                          ENDP

