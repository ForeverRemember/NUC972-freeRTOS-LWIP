; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\netconf.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\netconf.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -D__UVISION_VERSION=524 --omf_browse=.\obj\netconf.crf lwip-1.4.1\netconf.c]
                          ARM

                          AREA ||i.LwIP_DHCP_task||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  LwIP_DHCP_task PROC
;;;118      */
;;;119    void LwIP_DHCP_task(void * pvParameters)
000000  e92d4030          PUSH     {r4,r5,lr}
;;;120    {
000004  e24dd034          SUB      sp,sp,#0x34
000008  e1a05000          MOV      r5,r0
;;;121        u32_t ip_tmp;
;;;122    //  struct ip_addr ipaddr;
;;;123    //  struct ip_addr netmask;
;;;124    //  struct ip_addr gw;
;;;125      uint32_t IPaddress;
;;;126      uint8_t iptab[4];
;;;127      char iptxt[40];
;;;128      g_eDHCPState = DHCP_START;
00000c  e3a00000          MOV      r0,#0
000010  e59f118c          LDR      r1,|L1.420|
000014  e5c10000          STRB     r0,[r1,#0]  ; g_eDHCPState
;;;129    
;;;130      for (;;)
000018  e1a00000          MOV      r0,r0
                  |L1.28|
;;;131      {
;;;132        switch (g_eDHCPState)
00001c  e59f0180          LDR      r0,|L1.420|
000020  e5d00000          LDRB     r0,[r0,#0]  ; g_eDHCPState
000024  e3500000          CMP      r0,#0
000028  0a000002          BEQ      |L1.56|
00002c  e3500001          CMP      r0,#1
000030  1a000055          BNE      |L1.396|
000034  ea00000d          B        |L1.112|
                  |L1.56|
;;;133        {
;;;134          case DHCP_START:
000038  e1a00000          MOV      r0,r0
;;;135          {
;;;136            dhcp_start(&xnetif);
00003c  e59f0164          LDR      r0,|L1.424|
000040  ebfffffe          BL       dhcp_start
;;;137            IPaddress = 0;
000044  e3a04000          MOV      r4,#0
;;;138            g_eDHCPState = DHCP_WAIT_ADDRESS;
000048  e3a00001          MOV      r0,#1
00004c  e59f1150          LDR      r1,|L1.420|
000050  e5c10000          STRB     r0,[r1,#0]  ; g_eDHCPState
;;;139    #ifdef PRINT_INF
;;;140            PRINT_INF("     Looking for    \n");
000054  e28f0e15          ADR      r0,|L1.428|
000058  ebfffffe          BL       sysprintf
;;;141            PRINT_INF("     DHCP server    \n");
00005c  e28f0e16          ADR      r0,|L1.452|
000060  ebfffffe          BL       sysprintf
;;;142            PRINT_INF("     please wait... \n");
000064  e28f0e17          ADR      r0,|L1.476|
000068  ebfffffe          BL       sysprintf
;;;143    #endif
;;;144          }
;;;145          break;
00006c  ea000048          B        |L1.404|
                  |L1.112|
;;;146    
;;;147          case DHCP_WAIT_ADDRESS:
000070  e1a00000          MOV      r0,r0
;;;148          {
;;;149            /* Read the new IP address */
;;;150            IPaddress = xnetif.ip_addr.addr;
000074  e59f012c          LDR      r0,|L1.424|
000078  e5904004          LDR      r4,[r0,#4]  ; xnetif
;;;151    
;;;152            if (IPaddress!=0) 
00007c  e3540000          CMP      r4,#0
000080  0a00001e          BEQ      |L1.256|
;;;153            {
;;;154              g_eDHCPState = DHCP_ADDRESS_ASSIGNED;	
000084  e3a00002          MOV      r0,#2
000088  e59f1114          LDR      r1,|L1.420|
00008c  e5c10000          STRB     r0,[r1,#0]  ; g_eDHCPState
;;;155              
;;;156              /* Stop DHCP */
;;;157              dhcp_stop(&xnetif);
000090  e59f0110          LDR      r0,|L1.424|
000094  ebfffffe          BL       dhcp_stop
;;;158                
;;;159    #ifdef PRINT_INF      
;;;160              iptab[0] = (uint8_t)(IPaddress >> 24);
000098  e1a00c24          LSR      r0,r4,#24
00009c  e5cd0030          STRB     r0,[sp,#0x30]
;;;161              iptab[1] = (uint8_t)(IPaddress >> 16);
0000a0  e1a00404          LSL      r0,r4,#8
0000a4  e1a00c20          LSR      r0,r0,#24
0000a8  e5cd0031          STRB     r0,[sp,#0x31]
;;;162              iptab[2] = (uint8_t)(IPaddress >> 8);
0000ac  e1a00804          LSL      r0,r4,#16
0000b0  e1a00c20          LSR      r0,r0,#24
0000b4  e5cd0032          STRB     r0,[sp,#0x32]
;;;163              iptab[3] = (uint8_t)(IPaddress);
0000b8  e5cd4033          STRB     r4,[sp,#0x33]
;;;164    
;;;165              sprintf((char*)iptxt, "  %d.%d.%d.%d\n", iptab[3], iptab[2], iptab[1], iptab[0]);  
0000bc  e5dd0030          LDRB     r0,[sp,#0x30]
0000c0  e5dd1031          LDRB     r1,[sp,#0x31]
0000c4  e58d0004          STR      r0,[sp,#4]
0000c8  e58d1000          STR      r1,[sp,#0]
0000cc  e5dd3032          LDRB     r3,[sp,#0x32]
0000d0  e5dd2033          LDRB     r2,[sp,#0x33]
0000d4  e28f1f46          ADR      r1,|L1.500|
0000d8  e28d0008          ADD      r0,sp,#8
0000dc  ebfffffe          BL       __2sprintf
;;;166    
;;;167              /* Display the IP address */
;;;168              PRINT_INF("IP address assigned \n");
0000e0  e28f0f47          ADR      r0,|L1.516|
0000e4  ebfffffe          BL       sysprintf
;;;169              PRINT_INF("  by a DHCP server  \n");
0000e8  e28f0f4b          ADR      r0,|L1.540|
0000ec  ebfffffe          BL       sysprintf
;;;170              PRINT_INF(iptxt);
0000f0  e28d0008          ADD      r0,sp,#8
0000f4  ebfffffe          BL       sysprintf
                  |L1.248|
;;;171    #endif  
;;;172              /* end of DHCP process: LED1 stays ON*/
;;;173    //          STM_EVAL_LEDOn(LED1);
;;;174    #if 0
;;;175              vTaskDelete(NULL);
;;;176    #else
;;;177             return ;
;;;178    #endif
;;;179            }
;;;180            else
;;;181            {
;;;182              /* DHCP timeout */
;;;183              if (xnetif.dhcp->tries > MAX_DHCP_TRIES)
;;;184              {
;;;185                g_eDHCPState = DHCP_TIMEOUT;
;;;186    
;;;187                /* Stop DHCP */
;;;188                dhcp_stop(&xnetif);
;;;189    
;;;190                /* Static address used */
;;;191    //            IP4_ADDR(&ipaddr, IP_ADDR0 ,IP_ADDR1 , IP_ADDR2 , IP_ADDR3 );
;;;192    //            IP4_ADDR(&netmask, NETMASK_ADDR0, NETMASK_ADDR1, NETMASK_ADDR2, NETMASK_ADDR3);
;;;193    //            IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);
;;;194    //            netif_set_addr(&xnetif, &ipaddr , &netmask, &gw);
;;;195    
;;;196    #ifdef PRINT_INF   
;;;197                PRINT_INF("    DHCP timeout    \n");
;;;198    
;;;199                iptab[0] = IP_ADDR3;
;;;200                iptab[1] = IP_ADDR2;
;;;201                iptab[2] = IP_ADDR1;
;;;202                iptab[3] = IP_ADDR0;
;;;203    
;;;204                sprintf((char*)iptxt, "  %d.%d.%d.%d\n", iptab[3], iptab[2], iptab[1], iptab[0]); 
;;;205    
;;;206                PRINT_INF("  Static IP address   \n");
;;;207                PRINT_INF(iptxt);
;;;208    #endif
;;;209                /* end of DHCP process: LED1 stays ON*/
;;;210    //            STM_EVAL_LEDOn(LED1);
;;;211    #if 0
;;;212              vTaskDelete(NULL);
;;;213    #else
;;;214             return ;
;;;215    #endif
;;;216              }
;;;217            }
;;;218          }
;;;219          break;
;;;220    
;;;221          default: break;
;;;222        }
;;;223    
;;;224        /* Toggle LED1 */
;;;225    //    STM_EVAL_LEDToggle(LED1);
;;;226        /* wait 250 ms */
;;;227        vTaskDelay( 250/portTICK_PERIOD_MS );
;;;228      }   
;;;229    }
0000f8  e28dd034          ADD      sp,sp,#0x34
0000fc  e8bd8030          POP      {r4,r5,pc}
                  |L1.256|
000100  e59f00a0          LDR      r0,|L1.424|
000104  e5900020          LDR      r0,[r0,#0x20]         ;183  ; xnetif
000108  e5d0000d          LDRB     r0,[r0,#0xd]          ;183
00010c  e3500005          CMP      r0,#5                 ;183
000110  da00001c          BLE      |L1.392|
000114  e3a00003          MOV      r0,#3                 ;185
000118  e59f1084          LDR      r1,|L1.420|
00011c  e5c10000          STRB     r0,[r1,#0]            ;185  ; g_eDHCPState
000120  e59f0080          LDR      r0,|L1.424|
000124  ebfffffe          BL       dhcp_stop
000128  e28f0f41          ADR      r0,|L1.564|
00012c  ebfffffe          BL       sysprintf
000130  e3a000e3          MOV      r0,#0xe3              ;199
000134  e5cd0030          STRB     r0,[sp,#0x30]         ;199
000138  e3a00001          MOV      r0,#1                 ;200
00013c  e5cd0031          STRB     r0,[sp,#0x31]         ;200
000140  e3a000a8          MOV      r0,#0xa8              ;201
000144  e5cd0032          STRB     r0,[sp,#0x32]         ;201
000148  e3a000c0          MOV      r0,#0xc0              ;202
00014c  e5cd0033          STRB     r0,[sp,#0x33]         ;202
000150  e5dd0030          LDRB     r0,[sp,#0x30]         ;204
000154  e5dd1031          LDRB     r1,[sp,#0x31]         ;204
000158  e58d0004          STR      r0,[sp,#4]            ;204
00015c  e58d1000          STR      r1,[sp,#0]            ;204
000160  e5dd3032          LDRB     r3,[sp,#0x32]         ;204
000164  e5dd2033          LDRB     r2,[sp,#0x33]         ;204
000168  e28f1084          ADR      r1,|L1.500|
00016c  e28d0008          ADD      r0,sp,#8              ;204
000170  ebfffffe          BL       __2sprintf
000174  e28f00d0          ADR      r0,|L1.588|
000178  ebfffffe          BL       sysprintf
00017c  e28d0008          ADD      r0,sp,#8              ;207
000180  ebfffffe          BL       sysprintf
000184  eaffffdb          B        |L1.248|
                  |L1.392|
000188  ea000001          B        |L1.404|
                  |L1.396|
00018c  e1a00000          MOV      r0,r0                 ;221
000190  e1a00000          MOV      r0,r0                 ;221
                  |L1.404|
000194  e1a00000          MOV      r0,r0                 ;145
000198  e3a000fa          MOV      r0,#0xfa              ;227
00019c  ebfffffe          BL       vTaskDelay
0001a0  eaffff9d          B        |L1.28|
;;;230    #endif  /* LWIP_DHCP */
                          ENDP

                  |L1.420|
                          DCD      g_eDHCPState
                  |L1.424|
                          DCD      xnetif
                  |L1.428|
0001ac  20202020          DCB      "     Looking for    \n",0
0001b0  204c6f6f
0001b4  6b696e67
0001b8  20666f72
0001bc  20202020
0001c0  0a00    
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L1.452|
0001c4  20202020          DCB      "     DHCP server    \n",0
0001c8  20444843
0001cc  50207365
0001d0  72766572
0001d4  20202020
0001d8  0a00    
0001da  00                DCB      0
0001db  00                DCB      0
                  |L1.476|
0001dc  20202020          DCB      "     please wait... \n",0
0001e0  20706c65
0001e4  61736520
0001e8  77616974
0001ec  2e2e2e20
0001f0  0a00    
0001f2  00                DCB      0
0001f3  00                DCB      0
                  |L1.500|
0001f4  20202564          DCB      "  %d.%d.%d.%d\n",0
0001f8  2e25642e
0001fc  25642e25
000200  640a00  
000203  00                DCB      0
                  |L1.516|
000204  49502061          DCB      "IP address assigned \n",0
000208  64647265
00020c  73732061
000210  73736967
000214  6e656420
000218  0a00    
00021a  00                DCB      0
00021b  00                DCB      0
                  |L1.540|
00021c  20206279          DCB      "  by a DHCP server  \n",0
000220  20612044
000224  48435020
000228  73657276
00022c  65722020
000230  0a00    
000232  00                DCB      0
000233  00                DCB      0
                  |L1.564|
000234  20202020          DCB      "    DHCP timeout    \n",0
000238  44484350
00023c  2074696d
000240  656f7574
000244  20202020
000248  0a00    
00024a  00                DCB      0
00024b  00                DCB      0
                  |L1.588|
00024c  20205374          DCB      "  Static IP address   \n",0
000250  61746963
000254  20495020
000258  61646472
00025c  65737320
000260  20200a00

                          AREA ||i.LwIP_Init||, CODE, READONLY, ALIGN=2

                  LwIP_Init PROC
;;;69       */
;;;70     void LwIP_Init(void)
000000  e52de004          PUSH     {lr}
;;;71     {
000004  e24dd01c          SUB      sp,sp,#0x1c
;;;72       struct ip_addr ipaddr;
;;;73       struct ip_addr netmask;
;;;74       struct ip_addr gw;
;;;75     
;;;76       /* Create tcp_ip stack thread */
;;;77       tcpip_init( NULL, NULL );	
000008  e3a01000          MOV      r1,#0
00000c  e1a00001          MOV      r0,r1
000010  ebfffffe          BL       tcpip_init
;;;78     
;;;79         
;;;80       /* IP address setting & display on STM32_evalboard LCD*/
;;;81     #if LWIP_DHCP
;;;82       ipaddr.addr = 0;
000014  e3a00000          MOV      r0,#0
000018  e58d0018          STR      r0,[sp,#0x18]
;;;83       netmask.addr = 0;
00001c  e58d0014          STR      r0,[sp,#0x14]
;;;84       gw.addr = 0;
000020  e58d0010          STR      r0,[sp,#0x10]
;;;85     #else
;;;86       IP4_ADDR(&ipaddr, 192, 168, 1, 227);
;;;87       IP4_ADDR(&netmask, 225, 225 , 225, 0);
;;;88       IP4_ADDR(&gw, 192, 168, 1, 1);
;;;89     #endif
;;;90     
;;;91       /* - netif_add(struct netif *netif, struct ip_addr *ipaddr,
;;;92                 struct ip_addr *netmask, struct ip_addr *gw,
;;;93                 void *state, err_t (* init)(struct netif *netif),
;;;94                 err_t (* input)(struct pbuf *p, struct netif *netif))
;;;95         
;;;96        Adds your network interface to the netif_list. Allocate a struct
;;;97       netif and pass a pointer to this structure as the first argument.
;;;98       Give pointers to cleared ip_addr structures when using DHCP,
;;;99       or fill them with sane numbers otherwise. The state pointer may be NULL.
;;;100    
;;;101      The init function pointer must point to a initialization function for
;;;102      your ethernet netif interface. The following code illustrates it's use.*/
;;;103      netif_add(&xnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init0, &tcpip_input);
000024  e59f003c          LDR      r0,|L2.104|
000028  e59f103c          LDR      r1,|L2.108|
00002c  e3a02000          MOV      r2,#0
000030  e58d0008          STR      r0,[sp,#8]
000034  e58d1004          STR      r1,[sp,#4]
000038  e58d2000          STR      r2,[sp,#0]
00003c  e28d3010          ADD      r3,sp,#0x10
000040  e28d2014          ADD      r2,sp,#0x14
000044  e28d1018          ADD      r1,sp,#0x18
000048  e59f0020          LDR      r0,|L2.112|
00004c  ebfffffe          BL       netif_add
;;;104    
;;;105     /*  Registers the default network interface. */
;;;106      netif_set_default(&xnetif);
000050  e59f0018          LDR      r0,|L2.112|
000054  ebfffffe          BL       netif_set_default
;;;107    
;;;108     /*  When the netif is fully configured this function must be called.*/
;;;109      netif_set_up(&xnetif); 
000058  e59f0010          LDR      r0,|L2.112|
00005c  ebfffffe          BL       netif_set_up
;;;110    }
000060  e28dd01c          ADD      sp,sp,#0x1c
000064  e49df004          POP      {pc}
;;;111    
                          ENDP

                  |L2.104|
                          DCD      tcpip_input
                  |L2.108|
                          DCD      ethernetif_init0
                  |L2.112|
                          DCD      xnetif

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xnetif
                          %        52

                          AREA ||.data||, DATA, ALIGN=0

                  g_eDHCPState
000000  04                DCB      0x04
