; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\sockets.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\sockets.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -D__UVISION_VERSION=524 --omf_browse=.\obj\sockets.crf lwip-1.4.1\src\api\sockets.c]
                          ARM

                          AREA ||i.alloc_socket||, CODE, READONLY, ALIGN=2

                  alloc_socket PROC
;;;242    static int
;;;243    alloc_socket(struct netconn *newconn, int accepted)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;244    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;245      int i;
;;;246      SYS_ARCH_DECL_PROTECT(lev);
;;;247    
;;;248      /* allocate a new socket identifier */
;;;249      for (i = 0; i < NUM_SOCKETS; ++i) {
00000c  e3a04000          MOV      r4,#0
000010  ea000032          B        |L1.224|
                  |L1.20|
;;;250        /* Protect socket array */
;;;251        SYS_ARCH_PROTECT(lev);
000014  ebfffffe          BL       sys_arch_protect
000018  e1a07000          MOV      r7,r0
;;;252        if (!sockets[i].conn) {
00001c  e0840084          ADD      r0,r4,r4,LSL #1
000020  e59f10c8          LDR      r1,|L1.240|
000024  e7910180          LDR      r0,[r1,r0,LSL #3]
000028  e3500000          CMP      r0,#0
00002c  1a000028          BNE      |L1.212|
;;;253          sockets[i].conn       = newconn;
000030  e0840084          ADD      r0,r4,r4,LSL #1
000034  e7815180          STR      r5,[r1,r0,LSL #3]
;;;254          /* The socket is not yet known to anyone, so no need to protect
;;;255             after having marked it as used. */
;;;256          SYS_ARCH_UNPROTECT(lev);
000038  e1a00007          MOV      r0,r7
00003c  ebfffffe          BL       sys_arch_unprotect
;;;257          sockets[i].lastdata   = NULL;
000040  e3a00000          MOV      r0,#0
000044  e0841084          ADD      r1,r4,r4,LSL #1
000048  e59f20a0          LDR      r2,|L1.240|
00004c  e0821181          ADD      r1,r2,r1,LSL #3
000050  e5810004          STR      r0,[r1,#4]
;;;258          sockets[i].lastoffset = 0;
000054  e0841084          ADD      r1,r4,r4,LSL #1
000058  e0821181          ADD      r1,r2,r1,LSL #3
00005c  e1c100b8          STRH     r0,[r1,#8]
;;;259          sockets[i].rcvevent   = 0;
000060  e0841084          ADD      r1,r4,r4,LSL #1
000064  e0821181          ADD      r1,r2,r1,LSL #3
000068  e1c100ba          STRH     r0,[r1,#0xa]
;;;260          /* TCP sendbuf is empty, but the socket is not yet writable until connected
;;;261           * (unless it has been created by accept()). */
;;;262          sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
00006c  e5d50000          LDRB     r0,[r5,#0]
000070  e3500010          CMP      r0,#0x10
000074  1a000005          BNE      |L1.144|
000078  e3560000          CMP      r6,#0
00007c  0a000001          BEQ      |L1.136|
000080  e3a00001          MOV      r0,#1
000084  ea000002          B        |L1.148|
                  |L1.136|
000088  e3a00000          MOV      r0,#0
00008c  ea000000          B        |L1.148|
                  |L1.144|
000090  e3a00001          MOV      r0,#1
                  |L1.148|
000094  e0841084          ADD      r1,r4,r4,LSL #1
000098  e59f2050          LDR      r2,|L1.240|
00009c  e0821181          ADD      r1,r2,r1,LSL #3
0000a0  e1c100bc          STRH     r0,[r1,#0xc]
;;;263          sockets[i].errevent   = 0;
0000a4  e3a00000          MOV      r0,#0
0000a8  e0841084          ADD      r1,r4,r4,LSL #1
0000ac  e0821181          ADD      r1,r2,r1,LSL #3
0000b0  e1c100be          STRH     r0,[r1,#0xe]
;;;264          sockets[i].err        = 0;
0000b4  e0841084          ADD      r1,r4,r4,LSL #1
0000b8  e0821181          ADD      r1,r2,r1,LSL #3
0000bc  e5810010          STR      r0,[r1,#0x10]
;;;265          sockets[i].select_waiting = 0;
0000c0  e0841084          ADD      r1,r4,r4,LSL #1
0000c4  e0821181          ADD      r1,r2,r1,LSL #3
0000c8  e5810014          STR      r0,[r1,#0x14]
;;;266          return i;
0000cc  e1a00004          MOV      r0,r4
                  |L1.208|
;;;267        }
;;;268        SYS_ARCH_UNPROTECT(lev);
;;;269      }
;;;270      return -1;
;;;271    }
0000d0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.212|
0000d4  e1a00007          MOV      r0,r7                 ;268
0000d8  ebfffffe          BL       sys_arch_unprotect
0000dc  e2844001          ADD      r4,r4,#1              ;249
                  |L1.224|
0000e0  e3540004          CMP      r4,#4                 ;249
0000e4  baffffca          BLT      |L1.20|
0000e8  e3e00000          MVN      r0,#0                 ;270
0000ec  eafffff7          B        |L1.208|
;;;272    
                          ENDP

                  |L1.240|
                          DCD      sockets

                          AREA ||i.event_callback||, CODE, READONLY, ALIGN=2

                  event_callback PROC
;;;1247   static void
;;;1248   event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1249   {
000004  e1a07000          MOV      r7,r0
000008  e1a08001          MOV      r8,r1
;;;1250     int s;
;;;1251     struct lwip_sock *sock;
;;;1252     struct lwip_select_cb *scb;
;;;1253     int last_select_cb_ctr;
;;;1254     SYS_ARCH_DECL_PROTECT(lev);
;;;1255   
;;;1256     LWIP_UNUSED_ARG(len);
;;;1257   
;;;1258     /* Get socket */
;;;1259     if (conn) {
00000c  e3570000          CMP      r7,#0
000010  0a000018          BEQ      |L2.120|
;;;1260       s = conn->socket;
000014  e5974018          LDR      r4,[r7,#0x18]
;;;1261       if (s < 0) {
000018  e3540000          CMP      r4,#0
00001c  aa00000f          BGE      |L2.96|
;;;1262         /* Data comes in right away after an accept, even though
;;;1263          * the server task might not have created a new socket yet.
;;;1264          * Just count down (or up) if that's the case and we
;;;1265          * will use the data later. Note that only receive events
;;;1266          * can happen before the new socket is set up. */
;;;1267         SYS_ARCH_PROTECT(lev);
000020  ebfffffe          BL       sys_arch_protect
000024  e1a0b000          MOV      r11,r0
;;;1268         if (conn->socket < 0) {
000028  e5970018          LDR      r0,[r7,#0x18]
00002c  e3500000          CMP      r0,#0
000030  aa000007          BGE      |L2.84|
;;;1269           if (evt == NETCONN_EVT_RCVPLUS) {
000034  e3580000          CMP      r8,#0
000038  1a000002          BNE      |L2.72|
;;;1270             conn->socket--;
00003c  e5970018          LDR      r0,[r7,#0x18]
000040  e2400001          SUB      r0,r0,#1
000044  e5870018          STR      r0,[r7,#0x18]
                  |L2.72|
;;;1271           }
;;;1272           SYS_ARCH_UNPROTECT(lev);
000048  e1a0000b          MOV      r0,r11
00004c  ebfffffe          BL       sys_arch_unprotect
                  |L2.80|
;;;1273           return;
;;;1274         }
;;;1275         s = conn->socket;
;;;1276         SYS_ARCH_UNPROTECT(lev);
;;;1277       }
;;;1278   
;;;1279       sock = get_socket(s);
;;;1280       if (!sock) {
;;;1281         return;
;;;1282       }
;;;1283     } else {
;;;1284       return;
;;;1285     }
;;;1286   
;;;1287     SYS_ARCH_PROTECT(lev);
;;;1288     /* Set event as required */
;;;1289     switch (evt) {
;;;1290       case NETCONN_EVT_RCVPLUS:
;;;1291         sock->rcvevent++;
;;;1292         break;
;;;1293       case NETCONN_EVT_RCVMINUS:
;;;1294         sock->rcvevent--;
;;;1295         break;
;;;1296       case NETCONN_EVT_SENDPLUS:
;;;1297         sock->sendevent = 1;
;;;1298         break;
;;;1299       case NETCONN_EVT_SENDMINUS:
;;;1300         sock->sendevent = 0;
;;;1301         break;
;;;1302       case NETCONN_EVT_ERROR:
;;;1303         sock->errevent = 1;
;;;1304         break;
;;;1305       default:
;;;1306         LWIP_ASSERT("unknown event", 0);
;;;1307         break;
;;;1308     }
;;;1309   
;;;1310     if (sock->select_waiting == 0) {
;;;1311       /* noone is waiting for this socket, no need to check select_cb_list */
;;;1312       SYS_ARCH_UNPROTECT(lev);
;;;1313       return;
;;;1314     }
;;;1315   
;;;1316     /* Now decide if anyone is waiting for this socket */
;;;1317     /* NOTE: This code goes through the select_cb_list list multiple times
;;;1318        ONLY IF a select was actually waiting. We go through the list the number
;;;1319        of waiting select calls + 1. This list is expected to be small. */
;;;1320   
;;;1321     /* At this point, SYS_ARCH is still protected! */
;;;1322   again:
;;;1323     for (scb = select_cb_list; scb != NULL; scb = scb->next) {
;;;1324       if (scb->sem_signalled == 0) {
;;;1325         /* semaphore not signalled yet */
;;;1326         int do_signal = 0;
;;;1327         /* Test this select call for our socket */
;;;1328         if (sock->rcvevent > 0) {
;;;1329           if (scb->readset && FD_ISSET(s, scb->readset)) {
;;;1330             do_signal = 1;
;;;1331           }
;;;1332         }
;;;1333         if (sock->sendevent != 0) {
;;;1334           if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
;;;1335             do_signal = 1;
;;;1336           }
;;;1337         }
;;;1338         if (sock->errevent != 0) {
;;;1339           if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
;;;1340             do_signal = 1;
;;;1341           }
;;;1342         }
;;;1343         if (do_signal) {
;;;1344           scb->sem_signalled = 1;
;;;1345           /* Don't call SYS_ARCH_UNPROTECT() before signaling the semaphore, as this might
;;;1346              lead to the select thread taking itself off the list, invalidagin the semaphore. */
;;;1347           sys_sem_signal(&scb->sem);
;;;1348         }
;;;1349       }
;;;1350       /* unlock interrupts with each step */
;;;1351       last_select_cb_ctr = select_cb_ctr;
;;;1352       SYS_ARCH_UNPROTECT(lev);
;;;1353       /* this makes sure interrupt protection time is short */
;;;1354       SYS_ARCH_PROTECT(lev);
;;;1355       if (last_select_cb_ctr != select_cb_ctr) {
;;;1356         /* someone has changed select_cb_list, restart at the beginning */
;;;1357         goto again;
;;;1358       }
;;;1359     }
;;;1360     SYS_ARCH_UNPROTECT(lev);
;;;1361   }
000050  e8bd9ff0          POP      {r4-r12,pc}
                  |L2.84|
000054  e5974018          LDR      r4,[r7,#0x18]         ;1275
000058  e1a0000b          MOV      r0,r11                ;1276
00005c  ebfffffe          BL       sys_arch_unprotect
                  |L2.96|
000060  e1a00004          MOV      r0,r4                 ;1279
000064  ebfffffe          BL       get_socket
000068  e1a05000          MOV      r5,r0                 ;1279
00006c  e3550000          CMP      r5,#0                 ;1280
000070  1a000001          BNE      |L2.124|
000074  eafffff5          B        |L2.80|
                  |L2.120|
000078  eafffff4          B        |L2.80|
                  |L2.124|
00007c  ebfffffe          BL       sys_arch_protect
000080  e1a0b000          MOV      r11,r0                ;1287
000084  e3580005          CMP      r8,#5                 ;1289
000088  308ff108          ADDCC    pc,pc,r8,LSL #2       ;1289
00008c  ea00001e          B        |L2.268|
000090  ea000003          B        |L2.164|
000094  ea000009          B        |L2.192|
000098  ea00000f          B        |L2.220|
00009c  ea000012          B        |L2.236|
0000a0  ea000015          B        |L2.252|
                  |L2.164|
0000a4  e1a00000          MOV      r0,r0                 ;1290
0000a8  e1d500ba          LDRH     r0,[r5,#0xa]          ;1291
0000ac  e2800001          ADD      r0,r0,#1              ;1291
0000b0  e1a00800          LSL      r0,r0,#16             ;1291
0000b4  e1a00840          ASR      r0,r0,#16             ;1291
0000b8  e1c500ba          STRH     r0,[r5,#0xa]          ;1291
0000bc  ea00001d          B        |L2.312|
                  |L2.192|
0000c0  e1a00000          MOV      r0,r0                 ;1293
0000c4  e1d500ba          LDRH     r0,[r5,#0xa]          ;1294
0000c8  e2400001          SUB      r0,r0,#1              ;1294
0000cc  e1a00800          LSL      r0,r0,#16             ;1294
0000d0  e1a00840          ASR      r0,r0,#16             ;1294
0000d4  e1c500ba          STRH     r0,[r5,#0xa]          ;1294
0000d8  ea000016          B        |L2.312|
                  |L2.220|
0000dc  e1a00000          MOV      r0,r0                 ;1296
0000e0  e3a00001          MOV      r0,#1                 ;1297
0000e4  e1c500bc          STRH     r0,[r5,#0xc]          ;1297
0000e8  ea000012          B        |L2.312|
                  |L2.236|
0000ec  e1a00000          MOV      r0,r0                 ;1299
0000f0  e3a00000          MOV      r0,#0                 ;1300
0000f4  e1c500bc          STRH     r0,[r5,#0xc]          ;1300
0000f8  ea00000e          B        |L2.312|
                  |L2.252|
0000fc  e1a00000          MOV      r0,r0                 ;1302
000100  e3a00001          MOV      r0,#1                 ;1303
000104  e1c500be          STRH     r0,[r5,#0xe]          ;1303
000108  ea00000a          B        |L2.312|
                  |L2.268|
00010c  e1a00000          MOV      r0,r0                 ;1305
000110  e1a00000          MOV      r0,r0                 ;1306
000114  e1a00000          MOV      r0,r0                 ;1306
000118  e28f3f62          ADR      r3,|L2.680|
00011c  e59f21a4          LDR      r2,|L2.712|
000120  e28f1f69          ADR      r1,|L2.716|
000124  e28f0e1b          ADR      r0,|L2.732|
000128  ebfffffe          BL       sysprintf
00012c  e1a00000          MOV      r0,r0                 ;1306
000130  e1a00000          MOV      r0,r0                 ;1306
000134  e1a00000          MOV      r0,r0                 ;1307
                  |L2.312|
000138  e1a00000          MOV      r0,r0                 ;1292
00013c  e5950014          LDR      r0,[r5,#0x14]         ;1310
000140  e3500000          CMP      r0,#0                 ;1310
000144  1a000002          BNE      |L2.340|
000148  e1a0000b          MOV      r0,r11                ;1312
00014c  ebfffffe          BL       sys_arch_unprotect
000150  eaffffbe          B        |L2.80|
                  |L2.340|
000154  e1a00000          MOV      r0,r0                 ;1322
                  |L2.344|
000158  e59f01a4          LDR      r0,|L2.772|
00015c  e5906000          LDR      r6,[r0,#0]            ;1323  ; select_cb_list
000160  ea00004a          B        |L2.656|
                  |L2.356|
000164  e5960014          LDR      r0,[r6,#0x14]         ;1324
000168  e3500000          CMP      r0,#0                 ;1324
00016c  1a00003b          BNE      |L2.608|
000170  e3a09000          MOV      r9,#0                 ;1326
000174  e1d500fa          LDRSH    r0,[r5,#0xa]          ;1328
000178  e3500000          CMP      r0,#0                 ;1328
00017c  da00000c          BLE      |L2.436|
000180  e5961008          LDR      r1,[r6,#8]            ;1329
000184  e3510000          CMP      r1,#0                 ;1329
000188  0a000009          BEQ      |L2.436|
00018c  e1a01fc4          ASR      r1,r4,#31             ;1329
000190  e0841ea1          ADD      r1,r4,r1,LSR #29      ;1329
000194  e5962008          LDR      r2,[r6,#8]            ;1329
000198  e7d211c1          LDRB     r1,[r2,r1,ASR #3]     ;1329
00019c  e2042007          AND      r2,r4,#7              ;1329
0001a0  e3a03001          MOV      r3,#1                 ;1329
0001a4  e0011213          AND      r1,r1,r3,LSL r2       ;1329
0001a8  e3510000          CMP      r1,#0                 ;1329
0001ac  0a000000          BEQ      |L2.436|
0001b0  e3a09001          MOV      r9,#1                 ;1330
                  |L2.436|
0001b4  e1d500bc          LDRH     r0,[r5,#0xc]          ;1333
0001b8  e3500000          CMP      r0,#0                 ;1333
0001bc  0a00000e          BEQ      |L2.508|
0001c0  e3590000          CMP      r9,#0                 ;1334
0001c4  1a00000c          BNE      |L2.508|
0001c8  e596100c          LDR      r1,[r6,#0xc]          ;1334
0001cc  e3510000          CMP      r1,#0                 ;1334
0001d0  0a000009          BEQ      |L2.508|
0001d4  e1a01fc4          ASR      r1,r4,#31             ;1334
0001d8  e0841ea1          ADD      r1,r4,r1,LSR #29      ;1334
0001dc  e596200c          LDR      r2,[r6,#0xc]          ;1334
0001e0  e7d211c1          LDRB     r1,[r2,r1,ASR #3]     ;1334
0001e4  e2042007          AND      r2,r4,#7              ;1334
0001e8  e3a03001          MOV      r3,#1                 ;1334
0001ec  e0011213          AND      r1,r1,r3,LSL r2       ;1334
0001f0  e3510000          CMP      r1,#0                 ;1334
0001f4  0a000000          BEQ      |L2.508|
0001f8  e3a09001          MOV      r9,#1                 ;1335
                  |L2.508|
0001fc  e1d500be          LDRH     r0,[r5,#0xe]          ;1338
000200  e3500000          CMP      r0,#0                 ;1338
000204  0a00000e          BEQ      |L2.580|
000208  e3590000          CMP      r9,#0                 ;1339
00020c  1a00000c          BNE      |L2.580|
000210  e5961010          LDR      r1,[r6,#0x10]         ;1339
000214  e3510000          CMP      r1,#0                 ;1339
000218  0a000009          BEQ      |L2.580|
00021c  e1a01fc4          ASR      r1,r4,#31             ;1339
000220  e0841ea1          ADD      r1,r4,r1,LSR #29      ;1339
000224  e5962010          LDR      r2,[r6,#0x10]         ;1339
000228  e7d211c1          LDRB     r1,[r2,r1,ASR #3]     ;1339
00022c  e2042007          AND      r2,r4,#7              ;1339
000230  e3a03001          MOV      r3,#1                 ;1339
000234  e0011213          AND      r1,r1,r3,LSL r2       ;1339
000238  e3510000          CMP      r1,#0                 ;1339
00023c  0a000000          BEQ      |L2.580|
000240  e3a09001          MOV      r9,#1                 ;1340
                  |L2.580|
000244  e3590000          CMP      r9,#0                 ;1343
000248  0a000003          BEQ      |L2.604|
00024c  e3a00001          MOV      r0,#1                 ;1344
000250  e5860014          STR      r0,[r6,#0x14]         ;1344
000254  e2860018          ADD      r0,r6,#0x18           ;1347
000258  ebfffffe          BL       sys_sem_signal
                  |L2.604|
00025c  e1a00000          MOV      r0,r0                 ;1349
                  |L2.608|
000260  e59f00a0          LDR      r0,|L2.776|
000264  e590a000          LDR      r10,[r0,#0]           ;1351  ; select_cb_ctr
000268  e1a0000b          MOV      r0,r11                ;1352
00026c  ebfffffe          BL       sys_arch_unprotect
000270  ebfffffe          BL       sys_arch_protect
000274  e1a0b000          MOV      r11,r0                ;1354
000278  e59f0088          LDR      r0,|L2.776|
00027c  e5900000          LDR      r0,[r0,#0]            ;1355  ; select_cb_ctr
000280  e15a0000          CMP      r10,r0                ;1355
000284  0a000000          BEQ      |L2.652|
000288  eaffffb2          B        |L2.344|
                  |L2.652|
00028c  e5966000          LDR      r6,[r6,#0]            ;1323
                  |L2.656|
000290  e3560000          CMP      r6,#0                 ;1323
000294  1affffb2          BNE      |L2.356|
000298  e1a0000b          MOV      r0,r11                ;1360
00029c  ebfffffe          BL       sys_arch_unprotect
0002a0  e1a00000          MOV      r0,r0
0002a4  eaffff69          B        |L2.80|
;;;1362   
                          ENDP

                  |L2.680|
0002a8  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
0002ac  2d312e34
0002b0  2e315c73
0002b4  72635c61
0002b8  70695c73
0002bc  6f636b65
0002c0  74732e63
0002c4  00      
0002c5  00                DCB      0
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L2.712|
                          DCD      0x0000051a
                  |L2.716|
0002cc  756e6b6e          DCB      "unknown event",0
0002d0  6f776e20
0002d4  6576656e
0002d8  7400    
0002da  00                DCB      0
0002db  00                DCB      0
                  |L2.732|
0002dc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0002e0  7274696f
0002e4  6e202225
0002e8  73222066
0002ec  61696c65
0002f0  64206174
0002f4  206c696e
0002f8  65202564
0002fc  20696e20
000300  25730a00
                  |L2.772|
                          DCD      select_cb_list
                  |L2.776|
                          DCD      select_cb_ctr

                          AREA ||i.free_socket||, CODE, READONLY, ALIGN=2

                  free_socket PROC
;;;279    static void
;;;280    free_socket(struct lwip_sock *sock, int is_tcp)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;281    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;282      void *lastdata;
;;;283      SYS_ARCH_DECL_PROTECT(lev);
;;;284    
;;;285      lastdata         = sock->lastdata;
00000c  e5946004          LDR      r6,[r4,#4]
;;;286      sock->lastdata   = NULL;
000010  e3a00000          MOV      r0,#0
000014  e5840004          STR      r0,[r4,#4]
;;;287      sock->lastoffset = 0;
000018  e1c400b8          STRH     r0,[r4,#8]
;;;288      sock->err        = 0;
00001c  e5840010          STR      r0,[r4,#0x10]
;;;289    
;;;290      /* Protect socket array */
;;;291      SYS_ARCH_PROTECT(lev);
000020  ebfffffe          BL       sys_arch_protect
000024  e1a07000          MOV      r7,r0
;;;292      sock->conn       = NULL;
000028  e3a00000          MOV      r0,#0
00002c  e5840000          STR      r0,[r4,#0]
;;;293      SYS_ARCH_UNPROTECT(lev);
000030  e1a00007          MOV      r0,r7
000034  ebfffffe          BL       sys_arch_unprotect
;;;294      /* don't use 'sock' after this line, as another task might have allocated it */
;;;295    
;;;296      if (lastdata != NULL) {
000038  e3560000          CMP      r6,#0
00003c  0a000006          BEQ      |L3.92|
;;;297        if (is_tcp) {
000040  e3550000          CMP      r5,#0
000044  0a000002          BEQ      |L3.84|
;;;298          pbuf_free((struct pbuf *)lastdata);
000048  e1a00006          MOV      r0,r6
00004c  ebfffffe          BL       pbuf_free
000050  ea000001          B        |L3.92|
                  |L3.84|
;;;299        } else {
;;;300          netbuf_delete((struct netbuf *)lastdata);
000054  e1a00006          MOV      r0,r6
000058  ebfffffe          BL       netbuf_delete
                  |L3.92|
;;;301        }
;;;302      }
;;;303    }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;304    
                          ENDP


                          AREA ||i.get_socket||, CODE, READONLY, ALIGN=2

                  get_socket PROC
;;;194    static struct lwip_sock *
;;;195    get_socket(int s)
000000  e1a01000          MOV      r1,r0
;;;196    {
;;;197      struct lwip_sock *sock;
;;;198    
;;;199      if ((s < 0) || (s >= NUM_SOCKETS)) {
000004  e3510000          CMP      r1,#0
000008  ba000001          BLT      |L4.20|
00000c  e3510004          CMP      r1,#4
000010  ba000001          BLT      |L4.28|
                  |L4.20|
;;;200        LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
;;;201        set_errno(EBADF);
;;;202        return NULL;
000014  e3a00000          MOV      r0,#0
                  |L4.24|
;;;203      }
;;;204    
;;;205      sock = &sockets[s];
;;;206    
;;;207      if (!sock->conn) {
;;;208        LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
;;;209        set_errno(EBADF);
;;;210        return NULL;
;;;211      }
;;;212    
;;;213      return sock;
;;;214    }
000018  e12fff1e          BX       lr
                  |L4.28|
00001c  e0810081          ADD      r0,r1,r1,LSL #1       ;205
000020  e59f301c          LDR      r3,|L4.68|
000024  e0832180          ADD      r2,r3,r0,LSL #3       ;205
000028  e5920000          LDR      r0,[r2,#0]            ;207
00002c  e3500000          CMP      r0,#0                 ;207
000030  1a000001          BNE      |L4.60|
000034  e3a00000          MOV      r0,#0                 ;210
000038  eafffff6          B        |L4.24|
                  |L4.60|
00003c  e1a00002          MOV      r0,r2                 ;213
000040  eafffff4          B        |L4.24|
;;;215    
                          ENDP

                  |L4.68|
                          DCD      sockets

                          AREA ||i.lwip_accept||, CODE, READONLY, ALIGN=2

                  lwip_accept PROC
;;;311    int
;;;312    lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;313    {
000004  e24dd01c          SUB      sp,sp,#0x1c
000008  e1a0a000          MOV      r10,r0
00000c  e1a08001          MOV      r8,r1
000010  e1a07002          MOV      r7,r2
;;;314      struct lwip_sock *sock, *nsock;
;;;315      struct netconn *newconn;
;;;316      ip_addr_t naddr;
;;;317      u16_t port;
;;;318      int newsock;
;;;319      struct sockaddr_in sin;
;;;320      err_t err;
;;;321      SYS_ARCH_DECL_PROTECT(lev);
;;;322    
;;;323      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
;;;324      sock = get_socket(s);
000014  e1a0000a          MOV      r0,r10
000018  ebfffffe          BL       get_socket
00001c  e1a04000          MOV      r4,r0
;;;325      if (!sock) {
000020  e3540000          CMP      r4,#0
000024  1a000002          BNE      |L5.52|
;;;326        return -1;
000028  e3e00000          MVN      r0,#0
                  |L5.44|
00002c  e28dd01c          ADD      sp,sp,#0x1c
;;;327      }
;;;328    
;;;329      if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
;;;330        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): returning EWOULDBLOCK\n", s));
;;;331        sock_set_errno(sock, EWOULDBLOCK);
;;;332        return -1;
;;;333      }
;;;334    
;;;335      /* wait for a new connection */
;;;336      err = netconn_accept(sock->conn, &newconn);
;;;337      if (err != ERR_OK) {
;;;338        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
;;;339        if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;340          sock_set_errno(sock, EOPNOTSUPP);
;;;341          return EOPNOTSUPP;
;;;342        }
;;;343        sock_set_errno(sock, err_to_errno(err));
;;;344        return -1;
;;;345      }
;;;346      LWIP_ASSERT("newconn != NULL", newconn != NULL);
;;;347      /* Prevent automatic window updates, we do this on our own! */
;;;348      netconn_set_noautorecved(newconn, 1);
;;;349    
;;;350      /* get the IP address and port of the remote host */
;;;351      err = netconn_peer(newconn, &naddr, &port);
;;;352      if (err != ERR_OK) {
;;;353        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
;;;354        netconn_delete(newconn);
;;;355        sock_set_errno(sock, err_to_errno(err));
;;;356        return -1;
;;;357      }
;;;358    
;;;359      /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
;;;360       * not be NULL if addr is valid.
;;;361       */
;;;362      if (NULL != addr) {
;;;363        LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
;;;364        memset(&sin, 0, sizeof(sin));
;;;365        sin.sin_len = sizeof(sin);
;;;366        sin.sin_family = AF_INET;
;;;367        sin.sin_port = htons(port);
;;;368        inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
;;;369    
;;;370        if (*addrlen > sizeof(sin))
;;;371          *addrlen = sizeof(sin);
;;;372    
;;;373        MEMCPY(addr, &sin, *addrlen);
;;;374      }
;;;375    
;;;376      newsock = alloc_socket(newconn, 1);
;;;377      if (newsock == -1) {
;;;378        netconn_delete(newconn);
;;;379        sock_set_errno(sock, ENFILE);
;;;380        return -1;
;;;381      }
;;;382      LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
;;;383      LWIP_ASSERT("newconn->callback == event_callback", newconn->callback == event_callback);
;;;384      nsock = &sockets[newsock];
;;;385    
;;;386      /* See event_callback: If data comes in right away after an accept, even
;;;387       * though the server task might not have created a new socket yet.
;;;388       * In that case, newconn->socket is counted down (newconn->socket--),
;;;389       * so nsock->rcvevent is >= 1 here!
;;;390       */
;;;391      SYS_ARCH_PROTECT(lev);
;;;392      nsock->rcvevent += (s16_t)(-1 - newconn->socket);
;;;393      newconn->socket = newsock;
;;;394      SYS_ARCH_UNPROTECT(lev);
;;;395    
;;;396      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
;;;397      ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
;;;398      LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));
;;;399    
;;;400      sock_set_errno(sock, 0);
;;;401      return newsock;
;;;402    }
000030  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.52|
000034  e5940000          LDR      r0,[r4,#0]            ;329
000038  e5d0001c          LDRB     r0,[r0,#0x1c]         ;329
00003c  e2000002          AND      r0,r0,#2              ;329
000040  e3500000          CMP      r0,#0                 ;329
000044  0a000008          BEQ      |L5.108|
000048  e1d400fa          LDRSH    r0,[r4,#0xa]          ;329
00004c  e3500000          CMP      r0,#0                 ;329
000050  ca000005          BGT      |L5.108|
000054  e1a00000          MOV      r0,r0                 ;331
000058  e3a0000b          MOV      r0,#0xb               ;331
00005c  e5840010          STR      r0,[r4,#0x10]         ;331
000060  e1a00000          MOV      r0,r0                 ;331
000064  e3e00000          MVN      r0,#0                 ;332
000068  eaffffef          B        |L5.44|
                  |L5.108|
00006c  e28d1018          ADD      r1,sp,#0x18           ;336
000070  e5940000          LDR      r0,[r4,#0]            ;336
000074  ebfffffe          BL       netconn_accept
000078  e1a05000          MOV      r5,r0                 ;336
00007c  e3550000          CMP      r5,#0                 ;337
000080  0a000015          BEQ      |L5.220|
000084  e5940000          LDR      r0,[r4,#0]            ;339
000088  e5d00000          LDRB     r0,[r0,#0]            ;339
00008c  e3500010          CMP      r0,#0x10              ;339
000090  0a000004          BEQ      |L5.168|
000094  e1a00000          MOV      r0,r0                 ;340
000098  e3a0005f          MOV      r0,#0x5f              ;340
00009c  e5840010          STR      r0,[r4,#0x10]         ;340
0000a0  e1a00000          MOV      r0,r0                 ;340
0000a4  eaffffe0          B        |L5.44|
                  |L5.168|
0000a8  e1a00000          MOV      r0,r0                 ;343
0000ac  e2650000          RSB      r0,r5,#0              ;343
0000b0  e3500010          CMP      r0,#0x10              ;343
0000b4  2a000003          BCS      |L5.200|
0000b8  e59f0258          LDR      r0,|L5.792|
0000bc  e2651000          RSB      r1,r5,#0              ;343
0000c0  e7900101          LDR      r0,[r0,r1,LSL #2]     ;343
0000c4  ea000000          B        |L5.204|
                  |L5.200|
0000c8  e3a00005          MOV      r0,#5                 ;343
                  |L5.204|
0000cc  e5840010          STR      r0,[r4,#0x10]         ;343
0000d0  e1a00000          MOV      r0,r0                 ;343
0000d4  e3e00000          MVN      r0,#0                 ;344
0000d8  eaffffd3          B        |L5.44|
                  |L5.220|
0000dc  e1a00000          MOV      r0,r0                 ;346
0000e0  e59d0018          LDR      r0,[sp,#0x18]         ;346
0000e4  e3500000          CMP      r0,#0                 ;346
0000e8  1a000006          BNE      |L5.264|
0000ec  e1a00000          MOV      r0,r0                 ;346
0000f0  e28f3f89          ADR      r3,|L5.796|
0000f4  e59f2240          LDR      r2,|L5.828|
0000f8  e28f1d09          ADR      r1,|L5.832|
0000fc  e28f0f93          ADR      r0,|L5.848|
000100  ebfffffe          BL       sysprintf
000104  e1a00000          MOV      r0,r0                 ;346
                  |L5.264|
000108  e1a00000          MOV      r0,r0                 ;346
00010c  e1a00000          MOV      r0,r0                 ;348
000110  e59d0018          LDR      r0,[sp,#0x18]         ;348
000114  e5d0001c          LDRB     r0,[r0,#0x1c]         ;348
000118  e3800008          ORR      r0,r0,#8              ;348
00011c  e59d1018          LDR      r1,[sp,#0x18]         ;348
000120  e5c1001c          STRB     r0,[r1,#0x1c]         ;348
000124  e1a00000          MOV      r0,r0                 ;348
000128  e3a03000          MOV      r3,#0                 ;351
00012c  e28d2010          ADD      r2,sp,#0x10           ;351
000130  e28d1014          ADD      r1,sp,#0x14           ;351
000134  e59d0018          LDR      r0,[sp,#0x18]         ;351
000138  ebfffffe          BL       netconn_getaddr
00013c  e1a05000          MOV      r5,r0                 ;351
000140  e3550000          CMP      r5,#0                 ;352
000144  0a00000e          BEQ      |L5.388|
000148  e59d0018          LDR      r0,[sp,#0x18]         ;354
00014c  ebfffffe          BL       netconn_delete
000150  e1a00000          MOV      r0,r0                 ;355
000154  e2650000          RSB      r0,r5,#0              ;355
000158  e3500010          CMP      r0,#0x10              ;355
00015c  2a000003          BCS      |L5.368|
000160  e59f01b0          LDR      r0,|L5.792|
000164  e2651000          RSB      r1,r5,#0              ;355
000168  e7900101          LDR      r0,[r0,r1,LSL #2]     ;355
00016c  ea000000          B        |L5.372|
                  |L5.368|
000170  e3a00005          MOV      r0,#5                 ;355
                  |L5.372|
000174  e5840010          STR      r0,[r4,#0x10]         ;355
000178  e1a00000          MOV      r0,r0                 ;355
00017c  e3e00000          MVN      r0,#0                 ;356
000180  eaffffa9          B        |L5.44|
                  |L5.388|
000184  e3580000          CMP      r8,#0                 ;362
000188  0a000021          BEQ      |L5.532|
00018c  e1a00000          MOV      r0,r0                 ;363
000190  e3570000          CMP      r7,#0                 ;363
000194  1a000006          BNE      |L5.436|
000198  e1a00000          MOV      r0,r0                 ;363
00019c  e28f3f5e          ADR      r3,|L5.796|
0001a0  e59f21d0          LDR      r2,|L5.888|
0001a4  e28f1e1d          ADR      r1,|L5.892|
0001a8  e28f0e1a          ADR      r0,|L5.848|
0001ac  ebfffffe          BL       sysprintf
0001b0  e1a00000          MOV      r0,r0                 ;363
                  |L5.436|
0001b4  e1a00000          MOV      r0,r0                 ;363
0001b8  e3a00000          MOV      r0,#0                 ;364
0001bc  e58d0000          STR      r0,[sp,#0]            ;364
0001c0  e58d0004          STR      r0,[sp,#4]            ;364
0001c4  e58d0008          STR      r0,[sp,#8]            ;364
0001c8  e58d000c          STR      r0,[sp,#0xc]          ;364
0001cc  e3a00010          MOV      r0,#0x10              ;365
0001d0  e5cd0000          STRB     r0,[sp,#0]            ;365
0001d4  e3a00002          MOV      r0,#2                 ;366
0001d8  e5cd0001          STRB     r0,[sp,#1]            ;366
0001dc  e1dd01b0          LDRH     r0,[sp,#0x10]         ;367
0001e0  ebfffffe          BL       lwip_htons
0001e4  e1cd00b2          STRH     r0,[sp,#2]            ;367
0001e8  e59d0014          LDR      r0,[sp,#0x14]         ;368
0001ec  e58d0004          STR      r0,[sp,#4]            ;368
0001f0  e5970000          LDR      r0,[r7,#0]            ;370
0001f4  e3500010          CMP      r0,#0x10              ;370
0001f8  9a000001          BLS      |L5.516|
0001fc  e3a00010          MOV      r0,#0x10              ;371
000200  e5870000          STR      r0,[r7,#0]            ;371
                  |L5.516|
000204  e1a0100d          MOV      r1,sp                 ;373
000208  e1a00008          MOV      r0,r8                 ;373
00020c  e5972000          LDR      r2,[r7,#0]            ;373
000210  ebfffffe          BL       __aeabi_memcpy
                  |L5.532|
000214  e3a01001          MOV      r1,#1                 ;376
000218  e59d0018          LDR      r0,[sp,#0x18]         ;376
00021c  ebfffffe          BL       alloc_socket
000220  e1a06000          MOV      r6,r0                 ;376
000224  e3760001          CMN      r6,#1                 ;377
000228  1a000007          BNE      |L5.588|
00022c  e59d0018          LDR      r0,[sp,#0x18]         ;378
000230  ebfffffe          BL       netconn_delete
000234  e1a00000          MOV      r0,r0                 ;379
000238  e3a00017          MOV      r0,#0x17              ;379
00023c  e5840010          STR      r0,[r4,#0x10]         ;379
000240  e1a00000          MOV      r0,r0                 ;379
000244  e3e00000          MVN      r0,#0                 ;380
000248  eaffff77          B        |L5.44|
                  |L5.588|
00024c  e1a00000          MOV      r0,r0                 ;382
000250  e3560000          CMP      r6,#0                 ;382
000254  ba000001          BLT      |L5.608|
000258  e3560004          CMP      r6,#4                 ;382
00025c  ba000006          BLT      |L5.636|
                  |L5.608|
000260  e1a00000          MOV      r0,r0                 ;382
000264  e28f30b0          ADR      r3,|L5.796|
000268  e59f2128          LDR      r2,|L5.920|
00026c  e28f1f4a          ADR      r1,|L5.924|
000270  e28f00d8          ADR      r0,|L5.848|
000274  ebfffffe          BL       sysprintf
000278  e1a00000          MOV      r0,r0                 ;382
                  |L5.636|
00027c  e1a00000          MOV      r0,r0                 ;382
000280  e1a00000          MOV      r0,r0                 ;383
000284  e59d0018          LDR      r0,[sp,#0x18]         ;383
000288  e5900028          LDR      r0,[r0,#0x28]         ;383
00028c  e59f1120          LDR      r1,|L5.948|
000290  e1500001          CMP      r0,r1                 ;383
000294  0a000006          BEQ      |L5.692|
000298  e1a00000          MOV      r0,r0                 ;383
00029c  e28f3078          ADR      r3,|L5.796|
0002a0  e59f2110          LDR      r2,|L5.952|
0002a4  e28f1e11          ADR      r1,|L5.956|
0002a8  e28f00a0          ADR      r0,|L5.848|
0002ac  ebfffffe          BL       sysprintf
0002b0  e1a00000          MOV      r0,r0                 ;383
                  |L5.692|
0002b4  e1a00000          MOV      r0,r0                 ;383
0002b8  e0860086          ADD      r0,r6,r6,LSL #1       ;384
0002bc  e59f111c          LDR      r1,|L5.992|
0002c0  e0819180          ADD      r9,r1,r0,LSL #3       ;384
0002c4  ebfffffe          BL       sys_arch_protect
0002c8  e1a0b000          MOV      r11,r0                ;391
0002cc  e1d910ba          LDRH     r1,[r9,#0xa]          ;392
0002d0  e59d0018          LDR      r0,[sp,#0x18]         ;392
0002d4  e1d001b8          LDRH     r0,[r0,#0x18]         ;392
0002d8  e3e02000          MVN      r2,#0                 ;392
0002dc  e0420000          SUB      r0,r2,r0              ;392
0002e0  e0800001          ADD      r0,r0,r1              ;392
0002e4  e1a00800          LSL      r0,r0,#16             ;392
0002e8  e1a00840          ASR      r0,r0,#16             ;392
0002ec  e1c900ba          STRH     r0,[r9,#0xa]          ;392
0002f0  e59d0018          LDR      r0,[sp,#0x18]         ;393
0002f4  e5806018          STR      r6,[r0,#0x18]         ;393
0002f8  e1a0000b          MOV      r0,r11                ;394
0002fc  ebfffffe          BL       sys_arch_unprotect
000300  e1a00000          MOV      r0,r0                 ;400
000304  e3a00000          MOV      r0,#0                 ;400
000308  e5840010          STR      r0,[r4,#0x10]         ;400
00030c  e1a00000          MOV      r0,r0                 ;400
000310  e1a00006          MOV      r0,r6                 ;401
000314  eaffff44          B        |L5.44|
                  |L5.792|
                          DCD      err_to_errno_table
                  |L5.796|
00031c  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
000320  2d312e34
000324  2e315c73
000328  72635c61
00032c  70695c73
000330  6f636b65
000334  74732e63
000338  00      
000339  00                DCB      0
00033a  00                DCB      0
00033b  00                DCB      0
                  |L5.828|
                          DCD      0x0000015a
                  |L5.832|
000340  6e657763          DCB      "newconn != NULL",0
000344  6f6e6e20
000348  213d204e
00034c  554c4c00
                  |L5.848|
000350  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000354  7274696f
000358  6e202225
00035c  73222066
000360  61696c65
000364  64206174
000368  206c696e
00036c  65202564
000370  20696e20
000374  25730a00
                  |L5.888|
                          DCD      0x0000016b
                  |L5.892|
00037c  61646472          DCB      "addr valid but addrlen NULL",0
000380  2076616c
000384  69642062
000388  75742061
00038c  6464726c
000390  656e204e
000394  554c4c00
                  |L5.920|
                          DCD      0x0000017e
                  |L5.924|
00039c  696e7661          DCB      "invalid socket index",0
0003a0  6c696420
0003a4  736f636b
0003a8  65742069
0003ac  6e646578
0003b0  00      
0003b1  00                DCB      0
0003b2  00                DCB      0
0003b3  00                DCB      0
                  |L5.948|
                          DCD      event_callback
                  |L5.952|
                          DCD      0x0000017f
                  |L5.956|
0003bc  6e657763          DCB      "newconn->callback == event_callback",0
0003c0  6f6e6e2d
0003c4  3e63616c
0003c8  6c626163
0003cc  6b203d3d
0003d0  20657665
0003d4  6e745f63
0003d8  616c6c62
0003dc  61636b00
                  |L5.992|
                          DCD      sockets
                          ENDP


                          AREA ||i.lwip_bind||, CODE, READONLY, ALIGN=2

                  lwip_bind PROC
;;;404    int
;;;405    lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;406    {
000004  e1a0a000          MOV      r10,r0
000008  e1a04001          MOV      r4,r1
00000c  e1a08002          MOV      r8,r2
;;;407      struct lwip_sock *sock;
;;;408      ip_addr_t local_addr;
;;;409      u16_t local_port;
;;;410      err_t err;
;;;411      const struct sockaddr_in *name_in;
;;;412    
;;;413      sock = get_socket(s);
000010  e1a0000a          MOV      r0,r10
000014  ebfffffe          BL       get_socket
000018  e1a05000          MOV      r5,r0
;;;414      if (!sock) {
00001c  e3550000          CMP      r5,#0
000020  1a000001          BNE      |L6.44|
;;;415        return -1;
000024  e3e00000          MVN      r0,#0
                  |L6.40|
;;;416      }
;;;417    
;;;418      /* check size, familiy and alignment of 'name' */
;;;419      LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
;;;420                 ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
;;;421                 sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
;;;422      name_in = (const struct sockaddr_in *)(void*)name;
;;;423    
;;;424      inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
;;;425      local_port = name_in->sin_port;
;;;426    
;;;427      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
;;;428      ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
;;;429      LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(local_port)));
;;;430    
;;;431      err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
;;;432    
;;;433      if (err != ERR_OK) {
;;;434        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
;;;435        sock_set_errno(sock, err_to_errno(err));
;;;436        return -1;
;;;437      }
;;;438    
;;;439      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
;;;440      sock_set_errno(sock, 0);
;;;441      return 0;
;;;442    }
000028  e8bd8ff8          POP      {r3-r11,pc}
                  |L6.44|
00002c  e1a00000          MOV      r0,r0                 ;419
000030  e3580010          CMP      r8,#0x10              ;419
000034  1a000005          BNE      |L6.80|
000038  e5d40001          LDRB     r0,[r4,#1]            ;419
00003c  e3500002          CMP      r0,#2                 ;419
000040  1a000002          BNE      |L6.80|
000044  e2040003          AND      r0,r4,#3              ;419
000048  e3500000          CMP      r0,#0                 ;419
00004c  0a00000d          BEQ      |L6.136|
                  |L6.80|
000050  e1a00000          MOV      r0,r0                 ;419
000054  e28f30bc          ADR      r3,|L6.280|
000058  e59f20d8          LDR      r2,|L6.312|
00005c  e28f10d8          ADR      r1,|L6.316|
000060  e28f00f0          ADR      r0,|L6.344|
000064  ebfffffe          BL       sysprintf
000068  e1a00000          MOV      r0,r0                 ;419
00006c  e1a00000          MOV      r0,r0                 ;419
000070  e59f0108          LDR      r0,|L6.384|
000074  e5900038          LDR      r0,[r0,#0x38]         ;419  ; err_to_errno_table
000078  e5850010          STR      r0,[r5,#0x10]         ;419
00007c  e1a00000          MOV      r0,r0                 ;419
000080  e3e00000          MVN      r0,#0                 ;419
000084  eaffffe7          B        |L6.40|
                  |L6.136|
000088  e1a00000          MOV      r0,r0                 ;419
00008c  e1a07004          MOV      r7,r4                 ;422
000090  e1a04007          MOV      r4,r7                 ;424
000094  e5970004          LDR      r0,[r7,#4]            ;424
000098  e58d0000          STR      r0,[sp,#0]            ;424
00009c  e1a04007          MOV      r4,r7                 ;425
0000a0  e1d790b2          LDRH     r9,[r7,#2]            ;425
0000a4  e1a00009          MOV      r0,r9                 ;431
0000a8  ebfffffe          BL       lwip_ntohs
0000ac  e1a0b000          MOV      r11,r0                ;431
0000b0  e1a0200b          MOV      r2,r11                ;431
0000b4  e1a0100d          MOV      r1,sp                 ;431
0000b8  e5950000          LDR      r0,[r5,#0]            ;431
0000bc  ebfffffe          BL       netconn_bind
0000c0  e1a06000          MOV      r6,r0                 ;431
0000c4  e3560000          CMP      r6,#0                 ;433
0000c8  0a00000c          BEQ      |L6.256|
0000cc  e1a00000          MOV      r0,r0                 ;435
0000d0  e2660000          RSB      r0,r6,#0              ;435
0000d4  e3500010          CMP      r0,#0x10              ;435
0000d8  2a000003          BCS      |L6.236|
0000dc  e59f009c          LDR      r0,|L6.384|
0000e0  e2661000          RSB      r1,r6,#0              ;435
0000e4  e7900101          LDR      r0,[r0,r1,LSL #2]     ;435
0000e8  ea000000          B        |L6.240|
                  |L6.236|
0000ec  e3a00005          MOV      r0,#5                 ;435
                  |L6.240|
0000f0  e5850010          STR      r0,[r5,#0x10]         ;435
0000f4  e1a00000          MOV      r0,r0                 ;435
0000f8  e3e00000          MVN      r0,#0                 ;436
0000fc  eaffffc9          B        |L6.40|
                  |L6.256|
000100  e1a00000          MOV      r0,r0                 ;440
000104  e3a00000          MOV      r0,#0                 ;440
000108  e5850010          STR      r0,[r5,#0x10]         ;440
00010c  e1a00000          MOV      r0,r0                 ;440
000110  e1a00000          MOV      r0,r0                 ;441
000114  eaffffc3          B        |L6.40|
;;;443    
                          ENDP

                  |L6.280|
000118  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
00011c  2d312e34
000120  2e315c73
000124  72635c61
000128  70695c73
00012c  6f636b65
000130  74732e63
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L6.312|
                          DCD      0x000001a3
                  |L6.316|
00013c  6c776970          DCB      "lwip_bind: invalid address",0
000140  5f62696e
000144  643a2069
000148  6e76616c
00014c  69642061
000150  64647265
000154  737300  
000157  00                DCB      0
                  |L6.344|
000158  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00015c  7274696f
000160  6e202225
000164  73222066
000168  61696c65
00016c  64206174
000170  206c696e
000174  65202564
000178  20696e20
00017c  25730a00
                  |L6.384|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_close||, CODE, READONLY, ALIGN=2

                  lwip_close PROC
;;;444    int
;;;445    lwip_close(int s)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;446    {
000004  e1a05000          MOV      r5,r0
;;;447      struct lwip_sock *sock;
;;;448      int is_tcp = 0;
000008  e3a06000          MOV      r6,#0
;;;449    
;;;450      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));
;;;451    
;;;452      sock = get_socket(s);
00000c  e1a00005          MOV      r0,r5
000010  ebfffffe          BL       get_socket
000014  e1a04000          MOV      r4,r0
;;;453      if (!sock) {
000018  e3540000          CMP      r4,#0
00001c  1a000001          BNE      |L7.40|
;;;454        return -1;
000020  e3e00000          MVN      r0,#0
                  |L7.36|
;;;455      }
;;;456    
;;;457      if(sock->conn != NULL) {
;;;458        is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
;;;459      } else {
;;;460        LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
;;;461      }
;;;462    
;;;463      netconn_delete(sock->conn);
;;;464    
;;;465      free_socket(sock, is_tcp);
;;;466      set_errno(0);
;;;467      return 0;
;;;468    }
000024  e8bd8070          POP      {r4-r6,pc}
                  |L7.40|
000028  e5940000          LDR      r0,[r4,#0]            ;457
00002c  e3500000          CMP      r0,#0                 ;457
000030  0a000008          BEQ      |L7.88|
000034  e5940000          LDR      r0,[r4,#0]            ;458
000038  e5d00000          LDRB     r0,[r0,#0]            ;458
00003c  e3500010          CMP      r0,#0x10              ;458
000040  1a000001          BNE      |L7.76|
000044  e3a00001          MOV      r0,#1                 ;458
000048  ea000000          B        |L7.80|
                  |L7.76|
00004c  e3a00000          MOV      r0,#0                 ;458
                  |L7.80|
000050  e1a06000          MOV      r6,r0                 ;458
000054  ea00000b          B        |L7.136|
                  |L7.88|
000058  e1a00000          MOV      r0,r0                 ;460
00005c  e5940004          LDR      r0,[r4,#4]            ;460
000060  e3500000          CMP      r0,#0                 ;460
000064  0a000006          BEQ      |L7.132|
000068  e1a00000          MOV      r0,r0                 ;460
00006c  e28f3030          ADR      r3,|L7.164|
000070  e3a02f73          MOV      r2,#0x1cc             ;460
000074  e28f1048          ADR      r1,|L7.196|
000078  e28f005c          ADR      r0,|L7.220|
00007c  ebfffffe          BL       sysprintf
000080  e1a00000          MOV      r0,r0                 ;460
                  |L7.132|
000084  e1a00000          MOV      r0,r0                 ;460
                  |L7.136|
000088  e5940000          LDR      r0,[r4,#0]            ;463
00008c  ebfffffe          BL       netconn_delete
000090  e1a01006          MOV      r1,r6                 ;465
000094  e1a00004          MOV      r0,r4                 ;465
000098  ebfffffe          BL       free_socket
00009c  e3a00000          MOV      r0,#0                 ;467
0000a0  eaffffdf          B        |L7.36|
;;;469    
                          ENDP

                  |L7.164|
0000a4  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
0000a8  2d312e34
0000ac  2e315c73
0000b0  72635c61
0000b4  70695c73
0000b8  6f636b65
0000bc  74732e63
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L7.196|
0000c4  736f636b          DCB      "sock->lastdata == NULL",0
0000c8  2d3e6c61
0000cc  73746461
0000d0  7461203d
0000d4  3d204e55
0000d8  4c4c00  
0000db  00                DCB      0
                  |L7.220|
0000dc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000e0  7274696f
0000e4  6e202225
0000e8  73222066
0000ec  61696c65
0000f0  64206174
0000f4  206c696e
0000f8  65202564
0000fc  20696e20
000100  25730a00

                          AREA ||i.lwip_connect||, CODE, READONLY, ALIGN=2

                  lwip_connect PROC
;;;470    int
;;;471    lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;472    {
000004  e1a09000          MOV      r9,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a08002          MOV      r8,r2
;;;473      struct lwip_sock *sock;
;;;474      err_t err;
;;;475      const struct sockaddr_in *name_in;
;;;476    
;;;477      sock = get_socket(s);
000010  e1a00009          MOV      r0,r9
000014  ebfffffe          BL       get_socket
000018  e1a04000          MOV      r4,r0
;;;478      if (!sock) {
00001c  e3540000          CMP      r4,#0
000020  1a000001          BNE      |L8.44|
;;;479        return -1;
000024  e3e00000          MVN      r0,#0
                  |L8.40|
;;;480      }
;;;481    
;;;482      /* check size, familiy and alignment of 'name' */
;;;483      LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
;;;484                 ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
;;;485                 sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
;;;486      name_in = (const struct sockaddr_in *)(void*)name;
;;;487    
;;;488      if (name_in->sin_family == AF_UNSPEC) {
;;;489        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
;;;490        err = netconn_disconnect(sock->conn);
;;;491      } else {
;;;492        ip_addr_t remote_addr;
;;;493        u16_t remote_port;
;;;494    
;;;495        inet_addr_to_ipaddr(&remote_addr, &name_in->sin_addr);
;;;496        remote_port = name_in->sin_port;
;;;497    
;;;498        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
;;;499        ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
;;;500        LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(remote_port)));
;;;501    
;;;502        err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
;;;503      }
;;;504    
;;;505      if (err != ERR_OK) {
;;;506        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
;;;507        sock_set_errno(sock, err_to_errno(err));
;;;508        return -1;
;;;509      }
;;;510    
;;;511      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
;;;512      sock_set_errno(sock, 0);
;;;513      return 0;
;;;514    }
000028  e8bd8ff8          POP      {r3-r11,pc}
                  |L8.44|
00002c  e1a00000          MOV      r0,r0                 ;483
000030  e3580010          CMP      r8,#0x10              ;483
000034  1a000005          BNE      |L8.80|
000038  e5d60001          LDRB     r0,[r6,#1]            ;483
00003c  e3500002          CMP      r0,#2                 ;483
000040  1a000002          BNE      |L8.80|
000044  e2060003          AND      r0,r6,#3              ;483
000048  e3500000          CMP      r0,#0                 ;483
00004c  0a00000d          BEQ      |L8.136|
                  |L8.80|
000050  e1a00000          MOV      r0,r0                 ;483
000054  e28f30d8          ADR      r3,|L8.308|
000058  e59f20f4          LDR      r2,|L8.340|
00005c  e28f10f4          ADR      r1,|L8.344|
000060  e28f0e11          ADR      r0,|L8.376|
000064  ebfffffe          BL       sysprintf
000068  e1a00000          MOV      r0,r0                 ;483
00006c  e1a00000          MOV      r0,r0                 ;483
000070  e59f0128          LDR      r0,|L8.416|
000074  e5900038          LDR      r0,[r0,#0x38]         ;483  ; err_to_errno_table
000078  e5840010          STR      r0,[r4,#0x10]         ;483
00007c  e1a00000          MOV      r0,r0                 ;483
000080  e3e00000          MVN      r0,#0                 ;483
000084  eaffffe7          B        |L8.40|
                  |L8.136|
000088  e1a00000          MOV      r0,r0                 ;483
00008c  e1a07006          MOV      r7,r6                 ;486
000090  e1a06007          MOV      r6,r7                 ;488
000094  e5d70001          LDRB     r0,[r7,#1]            ;488
000098  e3500000          CMP      r0,#0                 ;488
00009c  1a000003          BNE      |L8.176|
0000a0  e5940000          LDR      r0,[r4,#0]            ;490
0000a4  ebfffffe          BL       netconn_disconnect
0000a8  e1a05000          MOV      r5,r0                 ;490
0000ac  ea00000b          B        |L8.224|
                  |L8.176|
0000b0  e5970004          LDR      r0,[r7,#4]            ;495
0000b4  e58d0000          STR      r0,[sp,#0]            ;495
0000b8  e1d7a0b2          LDRH     r10,[r7,#2]           ;496
0000bc  e1a0000a          MOV      r0,r10                ;502
0000c0  ebfffffe          BL       lwip_ntohs
0000c4  e1a0b000          MOV      r11,r0                ;502
0000c8  e1a0200b          MOV      r2,r11                ;502
0000cc  e1a0100d          MOV      r1,sp                 ;502
0000d0  e5940000          LDR      r0,[r4,#0]            ;502
0000d4  ebfffffe          BL       netconn_connect
0000d8  e1a05000          MOV      r5,r0                 ;502
0000dc  e1a00000          MOV      r0,r0                 ;503
                  |L8.224|
0000e0  e3550000          CMP      r5,#0                 ;505
0000e4  0a00000c          BEQ      |L8.284|
0000e8  e1a00000          MOV      r0,r0                 ;507
0000ec  e2650000          RSB      r0,r5,#0              ;507
0000f0  e3500010          CMP      r0,#0x10              ;507
0000f4  2a000003          BCS      |L8.264|
0000f8  e59f00a0          LDR      r0,|L8.416|
0000fc  e2651000          RSB      r1,r5,#0              ;507
000100  e7900101          LDR      r0,[r0,r1,LSL #2]     ;507
000104  ea000000          B        |L8.268|
                  |L8.264|
000108  e3a00005          MOV      r0,#5                 ;507
                  |L8.268|
00010c  e5840010          STR      r0,[r4,#0x10]         ;507
000110  e1a00000          MOV      r0,r0                 ;507
000114  e3e00000          MVN      r0,#0                 ;508
000118  eaffffc2          B        |L8.40|
                  |L8.284|
00011c  e1a00000          MOV      r0,r0                 ;512
000120  e3a00000          MOV      r0,#0                 ;512
000124  e5840010          STR      r0,[r4,#0x10]         ;512
000128  e1a00000          MOV      r0,r0                 ;512
00012c  e1a00000          MOV      r0,r0                 ;513
000130  eaffffbc          B        |L8.40|
;;;515    
                          ENDP

                  |L8.308|
000134  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
000138  2d312e34
00013c  2e315c73
000140  72635c61
000144  70695c73
000148  6f636b65
00014c  74732e63
000150  00      
000151  00                DCB      0
000152  00                DCB      0
000153  00                DCB      0
                  |L8.340|
                          DCD      0x000001e3
                  |L8.344|
000158  6c776970          DCB      "lwip_connect: invalid address",0
00015c  5f636f6e
000160  6e656374
000164  3a20696e
000168  76616c69
00016c  64206164
000170  64726573
000174  7300    
000176  00                DCB      0
000177  00                DCB      0
                  |L8.376|
000178  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00017c  7274696f
000180  6e202225
000184  73222066
000188  61696c65
00018c  64206174
000190  206c696e
000194  65202564
000198  20696e20
00019c  25730a00
                  |L8.416|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_fcntl||, CODE, READONLY, ALIGN=2

                  lwip_fcntl PROC
;;;2347   int
;;;2348   lwip_fcntl(int s, int cmd, int val)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2349   {
000004  e1a07000          MOV      r7,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a05002          MOV      r5,r2
;;;2350     struct lwip_sock *sock = get_socket(s);
000010  e1a00007          MOV      r0,r7
000014  ebfffffe          BL       get_socket
000018  e1a04000          MOV      r4,r0
;;;2351     int ret = -1;
00001c  e3e08000          MVN      r8,#0
;;;2352   
;;;2353     if (!sock || !sock->conn) {
000020  e3540000          CMP      r4,#0
000024  0a000002          BEQ      |L9.52|
000028  e5940000          LDR      r0,[r4,#0]
00002c  e3500000          CMP      r0,#0
000030  1a000001          BNE      |L9.60|
                  |L9.52|
;;;2354       return -1;
000034  e3e00000          MVN      r0,#0
                  |L9.56|
;;;2355     }
;;;2356   
;;;2357     switch (cmd) {
;;;2358     case F_GETFL:
;;;2359       ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
;;;2360       break;
;;;2361     case F_SETFL:
;;;2362       if ((val & ~O_NONBLOCK) == 0) {
;;;2363         /* only O_NONBLOCK, all other bits are zero */
;;;2364         netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
;;;2365         ret = 0;
;;;2366       }
;;;2367       break;
;;;2368     default:
;;;2369       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
;;;2370       break;
;;;2371     }
;;;2372     return ret;
;;;2373   }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L9.60|
00003c  e3560003          CMP      r6,#3                 ;2357
000040  0a000002          BEQ      |L9.80|
000044  e3560004          CMP      r6,#4                 ;2357
000048  1a00001c          BNE      |L9.192|
00004c  ea000005          B        |L9.104|
                  |L9.80|
000050  e1a00000          MOV      r0,r0                 ;2358
000054  e5940000          LDR      r0,[r4,#0]            ;2359
000058  e5d0001c          LDRB     r0,[r0,#0x1c]         ;2359
00005c  e2000002          AND      r0,r0,#2              ;2359
000060  e1a080a0          LSR      r8,r0,#1              ;2359
000064  ea000017          B        |L9.200|
                  |L9.104|
000068  e1a00000          MOV      r0,r0                 ;2361
00006c  e3c50001          BIC      r0,r5,#1              ;2362
000070  e3500000          CMP      r0,#0                 ;2362
000074  1a000010          BNE      |L9.188|
000078  e1a00000          MOV      r0,r0                 ;2364
00007c  e2050001          AND      r0,r5,#1              ;2364
000080  e3500000          CMP      r0,#0                 ;2364
000084  0a000005          BEQ      |L9.160|
000088  e5940000          LDR      r0,[r4,#0]            ;2364
00008c  e5d0001c          LDRB     r0,[r0,#0x1c]         ;2364
000090  e3800002          ORR      r0,r0,#2              ;2364
000094  e5941000          LDR      r1,[r4,#0]            ;2364
000098  e5c1001c          STRB     r0,[r1,#0x1c]         ;2364
00009c  ea000004          B        |L9.180|
                  |L9.160|
0000a0  e5940000          LDR      r0,[r4,#0]            ;2364
0000a4  e5d0001c          LDRB     r0,[r0,#0x1c]         ;2364
0000a8  e3c00002          BIC      r0,r0,#2              ;2364
0000ac  e5941000          LDR      r1,[r4,#0]            ;2364
0000b0  e5c1001c          STRB     r0,[r1,#0x1c]         ;2364
                  |L9.180|
0000b4  e1a00000          MOV      r0,r0                 ;2364
0000b8  e3a08000          MOV      r8,#0                 ;2365
                  |L9.188|
0000bc  ea000001          B        |L9.200|
                  |L9.192|
0000c0  e1a00000          MOV      r0,r0                 ;2368
0000c4  e1a00000          MOV      r0,r0                 ;2370
                  |L9.200|
0000c8  e1a00000          MOV      r0,r0                 ;2360
0000cc  e1a00008          MOV      r0,r8                 ;2372
0000d0  eaffffd8          B        |L9.56|
;;;2374   
                          ENDP


                          AREA ||i.lwip_getaddrname||, CODE, READONLY, ALIGN=2

                  lwip_getaddrname PROC
;;;1408   static int
;;;1409   lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1410   {
000004  e24dd018          SUB      sp,sp,#0x18
000008  e1a07000          MOV      r7,r0
00000c  e1a06001          MOV      r6,r1
000010  e1a04002          MOV      r4,r2
000014  e1a08003          MOV      r8,r3
;;;1411     struct lwip_sock *sock;
;;;1412     struct sockaddr_in sin;
;;;1413     ip_addr_t naddr;
;;;1414   
;;;1415     sock = get_socket(s);
000018  e1a00007          MOV      r0,r7
00001c  ebfffffe          BL       get_socket
000020  e1a05000          MOV      r5,r0
;;;1416     if (!sock) {
000024  e3550000          CMP      r5,#0
000028  1a000002          BNE      |L10.56|
;;;1417       return -1;
00002c  e3e00000          MVN      r0,#0
                  |L10.48|
000030  e28dd018          ADD      sp,sp,#0x18
;;;1418     }
;;;1419   
;;;1420     memset(&sin, 0, sizeof(sin));
;;;1421     sin.sin_len = sizeof(sin);
;;;1422     sin.sin_family = AF_INET;
;;;1423   
;;;1424     /* get the IP address and port */
;;;1425     netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
;;;1426   
;;;1427     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
;;;1428     ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
;;;1429     LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", sin.sin_port));
;;;1430   
;;;1431     sin.sin_port = htons(sin.sin_port);
;;;1432     inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
;;;1433   
;;;1434     if (*namelen > sizeof(sin)) {
;;;1435       *namelen = sizeof(sin);
;;;1436     }
;;;1437   
;;;1438     MEMCPY(name, &sin, *namelen);
;;;1439     sock_set_errno(sock, 0);
;;;1440     return 0;
;;;1441   }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L10.56|
000038  e3a00000          MOV      r0,#0                 ;1420
00003c  e58d0008          STR      r0,[sp,#8]            ;1420
000040  e58d000c          STR      r0,[sp,#0xc]          ;1420
000044  e58d0010          STR      r0,[sp,#0x10]         ;1420
000048  e58d0014          STR      r0,[sp,#0x14]         ;1420
00004c  e3a00010          MOV      r0,#0x10              ;1421
000050  e5cd0008          STRB     r0,[sp,#8]            ;1421
000054  e3a00002          MOV      r0,#2                 ;1422
000058  e5cd0009          STRB     r0,[sp,#9]            ;1422
00005c  e1a03008          MOV      r3,r8                 ;1425
000060  e28d200a          ADD      r2,sp,#0xa            ;1425
000064  e28d1004          ADD      r1,sp,#4              ;1425
000068  e5950000          LDR      r0,[r5,#0]            ;1425
00006c  ebfffffe          BL       netconn_getaddr
000070  e1dd00ba          LDRH     r0,[sp,#0xa]          ;1431
000074  ebfffffe          BL       lwip_htons
000078  e1cd00ba          STRH     r0,[sp,#0xa]          ;1431
00007c  e59d0004          LDR      r0,[sp,#4]            ;1432
000080  e58d000c          STR      r0,[sp,#0xc]          ;1432
000084  e5940000          LDR      r0,[r4,#0]            ;1434
000088  e3500010          CMP      r0,#0x10              ;1434
00008c  9a000001          BLS      |L10.152|
000090  e3a00010          MOV      r0,#0x10              ;1435
000094  e5840000          STR      r0,[r4,#0]            ;1435
                  |L10.152|
000098  e28d1008          ADD      r1,sp,#8              ;1438
00009c  e1a00006          MOV      r0,r6                 ;1438
0000a0  e5942000          LDR      r2,[r4,#0]            ;1438
0000a4  ebfffffe          BL       __aeabi_memcpy
0000a8  e1a00000          MOV      r0,r0                 ;1439
0000ac  e3a00000          MOV      r0,#0                 ;1439
0000b0  e5850010          STR      r0,[r5,#0x10]         ;1439
0000b4  e1a00000          MOV      r0,r0                 ;1439
0000b8  e1a00000          MOV      r0,r0                 ;1440
0000bc  eaffffdb          B        |L10.48|
;;;1442   
                          ENDP


                          AREA ||i.lwip_getpeername||, CODE, READONLY, ALIGN=2

                  lwip_getpeername PROC
;;;1443   int
;;;1444   lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1445   {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a06002          MOV      r6,r2
;;;1446     return lwip_getaddrname(s, name, namelen, 0);
000010  e3a03000          MOV      r3,#0
000014  e1a02006          MOV      r2,r6
000018  e1a01005          MOV      r1,r5
00001c  e1a00004          MOV      r0,r4
000020  ebfffffe          BL       lwip_getaddrname
;;;1447   }
000024  e8bd8070          POP      {r4-r6,pc}
;;;1448   
                          ENDP


                          AREA ||i.lwip_getsockname||, CODE, READONLY, ALIGN=2

                  lwip_getsockname PROC
;;;1449   int
;;;1450   lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1451   {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a06002          MOV      r6,r2
;;;1452     return lwip_getaddrname(s, name, namelen, 1);
000010  e3a03001          MOV      r3,#1
000014  e1a02006          MOV      r2,r6
000018  e1a01005          MOV      r1,r5
00001c  e1a00004          MOV      r0,r4
000020  ebfffffe          BL       lwip_getaddrname
;;;1453   }
000024  e8bd8070          POP      {r4-r6,pc}
;;;1454   
                          ENDP


                          AREA ||i.lwip_getsockopt||, CODE, READONLY, ALIGN=2

                  lwip_getsockopt PROC
;;;1455   int
;;;1456   lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1457   {
000004  e24dd020          SUB      sp,sp,#0x20
000008  e1a0a000          MOV      r10,r0
00000c  e1a08001          MOV      r8,r1
000010  e1a06002          MOV      r6,r2
000014  e1a09003          MOV      r9,r3
000018  e59d5040          LDR      r5,[sp,#0x40]
;;;1458     err_t err = ERR_OK;
00001c  e3a07000          MOV      r7,#0
;;;1459     struct lwip_sock *sock = get_socket(s);
000020  e1a0000a          MOV      r0,r10
000024  ebfffffe          BL       get_socket
000028  e1a04000          MOV      r4,r0
;;;1460     struct lwip_setgetsockopt_data data;
;;;1461   
;;;1462     if (!sock) {
00002c  e3540000          CMP      r4,#0
000030  1a000002          BNE      |L13.64|
;;;1463       return -1;
000034  e3e00000          MVN      r0,#0
                  |L13.56|
000038  e28dd020          ADD      sp,sp,#0x20
;;;1464     }
;;;1465   
;;;1466     if ((NULL == optval) || (NULL == optlen)) {
;;;1467       sock_set_errno(sock, EFAULT);
;;;1468       return -1;
;;;1469     }
;;;1470   
;;;1471     /* Do length and type checks for the various options first, to keep it readable. */
;;;1472     switch (level) {
;;;1473      
;;;1474   /* Level: SOL_SOCKET */
;;;1475     case SOL_SOCKET:
;;;1476       switch (optname) {
;;;1477          
;;;1478       case SO_ACCEPTCONN:
;;;1479       case SO_BROADCAST:
;;;1480       /* UNIMPL case SO_DEBUG: */
;;;1481       /* UNIMPL case SO_DONTROUTE: */
;;;1482       case SO_ERROR:
;;;1483       case SO_KEEPALIVE:
;;;1484       /* UNIMPL case SO_CONTIMEO: */
;;;1485   #if LWIP_SO_SNDTIMEO
;;;1486       case SO_SNDTIMEO:
;;;1487   #endif /* LWIP_SO_SNDTIMEO */
;;;1488   #if LWIP_SO_RCVTIMEO
;;;1489       case SO_RCVTIMEO:
;;;1490   #endif /* LWIP_SO_RCVTIMEO */
;;;1491   #if LWIP_SO_RCVBUF
;;;1492       case SO_RCVBUF:
;;;1493   #endif /* LWIP_SO_RCVBUF */
;;;1494       /* UNIMPL case SO_OOBINLINE: */
;;;1495       /* UNIMPL case SO_SNDBUF: */
;;;1496       /* UNIMPL case SO_RCVLOWAT: */
;;;1497       /* UNIMPL case SO_SNDLOWAT: */
;;;1498   #if SO_REUSE
;;;1499       case SO_REUSEADDR:
;;;1500       case SO_REUSEPORT:
;;;1501   #endif /* SO_REUSE */
;;;1502       case SO_TYPE:
;;;1503       /* UNIMPL case SO_USELOOPBACK: */
;;;1504         if (*optlen < sizeof(int)) {
;;;1505           err = EINVAL;
;;;1506         }
;;;1507         break;
;;;1508   
;;;1509       case SO_NO_CHECK:
;;;1510         if (*optlen < sizeof(int)) {
;;;1511           err = EINVAL;
;;;1512         }
;;;1513   #if LWIP_UDP
;;;1514         if ((sock->conn->type != NETCONN_UDP) ||
;;;1515             ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
;;;1516           /* this flag is only available for UDP, not for UDP lite */
;;;1517           err = EAFNOSUPPORT;
;;;1518         }
;;;1519   #endif /* LWIP_UDP */
;;;1520         break;
;;;1521   
;;;1522       default:
;;;1523         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
;;;1524                                     s, optname));
;;;1525         err = ENOPROTOOPT;
;;;1526       }  /* switch (optname) */
;;;1527       break;
;;;1528                        
;;;1529   /* Level: IPPROTO_IP */
;;;1530     case IPPROTO_IP:
;;;1531       switch (optname) {
;;;1532       /* UNIMPL case IP_HDRINCL: */
;;;1533       /* UNIMPL case IP_RCVDSTADDR: */
;;;1534       /* UNIMPL case IP_RCVIF: */
;;;1535       case IP_TTL:
;;;1536       case IP_TOS:
;;;1537         if (*optlen < sizeof(int)) {
;;;1538           err = EINVAL;
;;;1539         }
;;;1540         break;
;;;1541   #if LWIP_IGMP
;;;1542       case IP_MULTICAST_TTL:
;;;1543         if (*optlen < sizeof(u8_t)) {
;;;1544           err = EINVAL;
;;;1545         }
;;;1546         break;
;;;1547       case IP_MULTICAST_IF:
;;;1548         if (*optlen < sizeof(struct in_addr)) {
;;;1549           err = EINVAL;
;;;1550         }
;;;1551         break;
;;;1552       case IP_MULTICAST_LOOP:
;;;1553         if (*optlen < sizeof(u8_t)) {
;;;1554           err = EINVAL;
;;;1555         }
;;;1556         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1557           err = EAFNOSUPPORT;
;;;1558         }
;;;1559         break;
;;;1560   #endif /* LWIP_IGMP */
;;;1561   
;;;1562       default:
;;;1563         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
;;;1564                                     s, optname));
;;;1565         err = ENOPROTOOPT;
;;;1566       }  /* switch (optname) */
;;;1567       break;
;;;1568            
;;;1569   #if LWIP_TCP
;;;1570   /* Level: IPPROTO_TCP */
;;;1571     case IPPROTO_TCP:
;;;1572       if (*optlen < sizeof(int)) {
;;;1573         err = EINVAL;
;;;1574         break;
;;;1575       }
;;;1576       
;;;1577       /* If this is no TCP socket, ignore any options. */
;;;1578       if (sock->conn->type != NETCONN_TCP)
;;;1579         return 0;
;;;1580   
;;;1581       switch (optname) {
;;;1582       case TCP_NODELAY:
;;;1583       case TCP_KEEPALIVE:
;;;1584   #if LWIP_TCP_KEEPALIVE
;;;1585       case TCP_KEEPIDLE:
;;;1586       case TCP_KEEPINTVL:
;;;1587       case TCP_KEEPCNT:
;;;1588   #endif /* LWIP_TCP_KEEPALIVE */
;;;1589         break;
;;;1590          
;;;1591       default:
;;;1592         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
;;;1593                                     s, optname));
;;;1594         err = ENOPROTOOPT;
;;;1595       }  /* switch (optname) */
;;;1596       break;
;;;1597   #endif /* LWIP_TCP */
;;;1598   #if LWIP_UDP && LWIP_UDPLITE
;;;1599   /* Level: IPPROTO_UDPLITE */
;;;1600     case IPPROTO_UDPLITE:
;;;1601       if (*optlen < sizeof(int)) {
;;;1602         err = EINVAL;
;;;1603         break;
;;;1604       }
;;;1605       
;;;1606       /* If this is no UDP lite socket, ignore any options. */
;;;1607       if (sock->conn->type != NETCONN_UDPLITE) {
;;;1608         return 0;
;;;1609       }
;;;1610   
;;;1611       switch (optname) {
;;;1612       case UDPLITE_SEND_CSCOV:
;;;1613       case UDPLITE_RECV_CSCOV:
;;;1614         break;
;;;1615          
;;;1616       default:
;;;1617         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
;;;1618                                     s, optname));
;;;1619         err = ENOPROTOOPT;
;;;1620       }  /* switch (optname) */
;;;1621       break;
;;;1622   #endif /* LWIP_UDP && LWIP_UDPLITE*/
;;;1623   /* UNDEFINED LEVEL */
;;;1624     default:
;;;1625         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
;;;1626                                     s, level, optname));
;;;1627         err = ENOPROTOOPT;
;;;1628     }  /* switch */
;;;1629   
;;;1630      
;;;1631     if (err != ERR_OK) {
;;;1632       sock_set_errno(sock, err);
;;;1633       return -1;
;;;1634     }
;;;1635   
;;;1636     /* Now do the actual option processing */
;;;1637     data.sock = sock;
;;;1638   #ifdef LWIP_DEBUG
;;;1639     data.s = s;
;;;1640   #endif /* LWIP_DEBUG */
;;;1641     data.level = level;
;;;1642     data.optname = optname;
;;;1643     data.optval = optval;
;;;1644     data.optlen = optlen;
;;;1645     data.err = err;
;;;1646     tcpip_callback(lwip_getsockopt_internal, &data);
;;;1647     sys_arch_sem_wait(&sock->conn->op_completed, 0);
;;;1648     /* maybe lwip_getsockopt_internal has changed err */
;;;1649     err = data.err;
;;;1650   
;;;1651     sock_set_errno(sock, err);
;;;1652     return err ? -1 : 0;
;;;1653   }
00003c  e8bd87f0          POP      {r4-r10,pc}
                  |L13.64|
000040  e3590000          CMP      r9,#0                 ;1466
000044  0a000001          BEQ      |L13.80|
000048  e3550000          CMP      r5,#0                 ;1466
00004c  1a000005          BNE      |L13.104|
                  |L13.80|
000050  e1a00000          MOV      r0,r0                 ;1467
000054  e3a0000e          MOV      r0,#0xe               ;1467
000058  e5840010          STR      r0,[r4,#0x10]         ;1467
00005c  e1a00000          MOV      r0,r0                 ;1467
000060  e3e00000          MVN      r0,#0                 ;1468
000064  eafffff3          B        |L13.56|
                  |L13.104|
000068  e3580000          CMP      r8,#0                 ;1472
00006c  0a000036          BEQ      |L13.332|
000070  e3580006          CMP      r8,#6                 ;1472
000074  0a000044          BEQ      |L13.396|
000078  e2480c0f          SUB      r0,r8,#0xf00          ;1472
00007c  e24000ff          SUB      r0,r0,#0xff           ;1472
000080  e3500000          CMP      r0,#0                 ;1472
000084  1a000059          BNE      |L13.496|
000088  e59f11f0          LDR      r1,|L13.640|
00008c  e0460001          SUB      r0,r6,r1              ;1476
000090  e1560001          CMP      r6,r1                 ;1476
000094  0a00000f          BEQ      |L13.216|
000098  ca000006          BGT      |L13.184|
00009c  e3560002          CMP      r6,#2                 ;1476
0000a0  0a000009          BEQ      |L13.204|
0000a4  e3560008          CMP      r6,#8                 ;1476
0000a8  0a00000b          BEQ      |L13.220|
0000ac  e3560020          CMP      r6,#0x20              ;1476
0000b0  1a000020          BNE      |L13.312|
0000b4  ea000006          B        |L13.212|
                  |L13.184|
0000b8  e3500001          CMP      r0,#1                 ;1476
0000bc  0a000007          BEQ      |L13.224|
0000c0  e3500003          CMP      r0,#3                 ;1476
0000c4  1a00001b          BNE      |L13.312|
0000c8  ea000009          B        |L13.244|
                  |L13.204|
0000cc  e1a00000          MOV      r0,r0                 ;1478
0000d0  e1a00000          MOV      r0,r0                 ;1479
                  |L13.212|
0000d4  e1a00000          MOV      r0,r0                 ;1482
                  |L13.216|
0000d8  e1a00000          MOV      r0,r0                 ;1483
                  |L13.220|
0000dc  e1a00000          MOV      r0,r0                 ;1502
                  |L13.224|
0000e0  e5950000          LDR      r0,[r5,#0]            ;1504
0000e4  e3500004          CMP      r0,#4                 ;1504
0000e8  2a000000          BCS      |L13.240|
0000ec  e3a07016          MOV      r7,#0x16              ;1505
                  |L13.240|
0000f0  ea000013          B        |L13.324|
                  |L13.244|
0000f4  e1a00000          MOV      r0,r0                 ;1509
0000f8  e5950000          LDR      r0,[r5,#0]            ;1510
0000fc  e3500004          CMP      r0,#4                 ;1510
000100  2a000000          BCS      |L13.264|
000104  e3a07016          MOV      r7,#0x16              ;1511
                  |L13.264|
000108  e5940000          LDR      r0,[r4,#0]            ;1514
00010c  e5d00000          LDRB     r0,[r0,#0]            ;1514
000110  e3500020          CMP      r0,#0x20              ;1514
000114  1a000005          BNE      |L13.304|
000118  e5940000          LDR      r0,[r4,#0]            ;1515
00011c  e5900004          LDR      r0,[r0,#4]            ;1515
000120  e5d00010          LDRB     r0,[r0,#0x10]         ;1515
000124  e2000002          AND      r0,r0,#2              ;1515
000128  e3500000          CMP      r0,#0                 ;1515
00012c  0a000000          BEQ      |L13.308|
                  |L13.304|
000130  e3a07061          MOV      r7,#0x61              ;1517
                  |L13.308|
000134  ea000002          B        |L13.324|
                  |L13.312|
000138  e1a00000          MOV      r0,r0                 ;1522
00013c  e3a0705c          MOV      r7,#0x5c              ;1525
000140  e1a00000          MOV      r0,r0                 ;1476
                  |L13.324|
000144  e1a00000          MOV      r0,r0                 ;1507
000148  ea00002b          B        |L13.508|
                  |L13.332|
00014c  e1a00000          MOV      r0,r0                 ;1530
000150  e3560001          CMP      r6,#1                 ;1531
000154  0a000002          BEQ      |L13.356|
000158  e3560002          CMP      r6,#2                 ;1531
00015c  1a000005          BNE      |L13.376|
000160  e1a00000          MOV      r0,r0                 ;1536
                  |L13.356|
000164  e5950000          LDR      r0,[r5,#0]            ;1537
000168  e3500004          CMP      r0,#4                 ;1537
00016c  2a000000          BCS      |L13.372|
000170  e3a07016          MOV      r7,#0x16              ;1538
                  |L13.372|
000174  ea000002          B        |L13.388|
                  |L13.376|
000178  e1a00000          MOV      r0,r0                 ;1562
00017c  e3a0705c          MOV      r7,#0x5c              ;1565
000180  e1a00000          MOV      r0,r0                 ;1531
                  |L13.388|
000184  e1a00000          MOV      r0,r0                 ;1540
000188  ea00001b          B        |L13.508|
                  |L13.396|
00018c  e1a00000          MOV      r0,r0                 ;1571
000190  e5950000          LDR      r0,[r5,#0]            ;1572
000194  e3500004          CMP      r0,#4                 ;1572
000198  2a000001          BCS      |L13.420|
00019c  e3a07016          MOV      r7,#0x16              ;1573
0001a0  ea000015          B        |L13.508|
                  |L13.420|
0001a4  e5940000          LDR      r0,[r4,#0]            ;1578
0001a8  e5d00000          LDRB     r0,[r0,#0]            ;1578
0001ac  e3500010          CMP      r0,#0x10              ;1578
0001b0  0a000001          BEQ      |L13.444|
0001b4  e3a00000          MOV      r0,#0                 ;1579
0001b8  eaffff9e          B        |L13.56|
                  |L13.444|
0001bc  e3560001          CMP      r6,#1                 ;1581
0001c0  0a000002          BEQ      |L13.464|
0001c4  e3560002          CMP      r6,#2                 ;1581
0001c8  1a000003          BNE      |L13.476|
0001cc  ea000001          B        |L13.472|
                  |L13.464|
0001d0  e1a00000          MOV      r0,r0                 ;1582
0001d4  e1a00000          MOV      r0,r0                 ;1583
                  |L13.472|
0001d8  ea000002          B        |L13.488|
                  |L13.476|
0001dc  e1a00000          MOV      r0,r0                 ;1591
0001e0  e3a0705c          MOV      r7,#0x5c              ;1594
0001e4  e1a00000          MOV      r0,r0                 ;1581
                  |L13.488|
0001e8  e1a00000          MOV      r0,r0                 ;1589
0001ec  ea000002          B        |L13.508|
                  |L13.496|
0001f0  e1a00000          MOV      r0,r0                 ;1624
0001f4  e3a0705c          MOV      r7,#0x5c              ;1627
0001f8  e1a00000          MOV      r0,r0                 ;1472
                  |L13.508|
0001fc  e1a00000          MOV      r0,r0                 ;1527
000200  e3570000          CMP      r7,#0                 ;1631
000204  0a000004          BEQ      |L13.540|
000208  e1a00000          MOV      r0,r0                 ;1632
00020c  e5847010          STR      r7,[r4,#0x10]         ;1632
000210  e1a00000          MOV      r0,r0                 ;1632
000214  e3e00000          MVN      r0,#0                 ;1633
000218  eaffff86          B        |L13.56|
                  |L13.540|
00021c  e58d4004          STR      r4,[sp,#4]            ;1637
000220  e58da008          STR      r10,[sp,#8]           ;1639
000224  e58d800c          STR      r8,[sp,#0xc]          ;1641
000228  e58d6010          STR      r6,[sp,#0x10]         ;1642
00022c  e58d9014          STR      r9,[sp,#0x14]         ;1643
000230  e58d5018          STR      r5,[sp,#0x18]         ;1644
000234  e5cd701c          STRB     r7,[sp,#0x1c]         ;1645
000238  e3a02001          MOV      r2,#1                 ;1646
00023c  e28d1004          ADD      r1,sp,#4              ;1646
000240  e59f003c          LDR      r0,|L13.644|
000244  ebfffffe          BL       tcpip_callback_with_block
000248  e5941000          LDR      r1,[r4,#0]            ;1647
00024c  e281000c          ADD      r0,r1,#0xc            ;1647
000250  e3a01000          MOV      r1,#0                 ;1647
000254  ebfffffe          BL       sys_arch_sem_wait
000258  e1dd71dc          LDRSB    r7,[sp,#0x1c]         ;1649
00025c  e1a00000          MOV      r0,r0                 ;1651
000260  e5847010          STR      r7,[r4,#0x10]         ;1651
000264  e1a00000          MOV      r0,r0                 ;1651
000268  e3570000          CMP      r7,#0                 ;1652
00026c  0a000001          BEQ      |L13.632|
000270  e3e00000          MVN      r0,#0                 ;1652
000274  eaffff6f          B        |L13.56|
                  |L13.632|
000278  e3a00000          MOV      r0,#0                 ;1652
00027c  eaffff6d          B        |L13.56|
;;;1654   
                          ENDP

                  |L13.640|
                          DCD      0x00001007
                  |L13.644|
                          DCD      lwip_getsockopt_internal

                          AREA ||i.lwip_getsockopt_internal||, CODE, READONLY, ALIGN=2

                  lwip_getsockopt_internal PROC
;;;1655   static void
;;;1656   lwip_getsockopt_internal(void *arg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1657   {
000004  e1a06000          MOV      r6,r0
;;;1658     struct lwip_sock *sock;
;;;1659   #ifdef LWIP_DEBUG
;;;1660     int s;
;;;1661   #endif /* LWIP_DEBUG */
;;;1662     int level, optname;
;;;1663     void *optval;
;;;1664     struct lwip_setgetsockopt_data *data;
;;;1665   
;;;1666     LWIP_ASSERT("arg != NULL", arg != NULL);
000008  e1a00000          MOV      r0,r0
00000c  e3560000          CMP      r6,#0
000010  1a000006          BNE      |L14.48|
000014  e1a00000          MOV      r0,r0
000018  e28f3fb6          ADR      r3,|L14.760|
00001c  e59f22f4          LDR      r2,|L14.792|
000020  e28f1fbd          ADR      r1,|L14.796|
000024  e28f0fbf          ADR      r0,|L14.808|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L14.48|
000030  e1a00000          MOV      r0,r0
;;;1667   
;;;1668     data = (struct lwip_setgetsockopt_data*)arg;
000034  e1a07006          MOV      r7,r6
;;;1669     sock = data->sock;
000038  e5974000          LDR      r4,[r7,#0]
;;;1670   #ifdef LWIP_DEBUG
;;;1671     s = data->s;
00003c  e597a004          LDR      r10,[r7,#4]
;;;1672   #endif /* LWIP_DEBUG */
;;;1673     level = data->level;
000040  e5979008          LDR      r9,[r7,#8]
;;;1674     optname = data->optname;
000044  e597800c          LDR      r8,[r7,#0xc]
;;;1675     optval = data->optval;
000048  e5975010          LDR      r5,[r7,#0x10]
;;;1676   
;;;1677     switch (level) {
00004c  e3590000          CMP      r9,#0
000050  0a00006a          BEQ      |L14.512|
000054  e3590006          CMP      r9,#6
000058  0a000085          BEQ      |L14.628|
00005c  e2490c0f          SUB      r0,r9,#0xf00
000060  e24000ff          SUB      r0,r0,#0xff
000064  e3500000          CMP      r0,#0
000068  1a0000c2          BNE      |L14.888|
;;;1678   
;;;1679   /* Level: SOL_SOCKET */
;;;1680     case SOL_SOCKET:
;;;1681       switch (optname) {
00006c  e59f12dc          LDR      r1,|L14.848|
000070  e0480001          SUB      r0,r8,r1
000074  e1580001          CMP      r8,r1
000078  0a000031          BEQ      |L14.324|
00007c  ca000006          BGT      |L14.156|
000080  e3580002          CMP      r8,#2
000084  0a000009          BEQ      |L14.176|
000088  e3580008          CMP      r8,#8
00008c  0a00000a          BEQ      |L14.188|
000090  e3580020          CMP      r8,#0x20
000094  1a00004c          BNE      |L14.460|
000098  ea000006          B        |L14.184|
                  |L14.156|
00009c  e3500001          CMP      r0,#1
0000a0  0a00000b          BEQ      |L14.212|
0000a4  e3500003          CMP      r0,#3
0000a8  1a000047          BNE      |L14.460|
0000ac  ea00003f          B        |L14.432|
                  |L14.176|
;;;1682   
;;;1683       /* The option flags */
;;;1684       case SO_ACCEPTCONN:
0000b0  e1a00000          MOV      r0,r0
;;;1685       case SO_BROADCAST:
0000b4  e1a00000          MOV      r0,r0
                  |L14.184|
;;;1686       /* UNIMPL case SO_DEBUG: */
;;;1687       /* UNIMPL case SO_DONTROUTE: */
;;;1688       case SO_KEEPALIVE:
0000b8  e1a00000          MOV      r0,r0
                  |L14.188|
;;;1689       /* UNIMPL case SO_OOBINCLUDE: */
;;;1690   #if SO_REUSE
;;;1691       case SO_REUSEADDR:
;;;1692       case SO_REUSEPORT:
;;;1693   #endif /* SO_REUSE */
;;;1694       /*case SO_USELOOPBACK: UNIMPL */
;;;1695         *(int*)optval = ip_get_option(sock->conn->pcb.ip, optname);
0000bc  e5940000          LDR      r0,[r4,#0]
0000c0  e5900004          LDR      r0,[r0,#4]
0000c4  e5d00008          LDRB     r0,[r0,#8]
0000c8  e0000008          AND      r0,r0,r8
0000cc  e5850000          STR      r0,[r5,#0]
;;;1696         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
;;;1697                                     s, optname, (*(int*)optval?"on":"off")));
;;;1698         break;
0000d0  ea000048          B        |L14.504|
                  |L14.212|
;;;1699   
;;;1700       case SO_TYPE:
0000d4  e1a00000          MOV      r0,r0
;;;1701         switch (NETCONNTYPE_GROUP(sock->conn->type)) {
0000d8  e5940000          LDR      r0,[r4,#0]
0000dc  e5d00000          LDRB     r0,[r0,#0]
0000e0  e20000f0          AND      r0,r0,#0xf0
0000e4  e3500010          CMP      r0,#0x10
0000e8  0a000006          BEQ      |L14.264|
0000ec  e3500020          CMP      r0,#0x20
0000f0  0a000008          BEQ      |L14.280|
0000f4  e3500040          CMP      r0,#0x40
0000f8  1a00000a          BNE      |L14.296|
;;;1702         case NETCONN_RAW:
;;;1703           *(int*)optval = SOCK_RAW;
0000fc  e3a00003          MOV      r0,#3
000100  e5850000          STR      r0,[r5,#0]
;;;1704           break;
000104  ea00000c          B        |L14.316|
                  |L14.264|
;;;1705         case NETCONN_TCP:
000108  e1a00000          MOV      r0,r0
;;;1706           *(int*)optval = SOCK_STREAM;
00010c  e3a00001          MOV      r0,#1
000110  e5850000          STR      r0,[r5,#0]
;;;1707           break;
000114  ea000008          B        |L14.316|
                  |L14.280|
;;;1708         case NETCONN_UDP:
000118  e1a00000          MOV      r0,r0
;;;1709           *(int*)optval = SOCK_DGRAM;
00011c  e3a00002          MOV      r0,#2
000120  e5850000          STR      r0,[r5,#0]
;;;1710           break;
000124  ea000004          B        |L14.316|
                  |L14.296|
;;;1711         default: /* unrecognized socket type */
000128  e1a00000          MOV      r0,r0
;;;1712           *(int*)optval = sock->conn->type;
00012c  e5940000          LDR      r0,[r4,#0]
000130  e5d00000          LDRB     r0,[r0,#0]
000134  e5850000          STR      r0,[r5,#0]
000138  e1a00000          MOV      r0,r0                 ;1701
                  |L14.316|
00013c  e1a00000          MOV      r0,r0                 ;1704
;;;1713           LWIP_DEBUGF(SOCKETS_DEBUG,
;;;1714                       ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
;;;1715                       s, *(int *)optval));
;;;1716         }  /* switch (sock->conn->type) */
;;;1717         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
;;;1718                     s, *(int *)optval));
;;;1719         break;
000140  ea00002c          B        |L14.504|
                  |L14.324|
;;;1720   
;;;1721       case SO_ERROR:
000144  e1a00000          MOV      r0,r0
;;;1722         /* only overwrite ERR_OK or tempoary errors */
;;;1723         if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
000148  e5940010          LDR      r0,[r4,#0x10]
00014c  e3500000          CMP      r0,#0
000150  0a000002          BEQ      |L14.352|
000154  e5940010          LDR      r0,[r4,#0x10]
000158  e3500073          CMP      r0,#0x73
00015c  1a00000e          BNE      |L14.412|
                  |L14.352|
;;;1724           sock_set_errno(sock, err_to_errno(sock->conn->last_err));
000160  e1a00000          MOV      r0,r0
000164  e5940000          LDR      r0,[r4,#0]
000168  e1d000d8          LDRSB    r0,[r0,#8]
00016c  e2600000          RSB      r0,r0,#0
000170  e3500010          CMP      r0,#0x10
000174  2a000005          BCS      |L14.400|
000178  e5940000          LDR      r0,[r4,#0]
00017c  e1d000d8          LDRSB    r0,[r0,#8]
000180  e2600000          RSB      r0,r0,#0
000184  e59f11c8          LDR      r1,|L14.852|
000188  e7910100          LDR      r0,[r1,r0,LSL #2]
00018c  ea000000          B        |L14.404|
                  |L14.400|
000190  e3a00005          MOV      r0,#5
                  |L14.404|
000194  e5840010          STR      r0,[r4,#0x10]
000198  e1a00000          MOV      r0,r0
                  |L14.412|
;;;1725         } 
;;;1726         *(int *)optval = sock->err;
00019c  e5940010          LDR      r0,[r4,#0x10]
0001a0  e5850000          STR      r0,[r5,#0]
;;;1727         sock->err = 0;
0001a4  e3a00000          MOV      r0,#0
0001a8  e5840010          STR      r0,[r4,#0x10]
;;;1728         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
;;;1729                     s, *(int *)optval));
;;;1730         break;
0001ac  ea000011          B        |L14.504|
                  |L14.432|
;;;1731   
;;;1732   #if LWIP_SO_SNDTIMEO
;;;1733       case SO_SNDTIMEO:
;;;1734         *(int *)optval = netconn_get_sendtimeout(sock->conn);
;;;1735         break;
;;;1736   #endif /* LWIP_SO_SNDTIMEO */
;;;1737   #if LWIP_SO_RCVTIMEO
;;;1738       case SO_RCVTIMEO:
;;;1739         *(int *)optval = netconn_get_recvtimeout(sock->conn);
;;;1740         break;
;;;1741   #endif /* LWIP_SO_RCVTIMEO */
;;;1742   #if LWIP_SO_RCVBUF
;;;1743       case SO_RCVBUF:
;;;1744         *(int *)optval = netconn_get_recvbufsize(sock->conn);
;;;1745         break;
;;;1746   #endif /* LWIP_SO_RCVBUF */
;;;1747   #if LWIP_UDP
;;;1748       case SO_NO_CHECK:
0001b0  e1a00000          MOV      r0,r0
;;;1749         *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
0001b4  e5940000          LDR      r0,[r4,#0]
0001b8  e5900004          LDR      r0,[r0,#4]
0001bc  e5d00010          LDRB     r0,[r0,#0x10]
0001c0  e2000001          AND      r0,r0,#1
0001c4  e5850000          STR      r0,[r5,#0]
;;;1750         break;
0001c8  ea00000a          B        |L14.504|
                  |L14.460|
;;;1751   #endif /* LWIP_UDP*/
;;;1752       default:
0001cc  e1a00000          MOV      r0,r0
;;;1753         LWIP_ASSERT("unhandled optname", 0);
0001d0  e1a00000          MOV      r0,r0
0001d4  e1a00000          MOV      r0,r0
0001d8  e28f3f46          ADR      r3,|L14.760|
0001dc  e59f2174          LDR      r2,|L14.856|
0001e0  e28f1f5d          ADR      r1,|L14.860|
0001e4  e28f0f4f          ADR      r0,|L14.808|
0001e8  ebfffffe          BL       sysprintf
0001ec  e1a00000          MOV      r0,r0
0001f0  e1a00000          MOV      r0,r0
;;;1754         break;
0001f4  e1a00000          MOV      r0,r0
                  |L14.504|
0001f8  e1a00000          MOV      r0,r0                 ;1698
;;;1755       }  /* switch (optname) */
;;;1756       break;
0001fc  ea000068          B        |L14.932|
                  |L14.512|
;;;1757   
;;;1758   /* Level: IPPROTO_IP */
;;;1759     case IPPROTO_IP:
000200  e1a00000          MOV      r0,r0
;;;1760       switch (optname) {
000204  e3580001          CMP      r8,#1
000208  0a000006          BEQ      |L14.552|
00020c  e3580002          CMP      r8,#2
000210  1a00000a          BNE      |L14.576|
;;;1761       case IP_TTL:
;;;1762         *(int*)optval = sock->conn->pcb.ip->ttl;
000214  e5940000          LDR      r0,[r4,#0]
000218  e5900004          LDR      r0,[r0,#4]
00021c  e5d0000a          LDRB     r0,[r0,#0xa]
000220  e5850000          STR      r0,[r5,#0]
;;;1763         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
;;;1764                     s, *(int *)optval));
;;;1765         break;
000224  ea000010          B        |L14.620|
                  |L14.552|
;;;1766       case IP_TOS:
000228  e1a00000          MOV      r0,r0
;;;1767         *(int*)optval = sock->conn->pcb.ip->tos;
00022c  e5940000          LDR      r0,[r4,#0]
000230  e5900004          LDR      r0,[r0,#4]
000234  e5d00009          LDRB     r0,[r0,#9]
000238  e5850000          STR      r0,[r5,#0]
;;;1768         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
;;;1769                     s, *(int *)optval));
;;;1770         break;
00023c  ea00000a          B        |L14.620|
                  |L14.576|
;;;1771   #if LWIP_IGMP
;;;1772       case IP_MULTICAST_TTL:
;;;1773         *(u8_t*)optval = sock->conn->pcb.ip->ttl;
;;;1774         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_TTL) = %d\n",
;;;1775                     s, *(int *)optval));
;;;1776         break;
;;;1777       case IP_MULTICAST_IF:
;;;1778         inet_addr_from_ipaddr((struct in_addr*)optval, &sock->conn->pcb.udp->multicast_ip);
;;;1779         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%"X32_F"\n",
;;;1780                     s, *(u32_t *)optval));
;;;1781         break;
;;;1782       case IP_MULTICAST_LOOP:
;;;1783         if ((sock->conn->pcb.udp->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) {
;;;1784           *(u8_t*)optval = 1;
;;;1785         } else {
;;;1786           *(u8_t*)optval = 0;
;;;1787         }
;;;1788         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_LOOP) = %d\n",
;;;1789                     s, *(int *)optval));
;;;1790         break;
;;;1791   #endif /* LWIP_IGMP */
;;;1792       default:
000240  e1a00000          MOV      r0,r0
;;;1793         LWIP_ASSERT("unhandled optname", 0);
000244  e1a00000          MOV      r0,r0
000248  e1a00000          MOV      r0,r0
00024c  e28f30a4          ADR      r3,|L14.760|
000250  e59f2118          LDR      r2,|L14.880|
000254  e28f1c01          ADR      r1,|L14.860|
000258  e28f00c8          ADR      r0,|L14.808|
00025c  ebfffffe          BL       sysprintf
000260  e1a00000          MOV      r0,r0
000264  e1a00000          MOV      r0,r0
;;;1794         break;
000268  e1a00000          MOV      r0,r0
                  |L14.620|
00026c  e1a00000          MOV      r0,r0                 ;1765
;;;1795       }  /* switch (optname) */
;;;1796       break;
000270  ea00004b          B        |L14.932|
                  |L14.628|
;;;1797   
;;;1798   #if LWIP_TCP
;;;1799   /* Level: IPPROTO_TCP */
;;;1800     case IPPROTO_TCP:
000274  e1a00000          MOV      r0,r0
;;;1801       switch (optname) {
000278  e3580001          CMP      r8,#1
00027c  0a000002          BEQ      |L14.652|
000280  e3580002          CMP      r8,#2
000284  1a00000e          BNE      |L14.708|
000288  ea000007          B        |L14.684|
                  |L14.652|
;;;1802       case TCP_NODELAY:
00028c  e1a00000          MOV      r0,r0
;;;1803         *(int*)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
000290  e5940000          LDR      r0,[r4,#0]
000294  e5900004          LDR      r0,[r0,#4]
000298  e5d0001e          LDRB     r0,[r0,#0x1e]
00029c  e2000040          AND      r0,r0,#0x40
0002a0  e1a00320          LSR      r0,r0,#6
0002a4  e5850000          STR      r0,[r5,#0]
;;;1804         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
;;;1805                     s, (*(int*)optval)?"on":"off") );
;;;1806         break;
0002a8  ea000010          B        |L14.752|
                  |L14.684|
;;;1807       case TCP_KEEPALIVE:
0002ac  e1a00000          MOV      r0,r0
;;;1808         *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
0002b0  e5940000          LDR      r0,[r4,#0]
0002b4  e5900004          LDR      r0,[r0,#4]
0002b8  e5900090          LDR      r0,[r0,#0x90]
0002bc  e5850000          STR      r0,[r5,#0]
;;;1809         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
;;;1810                     s, *(int *)optval));
;;;1811         break;
0002c0  ea00000a          B        |L14.752|
                  |L14.708|
;;;1812   
;;;1813   #if LWIP_TCP_KEEPALIVE
;;;1814       case TCP_KEEPIDLE:
;;;1815         *(int*)optval = (int)(sock->conn->pcb.tcp->keep_idle/1000);
;;;1816         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPIDLE) = %d\n",
;;;1817                     s, *(int *)optval));
;;;1818         break;
;;;1819       case TCP_KEEPINTVL:
;;;1820         *(int*)optval = (int)(sock->conn->pcb.tcp->keep_intvl/1000);
;;;1821         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPINTVL) = %d\n",
;;;1822                     s, *(int *)optval));
;;;1823         break;
;;;1824       case TCP_KEEPCNT:
;;;1825         *(int*)optval = (int)sock->conn->pcb.tcp->keep_cnt;
;;;1826         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPCNT) = %d\n",
;;;1827                     s, *(int *)optval));
;;;1828         break;
;;;1829   #endif /* LWIP_TCP_KEEPALIVE */
;;;1830       default:
0002c4  e1a00000          MOV      r0,r0
;;;1831         LWIP_ASSERT("unhandled optname", 0);
0002c8  e1a00000          MOV      r0,r0
0002cc  e1a00000          MOV      r0,r0
0002d0  e28f3020          ADR      r3,|L14.760|
0002d4  e59f2098          LDR      r2,|L14.884|
0002d8  e28f107c          ADR      r1,|L14.860|
0002dc  e28f0044          ADR      r0,|L14.808|
0002e0  ebfffffe          BL       sysprintf
0002e4  e1a00000          MOV      r0,r0
0002e8  e1a00000          MOV      r0,r0
;;;1832         break;
0002ec  e1a00000          MOV      r0,r0
                  |L14.752|
0002f0  e1a00000          MOV      r0,r0                 ;1806
;;;1833       }  /* switch (optname) */
;;;1834       break;
0002f4  ea00002a          B        |L14.932|
                  |L14.760|
0002f8  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
0002fc  2d312e34
000300  2e315c73
000304  72635c61
000308  70695c73
00030c  6f636b65
000310  74732e63
000314  00      
000315  00                DCB      0
000316  00                DCB      0
000317  00                DCB      0
                  |L14.792|
                          DCD      0x00000682
                  |L14.796|
00031c  61726720          DCB      "arg != NULL",0
000320  213d204e
000324  554c4c00
                  |L14.808|
000328  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00032c  7274696f
000330  6e202225
000334  73222066
000338  61696c65
00033c  64206174
000340  206c696e
000344  65202564
000348  20696e20
00034c  25730a00
                  |L14.848|
                          DCD      0x00001007
                  |L14.852|
                          DCD      err_to_errno_table
                  |L14.856|
                          DCD      0x000006d9
                  |L14.860|
00035c  756e6861          DCB      "unhandled optname",0
000360  6e646c65
000364  64206f70
000368  746e616d
00036c  6500    
00036e  00                DCB      0
00036f  00                DCB      0
                  |L14.880|
                          DCD      0x00000701
                  |L14.884|
                          DCD      0x00000727
                  |L14.888|
;;;1835   #endif /* LWIP_TCP */
;;;1836   #if LWIP_UDP && LWIP_UDPLITE
;;;1837     /* Level: IPPROTO_UDPLITE */
;;;1838     case IPPROTO_UDPLITE:
;;;1839       switch (optname) {
;;;1840       case UDPLITE_SEND_CSCOV:
;;;1841         *(int*)optval = sock->conn->pcb.udp->chksum_len_tx;
;;;1842         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) = %d\n",
;;;1843                     s, (*(int*)optval)) );
;;;1844         break;
;;;1845       case UDPLITE_RECV_CSCOV:
;;;1846         *(int*)optval = sock->conn->pcb.udp->chksum_len_rx;
;;;1847         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) = %d\n",
;;;1848                     s, (*(int*)optval)) );
;;;1849         break;
;;;1850       default:
;;;1851         LWIP_ASSERT("unhandled optname", 0);
;;;1852         break;
;;;1853       }  /* switch (optname) */
;;;1854       break;
;;;1855   #endif /* LWIP_UDP */
;;;1856     default:
000378  e1a00000          MOV      r0,r0
;;;1857       LWIP_ASSERT("unhandled level", 0);
00037c  e1a00000          MOV      r0,r0
000380  e1a00000          MOV      r0,r0
000384  e24f3094          ADR      r3,|L14.760|
000388  e59f2028          LDR      r2,|L14.952|
00038c  e28f1028          ADR      r1,|L14.956|
000390  e24f0070          ADR      r0,|L14.808|
000394  ebfffffe          BL       sysprintf
000398  e1a00000          MOV      r0,r0
00039c  e1a00000          MOV      r0,r0
;;;1858       break;
0003a0  e1a00000          MOV      r0,r0
                  |L14.932|
0003a4  e1a00000          MOV      r0,r0                 ;1756
;;;1859     } /* switch (level) */
;;;1860     sys_sem_signal(&sock->conn->op_completed);
0003a8  e5941000          LDR      r1,[r4,#0]
0003ac  e281000c          ADD      r0,r1,#0xc
0003b0  ebfffffe          BL       sys_sem_signal
;;;1861   }
0003b4  e8bd87f0          POP      {r4-r10,pc}
;;;1862   
                          ENDP

                  |L14.952|
                          DCD      0x00000741
                  |L14.956|
0003bc  756e6861          DCB      "unhandled level",0
0003c0  6e646c65
0003c4  64206c65
0003c8  76656c00

                          AREA ||i.lwip_ioctl||, CODE, READONLY, ALIGN=2

                  lwip_ioctl PROC
;;;2281   int
;;;2282   lwip_ioctl(int s, long cmd, void *argp)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2283   {
000004  e1a08000          MOV      r8,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a05002          MOV      r5,r2
;;;2284     struct lwip_sock *sock = get_socket(s);
000010  e1a00008          MOV      r0,r8
000014  ebfffffe          BL       get_socket
000018  e1a04000          MOV      r4,r0
;;;2285     u8_t val;
;;;2286   #if LWIP_SO_RCVBUF
;;;2287     u16_t buflen = 0;
;;;2288     s16_t recv_avail;
;;;2289   #endif /* LWIP_SO_RCVBUF */
;;;2290   
;;;2291     if (!sock) {
00001c  e3540000          CMP      r4,#0
000020  1a000001          BNE      |L15.44|
;;;2292       return -1;
000024  e3e00000          MVN      r0,#0
                  |L15.40|
;;;2293     }
;;;2294   
;;;2295     switch (cmd) {
;;;2296   #if LWIP_SO_RCVBUF
;;;2297     case FIONREAD:
;;;2298       if (!argp) {
;;;2299         sock_set_errno(sock, EINVAL);
;;;2300         return -1;
;;;2301       }
;;;2302   
;;;2303       SYS_ARCH_GET(sock->conn->recv_avail, recv_avail);
;;;2304       if (recv_avail < 0) {
;;;2305         recv_avail = 0;
;;;2306       }
;;;2307       *((u16_t*)argp) = (u16_t)recv_avail;
;;;2308   
;;;2309       /* Check if there is data left from the last recv operation. /maq 041215 */
;;;2310       if (sock->lastdata) {
;;;2311         struct pbuf *p = (struct pbuf *)sock->lastdata;
;;;2312         if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;2313           p = ((struct netbuf *)p)->p;
;;;2314         }
;;;2315         buflen = p->tot_len;
;;;2316         buflen -= sock->lastoffset;
;;;2317   
;;;2318         *((u16_t*)argp) += buflen;
;;;2319       }
;;;2320   
;;;2321       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %"U16_F"\n", s, argp, *((u16_t*)argp)));
;;;2322       sock_set_errno(sock, 0);
;;;2323       return 0;
;;;2324   #endif /* LWIP_SO_RCVBUF */
;;;2325   
;;;2326     case FIONBIO:
;;;2327       val = 0;
;;;2328       if (argp && *(u32_t*)argp) {
;;;2329         val = 1;
;;;2330       }
;;;2331       netconn_set_nonblocking(sock->conn, val);
;;;2332       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
;;;2333       sock_set_errno(sock, 0);
;;;2334       return 0;
;;;2335   
;;;2336     default:
;;;2337       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
;;;2338       sock_set_errno(sock, ENOSYS); /* not yet implemented */
;;;2339       return -1;
;;;2340     } /* switch (cmd) */
;;;2341   }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L15.44|
00002c  e59f0090          LDR      r0,|L15.196|
000030  e0800006          ADD      r0,r0,r6              ;2295
000034  e3500000          CMP      r0,#0                 ;2295
000038  1a00001a          BNE      |L15.168|
00003c  e3a07000          MOV      r7,#0                 ;2327
000040  e3550000          CMP      r5,#0                 ;2328
000044  0a000003          BEQ      |L15.88|
000048  e5950000          LDR      r0,[r5,#0]            ;2328
00004c  e3500000          CMP      r0,#0                 ;2328
000050  0a000000          BEQ      |L15.88|
000054  e3a07001          MOV      r7,#1                 ;2329
                  |L15.88|
000058  e1a00000          MOV      r0,r0                 ;2331
00005c  e3570000          CMP      r7,#0                 ;2331
000060  0a000005          BEQ      |L15.124|
000064  e5940000          LDR      r0,[r4,#0]            ;2331
000068  e5d0001c          LDRB     r0,[r0,#0x1c]         ;2331
00006c  e3800002          ORR      r0,r0,#2              ;2331
000070  e5941000          LDR      r1,[r4,#0]            ;2331
000074  e5c1001c          STRB     r0,[r1,#0x1c]         ;2331
000078  ea000004          B        |L15.144|
                  |L15.124|
00007c  e5940000          LDR      r0,[r4,#0]            ;2331
000080  e5d0001c          LDRB     r0,[r0,#0x1c]         ;2331
000084  e3c00002          BIC      r0,r0,#2              ;2331
000088  e5941000          LDR      r1,[r4,#0]            ;2331
00008c  e5c1001c          STRB     r0,[r1,#0x1c]         ;2331
                  |L15.144|
000090  e1a00000          MOV      r0,r0                 ;2331
000094  e1a00000          MOV      r0,r0                 ;2333
000098  e3a00000          MOV      r0,#0                 ;2333
00009c  e5840010          STR      r0,[r4,#0x10]         ;2333
0000a0  e1a00000          MOV      r0,r0                 ;2333
0000a4  eaffffdf          B        |L15.40|
                  |L15.168|
0000a8  e1a00000          MOV      r0,r0                 ;2336
0000ac  e1a00000          MOV      r0,r0                 ;2338
0000b0  e3a00026          MOV      r0,#0x26              ;2338
0000b4  e5840010          STR      r0,[r4,#0x10]         ;2338
0000b8  e1a00000          MOV      r0,r0                 ;2338
0000bc  e3e00000          MVN      r0,#0                 ;2339
0000c0  eaffffd8          B        |L15.40|
;;;2342   
                          ENDP

                  |L15.196|
                          DCD      0x7ffb9982

                          AREA ||i.lwip_listen||, CODE, READONLY, ALIGN=2

                  lwip_listen PROC
;;;524    int
;;;525    lwip_listen(int s, int backlog)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;526    {
000004  e1a07000          MOV      r7,r0
000008  e1a06001          MOV      r6,r1
;;;527      struct lwip_sock *sock;
;;;528      err_t err;
;;;529    
;;;530      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));
;;;531    
;;;532      sock = get_socket(s);
00000c  e1a00007          MOV      r0,r7
000010  ebfffffe          BL       get_socket
000014  e1a04000          MOV      r4,r0
;;;533      if (!sock) {
000018  e3540000          CMP      r4,#0
00001c  1a000001          BNE      |L16.40|
;;;534        return -1;
000020  e3e00000          MVN      r0,#0
                  |L16.36|
;;;535      }
;;;536    
;;;537      /* limit the "backlog" parameter to fit in an u8_t */
;;;538      backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
;;;539    
;;;540      err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
;;;541    
;;;542      if (err != ERR_OK) {
;;;543        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
;;;544        if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;545          sock_set_errno(sock, EOPNOTSUPP);
;;;546          return EOPNOTSUPP;
;;;547        }
;;;548        sock_set_errno(sock, err_to_errno(err));
;;;549        return -1;
;;;550      }
;;;551    
;;;552      sock_set_errno(sock, 0);
;;;553      return 0;
;;;554    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L16.40|
000028  e3560000          CMP      r6,#0                 ;538
00002c  da000001          BLE      |L16.56|
000030  e1a00006          MOV      r0,r6                 ;538
000034  ea000000          B        |L16.60|
                  |L16.56|
000038  e3a00000          MOV      r0,#0                 ;538
                  |L16.60|
00003c  e35000ff          CMP      r0,#0xff              ;538
000040  aa000005          BGE      |L16.92|
000044  e3560000          CMP      r6,#0                 ;538
000048  da000001          BLE      |L16.84|
00004c  e1a00006          MOV      r0,r6                 ;538
000050  ea000002          B        |L16.96|
                  |L16.84|
000054  e3a00000          MOV      r0,#0                 ;538
000058  ea000000          B        |L16.96|
                  |L16.92|
00005c  e3a000ff          MOV      r0,#0xff              ;538
                  |L16.96|
000060  e1a06000          MOV      r6,r0                 ;538
000064  e20610ff          AND      r1,r6,#0xff           ;540
000068  e5940000          LDR      r0,[r4,#0]            ;540
00006c  ebfffffe          BL       netconn_listen_with_backlog
000070  e1a05000          MOV      r5,r0                 ;540
000074  e3550000          CMP      r5,#0                 ;542
000078  0a000015          BEQ      |L16.212|
00007c  e5940000          LDR      r0,[r4,#0]            ;544
000080  e5d00000          LDRB     r0,[r0,#0]            ;544
000084  e3500010          CMP      r0,#0x10              ;544
000088  0a000004          BEQ      |L16.160|
00008c  e1a00000          MOV      r0,r0                 ;545
000090  e3a0005f          MOV      r0,#0x5f              ;545
000094  e5840010          STR      r0,[r4,#0x10]         ;545
000098  e1a00000          MOV      r0,r0                 ;545
00009c  eaffffe0          B        |L16.36|
                  |L16.160|
0000a0  e1a00000          MOV      r0,r0                 ;548
0000a4  e2650000          RSB      r0,r5,#0              ;548
0000a8  e3500010          CMP      r0,#0x10              ;548
0000ac  2a000003          BCS      |L16.192|
0000b0  e59f0034          LDR      r0,|L16.236|
0000b4  e2651000          RSB      r1,r5,#0              ;548
0000b8  e7900101          LDR      r0,[r0,r1,LSL #2]     ;548
0000bc  ea000000          B        |L16.196|
                  |L16.192|
0000c0  e3a00005          MOV      r0,#5                 ;548
                  |L16.196|
0000c4  e5840010          STR      r0,[r4,#0x10]         ;548
0000c8  e1a00000          MOV      r0,r0                 ;548
0000cc  e3e00000          MVN      r0,#0                 ;549
0000d0  eaffffd3          B        |L16.36|
                  |L16.212|
0000d4  e1a00000          MOV      r0,r0                 ;552
0000d8  e3a00000          MOV      r0,#0                 ;552
0000dc  e5840010          STR      r0,[r4,#0x10]         ;552
0000e0  e1a00000          MOV      r0,r0                 ;552
0000e4  e1a00000          MOV      r0,r0                 ;553
0000e8  eaffffcd          B        |L16.36|
;;;555    
                          ENDP

                  |L16.236|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_read||, CODE, READONLY, ALIGN=2

                  lwip_read PROC
;;;742    int
;;;743    lwip_read(int s, void *mem, size_t len)
000000  e92d407c          PUSH     {r2-r6,lr}
;;;744    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a06002          MOV      r6,r2
;;;745      return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
000010  e3a00000          MOV      r0,#0
000014  e58d0000          STR      r0,[sp,#0]
000018  e58d0004          STR      r0,[sp,#4]
00001c  e1a03000          MOV      r3,r0
000020  e1a02006          MOV      r2,r6
000024  e1a01005          MOV      r1,r5
000028  e1a00004          MOV      r0,r4
00002c  ebfffffe          BL       lwip_recvfrom
;;;746    }
000030  e8bd807c          POP      {r2-r6,pc}
;;;747    
                          ENDP


                          AREA ||i.lwip_recv||, CODE, READONLY, ALIGN=2

                  lwip_recv PROC
;;;748    int
;;;749    lwip_recv(int s, void *mem, size_t len, int flags)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;750    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a06002          MOV      r6,r2
000010  e1a07003          MOV      r7,r3
;;;751      return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
000014  e3a00000          MOV      r0,#0
000018  e58d0000          STR      r0,[sp,#0]
00001c  e1a03007          MOV      r3,r7
000020  e1a02006          MOV      r2,r6
000024  e1a01005          MOV      r1,r5
000028  e58d0004          STR      r0,[sp,#4]
00002c  e1a00004          MOV      r0,r4
000030  ebfffffe          BL       lwip_recvfrom
;;;752    }
000034  e8bd81fc          POP      {r2-r8,pc}
;;;753    
                          ENDP


                          AREA ||i.lwip_recvfrom||, CODE, READONLY, ALIGN=2

                  lwip_recvfrom PROC
;;;556    int
;;;557    lwip_recvfrom(int s, void *mem, size_t len, int flags,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;558            struct sockaddr *from, socklen_t *fromlen)
;;;559    {
000004  e24dd02c          SUB      sp,sp,#0x2c
000008  e1a06002          MOV      r6,r2
00000c  e1a08003          MOV      r8,r3
000010  e59d9064          LDR      r9,[sp,#0x64]
;;;560      struct lwip_sock *sock;
;;;561      void             *buf = NULL;
000014  e3a00000          MOV      r0,#0
000018  e58d0028          STR      r0,[sp,#0x28]
;;;562      struct pbuf      *p;
;;;563      u16_t            buflen, copylen;
;;;564      int              off = 0;
00001c  e3a05000          MOV      r5,#0
;;;565      ip_addr_t        *addr;
;;;566      u16_t            port;
;;;567      u8_t             done = 0;
000020  e58d0018          STR      r0,[sp,#0x18]
;;;568      err_t            err;
;;;569    
;;;570      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
;;;571      sock = get_socket(s);
000024  e59d002c          LDR      r0,[sp,#0x2c]
000028  ebfffffe          BL       get_socket
00002c  e1a04000          MOV      r4,r0
;;;572      if (!sock) {
000030  e3540000          CMP      r4,#0
000034  1a000002          BNE      |L19.68|
;;;573        return -1;
000038  e3e00000          MVN      r0,#0
                  |L19.60|
00003c  e28dd03c          ADD      sp,sp,#0x3c
;;;574      }
;;;575    
;;;576      do {
;;;577        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", sock->lastdata));
;;;578        /* Check if there is data left from the last recv operation. */
;;;579        if (sock->lastdata) {
;;;580          buf = sock->lastdata;
;;;581        } else {
;;;582          /* If this is non-blocking call, then check first */
;;;583          if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
;;;584              (sock->rcvevent <= 0)) {
;;;585            if (off > 0) {
;;;586              /* update receive window */
;;;587              netconn_recved(sock->conn, (u32_t)off);
;;;588              /* already received data, return that */
;;;589              sock_set_errno(sock, 0);
;;;590              return off;
;;;591            }
;;;592            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
;;;593            sock_set_errno(sock, EWOULDBLOCK);
;;;594            return -1;
;;;595          }
;;;596    
;;;597          /* No data was left from the previous operation, so we try to get
;;;598             some from the network. */
;;;599          if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;600            err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
;;;601          } else {
;;;602            err = netconn_recv(sock->conn, (struct netbuf **)&buf);
;;;603          }
;;;604          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv err=%d, netbuf=%p\n",
;;;605            err, buf));
;;;606    
;;;607          if (err != ERR_OK) {
;;;608            if (off > 0) {
;;;609              /* update receive window */
;;;610              netconn_recved(sock->conn, (u32_t)off);
;;;611              /* already received data, return that */
;;;612              sock_set_errno(sock, 0);
;;;613              return off;
;;;614            }
;;;615            /* We should really do some error checking here. */
;;;616            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL, error is \"%s\"!\n",
;;;617              s, lwip_strerr(err)));
;;;618            sock_set_errno(sock, err_to_errno(err));
;;;619            if (err == ERR_CLSD) {
;;;620                printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
;;;621              return 0;
;;;622            } else {
;;;623              return -1;
;;;624            }
;;;625          }
;;;626          LWIP_ASSERT("buf != NULL", buf != NULL);
;;;627          sock->lastdata = buf;
;;;628        }
;;;629    
;;;630        if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;631          p = (struct pbuf *)buf;
;;;632        } else {
;;;633          p = ((struct netbuf *)buf)->p;
;;;634        }
;;;635        buflen = p->tot_len;
;;;636        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%"U16_F" len=%"SZT_F" off=%d sock->lastoffset=%"U16_F"\n",
;;;637          buflen, len, off, sock->lastoffset));
;;;638    
;;;639        buflen -= sock->lastoffset;
;;;640    
;;;641        if (len > buflen) {
;;;642          copylen = buflen;
;;;643        } else {
;;;644          copylen = (u16_t)len;
;;;645        }
;;;646    
;;;647        /* copy the contents of the received buffer into
;;;648        the supplied memory pointer mem */
;;;649        pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
;;;650    
;;;651        off += copylen;
;;;652    
;;;653        if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;654          LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
;;;655          len -= copylen;
;;;656          if ( (len <= 0) || 
;;;657               (p->flags & PBUF_FLAG_PUSH) || 
;;;658               (sock->rcvevent <= 0) || 
;;;659               ((flags & MSG_PEEK)!=0)) {
;;;660            done = 1;
;;;661          }
;;;662        } else {
;;;663          done = 1;
;;;664        }
;;;665    
;;;666        /* Check to see from where the data was.*/
;;;667        if (done) {
;;;668          ip_addr_t fromaddr;
;;;669          if (from && fromlen) {
;;;670            struct sockaddr_in sin;
;;;671    
;;;672            if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;673              addr = &fromaddr;
;;;674              netconn_getaddr(sock->conn, addr, &port, 0);
;;;675            } else {
;;;676              addr = netbuf_fromaddr((struct netbuf *)buf);
;;;677              port = netbuf_fromport((struct netbuf *)buf);
;;;678            }
;;;679    
;;;680            memset(&sin, 0, sizeof(sin));
;;;681            sin.sin_len = sizeof(sin);
;;;682            sin.sin_family = AF_INET;
;;;683            sin.sin_port = htons(port);
;;;684            inet_addr_from_ipaddr(&sin.sin_addr, addr);
;;;685    
;;;686            if (*fromlen > sizeof(sin)) {
;;;687              *fromlen = sizeof(sin);
;;;688            }
;;;689    
;;;690            MEMCPY(from, &sin, *fromlen);
;;;691    
;;;692            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
;;;693            ip_addr_debug_print(SOCKETS_DEBUG, addr);
;;;694            LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", port, off));
;;;695          } else {
;;;696    #if SOCKETS_DEBUG
;;;697            if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;698              addr = &fromaddr;
;;;699              netconn_getaddr(sock->conn, addr, &port, 0);
;;;700            } else {
;;;701              addr = netbuf_fromaddr((struct netbuf *)buf);
;;;702              port = netbuf_fromport((struct netbuf *)buf);
;;;703            }
;;;704    
;;;705            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
;;;706            ip_addr_debug_print(SOCKETS_DEBUG, addr);
;;;707            LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", port, off));
;;;708    #endif /*  SOCKETS_DEBUG */
;;;709          }
;;;710        }
;;;711    
;;;712        /* If we don't peek the incoming message... */
;;;713        if ((flags & MSG_PEEK) == 0) {
;;;714          /* If this is a TCP socket, check if there is data left in the
;;;715             buffer. If so, it should be saved in the sock structure for next
;;;716             time around. */
;;;717          if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
;;;718            sock->lastdata = buf;
;;;719            sock->lastoffset += copylen;
;;;720            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
;;;721          } else {
;;;722            sock->lastdata = NULL;
;;;723            sock->lastoffset = 0;
;;;724            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
;;;725            if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;726              pbuf_free((struct pbuf *)buf);
;;;727            } else {
;;;728              netbuf_delete((struct netbuf *)buf);
;;;729            }
;;;730          }
;;;731        }
;;;732      } while (!done);
;;;733    
;;;734      if (off > 0) {
;;;735        /* update receive window */
;;;736        netconn_recved(sock->conn, (u32_t)off);
;;;737      }
;;;738      sock_set_errno(sock, 0);
;;;739      return off;
;;;740    }
000040  e8bd8ff0          POP      {r4-r11,pc}
                  |L19.68|
000044  e1a00000          MOV      r0,r0                 ;576
                  |L19.72|
000048  e5940004          LDR      r0,[r4,#4]            ;579
00004c  e3500000          CMP      r0,#0                 ;579
000050  0a000002          BEQ      |L19.96|
000054  e5940004          LDR      r0,[r4,#4]            ;580
000058  e58d0028          STR      r0,[sp,#0x28]         ;580
00005c  ea000056          B        |L19.444|
                  |L19.96|
000060  e2080008          AND      r0,r8,#8              ;583
000064  e3500000          CMP      r0,#0                 ;583
000068  1a000004          BNE      |L19.128|
00006c  e5940000          LDR      r0,[r4,#0]            ;583
000070  e5d0001c          LDRB     r0,[r0,#0x1c]         ;583
000074  e2000002          AND      r0,r0,#2              ;583
000078  e3500000          CMP      r0,#0                 ;583
00007c  0a000013          BEQ      |L19.208|
                  |L19.128|
000080  e1d400fa          LDRSH    r0,[r4,#0xa]          ;584
000084  e3500000          CMP      r0,#0                 ;584
000088  ca000010          BGT      |L19.208|
00008c  e3550000          CMP      r5,#0                 ;585
000090  da000008          BLE      |L19.184|
000094  e1a01005          MOV      r1,r5                 ;587
000098  e5940000          LDR      r0,[r4,#0]            ;587
00009c  ebfffffe          BL       netconn_recved
0000a0  e1a00000          MOV      r0,r0                 ;589
0000a4  e3a00000          MOV      r0,#0                 ;589
0000a8  e5840010          STR      r0,[r4,#0x10]         ;589
0000ac  e1a00000          MOV      r0,r0                 ;589
0000b0  e1a00005          MOV      r0,r5                 ;590
0000b4  eaffffe0          B        |L19.60|
                  |L19.184|
0000b8  e1a00000          MOV      r0,r0                 ;593
0000bc  e3a0000b          MOV      r0,#0xb               ;593
0000c0  e5840010          STR      r0,[r4,#0x10]         ;593
0000c4  e1a00000          MOV      r0,r0                 ;593
0000c8  e3e00000          MVN      r0,#0                 ;594
0000cc  eaffffda          B        |L19.60|
                  |L19.208|
0000d0  e5940000          LDR      r0,[r4,#0]            ;599
0000d4  e5d00000          LDRB     r0,[r0,#0]            ;599
0000d8  e3500010          CMP      r0,#0x10              ;599
0000dc  1a000004          BNE      |L19.244|
0000e0  e28d1028          ADD      r1,sp,#0x28           ;600
0000e4  e5940000          LDR      r0,[r4,#0]            ;600
0000e8  ebfffffe          BL       netconn_recv_tcp_pbuf
0000ec  e1a0b000          MOV      r11,r0                ;600
0000f0  ea000003          B        |L19.260|
                  |L19.244|
0000f4  e28d1028          ADD      r1,sp,#0x28           ;602
0000f8  e5940000          LDR      r0,[r4,#0]            ;602
0000fc  ebfffffe          BL       netconn_recv
000100  e1a0b000          MOV      r11,r0                ;602
                  |L19.260|
000104  e35b0000          CMP      r11,#0                ;607
000108  0a00001d          BEQ      |L19.388|
00010c  e3550000          CMP      r5,#0                 ;608
000110  da000008          BLE      |L19.312|
000114  e1a01005          MOV      r1,r5                 ;610
000118  e5940000          LDR      r0,[r4,#0]            ;610
00011c  ebfffffe          BL       netconn_recved
000120  e1a00000          MOV      r0,r0                 ;612
000124  e3a00000          MOV      r0,#0                 ;612
000128  e5840010          STR      r0,[r4,#0x10]         ;612
00012c  e1a00000          MOV      r0,r0                 ;612
000130  e1a00005          MOV      r0,r5                 ;613
000134  eaffffc0          B        |L19.60|
                  |L19.312|
000138  e1a00000          MOV      r0,r0                 ;618
00013c  e26b0000          RSB      r0,r11,#0             ;618
000140  e3500010          CMP      r0,#0x10              ;618
000144  2a000003          BCS      |L19.344|
000148  e59f02e0          LDR      r0,|L19.1072|
00014c  e26b1000          RSB      r1,r11,#0             ;618
000150  e7900101          LDR      r0,[r0,r1,LSL #2]     ;618
000154  ea000000          B        |L19.348|
                  |L19.344|
000158  e3a00005          MOV      r0,#5                 ;618
                  |L19.348|
00015c  e5840010          STR      r0,[r4,#0x10]         ;618
000160  e1a00000          MOV      r0,r0                 ;618
000164  e37b000c          CMN      r11,#0xc              ;619
000168  1a000003          BNE      |L19.380|
00016c  e28f0d0b          ADR      r0,|L19.1076|
000170  ebfffffe          BL       __2printf
000174  e3a00000          MOV      r0,#0                 ;621
000178  eaffffaf          B        |L19.60|
                  |L19.380|
00017c  e3e00000          MVN      r0,#0                 ;623
000180  eaffffad          B        |L19.60|
                  |L19.388|
000184  e1a00000          MOV      r0,r0                 ;626
000188  e59d0028          LDR      r0,[sp,#0x28]         ;626
00018c  e3500000          CMP      r0,#0                 ;626
000190  1a000006          BNE      |L19.432|
000194  e1a00000          MOV      r0,r0                 ;626
000198  e28f3fae          ADR      r3,|L19.1112|
00019c  e59f22d4          LDR      r2,|L19.1144|
0001a0  e28f1fb5          ADR      r1,|L19.1148|
0001a4  e28f0fb7          ADR      r0,|L19.1160|
0001a8  ebfffffe          BL       sysprintf
0001ac  e1a00000          MOV      r0,r0                 ;626
                  |L19.432|
0001b0  e1a00000          MOV      r0,r0                 ;626
0001b4  e59d0028          LDR      r0,[sp,#0x28]         ;627
0001b8  e5840004          STR      r0,[r4,#4]            ;627
                  |L19.444|
0001bc  e5940000          LDR      r0,[r4,#0]            ;630
0001c0  e5d00000          LDRB     r0,[r0,#0]            ;630
0001c4  e3500010          CMP      r0,#0x10              ;630
0001c8  1a000002          BNE      |L19.472|
0001cc  e59d0028          LDR      r0,[sp,#0x28]         ;631
0001d0  e58d0024          STR      r0,[sp,#0x24]         ;631
0001d4  ea000002          B        |L19.484|
                  |L19.472|
0001d8  e59d0028          LDR      r0,[sp,#0x28]         ;633
0001dc  e5900000          LDR      r0,[r0,#0]            ;633
0001e0  e58d0024          STR      r0,[sp,#0x24]         ;633
                  |L19.484|
0001e4  e59d0024          LDR      r0,[sp,#0x24]         ;635
0001e8  e1d0a0b8          LDRH     r10,[r0,#8]           ;635
0001ec  e1d400b8          LDRH     r0,[r4,#8]            ;639
0001f0  e04a0000          SUB      r0,r10,r0             ;639
0001f4  e1a0a800          LSL      r10,r0,#16            ;639
0001f8  e1a0a82a          LSR      r10,r10,#16           ;639
0001fc  e156000a          CMP      r6,r10                ;641
000200  9a000001          BLS      |L19.524|
000204  e1a0700a          MOV      r7,r10                ;642
000208  ea000001          B        |L19.532|
                  |L19.524|
00020c  e1a07806          LSL      r7,r6,#16             ;644
000210  e1a07827          LSR      r7,r7,#16             ;644
                  |L19.532|
000214  e1d430b8          LDRH     r3,[r4,#8]            ;649
000218  e59d0030          LDR      r0,[sp,#0x30]         ;649
00021c  e0801005          ADD      r1,r0,r5              ;649
000220  e1a02007          MOV      r2,r7                 ;649
000224  e59d0024          LDR      r0,[sp,#0x24]         ;649
000228  ebfffffe          BL       pbuf_copy_partial
00022c  e0855007          ADD      r5,r5,r7              ;651
000230  e5940000          LDR      r0,[r4,#0]            ;653
000234  e5d00000          LDRB     r0,[r0,#0]            ;653
000238  e3500010          CMP      r0,#0x10              ;653
00023c  1a00001b          BNE      |L19.688|
000240  e1a00000          MOV      r0,r0                 ;654
000244  e1560007          CMP      r6,r7                 ;654
000248  2a000006          BCS      |L19.616|
00024c  e1a00000          MOV      r0,r0                 ;654
000250  e28f3c02          ADR      r3,|L19.1112|
000254  e59f2254          LDR      r2,|L19.1200|
000258  e28f1f95          ADR      r1,|L19.1204|
00025c  e28f0f89          ADR      r0,|L19.1160|
000260  ebfffffe          BL       sysprintf
000264  e1a00000          MOV      r0,r0                 ;654
                  |L19.616|
000268  e1a00000          MOV      r0,r0                 ;654
00026c  e0466007          SUB      r6,r6,r7              ;655
000270  e3560000          CMP      r6,#0                 ;656
000274  0a00000a          BEQ      |L19.676|
000278  e59d0024          LDR      r0,[sp,#0x24]         ;657
00027c  e5d0000d          LDRB     r0,[r0,#0xd]          ;657
000280  e2000001          AND      r0,r0,#1              ;657
000284  e3500000          CMP      r0,#0                 ;657
000288  1a000005          BNE      |L19.676|
00028c  e1d400fa          LDRSH    r0,[r4,#0xa]          ;658
000290  e3500000          CMP      r0,#0                 ;658
000294  da000002          BLE      |L19.676|
000298  e2080001          AND      r0,r8,#1              ;659
00029c  e3500000          CMP      r0,#0                 ;659
0002a0  0a000004          BEQ      |L19.696|
                  |L19.676|
0002a4  e3a00001          MOV      r0,#1                 ;660
0002a8  e58d0018          STR      r0,[sp,#0x18]         ;660
0002ac  ea000001          B        |L19.696|
                  |L19.688|
0002b0  e3a00001          MOV      r0,#1                 ;663
0002b4  e58d0018          STR      r0,[sp,#0x18]         ;663
                  |L19.696|
0002b8  e59d0018          LDR      r0,[sp,#0x18]         ;667
0002bc  e3500000          CMP      r0,#0                 ;667
0002c0  0a000030          BEQ      |L19.904|
0002c4  e59d0060          LDR      r0,[sp,#0x60]         ;669
0002c8  e3500000          CMP      r0,#0                 ;669
0002cc  0a00002c          BEQ      |L19.900|
0002d0  e3590000          CMP      r9,#0                 ;669
0002d4  0a00002a          BEQ      |L19.900|
0002d8  e5940000          LDR      r0,[r4,#0]            ;672
0002dc  e5d00000          LDRB     r0,[r0,#0]            ;672
0002e0  e3500010          CMP      r0,#0x10              ;672
0002e4  1a000007          BNE      |L19.776|
0002e8  e28d0014          ADD      r0,sp,#0x14           ;673
0002ec  e58d0020          STR      r0,[sp,#0x20]         ;673
0002f0  e3a03000          MOV      r3,#0                 ;674
0002f4  e28d201c          ADD      r2,sp,#0x1c           ;674
0002f8  e5940000          LDR      r0,[r4,#0]            ;674
0002fc  e59d1020          LDR      r1,[sp,#0x20]         ;674
000300  ebfffffe          BL       netconn_getaddr
000304  ea000005          B        |L19.800|
                  |L19.776|
000308  e59d0028          LDR      r0,[sp,#0x28]         ;676
00030c  e2800008          ADD      r0,r0,#8              ;676
000310  e58d0020          STR      r0,[sp,#0x20]         ;676
000314  e59d0028          LDR      r0,[sp,#0x28]         ;677
000318  e1d000bc          LDRH     r0,[r0,#0xc]          ;677
00031c  e58d001c          STR      r0,[sp,#0x1c]         ;677
                  |L19.800|
000320  e3a00000          MOV      r0,#0                 ;680
000324  e58d0004          STR      r0,[sp,#4]            ;680
000328  e58d0008          STR      r0,[sp,#8]            ;680
00032c  e58d000c          STR      r0,[sp,#0xc]          ;680
000330  e58d0010          STR      r0,[sp,#0x10]         ;680
000334  e3a00010          MOV      r0,#0x10              ;681
000338  e5cd0004          STRB     r0,[sp,#4]            ;681
00033c  e3a00002          MOV      r0,#2                 ;682
000340  e5cd0005          STRB     r0,[sp,#5]            ;682
000344  e1dd01bc          LDRH     r0,[sp,#0x1c]         ;683
000348  ebfffffe          BL       lwip_htons
00034c  e1cd00b6          STRH     r0,[sp,#6]            ;683
000350  e59d0020          LDR      r0,[sp,#0x20]         ;684
000354  e5900000          LDR      r0,[r0,#0]            ;684
000358  e58d0008          STR      r0,[sp,#8]            ;684
00035c  e5990000          LDR      r0,[r9,#0]            ;686
000360  e3500010          CMP      r0,#0x10              ;686
000364  9a000001          BLS      |L19.880|
000368  e3a00010          MOV      r0,#0x10              ;687
00036c  e5890000          STR      r0,[r9,#0]            ;687
                  |L19.880|
000370  e28d1004          ADD      r1,sp,#4              ;690
000374  e5992000          LDR      r2,[r9,#0]            ;690
000378  e59d0060          LDR      r0,[sp,#0x60]         ;690
00037c  ebfffffe          BL       __aeabi_memcpy
000380  e1a00000          MOV      r0,r0                 ;695
                  |L19.900|
000384  e1a00000          MOV      r0,r0                 ;710
                  |L19.904|
000388  e2080001          AND      r0,r8,#1              ;713
00038c  e3500000          CMP      r0,#0                 ;713
000390  1a000018          BNE      |L19.1016|
000394  e5940000          LDR      r0,[r4,#0]            ;717
000398  e5d00000          LDRB     r0,[r0,#0]            ;717
00039c  e3500010          CMP      r0,#0x10              ;717
0003a0  1a000008          BNE      |L19.968|
0003a4  e04a0007          SUB      r0,r10,r7             ;717
0003a8  e3500000          CMP      r0,#0                 ;717
0003ac  da000005          BLE      |L19.968|
0003b0  e59d0028          LDR      r0,[sp,#0x28]         ;718
0003b4  e5840004          STR      r0,[r4,#4]            ;718
0003b8  e1d400b8          LDRH     r0,[r4,#8]            ;719
0003bc  e0800007          ADD      r0,r0,r7              ;719
0003c0  e1c400b8          STRH     r0,[r4,#8]            ;719
0003c4  ea00000b          B        |L19.1016|
                  |L19.968|
0003c8  e3a00000          MOV      r0,#0                 ;722
0003cc  e5840004          STR      r0,[r4,#4]            ;722
0003d0  e1c400b8          STRH     r0,[r4,#8]            ;723
0003d4  e5940000          LDR      r0,[r4,#0]            ;725
0003d8  e5d00000          LDRB     r0,[r0,#0]            ;725
0003dc  e3500010          CMP      r0,#0x10              ;725
0003e0  1a000002          BNE      |L19.1008|
0003e4  e59d0028          LDR      r0,[sp,#0x28]         ;726
0003e8  ebfffffe          BL       pbuf_free
0003ec  ea000001          B        |L19.1016|
                  |L19.1008|
0003f0  e59d0028          LDR      r0,[sp,#0x28]         ;728
0003f4  ebfffffe          BL       netbuf_delete
                  |L19.1016|
0003f8  e59d0018          LDR      r0,[sp,#0x18]         ;732
0003fc  e3500000          CMP      r0,#0                 ;732
000400  0affff10          BEQ      |L19.72|
000404  e3550000          CMP      r5,#0                 ;734
000408  da000002          BLE      |L19.1048|
00040c  e1a01005          MOV      r1,r5                 ;736
000410  e5940000          LDR      r0,[r4,#0]            ;736
000414  ebfffffe          BL       netconn_recved
                  |L19.1048|
000418  e1a00000          MOV      r0,r0                 ;738
00041c  e3a00000          MOV      r0,#0                 ;738
000420  e5840010          STR      r0,[r4,#0x10]         ;738
000424  e1a00000          MOV      r0,r0                 ;738
000428  e1a00005          MOV      r0,r5                 ;739
00042c  eaffff02          B        |L19.60|
                  |L19.1072|
                          DCD      err_to_errno_table
                  |L19.1076|
000434  7e7e7e7e          DCB      "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",0
000438  7e7e7e7e
00043c  7e7e7e7e
000440  7e7e7e7e
000444  7e7e7e7e
000448  7e7e7e7e
00044c  7e7e7e7e
000450  7e7e7e7e
000454  7e0a00  
000457  00                DCB      0
                  |L19.1112|
000458  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
00045c  2d312e34
000460  2e315c73
000464  72635c61
000468  70695c73
00046c  6f636b65
000470  74732e63
000474  00      
000475  00                DCB      0
000476  00                DCB      0
000477  00                DCB      0
                  |L19.1144|
                          DCD      0x00000272
                  |L19.1148|
00047c  62756620          DCB      "buf != NULL",0
000480  213d204e
000484  554c4c00
                  |L19.1160|
000488  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00048c  7274696f
000490  6e202225
000494  73222066
000498  61696c65
00049c  64206174
0004a0  206c696e
0004a4  65202564
0004a8  20696e20
0004ac  25730a00
                  |L19.1200|
                          DCD      0x0000028e
                  |L19.1204|
0004b4  696e7661          DCB      "invalid copylen, len would underflow",0
0004b8  6c696420
0004bc  636f7079
0004c0  6c656e2c
0004c4  206c656e
0004c8  20776f75
0004cc  6c642075
0004d0  6e646572
0004d4  666c6f77
0004d8  00      
0004d9  00                DCB      0
0004da  00                DCB      0
0004db  00                DCB      0
                          ENDP


                          AREA ||i.lwip_select||, CODE, READONLY, ALIGN=2

                  lwip_select PROC
;;;1088   int
;;;1089   lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1090               struct timeval *timeout)
;;;1091   {
000004  e24dd044          SUB      sp,sp,#0x44
000008  e1a0b000          MOV      r11,r0
00000c  e1a05001          MOV      r5,r1
000010  e1a06002          MOV      r6,r2
000014  e1a07003          MOV      r7,r3
000018  e59d8068          LDR      r8,[sp,#0x68]
;;;1092     u32_t waitres = 0;
00001c  e3a00000          MOV      r0,#0
000020  e58d0040          STR      r0,[sp,#0x40]
;;;1093     int nready;
;;;1094     fd_set lreadset, lwriteset, lexceptset;
;;;1095     u32_t msectimeout;
;;;1096     struct lwip_select_cb select_cb;
;;;1097     err_t err;
;;;1098     int i;
;;;1099     SYS_ARCH_DECL_PROTECT(lev);
;;;1100   
;;;1101     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%"S32_F" tvusec=%"S32_F")\n",
;;;1102                     maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
;;;1103                     timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
;;;1104                     timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));
;;;1105   
;;;1106     /* Go through each socket in each list to count number of sockets which
;;;1107        currently match */
;;;1108     nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
000024  e28d0030          ADD      r0,sp,#0x30
000028  e28d1034          ADD      r1,sp,#0x34
00002c  e28d2038          ADD      r2,sp,#0x38
000030  e1a03007          MOV      r3,r7
000034  e58d2000          STR      r2,[sp,#0]
000038  e1a02006          MOV      r2,r6
00003c  e58d1004          STR      r1,[sp,#4]
000040  e1a01005          MOV      r1,r5
000044  e58d0008          STR      r0,[sp,#8]
000048  e1a0000b          MOV      r0,r11
00004c  ebfffffe          BL       lwip_selscan
000050  e58d003c          STR      r0,[sp,#0x3c]
;;;1109   
;;;1110     /* If we don't have any current events, then suspend if we are supposed to */
;;;1111     if (!nready) {
000054  e59d003c          LDR      r0,[sp,#0x3c]
000058  e3500000          CMP      r0,#0
00005c  1a000159          BNE      |L20.1480|
;;;1112       if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
000060  e3580000          CMP      r8,#0
000064  0a000006          BEQ      |L20.132|
000068  e5980000          LDR      r0,[r8,#0]
00006c  e3500000          CMP      r0,#0
000070  1a000003          BNE      |L20.132|
000074  e5980004          LDR      r0,[r8,#4]
000078  e3500000          CMP      r0,#0
00007c  1a000000          BNE      |L20.132|
;;;1113         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
;;;1114         /* This is OK as the local fdsets are empty and nready is zero,
;;;1115            or we would have returned earlier. */
;;;1116         goto return_copy_fdsets;
000080  ea000151          B        |L20.1484|
                  |L20.132|
;;;1117       }
;;;1118   
;;;1119       /* None ready: add our semaphore to list:
;;;1120          We don't actually need any dynamic memory. Our entry on the
;;;1121          list is only valid while we are in this function, so it's ok
;;;1122          to use local variables. */
;;;1123   
;;;1124       select_cb.next = NULL;
000084  e3a00000          MOV      r0,#0
000088  e58d0014          STR      r0,[sp,#0x14]
;;;1125       select_cb.prev = NULL;
00008c  e58d0018          STR      r0,[sp,#0x18]
;;;1126       select_cb.readset = readset;
000090  e58d501c          STR      r5,[sp,#0x1c]
;;;1127       select_cb.writeset = writeset;
000094  e58d6020          STR      r6,[sp,#0x20]
;;;1128       select_cb.exceptset = exceptset;
000098  e58d7024          STR      r7,[sp,#0x24]
;;;1129       select_cb.sem_signalled = 0;
00009c  e58d0028          STR      r0,[sp,#0x28]
;;;1130       err = sys_sem_new(&select_cb.sem, 0);
0000a0  e3a01000          MOV      r1,#0
0000a4  e28d002c          ADD      r0,sp,#0x2c
0000a8  ebfffffe          BL       sys_sem_new
0000ac  e58d0010          STR      r0,[sp,#0x10]
;;;1131       if (err != ERR_OK) {
0000b0  e59d0010          LDR      r0,[sp,#0x10]
0000b4  e3500000          CMP      r0,#0
0000b8  0a000002          BEQ      |L20.200|
;;;1132         /* failed to create semaphore */
;;;1133         set_errno(ENOMEM);
;;;1134         return -1;
0000bc  e3e00000          MVN      r0,#0
                  |L20.192|
0000c0  e28dd044          ADD      sp,sp,#0x44
;;;1135       }
;;;1136   
;;;1137       /* Protect the select_cb_list */
;;;1138       SYS_ARCH_PROTECT(lev);
;;;1139   
;;;1140       /* Put this select_cb on top of list */
;;;1141       select_cb.next = select_cb_list;
;;;1142       if (select_cb_list != NULL) {
;;;1143         select_cb_list->prev = &select_cb;
;;;1144       }
;;;1145       select_cb_list = &select_cb;
;;;1146       /* Increasing this counter tells even_callback that the list has changed. */
;;;1147       select_cb_ctr++;
;;;1148   
;;;1149       /* Now we can safely unprotect */
;;;1150       SYS_ARCH_UNPROTECT(lev);
;;;1151   
;;;1152       /* Increase select_waiting for each socket we are interested in */
;;;1153       for(i = 0; i < maxfdp1; i++) {
;;;1154         if ((readset && FD_ISSET(i, readset)) ||
;;;1155             (writeset && FD_ISSET(i, writeset)) ||
;;;1156             (exceptset && FD_ISSET(i, exceptset))) {
;;;1157           struct lwip_sock *sock = tryget_socket(i);
;;;1158           LWIP_ASSERT("sock != NULL", sock != NULL);
;;;1159           SYS_ARCH_PROTECT(lev);
;;;1160           sock->select_waiting++;
;;;1161           LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
;;;1162           SYS_ARCH_UNPROTECT(lev);
;;;1163         }
;;;1164       }
;;;1165   
;;;1166       /* Call lwip_selscan again: there could have been events between
;;;1167          the last scan (whithout us on the list) and putting us on the list! */
;;;1168       nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
;;;1169       if (!nready) {
;;;1170         /* Still none ready, just wait to be woken */
;;;1171         if (timeout == 0) {
;;;1172           /* Wait forever */
;;;1173           msectimeout = 0;
;;;1174         } else {
;;;1175           msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
;;;1176           if (msectimeout == 0) {
;;;1177             /* Wait 1ms at least (0 means wait forever) */
;;;1178             msectimeout = 1;
;;;1179           }
;;;1180         }
;;;1181   
;;;1182         waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
;;;1183       }
;;;1184       /* Increase select_waiting for each socket we are interested in */
;;;1185       for(i = 0; i < maxfdp1; i++) {
;;;1186         if ((readset && FD_ISSET(i, readset)) ||
;;;1187             (writeset && FD_ISSET(i, writeset)) ||
;;;1188             (exceptset && FD_ISSET(i, exceptset))) {
;;;1189           struct lwip_sock *sock = tryget_socket(i);
;;;1190           LWIP_ASSERT("sock != NULL", sock != NULL);
;;;1191           SYS_ARCH_PROTECT(lev);
;;;1192           sock->select_waiting--;
;;;1193           LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
;;;1194           SYS_ARCH_UNPROTECT(lev);
;;;1195         }
;;;1196       }
;;;1197       /* Take us off the list */
;;;1198       SYS_ARCH_PROTECT(lev);
;;;1199       if (select_cb.next != NULL) {
;;;1200         select_cb.next->prev = select_cb.prev;
;;;1201       }
;;;1202       if (select_cb_list == &select_cb) {
;;;1203         LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
;;;1204         select_cb_list = select_cb.next;
;;;1205       } else {
;;;1206         LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
;;;1207         select_cb.prev->next = select_cb.next;
;;;1208       }
;;;1209       /* Increasing this counter tells even_callback that the list has changed. */
;;;1210       select_cb_ctr++;
;;;1211       SYS_ARCH_UNPROTECT(lev);
;;;1212   
;;;1213       sys_sem_free(&select_cb.sem);
;;;1214       if (waitres == SYS_ARCH_TIMEOUT)  {
;;;1215         /* Timeout */
;;;1216         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
;;;1217         /* This is OK as the local fdsets are empty and nready is zero,
;;;1218            or we would have returned earlier. */
;;;1219         goto return_copy_fdsets;
;;;1220       }
;;;1221   
;;;1222       /* See what's set */
;;;1223       nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
;;;1224     }
;;;1225   
;;;1226     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
;;;1227   return_copy_fdsets:
;;;1228     set_errno(0);
;;;1229     if (readset) {
;;;1230       *readset = lreadset;
;;;1231     }
;;;1232     if (writeset) {
;;;1233       *writeset = lwriteset;
;;;1234     }
;;;1235     if (exceptset) {
;;;1236       *exceptset = lexceptset;
;;;1237     }
;;;1238   
;;;1239   
;;;1240     return nready;
;;;1241   }
0000c4  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.200|
0000c8  ebfffffe          BL       sys_arch_protect
0000cc  e58d000c          STR      r0,[sp,#0xc]          ;1138
0000d0  e59f03e0          LDR      r0,|L20.1208|
0000d4  e5900000          LDR      r0,[r0,#0]            ;1141  ; select_cb_list
0000d8  e58d0014          STR      r0,[sp,#0x14]         ;1141
0000dc  e59f03d4          LDR      r0,|L20.1208|
0000e0  e5900000          LDR      r0,[r0,#0]            ;1142  ; select_cb_list
0000e4  e3500000          CMP      r0,#0                 ;1142
0000e8  0a000003          BEQ      |L20.252|
0000ec  e28d0014          ADD      r0,sp,#0x14           ;1143
0000f0  e59f13c0          LDR      r1,|L20.1208|
0000f4  e5911000          LDR      r1,[r1,#0]            ;1143  ; select_cb_list
0000f8  e5810004          STR      r0,[r1,#4]            ;1143
                  |L20.252|
0000fc  e28d0014          ADD      r0,sp,#0x14           ;1145
000100  e59f13b0          LDR      r1,|L20.1208|
000104  e5810000          STR      r0,[r1,#0]            ;1145  ; select_cb_list
000108  e59f03ac          LDR      r0,|L20.1212|
00010c  e5900000          LDR      r0,[r0,#0]            ;1147  ; select_cb_ctr
000110  e2800001          ADD      r0,r0,#1              ;1147
000114  e59f13a0          LDR      r1,|L20.1212|
000118  e5810000          STR      r0,[r1,#0]            ;1147  ; select_cb_ctr
00011c  e59d000c          LDR      r0,[sp,#0xc]          ;1150
000120  ebfffffe          BL       sys_arch_unprotect
000124  e3a04000          MOV      r4,#0                 ;1153
000128  ea000040          B        |L20.560|
                  |L20.300|
00012c  e3550000          CMP      r5,#0                 ;1154
000130  0a000007          BEQ      |L20.340|
000134  e1a03fc4          ASR      r3,r4,#31             ;1154
000138  e0843ea3          ADD      r3,r4,r3,LSR #29      ;1154
00013c  e7d531c3          LDRB     r3,[r5,r3,ASR #3]     ;1154
000140  e204c007          AND      r12,r4,#7             ;1154
000144  e3a0a001          MOV      r10,#1                ;1154
000148  e0033c1a          AND      r3,r3,r10,LSL r12     ;1154
00014c  e3530000          CMP      r3,#0                 ;1154
000150  1a000013          BNE      |L20.420|
                  |L20.340|
000154  e3560000          CMP      r6,#0                 ;1155
000158  0a000007          BEQ      |L20.380|
00015c  e1a03fc4          ASR      r3,r4,#31             ;1155
000160  e0843ea3          ADD      r3,r4,r3,LSR #29      ;1155
000164  e7d631c3          LDRB     r3,[r6,r3,ASR #3]     ;1155
000168  e204c007          AND      r12,r4,#7             ;1155
00016c  e3a0a001          MOV      r10,#1                ;1155
000170  e0033c1a          AND      r3,r3,r10,LSL r12     ;1155
000174  e3530000          CMP      r3,#0                 ;1155
000178  1a000009          BNE      |L20.420|
                  |L20.380|
00017c  e3570000          CMP      r7,#0                 ;1156
000180  0a000029          BEQ      |L20.556|
000184  e1a03fc4          ASR      r3,r4,#31             ;1156
000188  e0843ea3          ADD      r3,r4,r3,LSR #29      ;1156
00018c  e7d731c3          LDRB     r3,[r7,r3,ASR #3]     ;1156
000190  e204c007          AND      r12,r4,#7             ;1156
000194  e3a0a001          MOV      r10,#1                ;1156
000198  e0033c1a          AND      r3,r3,r10,LSL r12     ;1156
00019c  e3530000          CMP      r3,#0                 ;1156
0001a0  0a000021          BEQ      |L20.556|
                  |L20.420|
0001a4  e1a00004          MOV      r0,r4                 ;1157
0001a8  ebfffffe          BL       tryget_socket
0001ac  e1a0a000          MOV      r10,r0                ;1157
0001b0  e1a00000          MOV      r0,r0                 ;1158
0001b4  e35a0000          CMP      r10,#0                ;1158
0001b8  1a000006          BNE      |L20.472|
0001bc  e1a00000          MOV      r0,r0                 ;1158
0001c0  e28f3fbe          ADR      r3,|L20.1216|
0001c4  e59f2314          LDR      r2,|L20.1248|
0001c8  e28f1fc5          ADR      r1,|L20.1252|
0001cc  e28f0e32          ADR      r0,|L20.1268|
0001d0  ebfffffe          BL       sysprintf
0001d4  e1a00000          MOV      r0,r0                 ;1158
                  |L20.472|
0001d8  e1a00000          MOV      r0,r0                 ;1158
0001dc  ebfffffe          BL       sys_arch_protect
0001e0  e58d000c          STR      r0,[sp,#0xc]          ;1159
0001e4  e59a0014          LDR      r0,[r10,#0x14]        ;1160
0001e8  e2800001          ADD      r0,r0,#1              ;1160
0001ec  e58a0014          STR      r0,[r10,#0x14]        ;1160
0001f0  e1a00000          MOV      r0,r0                 ;1161
0001f4  e59a0014          LDR      r0,[r10,#0x14]        ;1161
0001f8  e3500000          CMP      r0,#0                 ;1161
0001fc  ca000006          BGT      |L20.540|
000200  e1a00000          MOV      r0,r0                 ;1161
000204  e28f3fad          ADR      r3,|L20.1216|
000208  e59f230c          LDR      r2,|L20.1308|
00020c  e28f1fc3          ADR      r1,|L20.1312|
000210  e28f0fb7          ADR      r0,|L20.1268|
000214  ebfffffe          BL       sysprintf
000218  e1a00000          MOV      r0,r0                 ;1161
                  |L20.540|
00021c  e1a00000          MOV      r0,r0                 ;1161
000220  e59d000c          LDR      r0,[sp,#0xc]          ;1162
000224  ebfffffe          BL       sys_arch_unprotect
000228  e1a00000          MOV      r0,r0                 ;1163
                  |L20.556|
00022c  e2844001          ADD      r4,r4,#1              ;1153
                  |L20.560|
000230  e154000b          CMP      r4,r11                ;1153
000234  baffffbc          BLT      |L20.300|
000238  e28d0030          ADD      r0,sp,#0x30           ;1168
00023c  e28d1034          ADD      r1,sp,#0x34           ;1168
000240  e28d2038          ADD      r2,sp,#0x38           ;1168
000244  e1a03007          MOV      r3,r7                 ;1168
000248  e58d2000          STR      r2,[sp,#0]            ;1168
00024c  e1a02006          MOV      r2,r6                 ;1168
000250  e58d1004          STR      r1,[sp,#4]            ;1168
000254  e1a01005          MOV      r1,r5                 ;1168
000258  e58d0008          STR      r0,[sp,#8]            ;1168
00025c  e1a0000b          MOV      r0,r11                ;1168
000260  ebfffffe          BL       lwip_selscan
000264  e58d003c          STR      r0,[sp,#0x3c]         ;1168
000268  e59d003c          LDR      r0,[sp,#0x3c]         ;1169
00026c  e3500000          CMP      r0,#0                 ;1169
000270  1a000012          BNE      |L20.704|
000274  e3580000          CMP      r8,#0                 ;1171
000278  1a000001          BNE      |L20.644|
00027c  e3a09000          MOV      r9,#0                 ;1173
000280  ea00000a          B        |L20.688|
                  |L20.644|
000284  e5981004          LDR      r1,[r8,#4]            ;1175
000288  e2810f7d          ADD      r0,r1,#0x1f4          ;1175
00028c  e3a01ffa          MOV      r1,#0x3e8             ;1175
000290  ebfffffe          BL       __aeabi_idivmod
000294  e5981000          LDR      r1,[r8,#0]            ;1175
000298  e0812081          ADD      r2,r1,r1,LSL #1       ;1175
00029c  e0621381          RSB      r1,r2,r1,LSL #7       ;1175
0002a0  e0809181          ADD      r9,r0,r1,LSL #3       ;1175
0002a4  e3590000          CMP      r9,#0                 ;1176
0002a8  1a000000          BNE      |L20.688|
0002ac  e3a09001          MOV      r9,#1                 ;1178
                  |L20.688|
0002b0  e1a01009          MOV      r1,r9                 ;1182
0002b4  e28d002c          ADD      r0,sp,#0x2c           ;1182
0002b8  ebfffffe          BL       sys_arch_sem_wait
0002bc  e58d0040          STR      r0,[sp,#0x40]         ;1182
                  |L20.704|
0002c0  e3a04000          MOV      r4,#0                 ;1185
0002c4  ea000040          B        |L20.972|
                  |L20.712|
0002c8  e3550000          CMP      r5,#0                 ;1186
0002cc  0a000007          BEQ      |L20.752|
0002d0  e1a03fc4          ASR      r3,r4,#31             ;1186
0002d4  e0843ea3          ADD      r3,r4,r3,LSR #29      ;1186
0002d8  e7d531c3          LDRB     r3,[r5,r3,ASR #3]     ;1186
0002dc  e204c007          AND      r12,r4,#7             ;1186
0002e0  e3a0a001          MOV      r10,#1                ;1186
0002e4  e0033c1a          AND      r3,r3,r10,LSL r12     ;1186
0002e8  e3530000          CMP      r3,#0                 ;1186
0002ec  1a000013          BNE      |L20.832|
                  |L20.752|
0002f0  e3560000          CMP      r6,#0                 ;1187
0002f4  0a000007          BEQ      |L20.792|
0002f8  e1a03fc4          ASR      r3,r4,#31             ;1187
0002fc  e0843ea3          ADD      r3,r4,r3,LSR #29      ;1187
000300  e7d631c3          LDRB     r3,[r6,r3,ASR #3]     ;1187
000304  e204c007          AND      r12,r4,#7             ;1187
000308  e3a0a001          MOV      r10,#1                ;1187
00030c  e0033c1a          AND      r3,r3,r10,LSL r12     ;1187
000310  e3530000          CMP      r3,#0                 ;1187
000314  1a000009          BNE      |L20.832|
                  |L20.792|
000318  e3570000          CMP      r7,#0                 ;1188
00031c  0a000029          BEQ      |L20.968|
000320  e1a03fc4          ASR      r3,r4,#31             ;1188
000324  e0843ea3          ADD      r3,r4,r3,LSR #29      ;1188
000328  e7d731c3          LDRB     r3,[r7,r3,ASR #3]     ;1188
00032c  e204c007          AND      r12,r4,#7             ;1188
000330  e3a0a001          MOV      r10,#1                ;1188
000334  e0033c1a          AND      r3,r3,r10,LSL r12     ;1188
000338  e3530000          CMP      r3,#0                 ;1188
00033c  0a000021          BEQ      |L20.968|
                  |L20.832|
000340  e1a00004          MOV      r0,r4                 ;1189
000344  ebfffffe          BL       tryget_socket
000348  e1a0a000          MOV      r10,r0                ;1189
00034c  e1a00000          MOV      r0,r0                 ;1190
000350  e35a0000          CMP      r10,#0                ;1190
000354  1a000006          BNE      |L20.884|
000358  e1a00000          MOV      r0,r0                 ;1190
00035c  e28f3f57          ADR      r3,|L20.1216|
000360  e59f21d4          LDR      r2,|L20.1340|
000364  e28f1f5e          ADR      r1,|L20.1252|
000368  e28f0f61          ADR      r0,|L20.1268|
00036c  ebfffffe          BL       sysprintf
000370  e1a00000          MOV      r0,r0                 ;1190
                  |L20.884|
000374  e1a00000          MOV      r0,r0                 ;1190
000378  ebfffffe          BL       sys_arch_protect
00037c  e58d000c          STR      r0,[sp,#0xc]          ;1191
000380  e59a0014          LDR      r0,[r10,#0x14]        ;1192
000384  e2400001          SUB      r0,r0,#1              ;1192
000388  e58a0014          STR      r0,[r10,#0x14]        ;1192
00038c  e1a00000          MOV      r0,r0                 ;1193
000390  e59a0014          LDR      r0,[r10,#0x14]        ;1193
000394  e3500000          CMP      r0,#0                 ;1193
000398  aa000006          BGE      |L20.952|
00039c  e1a00000          MOV      r0,r0                 ;1193
0003a0  e28f3f46          ADR      r3,|L20.1216|
0003a4  e59f2194          LDR      r2,|L20.1344|
0003a8  e28f1f65          ADR      r1,|L20.1348|
0003ac  e28f0d05          ADR      r0,|L20.1268|
0003b0  ebfffffe          BL       sysprintf
0003b4  e1a00000          MOV      r0,r0                 ;1193
                  |L20.952|
0003b8  e1a00000          MOV      r0,r0                 ;1193
0003bc  e59d000c          LDR      r0,[sp,#0xc]          ;1194
0003c0  ebfffffe          BL       sys_arch_unprotect
0003c4  e1a00000          MOV      r0,r0                 ;1195
                  |L20.968|
0003c8  e2844001          ADD      r4,r4,#1              ;1185
                  |L20.972|
0003cc  e154000b          CMP      r4,r11                ;1185
0003d0  baffffbc          BLT      |L20.712|
0003d4  ebfffffe          BL       sys_arch_protect
0003d8  e58d000c          STR      r0,[sp,#0xc]          ;1198
0003dc  e59d0014          LDR      r0,[sp,#0x14]         ;1199
0003e0  e3500000          CMP      r0,#0                 ;1199
0003e4  0a000002          BEQ      |L20.1012|
0003e8  e59d0018          LDR      r0,[sp,#0x18]         ;1200
0003ec  e59d1014          LDR      r1,[sp,#0x14]         ;1200
0003f0  e5810004          STR      r0,[r1,#4]            ;1200
                  |L20.1012|
0003f4  e59f00bc          LDR      r0,|L20.1208|
0003f8  e5900000          LDR      r0,[r0,#0]            ;1202  ; select_cb_list
0003fc  e28d1014          ADD      r1,sp,#0x14           ;1202
000400  e1500001          CMP      r0,r1                 ;1202
000404  1a00000f          BNE      |L20.1096|
000408  e1a00000          MOV      r0,r0                 ;1203
00040c  e59d0018          LDR      r0,[sp,#0x18]         ;1203
000410  e3500000          CMP      r0,#0                 ;1203
000414  0a000006          BEQ      |L20.1076|
000418  e1a00000          MOV      r0,r0                 ;1203
00041c  e28f309c          ADR      r3,|L20.1216|
000420  e59f2138          LDR      r2,|L20.1376|
000424  e28f1f4e          ADR      r1,|L20.1380|
000428  e28f00c4          ADR      r0,|L20.1268|
00042c  ebfffffe          BL       sysprintf
000430  e1a00000          MOV      r0,r0                 ;1203
                  |L20.1076|
000434  e1a00000          MOV      r0,r0                 ;1203
000438  e59f1078          LDR      r1,|L20.1208|
00043c  e59d0014          LDR      r0,[sp,#0x14]         ;1204
000440  e5810000          STR      r0,[r1,#0]            ;1204  ; select_cb_list
000444  ea00000e          B        |L20.1156|
                  |L20.1096|
000448  e1a00000          MOV      r0,r0                 ;1206
00044c  e59d0018          LDR      r0,[sp,#0x18]         ;1206
000450  e3500000          CMP      r0,#0                 ;1206
000454  1a000006          BNE      |L20.1140|
000458  e1a00000          MOV      r0,r0                 ;1206
00045c  e28f305c          ADR      r3,|L20.1216|
000460  e59f2114          LDR      r2,|L20.1404|
000464  e28f1f45          ADR      r1,|L20.1408|
000468  e28f0084          ADR      r0,|L20.1268|
00046c  ebfffffe          BL       sysprintf
000470  e1a00000          MOV      r0,r0                 ;1206
                  |L20.1140|
000474  e1a00000          MOV      r0,r0                 ;1206
000478  e59d0014          LDR      r0,[sp,#0x14]         ;1207
00047c  e59d1018          LDR      r1,[sp,#0x18]         ;1207
000480  e5810000          STR      r0,[r1,#0]            ;1207
                  |L20.1156|
000484  e59f0030          LDR      r0,|L20.1212|
000488  e5900000          LDR      r0,[r0,#0]            ;1210  ; select_cb_ctr
00048c  e2800001          ADD      r0,r0,#1              ;1210
000490  e59f1024          LDR      r1,|L20.1212|
000494  e5810000          STR      r0,[r1,#0]            ;1210  ; select_cb_ctr
000498  e59d000c          LDR      r0,[sp,#0xc]          ;1211
00049c  ebfffffe          BL       sys_arch_unprotect
0004a0  e28d002c          ADD      r0,sp,#0x2c           ;1213
0004a4  ebfffffe          BL       sys_sem_free
0004a8  e59d0040          LDR      r0,[sp,#0x40]         ;1214
0004ac  e3700001          CMN      r0,#1                 ;1214
0004b0  1a000038          BNE      |L20.1432|
0004b4  ea000044          B        |L20.1484|
                  |L20.1208|
                          DCD      select_cb_list
                  |L20.1212|
                          DCD      select_cb_ctr
                  |L20.1216|
0004c0  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
0004c4  2d312e34
0004c8  2e315c73
0004cc  72635c61
0004d0  70695c73
0004d4  6f636b65
0004d8  74732e63
0004dc  00      
0004dd  00                DCB      0
0004de  00                DCB      0
0004df  00                DCB      0
                  |L20.1248|
                          DCD      0x00000486
                  |L20.1252|
0004e4  736f636b          DCB      "sock != NULL",0
0004e8  20213d20
0004ec  4e554c4c
0004f0  00      
0004f1  00                DCB      0
0004f2  00                DCB      0
0004f3  00                DCB      0
                  |L20.1268|
0004f4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0004f8  7274696f
0004fc  6e202225
000500  73222066
000504  61696c65
000508  64206174
00050c  206c696e
000510  65202564
000514  20696e20
000518  25730a00
                  |L20.1308|
                          DCD      0x00000489
                  |L20.1312|
000520  736f636b          DCB      "sock->select_waiting > 0",0
000524  2d3e7365
000528  6c656374
00052c  5f776169
000530  74696e67
000534  203e2030
000538  00      
000539  00                DCB      0
00053a  00                DCB      0
00053b  00                DCB      0
                  |L20.1340|
                          DCD      0x000004a6
                  |L20.1344|
                          DCD      0x000004a9
                  |L20.1348|
000544  736f636b          DCB      "sock->select_waiting >= 0",0
000548  2d3e7365
00054c  6c656374
000550  5f776169
000554  74696e67
000558  203e3d20
00055c  3000    
00055e  00                DCB      0
00055f  00                DCB      0
                  |L20.1376|
                          DCD      0x000004b3
                  |L20.1380|
000564  73656c65          DCB      "select_cb.prev == NULL",0
000568  63745f63
00056c  622e7072
000570  6576203d
000574  3d204e55
000578  4c4c00  
00057b  00                DCB      0
                  |L20.1404|
                          DCD      0x000004b6
                  |L20.1408|
000580  73656c65          DCB      "select_cb.prev != NULL",0
000584  63745f63
000588  622e7072
00058c  65762021
000590  3d204e55
000594  4c4c00  
000597  00                DCB      0
                  |L20.1432|
000598  e28d0030          ADD      r0,sp,#0x30           ;1223
00059c  e28d1034          ADD      r1,sp,#0x34           ;1223
0005a0  e28d2038          ADD      r2,sp,#0x38           ;1223
0005a4  e1a03007          MOV      r3,r7                 ;1223
0005a8  e58d2000          STR      r2,[sp,#0]            ;1223
0005ac  e1a02006          MOV      r2,r6                 ;1223
0005b0  e58d1004          STR      r1,[sp,#4]            ;1223
0005b4  e1a01005          MOV      r1,r5                 ;1223
0005b8  e58d0008          STR      r0,[sp,#8]            ;1223
0005bc  e1a0000b          MOV      r0,r11                ;1223
0005c0  ebfffffe          BL       lwip_selscan
0005c4  e58d003c          STR      r0,[sp,#0x3c]         ;1223
                  |L20.1480|
0005c8  e1a00000          MOV      r0,r0                 ;1227
                  |L20.1484|
0005cc  e3550000          CMP      r5,#0                 ;1229
0005d0  0a000001          BEQ      |L20.1500|
0005d4  e5dd0038          LDRB     r0,[sp,#0x38]         ;1230
0005d8  e5c50000          STRB     r0,[r5,#0]            ;1230
                  |L20.1500|
0005dc  e3560000          CMP      r6,#0                 ;1232
0005e0  0a000001          BEQ      |L20.1516|
0005e4  e5dd0034          LDRB     r0,[sp,#0x34]         ;1233
0005e8  e5c60000          STRB     r0,[r6,#0]            ;1233
                  |L20.1516|
0005ec  e3570000          CMP      r7,#0                 ;1235
0005f0  0a000001          BEQ      |L20.1532|
0005f4  e5dd0030          LDRB     r0,[sp,#0x30]         ;1236
0005f8  e5c70000          STRB     r0,[r7,#0]            ;1236
                  |L20.1532|
0005fc  e59d003c          LDR      r0,[sp,#0x3c]         ;1240
000600  eafffeae          B        |L20.192|
;;;1242   
                          ENDP


                          AREA ||i.lwip_selscan||, CODE, READONLY, ALIGN=2

                  lwip_selscan PROC
;;;1026   static int
;;;1027   lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1028                fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
;;;1029   {
000004  e24dd01c          SUB      sp,sp,#0x1c
000008  e1a0a000          MOV      r10,r0
00000c  e1a07001          MOV      r7,r1
000010  e1a08002          MOV      r8,r2
000014  e1a09003          MOV      r9,r3
;;;1030     int i, nready = 0;
000018  e3a06000          MOV      r6,#0
;;;1031     fd_set lreadset, lwriteset, lexceptset;
;;;1032     struct lwip_sock *sock;
;;;1033     SYS_ARCH_DECL_PROTECT(lev);
;;;1034   
;;;1035     FD_ZERO(&lreadset);
00001c  e3a00000          MOV      r0,#0
000020  e58d0018          STR      r0,[sp,#0x18]
;;;1036     FD_ZERO(&lwriteset);
000024  e58d0014          STR      r0,[sp,#0x14]
;;;1037     FD_ZERO(&lexceptset);
000028  e58d0010          STR      r0,[sp,#0x10]
;;;1038   
;;;1039     /* Go through each socket in each list to count number of sockets which
;;;1040        currently match */
;;;1041     for(i = 0; i < maxfdp1; i++) {
00002c  e3a04000          MOV      r4,#0
000030  ea000063          B        |L21.452|
                  |L21.52|
;;;1042       void* lastdata = NULL;
000034  e3a0b000          MOV      r11,#0
;;;1043       s16_t rcvevent = 0;
000038  e3a00000          MOV      r0,#0
00003c  e58d0008          STR      r0,[sp,#8]
;;;1044       u16_t sendevent = 0;
000040  e58d0004          STR      r0,[sp,#4]
;;;1045       u16_t errevent = 0;
000044  e58d0000          STR      r0,[sp,#0]
;;;1046       /* First get the socket's status (protected)... */
;;;1047       SYS_ARCH_PROTECT(lev);
000048  ebfffffe          BL       sys_arch_protect
00004c  e58d000c          STR      r0,[sp,#0xc]
;;;1048       sock = tryget_socket(i);
000050  e1a00004          MOV      r0,r4
000054  ebfffffe          BL       tryget_socket
000058  e1a05000          MOV      r5,r0
;;;1049       if (sock != NULL) {
00005c  e3550000          CMP      r5,#0
000060  0a000006          BEQ      |L21.128|
;;;1050         lastdata = sock->lastdata;
000064  e595b004          LDR      r11,[r5,#4]
;;;1051         rcvevent = sock->rcvevent;
000068  e1d500fa          LDRSH    r0,[r5,#0xa]
00006c  e58d0008          STR      r0,[sp,#8]
;;;1052         sendevent = sock->sendevent;
000070  e1d500bc          LDRH     r0,[r5,#0xc]
000074  e58d0004          STR      r0,[sp,#4]
;;;1053         errevent = sock->errevent;
000078  e1d500be          LDRH     r0,[r5,#0xe]
00007c  e58d0000          STR      r0,[sp,#0]
                  |L21.128|
;;;1054       }
;;;1055       SYS_ARCH_UNPROTECT(lev);
000080  e59d000c          LDR      r0,[sp,#0xc]
000084  ebfffffe          BL       sys_arch_unprotect
;;;1056       /* ... then examine it: */
;;;1057       /* See if netconn of this socket is ready for read */
;;;1058       if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
000088  e3570000          CMP      r7,#0
00008c  0a000019          BEQ      |L21.248|
000090  e1a01fc4          ASR      r1,r4,#31
000094  e0841ea1          ADD      r1,r4,r1,LSR #29
000098  e7d711c1          LDRB     r1,[r7,r1,ASR #3]
00009c  e2042007          AND      r2,r4,#7
0000a0  e3a03001          MOV      r3,#1
0000a4  e0011213          AND      r1,r1,r3,LSL r2
0000a8  e3510000          CMP      r1,#0
0000ac  0a000011          BEQ      |L21.248|
0000b0  e35b0000          CMP      r11,#0
0000b4  1a000002          BNE      |L21.196|
0000b8  e59d1008          LDR      r1,[sp,#8]
0000bc  e3510000          CMP      r1,#0
0000c0  da00000c          BLE      |L21.248|
                  |L21.196|
;;;1059         FD_SET(i, &lreadset);
0000c4  e1a01fc4          ASR      r1,r4,#31
0000c8  e0841ea1          ADD      r1,r4,r1,LSR #29
0000cc  e28d2018          ADD      r2,sp,#0x18
0000d0  e7d211c1          LDRB     r1,[r2,r1,ASR #3]
0000d4  e2042007          AND      r2,r4,#7
0000d8  e3a03001          MOV      r3,#1
0000dc  e1811213          ORR      r1,r1,r3,LSL r2
0000e0  e1a00004          MOV      r0,r4
0000e4  e1a02fc4          ASR      r2,r4,#31
0000e8  e0842ea2          ADD      r2,r4,r2,LSR #29
0000ec  e28d3018          ADD      r3,sp,#0x18
0000f0  e7c311c2          STRB     r1,[r3,r2,ASR #3]
;;;1060         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
;;;1061         nready++;
0000f4  e2866001          ADD      r6,r6,#1
                  |L21.248|
;;;1062       }
;;;1063       /* See if netconn of this socket is ready for write */
;;;1064       if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
0000f8  e3580000          CMP      r8,#0
0000fc  0a000016          BEQ      |L21.348|
000100  e1a01fc4          ASR      r1,r4,#31
000104  e0841ea1          ADD      r1,r4,r1,LSR #29
000108  e7d811c1          LDRB     r1,[r8,r1,ASR #3]
00010c  e2042007          AND      r2,r4,#7
000110  e3a03001          MOV      r3,#1
000114  e0011213          AND      r1,r1,r3,LSL r2
000118  e3510000          CMP      r1,#0
00011c  0a00000e          BEQ      |L21.348|
000120  e59d1004          LDR      r1,[sp,#4]
000124  e3510000          CMP      r1,#0
000128  0a00000b          BEQ      |L21.348|
;;;1065         FD_SET(i, &lwriteset);
00012c  e1a01fc4          ASR      r1,r4,#31
000130  e0841ea1          ADD      r1,r4,r1,LSR #29
000134  e28d2014          ADD      r2,sp,#0x14
000138  e7d211c1          LDRB     r1,[r2,r1,ASR #3]
00013c  e2042007          AND      r2,r4,#7
000140  e1811213          ORR      r1,r1,r3,LSL r2
000144  e1a00004          MOV      r0,r4
000148  e1a02fc4          ASR      r2,r4,#31
00014c  e0842ea2          ADD      r2,r4,r2,LSR #29
000150  e28d3014          ADD      r3,sp,#0x14
000154  e7c311c2          STRB     r1,[r3,r2,ASR #3]
;;;1066         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
;;;1067         nready++;
000158  e2866001          ADD      r6,r6,#1
                  |L21.348|
;;;1068       }
;;;1069       /* See if netconn of this socket had an error */
;;;1070       if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
00015c  e3590000          CMP      r9,#0
000160  0a000016          BEQ      |L21.448|
000164  e1a01fc4          ASR      r1,r4,#31
000168  e0841ea1          ADD      r1,r4,r1,LSR #29
00016c  e7d911c1          LDRB     r1,[r9,r1,ASR #3]
000170  e2042007          AND      r2,r4,#7
000174  e3a03001          MOV      r3,#1
000178  e0011213          AND      r1,r1,r3,LSL r2
00017c  e3510000          CMP      r1,#0
000180  0a00000e          BEQ      |L21.448|
000184  e59d1000          LDR      r1,[sp,#0]
000188  e3510000          CMP      r1,#0
00018c  0a00000b          BEQ      |L21.448|
;;;1071         FD_SET(i, &lexceptset);
000190  e1a01fc4          ASR      r1,r4,#31
000194  e0841ea1          ADD      r1,r4,r1,LSR #29
000198  e28d2010          ADD      r2,sp,#0x10
00019c  e7d211c1          LDRB     r1,[r2,r1,ASR #3]
0001a0  e2042007          AND      r2,r4,#7
0001a4  e1811213          ORR      r1,r1,r3,LSL r2
0001a8  e1a00004          MOV      r0,r4
0001ac  e1a02fc4          ASR      r2,r4,#31
0001b0  e0842ea2          ADD      r2,r4,r2,LSR #29
0001b4  e28d3010          ADD      r3,sp,#0x10
0001b8  e7c311c2          STRB     r1,[r3,r2,ASR #3]
;;;1072         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
;;;1073         nready++;
0001bc  e2866001          ADD      r6,r6,#1
                  |L21.448|
0001c0  e2844001          ADD      r4,r4,#1              ;1041
                  |L21.452|
0001c4  e154000a          CMP      r4,r10                ;1041
0001c8  baffff99          BLT      |L21.52|
;;;1074       }
;;;1075     }
;;;1076     /* copy local sets to the ones provided as arguments */
;;;1077     *readset_out = lreadset;
0001cc  e59d0040          LDR      r0,[sp,#0x40]
0001d0  e5dd1018          LDRB     r1,[sp,#0x18]
0001d4  e5c01000          STRB     r1,[r0,#0]
;;;1078     *writeset_out = lwriteset;
0001d8  e59d0044          LDR      r0,[sp,#0x44]
0001dc  e5dd1014          LDRB     r1,[sp,#0x14]
0001e0  e5c01000          STRB     r1,[r0,#0]
;;;1079     *exceptset_out = lexceptset;
0001e4  e59d0048          LDR      r0,[sp,#0x48]
0001e8  e5dd1010          LDRB     r1,[sp,#0x10]
0001ec  e5c01000          STRB     r1,[r0,#0]
;;;1080   
;;;1081     LWIP_ASSERT("nready >= 0", nready >= 0);
0001f0  e1a00000          MOV      r0,r0
0001f4  e3560000          CMP      r6,#0
0001f8  aa000006          BGE      |L21.536|
0001fc  e1a00000          MOV      r0,r0
000200  e28f3020          ADR      r3,|L21.552|
000204  e59f203c          LDR      r2,|L21.584|
000208  e28f103c          ADR      r1,|L21.588|
00020c  e28f0044          ADR      r0,|L21.600|
000210  ebfffffe          BL       sysprintf
000214  e1a00000          MOV      r0,r0
                  |L21.536|
000218  e1a00000          MOV      r0,r0
;;;1082     return nready;
00021c  e1a00006          MOV      r0,r6
000220  e28dd01c          ADD      sp,sp,#0x1c
;;;1083   }
000224  e8bd8ff0          POP      {r4-r11,pc}
;;;1084   
                          ENDP

                  |L21.552|
000228  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
00022c  2d312e34
000230  2e315c73
000234  72635c61
000238  70695c73
00023c  6f636b65
000240  74732e63
000244  00      
000245  00                DCB      0
000246  00                DCB      0
000247  00                DCB      0
                  |L21.584|
                          DCD      0x00000439
                  |L21.588|
00024c  6e726561          DCB      "nready >= 0",0
000250  6479203e
000254  3d203000
                  |L21.600|
000258  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00025c  7274696f
000260  6e202225
000264  73222066
000268  61696c65
00026c  64206174
000270  206c696e
000274  65202564
000278  20696e20
00027c  25730a00

                          AREA ||i.lwip_send||, CODE, READONLY, ALIGN=2

                  lwip_send PROC
;;;754    int
;;;755    lwip_send(int s, const void *data, size_t size, int flags)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;756    {
000004  e1a08000          MOV      r8,r0
000008  e1a09001          MOV      r9,r1
00000c  e1a0a002          MOV      r10,r2
000010  e1a06003          MOV      r6,r3
;;;757      struct lwip_sock *sock;
;;;758      err_t err;
;;;759      u8_t write_flags;
;;;760      size_t written;
;;;761    
;;;762      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
;;;763                                  s, data, size, flags));
;;;764    
;;;765      sock = get_socket(s);
000014  e1a00008          MOV      r0,r8
000018  ebfffffe          BL       get_socket
00001c  e1a05000          MOV      r5,r0
;;;766      if (!sock) {
000020  e3550000          CMP      r5,#0
000024  1a000001          BNE      |L22.48|
;;;767        return -1;
000028  e3e00000          MVN      r0,#0
                  |L22.44|
;;;768      }
;;;769    
;;;770      if (sock->conn->type != NETCONN_TCP) {
;;;771    #if (LWIP_UDP || LWIP_RAW)
;;;772        return lwip_sendto(s, data, size, flags, NULL, 0);
;;;773    #else /* (LWIP_UDP || LWIP_RAW) */
;;;774        sock_set_errno(sock, err_to_errno(ERR_ARG));
;;;775        return -1;
;;;776    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;777      }
;;;778    
;;;779      write_flags = NETCONN_COPY |
;;;780        ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
;;;781        ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
;;;782      written = 0;
;;;783      err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
;;;784    
;;;785      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
;;;786      sock_set_errno(sock, err_to_errno(err));
;;;787      return (err == ERR_OK ? (int)written : -1);
;;;788    }
00002c  e8bd8ffe          POP      {r1-r11,pc}
                  |L22.48|
000030  e5950000          LDR      r0,[r5,#0]            ;770
000034  e5d00000          LDRB     r0,[r0,#0]            ;770
000038  e3500010          CMP      r0,#0x10              ;770
00003c  0a000008          BEQ      |L22.100|
000040  e3a00000          MOV      r0,#0                 ;772
000044  e58d0000          STR      r0,[sp,#0]            ;772
000048  e1a03006          MOV      r3,r6                 ;772
00004c  e1a0200a          MOV      r2,r10                ;772
000050  e1a01009          MOV      r1,r9                 ;772
000054  e58d0004          STR      r0,[sp,#4]            ;772
000058  e1a00008          MOV      r0,r8                 ;772
00005c  ebfffffe          BL       lwip_sendto
000060  eafffff1          B        |L22.44|
                  |L22.100|
000064  e2060010          AND      r0,r6,#0x10           ;779
000068  e3500000          CMP      r0,#0                 ;779
00006c  0a000001          BEQ      |L22.120|
000070  e3a00002          MOV      r0,#2                 ;780
000074  ea000000          B        |L22.124|
                  |L22.120|
000078  e3a00000          MOV      r0,#0                 ;780
                  |L22.124|
00007c  e3800001          ORR      r0,r0,#1              ;780
000080  e2061008          AND      r1,r6,#8              ;780
000084  e3510000          CMP      r1,#0                 ;780
000088  0a000001          BEQ      |L22.148|
00008c  e3a01004          MOV      r1,#4                 ;781
000090  ea000000          B        |L22.152|
                  |L22.148|
000094  e3a01000          MOV      r1,#0                 ;781
                  |L22.152|
000098  e1807001          ORR      r7,r0,r1              ;781
00009c  e3a00000          MOV      r0,#0                 ;782
0000a0  e58d0008          STR      r0,[sp,#8]            ;782
0000a4  e28d0008          ADD      r0,sp,#8              ;783
0000a8  e58d0000          STR      r0,[sp,#0]            ;783
0000ac  e1a03007          MOV      r3,r7                 ;783
0000b0  e1a0200a          MOV      r2,r10                ;783
0000b4  e1a01009          MOV      r1,r9                 ;783
0000b8  e5950000          LDR      r0,[r5,#0]            ;783
0000bc  ebfffffe          BL       netconn_write_partly
0000c0  e1a04000          MOV      r4,r0                 ;783
0000c4  e1a00000          MOV      r0,r0                 ;786
0000c8  e2640000          RSB      r0,r4,#0              ;786
0000cc  e3500010          CMP      r0,#0x10              ;786
0000d0  2a000003          BCS      |L22.228|
0000d4  e59f002c          LDR      r0,|L22.264|
0000d8  e2641000          RSB      r1,r4,#0              ;786
0000dc  e7900101          LDR      r0,[r0,r1,LSL #2]     ;786
0000e0  ea000000          B        |L22.232|
                  |L22.228|
0000e4  e3a00005          MOV      r0,#5                 ;786
                  |L22.232|
0000e8  e5850010          STR      r0,[r5,#0x10]         ;786
0000ec  e1a00000          MOV      r0,r0                 ;786
0000f0  e3540000          CMP      r4,#0                 ;787
0000f4  1a000001          BNE      |L22.256|
0000f8  e59d0008          LDR      r0,[sp,#8]            ;787
0000fc  eaffffca          B        |L22.44|
                  |L22.256|
000100  e3e00000          MVN      r0,#0                 ;787
000104  eaffffc8          B        |L22.44|
;;;789    
                          ENDP

                  |L22.264|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_sendto||, CODE, READONLY, ALIGN=2

                  lwip_sendto PROC
;;;790    int
;;;791    lwip_sendto(int s, const void *data, size_t size, int flags,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;792           const struct sockaddr *to, socklen_t tolen)
;;;793    {
000004  e24dd014          SUB      sp,sp,#0x14
000008  e1a09002          MOV      r9,r2
00000c  e59d5048          LDR      r5,[sp,#0x48]
000010  e59da04c          LDR      r10,[sp,#0x4c]
;;;794      struct lwip_sock *sock;
;;;795      err_t err;
;;;796      u16_t short_size;
;;;797      const struct sockaddr_in *to_in;
;;;798      u16_t remote_port;
;;;799    #if !LWIP_TCPIP_CORE_LOCKING
;;;800      struct netbuf buf;
;;;801    #endif
;;;802    
;;;803      sock = get_socket(s);
000014  e59d0014          LDR      r0,[sp,#0x14]
000018  ebfffffe          BL       get_socket
00001c  e1a06000          MOV      r6,r0
;;;804      if (!sock) {
000020  e3560000          CMP      r6,#0
000024  1a000002          BNE      |L23.52|
;;;805        return -1;
000028  e3e00000          MVN      r0,#0
                  |L23.44|
00002c  e28dd024          ADD      sp,sp,#0x24
;;;806      }
;;;807    
;;;808      if (sock->conn->type == NETCONN_TCP) {
;;;809    #if LWIP_TCP
;;;810        return lwip_send(s, data, size, flags);
;;;811    #else /* LWIP_TCP */
;;;812        LWIP_UNUSED_ARG(flags);
;;;813        sock_set_errno(sock, err_to_errno(ERR_ARG));
;;;814        return -1;
;;;815    #endif /* LWIP_TCP */
;;;816      }
;;;817    
;;;818      /* @todo: split into multiple sendto's? */
;;;819      LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
;;;820      short_size = (u16_t)size;
;;;821      LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
;;;822                 ((tolen == sizeof(struct sockaddr_in)) &&
;;;823                 ((to->sa_family) == AF_INET) && ((((mem_ptr_t)to) % 4) == 0))),
;;;824                 sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
;;;825      to_in = (const struct sockaddr_in *)(void*)to;
;;;826    
;;;827    #if LWIP_TCPIP_CORE_LOCKING
;;;828      /* Should only be consider like a sample or a simple way to experiment this option (no check of "to" field...) */
;;;829      {
;;;830        struct pbuf* p;
;;;831        ip_addr_t *remote_addr;
;;;832    
;;;833    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;834        p = pbuf_alloc(PBUF_TRANSPORT, short_size, PBUF_RAM);
;;;835        if (p != NULL) {
;;;836    #if LWIP_CHECKSUM_ON_COPY
;;;837          u16_t chksum = 0;
;;;838          if (sock->conn->type != NETCONN_RAW) {
;;;839            chksum = LWIP_CHKSUM_COPY(p->payload, data, short_size);
;;;840          } else
;;;841    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;842          MEMCPY(p->payload, data, size);
;;;843    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;844        p = pbuf_alloc(PBUF_TRANSPORT, short_size, PBUF_REF);
;;;845        if (p != NULL) {
;;;846          p->payload = (void*)data;
;;;847    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;848    
;;;849          if (to_in != NULL) {
;;;850            inet_addr_to_ipaddr_p(remote_addr, &to_in->sin_addr);
;;;851            remote_port = ntohs(to_in->sin_port);
;;;852          } else {
;;;853            remote_addr = &sock->conn->pcb.ip->remote_ip;
;;;854    #if LWIP_UDP
;;;855            if (NETCONNTYPE_GROUP(sock->conn->type) == NETCONN_UDP) {
;;;856              remote_port = sock->conn->pcb.udp->remote_port;
;;;857            } else
;;;858    #endif /* LWIP_UDP */
;;;859            {
;;;860              remote_port = 0;
;;;861            }
;;;862          }
;;;863    
;;;864          LOCK_TCPIP_CORE();
;;;865          if (netconn_type(sock->conn) == NETCONN_RAW) {
;;;866    #if LWIP_RAW
;;;867            err = sock->conn->last_err = raw_sendto(sock->conn->pcb.raw, p, remote_addr);
;;;868    #else /* LWIP_RAW */
;;;869            err = ERR_ARG;
;;;870    #endif /* LWIP_RAW */
;;;871          }
;;;872    #if LWIP_UDP && LWIP_RAW
;;;873          else
;;;874    #endif /* LWIP_UDP && LWIP_RAW */
;;;875          {
;;;876    #if LWIP_UDP
;;;877    #if LWIP_CHECKSUM_ON_COPY && LWIP_NETIF_TX_SINGLE_PBUF
;;;878            err = sock->conn->last_err = udp_sendto_chksum(sock->conn->pcb.udp, p,
;;;879              remote_addr, remote_port, 1, chksum);
;;;880    #else /* LWIP_CHECKSUM_ON_COPY && LWIP_NETIF_TX_SINGLE_PBUF */
;;;881            err = sock->conn->last_err = udp_sendto(sock->conn->pcb.udp, p,
;;;882              remote_addr, remote_port);
;;;883    #endif /* LWIP_CHECKSUM_ON_COPY && LWIP_NETIF_TX_SINGLE_PBUF */
;;;884    #else /* LWIP_UDP */
;;;885            err = ERR_ARG;
;;;886    #endif /* LWIP_UDP */
;;;887          }
;;;888          UNLOCK_TCPIP_CORE();
;;;889          
;;;890          pbuf_free(p);
;;;891        } else {
;;;892          err = ERR_MEM;
;;;893        }
;;;894      }
;;;895    #else /* LWIP_TCPIP_CORE_LOCKING */
;;;896      /* initialize a buffer */
;;;897      buf.p = buf.ptr = NULL;
;;;898    #if LWIP_CHECKSUM_ON_COPY
;;;899      buf.flags = 0;
;;;900    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;901      if (to) {
;;;902        inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
;;;903        remote_port           = ntohs(to_in->sin_port);
;;;904        netbuf_fromport(&buf) = remote_port;
;;;905      } else {
;;;906        remote_port           = 0;
;;;907        ip_addr_set_any(&buf.addr);
;;;908        netbuf_fromport(&buf) = 0;
;;;909      }
;;;910    
;;;911      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_sendto(%d, data=%p, short_size=%"U16_F", flags=0x%x to=",
;;;912                  s, data, short_size, flags));
;;;913      ip_addr_debug_print(SOCKETS_DEBUG, &buf.addr);
;;;914      LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", remote_port));
;;;915    
;;;916      /* make the buffer point to the data that should be sent */
;;;917    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;918      /* Allocate a new netbuf and copy the data into it. */
;;;919      if (netbuf_alloc(&buf, short_size) == NULL) {
;;;920        err = ERR_MEM;
;;;921      } else {
;;;922    #if LWIP_CHECKSUM_ON_COPY
;;;923        if (sock->conn->type != NETCONN_RAW) {
;;;924          u16_t chksum = LWIP_CHKSUM_COPY(buf.p->payload, data, short_size);
;;;925          netbuf_set_chksum(&buf, chksum);
;;;926          err = ERR_OK;
;;;927        } else
;;;928    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;929        {
;;;930          err = netbuf_take(&buf, data, short_size);
;;;931        }
;;;932      }
;;;933    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;934      err = netbuf_ref(&buf, data, short_size);
;;;935    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;936      if (err == ERR_OK) {
;;;937        /* send the data */
;;;938        err = netconn_send(sock->conn, &buf);
;;;939      }
;;;940    
;;;941      /* deallocated the buffer */
;;;942      netbuf_free(&buf);
;;;943    #endif /* LWIP_TCPIP_CORE_LOCKING */
;;;944      sock_set_errno(sock, err_to_errno(err));
;;;945      return (err == ERR_OK ? short_size : -1);
;;;946    }
000030  e8bd8ff0          POP      {r4-r11,pc}
                  |L23.52|
000034  e5960000          LDR      r0,[r6,#0]            ;808
000038  e5d00000          LDRB     r0,[r0,#0]            ;808
00003c  e3500010          CMP      r0,#0x10              ;808
000040  1a000005          BNE      |L23.92|
000044  e1a02009          MOV      r2,r9                 ;810
000048  e59d0014          LDR      r0,[sp,#0x14]         ;810
00004c  e59d1018          LDR      r1,[sp,#0x18]         ;810
000050  e59d3020          LDR      r3,[sp,#0x20]         ;810
000054  ebfffffe          BL       lwip_send
000058  eafffff3          B        |L23.44|
                  |L23.92|
00005c  e1a00000          MOV      r0,r0                 ;819
000060  e3590801          CMP      r9,#0x10000           ;819
000064  3a000006          BCC      |L23.132|
000068  e1a00000          MOV      r0,r0                 ;819
00006c  e28f3f52          ADR      r3,|L23.444|
000070  e59f2164          LDR      r2,|L23.476|
000074  e28f1f59          ADR      r1,|L23.480|
000078  e28f0f61          ADR      r0,|L23.516|
00007c  ebfffffe          BL       sysprintf
000080  e1a00000          MOV      r0,r0                 ;819
                  |L23.132|
000084  e1a00000          MOV      r0,r0                 ;819
000088  e1a0b809          LSL      r11,r9,#16            ;820
00008c  e1a0b82b          LSR      r11,r11,#16           ;820
000090  e1a00000          MOV      r0,r0                 ;821
000094  e3550000          CMP      r5,#0                 ;821
000098  1a000001          BNE      |L23.164|
00009c  e35a0000          CMP      r10,#0                ;821
0000a0  0a000015          BEQ      |L23.252|
                  |L23.164|
0000a4  e35a0010          CMP      r10,#0x10             ;821
0000a8  1a000005          BNE      |L23.196|
0000ac  e5d50001          LDRB     r0,[r5,#1]            ;821
0000b0  e3500002          CMP      r0,#2                 ;821
0000b4  1a000002          BNE      |L23.196|
0000b8  e2050003          AND      r0,r5,#3              ;821
0000bc  e3500000          CMP      r0,#0                 ;821
0000c0  0a00000d          BEQ      |L23.252|
                  |L23.196|
0000c4  e1a00000          MOV      r0,r0                 ;821
0000c8  e28f30ec          ADR      r3,|L23.444|
0000cc  e59f2158          LDR      r2,|L23.556|
0000d0  e28f1f56          ADR      r1,|L23.560|
0000d4  e28f0f4a          ADR      r0,|L23.516|
0000d8  ebfffffe          BL       sysprintf
0000dc  e1a00000          MOV      r0,r0                 ;821
0000e0  e1a00000          MOV      r0,r0                 ;821
0000e4  e59f0164          LDR      r0,|L23.592|
0000e8  e5900038          LDR      r0,[r0,#0x38]         ;821  ; err_to_errno_table
0000ec  e5860010          STR      r0,[r6,#0x10]         ;821
0000f0  e1a00000          MOV      r0,r0                 ;821
0000f4  e3e00000          MVN      r0,#0                 ;821
0000f8  eaffffcb          B        |L23.44|
                  |L23.252|
0000fc  e1a00000          MOV      r0,r0                 ;821
000100  e1a07005          MOV      r7,r5                 ;825
000104  e3a00000          MOV      r0,#0                 ;897
000108  e58d0008          STR      r0,[sp,#8]            ;897
00010c  e58d0004          STR      r0,[sp,#4]            ;897
000110  e3550000          CMP      r5,#0                 ;901
000114  0a000006          BEQ      |L23.308|
000118  e5970004          LDR      r0,[r7,#4]            ;902
00011c  e58d000c          STR      r0,[sp,#0xc]          ;902
000120  e1d700b2          LDRH     r0,[r7,#2]            ;903
000124  ebfffffe          BL       lwip_ntohs
000128  e1a08000          MOV      r8,r0                 ;903
00012c  e1cd81b0          STRH     r8,[sp,#0x10]         ;904
000130  ea000003          B        |L23.324|
                  |L23.308|
000134  e3a08000          MOV      r8,#0                 ;906
000138  e3a00000          MOV      r0,#0                 ;907
00013c  e58d000c          STR      r0,[sp,#0xc]          ;907
000140  e1cd01b0          STRH     r0,[sp,#0x10]         ;908
                  |L23.324|
000144  e1a0200b          MOV      r2,r11                ;934
000148  e59d1018          LDR      r1,[sp,#0x18]         ;934
00014c  e28d0004          ADD      r0,sp,#4              ;934
000150  ebfffffe          BL       netbuf_ref
000154  e1a04000          MOV      r4,r0                 ;934
000158  e3540000          CMP      r4,#0                 ;936
00015c  1a000003          BNE      |L23.368|
000160  e28d1004          ADD      r1,sp,#4              ;938
000164  e5960000          LDR      r0,[r6,#0]            ;938
000168  ebfffffe          BL       netconn_send
00016c  e1a04000          MOV      r4,r0                 ;938
                  |L23.368|
000170  e28d0004          ADD      r0,sp,#4              ;942
000174  ebfffffe          BL       netbuf_free
000178  e1a00000          MOV      r0,r0                 ;944
00017c  e2640000          RSB      r0,r4,#0              ;944
000180  e3500010          CMP      r0,#0x10              ;944
000184  2a000003          BCS      |L23.408|
000188  e59f00c0          LDR      r0,|L23.592|
00018c  e2641000          RSB      r1,r4,#0              ;944
000190  e7900101          LDR      r0,[r0,r1,LSL #2]     ;944
000194  ea000000          B        |L23.412|
                  |L23.408|
000198  e3a00005          MOV      r0,#5                 ;944
                  |L23.412|
00019c  e5860010          STR      r0,[r6,#0x10]         ;944
0001a0  e1a00000          MOV      r0,r0                 ;944
0001a4  e3540000          CMP      r4,#0                 ;945
0001a8  1a000001          BNE      |L23.436|
0001ac  e1a0000b          MOV      r0,r11                ;945
0001b0  eaffff9d          B        |L23.44|
                  |L23.436|
0001b4  e3e00000          MVN      r0,#0                 ;945
0001b8  eaffff9b          B        |L23.44|
;;;947    
                          ENDP

                  |L23.444|
0001bc  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
0001c0  2d312e34
0001c4  2e315c73
0001c8  72635c61
0001cc  70695c73
0001d0  6f636b65
0001d4  74732e63
0001d8  00      
0001d9  00                DCB      0
0001da  00                DCB      0
0001db  00                DCB      0
                  |L23.476|
                          DCD      0x00000333
                  |L23.480|
0001e0  6c776970          DCB      "lwip_sendto: size must fit in u16_t",0
0001e4  5f73656e
0001e8  64746f3a
0001ec  2073697a
0001f0  65206d75
0001f4  73742066
0001f8  69742069
0001fc  6e207531
000200  365f7400
                  |L23.516|
000204  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000208  7274696f
00020c  6e202225
000210  73222066
000214  61696c65
000218  64206174
00021c  206c696e
000220  65202564
000224  20696e20
000228  25730a00
                  |L23.556|
                          DCD      0x00000335
                  |L23.560|
000230  6c776970          DCB      "lwip_sendto: invalid address",0
000234  5f73656e
000238  64746f3a
00023c  20696e76
000240  616c6964
000244  20616464
000248  72657373
00024c  00      
00024d  00                DCB      0
00024e  00                DCB      0
00024f  00                DCB      0
                  |L23.592|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_setsockopt||, CODE, READONLY, ALIGN=2

                  lwip_setsockopt PROC
;;;1863   int
;;;1864   lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1865   {
000004  e24dd01c          SUB      sp,sp,#0x1c
000008  e1a09000          MOV      r9,r0
00000c  e1a07001          MOV      r7,r1
000010  e1a05002          MOV      r5,r2
000014  e1a08003          MOV      r8,r3
;;;1866     struct lwip_sock *sock = get_socket(s);
000018  e1a00009          MOV      r0,r9
00001c  ebfffffe          BL       get_socket
000020  e1a04000          MOV      r4,r0
;;;1867     err_t err = ERR_OK;
000024  e3a06000          MOV      r6,#0
;;;1868     struct lwip_setgetsockopt_data data;
;;;1869   
;;;1870     if (!sock) {
000028  e3540000          CMP      r4,#0
00002c  1a000002          BNE      |L24.60|
;;;1871       return -1;
000030  e3e00000          MVN      r0,#0
                  |L24.52|
000034  e28dd01c          ADD      sp,sp,#0x1c
;;;1872     }
;;;1873   
;;;1874     if (NULL == optval) {
;;;1875       sock_set_errno(sock, EFAULT);
;;;1876       return -1;
;;;1877     }
;;;1878   
;;;1879     /* Do length and type checks for the various options first, to keep it readable. */
;;;1880     switch (level) {
;;;1881   
;;;1882   /* Level: SOL_SOCKET */
;;;1883     case SOL_SOCKET:
;;;1884       switch (optname) {
;;;1885   
;;;1886       case SO_BROADCAST:
;;;1887       /* UNIMPL case SO_DEBUG: */
;;;1888       /* UNIMPL case SO_DONTROUTE: */
;;;1889       case SO_KEEPALIVE:
;;;1890       /* UNIMPL case case SO_CONTIMEO: */
;;;1891   #if LWIP_SO_SNDTIMEO
;;;1892       case SO_SNDTIMEO:
;;;1893   #endif /* LWIP_SO_SNDTIMEO */
;;;1894   #if LWIP_SO_RCVTIMEO
;;;1895       case SO_RCVTIMEO:
;;;1896   #endif /* LWIP_SO_RCVTIMEO */
;;;1897   #if LWIP_SO_RCVBUF
;;;1898       case SO_RCVBUF:
;;;1899   #endif /* LWIP_SO_RCVBUF */
;;;1900       /* UNIMPL case SO_OOBINLINE: */
;;;1901       /* UNIMPL case SO_SNDBUF: */
;;;1902       /* UNIMPL case SO_RCVLOWAT: */
;;;1903       /* UNIMPL case SO_SNDLOWAT: */
;;;1904   #if SO_REUSE
;;;1905       case SO_REUSEADDR:
;;;1906       case SO_REUSEPORT:
;;;1907   #endif /* SO_REUSE */
;;;1908       /* UNIMPL case SO_USELOOPBACK: */
;;;1909         if (optlen < sizeof(int)) {
;;;1910           err = EINVAL;
;;;1911         }
;;;1912         break;
;;;1913       case SO_NO_CHECK:
;;;1914         if (optlen < sizeof(int)) {
;;;1915           err = EINVAL;
;;;1916         }
;;;1917   #if LWIP_UDP
;;;1918         if ((sock->conn->type != NETCONN_UDP) ||
;;;1919             ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
;;;1920           /* this flag is only available for UDP, not for UDP lite */
;;;1921           err = EAFNOSUPPORT;
;;;1922         }
;;;1923   #endif /* LWIP_UDP */
;;;1924         break;
;;;1925       default:
;;;1926         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
;;;1927                     s, optname));
;;;1928         err = ENOPROTOOPT;
;;;1929       }  /* switch (optname) */
;;;1930       break;
;;;1931   
;;;1932   /* Level: IPPROTO_IP */
;;;1933     case IPPROTO_IP:
;;;1934       switch (optname) {
;;;1935       /* UNIMPL case IP_HDRINCL: */
;;;1936       /* UNIMPL case IP_RCVDSTADDR: */
;;;1937       /* UNIMPL case IP_RCVIF: */
;;;1938       case IP_TTL:
;;;1939       case IP_TOS:
;;;1940         if (optlen < sizeof(int)) {
;;;1941           err = EINVAL;
;;;1942         }
;;;1943         break;
;;;1944   #if LWIP_IGMP
;;;1945       case IP_MULTICAST_TTL:
;;;1946         if (optlen < sizeof(u8_t)) {
;;;1947           err = EINVAL;
;;;1948         }
;;;1949         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1950           err = EAFNOSUPPORT;
;;;1951         }
;;;1952         break;
;;;1953       case IP_MULTICAST_IF:
;;;1954         if (optlen < sizeof(struct in_addr)) {
;;;1955           err = EINVAL;
;;;1956         }
;;;1957         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1958           err = EAFNOSUPPORT;
;;;1959         }
;;;1960         break;
;;;1961       case IP_MULTICAST_LOOP:
;;;1962         if (optlen < sizeof(u8_t)) {
;;;1963           err = EINVAL;
;;;1964         }
;;;1965         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1966           err = EAFNOSUPPORT;
;;;1967         }
;;;1968         break;
;;;1969       case IP_ADD_MEMBERSHIP:
;;;1970       case IP_DROP_MEMBERSHIP:
;;;1971         if (optlen < sizeof(struct ip_mreq)) {
;;;1972           err = EINVAL;
;;;1973         }
;;;1974         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1975           err = EAFNOSUPPORT;
;;;1976         }
;;;1977         break;
;;;1978   #endif /* LWIP_IGMP */
;;;1979         default:
;;;1980           LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
;;;1981                       s, optname));
;;;1982           err = ENOPROTOOPT;
;;;1983       }  /* switch (optname) */
;;;1984       break;
;;;1985   
;;;1986   #if LWIP_TCP
;;;1987   /* Level: IPPROTO_TCP */
;;;1988     case IPPROTO_TCP:
;;;1989       if (optlen < sizeof(int)) {
;;;1990         err = EINVAL;
;;;1991         break;
;;;1992       }
;;;1993   
;;;1994       /* If this is no TCP socket, ignore any options. */
;;;1995       if (sock->conn->type != NETCONN_TCP)
;;;1996         return 0;
;;;1997   
;;;1998       switch (optname) {
;;;1999       case TCP_NODELAY:
;;;2000       case TCP_KEEPALIVE:
;;;2001   #if LWIP_TCP_KEEPALIVE
;;;2002       case TCP_KEEPIDLE:
;;;2003       case TCP_KEEPINTVL:
;;;2004       case TCP_KEEPCNT:
;;;2005   #endif /* LWIP_TCP_KEEPALIVE */
;;;2006         break;
;;;2007   
;;;2008       default:
;;;2009         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
;;;2010                     s, optname));
;;;2011         err = ENOPROTOOPT;
;;;2012       }  /* switch (optname) */
;;;2013       break;
;;;2014   #endif /* LWIP_TCP */
;;;2015   #if LWIP_UDP && LWIP_UDPLITE
;;;2016   /* Level: IPPROTO_UDPLITE */
;;;2017     case IPPROTO_UDPLITE:
;;;2018       if (optlen < sizeof(int)) {
;;;2019         err = EINVAL;
;;;2020         break;
;;;2021       }
;;;2022   
;;;2023       /* If this is no UDP lite socket, ignore any options. */
;;;2024       if (sock->conn->type != NETCONN_UDPLITE)
;;;2025         return 0;
;;;2026   
;;;2027       switch (optname) {
;;;2028       case UDPLITE_SEND_CSCOV:
;;;2029       case UDPLITE_RECV_CSCOV:
;;;2030         break;
;;;2031   
;;;2032       default:
;;;2033         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
;;;2034                     s, optname));
;;;2035         err = ENOPROTOOPT;
;;;2036       }  /* switch (optname) */
;;;2037       break;
;;;2038   #endif /* LWIP_UDP && LWIP_UDPLITE */
;;;2039   /* UNDEFINED LEVEL */
;;;2040     default:
;;;2041       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
;;;2042                   s, level, optname));
;;;2043       err = ENOPROTOOPT;
;;;2044     }  /* switch (level) */
;;;2045   
;;;2046   
;;;2047     if (err != ERR_OK) {
;;;2048       sock_set_errno(sock, err);
;;;2049       return -1;
;;;2050     }
;;;2051   
;;;2052   
;;;2053     /* Now do the actual option processing */
;;;2054     data.sock = sock;
;;;2055   #ifdef LWIP_DEBUG
;;;2056     data.s = s;
;;;2057   #endif /* LWIP_DEBUG */
;;;2058     data.level = level;
;;;2059     data.optname = optname;
;;;2060     data.optval = (void*)optval;
;;;2061     data.optlen = &optlen;
;;;2062     data.err = err;
;;;2063     tcpip_callback(lwip_setsockopt_internal, &data);
;;;2064     sys_arch_sem_wait(&sock->conn->op_completed, 0);
;;;2065     /* maybe lwip_setsockopt_internal has changed err */
;;;2066     err = data.err;
;;;2067   
;;;2068     sock_set_errno(sock, err);
;;;2069     return err ? -1 : 0;
;;;2070   }
000038  e8bd83f0          POP      {r4-r9,pc}
                  |L24.60|
00003c  e3580000          CMP      r8,#0                 ;1874
000040  1a000005          BNE      |L24.92|
000044  e1a00000          MOV      r0,r0                 ;1875
000048  e3a0000e          MOV      r0,#0xe               ;1875
00004c  e5840010          STR      r0,[r4,#0x10]         ;1875
000050  e1a00000          MOV      r0,r0                 ;1875
000054  e3e00000          MVN      r0,#0                 ;1876
000058  eafffff5          B        |L24.52|
                  |L24.92|
00005c  e3570000          CMP      r7,#0                 ;1880
000060  0a00002b          BEQ      |L24.276|
000064  e3570006          CMP      r7,#6                 ;1880
000068  0a000039          BEQ      |L24.340|
00006c  e2470c0f          SUB      r0,r7,#0xf00          ;1880
000070  e24000ff          SUB      r0,r0,#0xff           ;1880
000074  e3500000          CMP      r0,#0                 ;1880
000078  1a00004e          BNE      |L24.440|
00007c  e3550008          CMP      r5,#8                 ;1884
000080  0a000008          BEQ      |L24.168|
000084  e3550020          CMP      r5,#0x20              ;1884
000088  0a000004          BEQ      |L24.160|
00008c  e2450a01          SUB      r0,r5,#0x1000         ;1884
000090  e240000a          SUB      r0,r0,#0xa            ;1884
000094  e3500000          CMP      r0,#0                 ;1884
000098  1a000018          BNE      |L24.256|
00009c  ea000006          B        |L24.188|
                  |L24.160|
0000a0  e1a00000          MOV      r0,r0                 ;1886
0000a4  e1a00000          MOV      r0,r0                 ;1889
                  |L24.168|
0000a8  e59d0038          LDR      r0,[sp,#0x38]         ;1909
0000ac  e3500004          CMP      r0,#4                 ;1909
0000b0  2a000000          BCS      |L24.184|
0000b4  e3a06016          MOV      r6,#0x16              ;1910
                  |L24.184|
0000b8  ea000013          B        |L24.268|
                  |L24.188|
0000bc  e1a00000          MOV      r0,r0                 ;1913
0000c0  e59d0038          LDR      r0,[sp,#0x38]         ;1914
0000c4  e3500004          CMP      r0,#4                 ;1914
0000c8  2a000000          BCS      |L24.208|
0000cc  e3a06016          MOV      r6,#0x16              ;1915
                  |L24.208|
0000d0  e5940000          LDR      r0,[r4,#0]            ;1918
0000d4  e5d00000          LDRB     r0,[r0,#0]            ;1918
0000d8  e3500020          CMP      r0,#0x20              ;1918
0000dc  1a000005          BNE      |L24.248|
0000e0  e5940000          LDR      r0,[r4,#0]            ;1919
0000e4  e5900004          LDR      r0,[r0,#4]            ;1919
0000e8  e5d00010          LDRB     r0,[r0,#0x10]         ;1919
0000ec  e2000002          AND      r0,r0,#2              ;1919
0000f0  e3500000          CMP      r0,#0                 ;1919
0000f4  0a000000          BEQ      |L24.252|
                  |L24.248|
0000f8  e3a06061          MOV      r6,#0x61              ;1921
                  |L24.252|
0000fc  ea000002          B        |L24.268|
                  |L24.256|
000100  e1a00000          MOV      r0,r0                 ;1925
000104  e3a0605c          MOV      r6,#0x5c              ;1928
000108  e1a00000          MOV      r0,r0                 ;1884
                  |L24.268|
00010c  e1a00000          MOV      r0,r0                 ;1912
000110  ea00002b          B        |L24.452|
                  |L24.276|
000114  e1a00000          MOV      r0,r0                 ;1933
000118  e3550001          CMP      r5,#1                 ;1934
00011c  0a000002          BEQ      |L24.300|
000120  e3550002          CMP      r5,#2                 ;1934
000124  1a000005          BNE      |L24.320|
000128  e1a00000          MOV      r0,r0                 ;1939
                  |L24.300|
00012c  e59d0038          LDR      r0,[sp,#0x38]         ;1940
000130  e3500004          CMP      r0,#4                 ;1940
000134  2a000000          BCS      |L24.316|
000138  e3a06016          MOV      r6,#0x16              ;1941
                  |L24.316|
00013c  ea000002          B        |L24.332|
                  |L24.320|
000140  e1a00000          MOV      r0,r0                 ;1979
000144  e3a0605c          MOV      r6,#0x5c              ;1982
000148  e1a00000          MOV      r0,r0                 ;1934
                  |L24.332|
00014c  e1a00000          MOV      r0,r0                 ;1943
000150  ea00001b          B        |L24.452|
                  |L24.340|
000154  e1a00000          MOV      r0,r0                 ;1988
000158  e59d0038          LDR      r0,[sp,#0x38]         ;1989
00015c  e3500004          CMP      r0,#4                 ;1989
000160  2a000001          BCS      |L24.364|
000164  e3a06016          MOV      r6,#0x16              ;1990
000168  ea000015          B        |L24.452|
                  |L24.364|
00016c  e5940000          LDR      r0,[r4,#0]            ;1995
000170  e5d00000          LDRB     r0,[r0,#0]            ;1995
000174  e3500010          CMP      r0,#0x10              ;1995
000178  0a000001          BEQ      |L24.388|
00017c  e3a00000          MOV      r0,#0                 ;1996
000180  eaffffab          B        |L24.52|
                  |L24.388|
000184  e3550001          CMP      r5,#1                 ;1998
000188  0a000002          BEQ      |L24.408|
00018c  e3550002          CMP      r5,#2                 ;1998
000190  1a000003          BNE      |L24.420|
000194  ea000001          B        |L24.416|
                  |L24.408|
000198  e1a00000          MOV      r0,r0                 ;1999
00019c  e1a00000          MOV      r0,r0                 ;2000
                  |L24.416|
0001a0  ea000002          B        |L24.432|
                  |L24.420|
0001a4  e1a00000          MOV      r0,r0                 ;2008
0001a8  e3a0605c          MOV      r6,#0x5c              ;2011
0001ac  e1a00000          MOV      r0,r0                 ;1998
                  |L24.432|
0001b0  e1a00000          MOV      r0,r0                 ;2006
0001b4  ea000002          B        |L24.452|
                  |L24.440|
0001b8  e1a00000          MOV      r0,r0                 ;2040
0001bc  e3a0605c          MOV      r6,#0x5c              ;2043
0001c0  e1a00000          MOV      r0,r0                 ;1880
                  |L24.452|
0001c4  e1a00000          MOV      r0,r0                 ;1930
0001c8  e3560000          CMP      r6,#0                 ;2047
0001cc  0a000004          BEQ      |L24.484|
0001d0  e1a00000          MOV      r0,r0                 ;2048
0001d4  e5846010          STR      r6,[r4,#0x10]         ;2048
0001d8  e1a00000          MOV      r0,r0                 ;2048
0001dc  e3e00000          MVN      r0,#0                 ;2049
0001e0  eaffff93          B        |L24.52|
                  |L24.484|
0001e4  e58d4000          STR      r4,[sp,#0]            ;2054
0001e8  e58d9004          STR      r9,[sp,#4]            ;2056
0001ec  e58d7008          STR      r7,[sp,#8]            ;2058
0001f0  e58d500c          STR      r5,[sp,#0xc]          ;2059
0001f4  e58d8010          STR      r8,[sp,#0x10]         ;2060
0001f8  e28d0038          ADD      r0,sp,#0x38           ;2061
0001fc  e58d0014          STR      r0,[sp,#0x14]         ;2061
000200  e5cd6018          STRB     r6,[sp,#0x18]         ;2062
000204  e3a02001          MOV      r2,#1                 ;2063
000208  e1a0100d          MOV      r1,sp                 ;2063
00020c  e59f0038          LDR      r0,|L24.588|
000210  ebfffffe          BL       tcpip_callback_with_block
000214  e5941000          LDR      r1,[r4,#0]            ;2064
000218  e281000c          ADD      r0,r1,#0xc            ;2064
00021c  e3a01000          MOV      r1,#0                 ;2064
000220  ebfffffe          BL       sys_arch_sem_wait
000224  e1dd61d8          LDRSB    r6,[sp,#0x18]         ;2066
000228  e1a00000          MOV      r0,r0                 ;2068
00022c  e5846010          STR      r6,[r4,#0x10]         ;2068
000230  e1a00000          MOV      r0,r0                 ;2068
000234  e3560000          CMP      r6,#0                 ;2069
000238  0a000001          BEQ      |L24.580|
00023c  e3e00000          MVN      r0,#0                 ;2069
000240  eaffff7b          B        |L24.52|
                  |L24.580|
000244  e3a00000          MOV      r0,#0                 ;2069
000248  eaffff79          B        |L24.52|
;;;2071   
                          ENDP

                  |L24.588|
                          DCD      lwip_setsockopt_internal

                          AREA ||i.lwip_setsockopt_internal||, CODE, READONLY, ALIGN=2

                  lwip_setsockopt_internal PROC
;;;2072   static void
;;;2073   lwip_setsockopt_internal(void *arg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2074   {
000004  e1a05000          MOV      r5,r0
;;;2075     struct lwip_sock *sock;
;;;2076   #ifdef LWIP_DEBUG
;;;2077     int s;
;;;2078   #endif /* LWIP_DEBUG */
;;;2079     int level, optname;
;;;2080     const void *optval;
;;;2081     struct lwip_setgetsockopt_data *data;
;;;2082   
;;;2083     LWIP_ASSERT("arg != NULL", arg != NULL);
000008  e1a00000          MOV      r0,r0
00000c  e3550000          CMP      r5,#0
000010  1a000006          BNE      |L25.48|
000014  e1a00000          MOV      r0,r0
000018  e28f3e2b          ADR      r3,|L25.720|
00001c  e59f22cc          LDR      r2,|L25.752|
000020  e28f1fb3          ADR      r1,|L25.756|
000024  e28f0fb5          ADR      r0,|L25.768|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L25.48|
000030  e1a00000          MOV      r0,r0
;;;2084   
;;;2085     data = (struct lwip_setgetsockopt_data*)arg;
000034  e1a08005          MOV      r8,r5
;;;2086     sock = data->sock;
000038  e5984000          LDR      r4,[r8,#0]
;;;2087   #ifdef LWIP_DEBUG
;;;2088     s = data->s;
00003c  e598a004          LDR      r10,[r8,#4]
;;;2089   #endif /* LWIP_DEBUG */
;;;2090     level = data->level;
000040  e5989008          LDR      r9,[r8,#8]
;;;2091     optname = data->optname;
000044  e598700c          LDR      r7,[r8,#0xc]
;;;2092     optval = data->optval;
000048  e5986010          LDR      r6,[r8,#0x10]
;;;2093   
;;;2094     switch (level) {
00004c  e3590000          CMP      r9,#0
000050  0a000044          BEQ      |L25.360|
000054  e3590006          CMP      r9,#6
000058  0a00005f          BEQ      |L25.476|
00005c  e2490c0f          SUB      r0,r9,#0xf00
000060  e24000ff          SUB      r0,r0,#0xff
000064  e3500000          CMP      r0,#0
000068  1a000088          BNE      |L25.656|
;;;2095   
;;;2096   /* Level: SOL_SOCKET */
;;;2097     case SOL_SOCKET:
;;;2098       switch (optname) {
00006c  e3570008          CMP      r7,#8
000070  0a000008          BEQ      |L25.152|
000074  e3570020          CMP      r7,#0x20
000078  0a000004          BEQ      |L25.144|
00007c  e2470a01          SUB      r0,r7,#0x1000
000080  e240000a          SUB      r0,r0,#0xa
000084  e3500000          CMP      r0,#0
000088  1a000029          BNE      |L25.308|
00008c  ea000014          B        |L25.228|
                  |L25.144|
;;;2099   
;;;2100       /* The option flags */
;;;2101       case SO_BROADCAST:
000090  e1a00000          MOV      r0,r0
;;;2102       /* UNIMPL case SO_DEBUG: */
;;;2103       /* UNIMPL case SO_DONTROUTE: */
;;;2104       case SO_KEEPALIVE:
000094  e1a00000          MOV      r0,r0
                  |L25.152|
;;;2105       /* UNIMPL case SO_OOBINCLUDE: */
;;;2106   #if SO_REUSE
;;;2107       case SO_REUSEADDR:
;;;2108       case SO_REUSEPORT:
;;;2109   #endif /* SO_REUSE */
;;;2110       /* UNIMPL case SO_USELOOPBACK: */
;;;2111         if (*(int*)optval) {
000098  e5960000          LDR      r0,[r6,#0]
00009c  e3500000          CMP      r0,#0
0000a0  0a000007          BEQ      |L25.196|
;;;2112           ip_set_option(sock->conn->pcb.ip, optname);
0000a4  e5940000          LDR      r0,[r4,#0]
0000a8  e5900004          LDR      r0,[r0,#4]
0000ac  e5d00008          LDRB     r0,[r0,#8]
0000b0  e1800007          ORR      r0,r0,r7
0000b4  e5941000          LDR      r1,[r4,#0]
0000b8  e5911004          LDR      r1,[r1,#4]
0000bc  e5c10008          STRB     r0,[r1,#8]
0000c0  ea000006          B        |L25.224|
                  |L25.196|
;;;2113         } else {
;;;2114           ip_reset_option(sock->conn->pcb.ip, optname);
0000c4  e5940000          LDR      r0,[r4,#0]
0000c8  e5900004          LDR      r0,[r0,#4]
0000cc  e5d00008          LDRB     r0,[r0,#8]
0000d0  e1c00007          BIC      r0,r0,r7
0000d4  e5941000          LDR      r1,[r4,#0]
0000d8  e5911004          LDR      r1,[r1,#4]
0000dc  e5c10008          STRB     r0,[r1,#8]
                  |L25.224|
;;;2115         }
;;;2116         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
;;;2117                     s, optname, (*(int*)optval?"on":"off")));
;;;2118         break;
0000e0  ea00001e          B        |L25.352|
                  |L25.228|
;;;2119   #if LWIP_SO_SNDTIMEO
;;;2120       case SO_SNDTIMEO:
;;;2121         netconn_set_sendtimeout(sock->conn, (s32_t)*(int*)optval);
;;;2122         break;
;;;2123   #endif /* LWIP_SO_SNDTIMEO */
;;;2124   #if LWIP_SO_RCVTIMEO
;;;2125       case SO_RCVTIMEO:
;;;2126         netconn_set_recvtimeout(sock->conn, *(int*)optval);
;;;2127         break;
;;;2128   #endif /* LWIP_SO_RCVTIMEO */
;;;2129   #if LWIP_SO_RCVBUF
;;;2130       case SO_RCVBUF:
;;;2131         netconn_set_recvbufsize(sock->conn, *(int*)optval);
;;;2132         break;
;;;2133   #endif /* LWIP_SO_RCVBUF */
;;;2134   #if LWIP_UDP
;;;2135       case SO_NO_CHECK:
0000e4  e1a00000          MOV      r0,r0
;;;2136         if (*(int*)optval) {
0000e8  e5960000          LDR      r0,[r6,#0]
0000ec  e3500000          CMP      r0,#0
0000f0  0a000007          BEQ      |L25.276|
;;;2137           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
0000f4  e5940000          LDR      r0,[r4,#0]
0000f8  e5900004          LDR      r0,[r0,#4]
0000fc  e5d00010          LDRB     r0,[r0,#0x10]
000100  e3800001          ORR      r0,r0,#1
000104  e5941000          LDR      r1,[r4,#0]
000108  e5911004          LDR      r1,[r1,#4]
00010c  e5c10010          STRB     r0,[r1,#0x10]
000110  ea000006          B        |L25.304|
                  |L25.276|
;;;2138         } else {
;;;2139           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
000114  e5940000          LDR      r0,[r4,#0]
000118  e5900004          LDR      r0,[r0,#4]
00011c  e5d00010          LDRB     r0,[r0,#0x10]
000120  e3c00001          BIC      r0,r0,#1
000124  e5941000          LDR      r1,[r4,#0]
000128  e5911004          LDR      r1,[r1,#4]
00012c  e5c10010          STRB     r0,[r1,#0x10]
                  |L25.304|
;;;2140         }
;;;2141         break;
000130  ea00000a          B        |L25.352|
                  |L25.308|
;;;2142   #endif /* LWIP_UDP */
;;;2143       default:
000134  e1a00000          MOV      r0,r0
;;;2144         LWIP_ASSERT("unhandled optname", 0);
000138  e1a00000          MOV      r0,r0
00013c  e1a00000          MOV      r0,r0
000140  e28f3f62          ADR      r3,|L25.720|
000144  e3a02e86          MOV      r2,#0x860
000148  e28f1f76          ADR      r1,|L25.808|
00014c  e28f0f6b          ADR      r0,|L25.768|
000150  ebfffffe          BL       sysprintf
000154  e1a00000          MOV      r0,r0
000158  e1a00000          MOV      r0,r0
;;;2145         break;
00015c  e1a00000          MOV      r0,r0
                  |L25.352|
000160  e1a00000          MOV      r0,r0                 ;2118
;;;2146       }  /* switch (optname) */
;;;2147       break;
000164  ea000054          B        |L25.700|
                  |L25.360|
;;;2148   
;;;2149   /* Level: IPPROTO_IP */
;;;2150     case IPPROTO_IP:
000168  e1a00000          MOV      r0,r0
;;;2151       switch (optname) {
00016c  e3570001          CMP      r7,#1
000170  0a000006          BEQ      |L25.400|
000174  e3570002          CMP      r7,#2
000178  1a00000a          BNE      |L25.424|
;;;2152       case IP_TTL:
;;;2153         sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
00017c  e5d60000          LDRB     r0,[r6,#0]
000180  e5941000          LDR      r1,[r4,#0]
000184  e5911004          LDR      r1,[r1,#4]
000188  e5c1000a          STRB     r0,[r1,#0xa]
;;;2154         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
;;;2155                     s, sock->conn->pcb.ip->ttl));
;;;2156         break;
00018c  ea000010          B        |L25.468|
                  |L25.400|
;;;2157       case IP_TOS:
000190  e1a00000          MOV      r0,r0
;;;2158         sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
000194  e5d60000          LDRB     r0,[r6,#0]
000198  e5941000          LDR      r1,[r4,#0]
00019c  e5911004          LDR      r1,[r1,#4]
0001a0  e5c10009          STRB     r0,[r1,#9]
;;;2159         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
;;;2160                     s, sock->conn->pcb.ip->tos));
;;;2161         break;
0001a4  ea00000a          B        |L25.468|
                  |L25.424|
;;;2162   #if LWIP_IGMP
;;;2163       case IP_MULTICAST_TTL:
;;;2164         sock->conn->pcb.udp->ttl = (u8_t)(*(u8_t*)optval);
;;;2165         break;
;;;2166       case IP_MULTICAST_IF:
;;;2167         inet_addr_to_ipaddr(&sock->conn->pcb.udp->multicast_ip, (struct in_addr*)optval);
;;;2168         break;
;;;2169       case IP_MULTICAST_LOOP:
;;;2170         if (*(u8_t*)optval) {
;;;2171           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_MULTICAST_LOOP);
;;;2172         } else {
;;;2173           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_MULTICAST_LOOP);
;;;2174         }
;;;2175         break;
;;;2176       case IP_ADD_MEMBERSHIP:
;;;2177       case IP_DROP_MEMBERSHIP:
;;;2178         {
;;;2179           /* If this is a TCP or a RAW socket, ignore these options. */
;;;2180           struct ip_mreq *imr = (struct ip_mreq *)optval;
;;;2181           ip_addr_t if_addr;
;;;2182           ip_addr_t multi_addr;
;;;2183           inet_addr_to_ipaddr(&if_addr, &imr->imr_interface);
;;;2184           inet_addr_to_ipaddr(&multi_addr, &imr->imr_multiaddr);
;;;2185           if(optname == IP_ADD_MEMBERSHIP){
;;;2186             data->err = igmp_joingroup(&if_addr, &multi_addr);
;;;2187           } else {
;;;2188             data->err = igmp_leavegroup(&if_addr, &multi_addr);
;;;2189           }
;;;2190           if(data->err != ERR_OK) {
;;;2191             data->err = EADDRNOTAVAIL;
;;;2192           }
;;;2193         }
;;;2194         break;
;;;2195   #endif /* LWIP_IGMP */
;;;2196       default:
0001a8  e1a00000          MOV      r0,r0
;;;2197         LWIP_ASSERT("unhandled optname", 0);
0001ac  e1a00000          MOV      r0,r0
0001b0  e1a00000          MOV      r0,r0
0001b4  e28f3f45          ADR      r3,|L25.720|
0001b8  e59f217c          LDR      r2,|L25.828|
0001bc  e28f1f59          ADR      r1,|L25.808|
0001c0  e28f0f4e          ADR      r0,|L25.768|
0001c4  ebfffffe          BL       sysprintf
0001c8  e1a00000          MOV      r0,r0
0001cc  e1a00000          MOV      r0,r0
;;;2198         break;
0001d0  e1a00000          MOV      r0,r0
                  |L25.468|
0001d4  e1a00000          MOV      r0,r0                 ;2156
;;;2199       }  /* switch (optname) */
;;;2200       break;
0001d8  ea000037          B        |L25.700|
                  |L25.476|
;;;2201   
;;;2202   #if LWIP_TCP
;;;2203   /* Level: IPPROTO_TCP */
;;;2204     case IPPROTO_TCP:
0001dc  e1a00000          MOV      r0,r0
;;;2205       switch (optname) {
0001e0  e3570001          CMP      r7,#1
0001e4  0a000002          BEQ      |L25.500|
0001e8  e3570002          CMP      r7,#2
0001ec  1a00001a          BNE      |L25.604|
0001f0  ea000013          B        |L25.580|
                  |L25.500|
;;;2206       case TCP_NODELAY:
0001f4  e1a00000          MOV      r0,r0
;;;2207         if (*(int*)optval) {
0001f8  e5960000          LDR      r0,[r6,#0]
0001fc  e3500000          CMP      r0,#0
000200  0a000007          BEQ      |L25.548|
;;;2208           tcp_nagle_disable(sock->conn->pcb.tcp);
000204  e5940000          LDR      r0,[r4,#0]
000208  e5900004          LDR      r0,[r0,#4]
00020c  e5d0001e          LDRB     r0,[r0,#0x1e]
000210  e3800040          ORR      r0,r0,#0x40
000214  e5941000          LDR      r1,[r4,#0]
000218  e5911004          LDR      r1,[r1,#4]
00021c  e5c1001e          STRB     r0,[r1,#0x1e]
000220  ea000006          B        |L25.576|
                  |L25.548|
;;;2209         } else {
;;;2210           tcp_nagle_enable(sock->conn->pcb.tcp);
000224  e5940000          LDR      r0,[r4,#0]
000228  e5900004          LDR      r0,[r0,#4]
00022c  e5d0001e          LDRB     r0,[r0,#0x1e]
000230  e3c00040          BIC      r0,r0,#0x40
000234  e5941000          LDR      r1,[r4,#0]
000238  e5911004          LDR      r1,[r1,#4]
00023c  e5c1001e          STRB     r0,[r1,#0x1e]
                  |L25.576|
;;;2211         }
;;;2212         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
;;;2213                     s, (*(int *)optval)?"on":"off") );
;;;2214         break;
000240  ea000010          B        |L25.648|
                  |L25.580|
;;;2215       case TCP_KEEPALIVE:
000244  e1a00000          MOV      r0,r0
;;;2216         sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
000248  e5960000          LDR      r0,[r6,#0]
00024c  e5941000          LDR      r1,[r4,#0]
000250  e5911004          LDR      r1,[r1,#4]
000254  e5810090          STR      r0,[r1,#0x90]
;;;2217         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
;;;2218                     s, sock->conn->pcb.tcp->keep_idle));
;;;2219         break;
000258  ea00000a          B        |L25.648|
                  |L25.604|
;;;2220   
;;;2221   #if LWIP_TCP_KEEPALIVE
;;;2222       case TCP_KEEPIDLE:
;;;2223         sock->conn->pcb.tcp->keep_idle = 1000*(u32_t)(*(int*)optval);
;;;2224         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %"U32_F"\n",
;;;2225                     s, sock->conn->pcb.tcp->keep_idle));
;;;2226         break;
;;;2227       case TCP_KEEPINTVL:
;;;2228         sock->conn->pcb.tcp->keep_intvl = 1000*(u32_t)(*(int*)optval);
;;;2229         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %"U32_F"\n",
;;;2230                     s, sock->conn->pcb.tcp->keep_intvl));
;;;2231         break;
;;;2232       case TCP_KEEPCNT:
;;;2233         sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(int*)optval);
;;;2234         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %"U32_F"\n",
;;;2235                     s, sock->conn->pcb.tcp->keep_cnt));
;;;2236         break;
;;;2237   #endif /* LWIP_TCP_KEEPALIVE */
;;;2238       default:
00025c  e1a00000          MOV      r0,r0
;;;2239         LWIP_ASSERT("unhandled optname", 0);
000260  e1a00000          MOV      r0,r0
000264  e1a00000          MOV      r0,r0
000268  e28f3060          ADR      r3,|L25.720|
00026c  e59f20cc          LDR      r2,|L25.832|
000270  e28f10b0          ADR      r1,|L25.808|
000274  e28f0084          ADR      r0,|L25.768|
000278  ebfffffe          BL       sysprintf
00027c  e1a00000          MOV      r0,r0
000280  e1a00000          MOV      r0,r0
;;;2240         break;
000284  e1a00000          MOV      r0,r0
                  |L25.648|
000288  e1a00000          MOV      r0,r0                 ;2214
;;;2241       }  /* switch (optname) */
;;;2242       break;
00028c  ea00000a          B        |L25.700|
                  |L25.656|
;;;2243   #endif /* LWIP_TCP*/
;;;2244   #if LWIP_UDP && LWIP_UDPLITE
;;;2245     /* Level: IPPROTO_UDPLITE */
;;;2246     case IPPROTO_UDPLITE:
;;;2247       switch (optname) {
;;;2248       case UDPLITE_SEND_CSCOV:
;;;2249         if ((*(int*)optval != 0) && ((*(int*)optval < 8) || (*(int*)optval > 0xffff))) {
;;;2250           /* don't allow illegal values! */
;;;2251           sock->conn->pcb.udp->chksum_len_tx = 8;
;;;2252         } else {
;;;2253           sock->conn->pcb.udp->chksum_len_tx = (u16_t)*(int*)optval;
;;;2254         }
;;;2255         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) -> %d\n",
;;;2256                     s, (*(int*)optval)) );
;;;2257         break;
;;;2258       case UDPLITE_RECV_CSCOV:
;;;2259         if ((*(int*)optval != 0) && ((*(int*)optval < 8) || (*(int*)optval > 0xffff))) {
;;;2260           /* don't allow illegal values! */
;;;2261           sock->conn->pcb.udp->chksum_len_rx = 8;
;;;2262         } else {
;;;2263           sock->conn->pcb.udp->chksum_len_rx = (u16_t)*(int*)optval;
;;;2264         }
;;;2265         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) -> %d\n",
;;;2266                     s, (*(int*)optval)) );
;;;2267         break;
;;;2268       default:
;;;2269         LWIP_ASSERT("unhandled optname", 0);
;;;2270         break;
;;;2271       }  /* switch (optname) */
;;;2272       break;
;;;2273   #endif /* LWIP_UDP */
;;;2274     default:
000290  e1a00000          MOV      r0,r0
;;;2275       LWIP_ASSERT("unhandled level", 0);
000294  e1a00000          MOV      r0,r0
000298  e1a00000          MOV      r0,r0
00029c  e28f302c          ADR      r3,|L25.720|
0002a0  e59f209c          LDR      r2,|L25.836|
0002a4  e28f109c          ADR      r1,|L25.840|
0002a8  e28f0050          ADR      r0,|L25.768|
0002ac  ebfffffe          BL       sysprintf
0002b0  e1a00000          MOV      r0,r0
0002b4  e1a00000          MOV      r0,r0
;;;2276       break;
0002b8  e1a00000          MOV      r0,r0
                  |L25.700|
0002bc  e1a00000          MOV      r0,r0                 ;2147
;;;2277     }  /* switch (level) */
;;;2278     sys_sem_signal(&sock->conn->op_completed);
0002c0  e5941000          LDR      r1,[r4,#0]
0002c4  e281000c          ADD      r0,r1,#0xc
0002c8  ebfffffe          BL       sys_sem_signal
;;;2279   }
0002cc  e8bd87f0          POP      {r4-r10,pc}
                  |L25.720|
0002d0  6c776970          DCB      "lwip-1.4.1\\src\\api\\sockets.c",0
0002d4  2d312e34
0002d8  2e315c73
0002dc  72635c61
0002e0  70695c73
0002e4  6f636b65
0002e8  74732e63
0002ec  00      
0002ed  00                DCB      0
0002ee  00                DCB      0
0002ef  00                DCB      0
                  |L25.752|
                          DCD      0x00000823
                  |L25.756|
0002f4  61726720          DCB      "arg != NULL",0
0002f8  213d204e
0002fc  554c4c00
                  |L25.768|
000300  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000304  7274696f
000308  6e202225
00030c  73222066
000310  61696c65
000314  64206174
000318  206c696e
00031c  65202564
000320  20696e20
000324  25730a00
                  |L25.808|
000328  756e6861          DCB      "unhandled optname",0
00032c  6e646c65
000330  64206f70
000334  746e616d
000338  6500    
00033a  00                DCB      0
00033b  00                DCB      0
                  |L25.828|
                          DCD      0x00000895
                  |L25.832|
                          DCD      0x000008bf
                  |L25.836|
                          DCD      0x000008e3
                  |L25.840|
000348  756e6861          DCB      "unhandled level",0
00034c  6e646c65
000350  64206c65
000354  76656c00
                          ENDP


                          AREA ||i.lwip_shutdown||, CODE, READONLY, ALIGN=2

                  lwip_shutdown PROC
;;;1367   int
;;;1368   lwip_shutdown(int s, int how)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1369   {
000004  e1a07000          MOV      r7,r0
000008  e1a06001          MOV      r6,r1
;;;1370     struct lwip_sock *sock;
;;;1371     err_t err;
;;;1372     u8_t shut_rx = 0, shut_tx = 0;
00000c  e3a08000          MOV      r8,#0
000010  e3a09000          MOV      r9,#0
;;;1373   
;;;1374     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
;;;1375   
;;;1376     sock = get_socket(s);
000014  e1a00007          MOV      r0,r7
000018  ebfffffe          BL       get_socket
00001c  e1a04000          MOV      r4,r0
;;;1377     if (!sock) {
000020  e3540000          CMP      r4,#0
000024  1a000001          BNE      |L26.48|
;;;1378       return -1;
000028  e3e00000          MVN      r0,#0
                  |L26.44|
;;;1379     }
;;;1380   
;;;1381     if (sock->conn != NULL) {
;;;1382       if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;1383         sock_set_errno(sock, EOPNOTSUPP);
;;;1384         return EOPNOTSUPP;
;;;1385       }
;;;1386     } else {
;;;1387       sock_set_errno(sock, ENOTCONN);
;;;1388       return ENOTCONN;
;;;1389     }
;;;1390   
;;;1391     if (how == SHUT_RD) {
;;;1392       shut_rx = 1;
;;;1393     } else if (how == SHUT_WR) {
;;;1394       shut_tx = 1;
;;;1395     } else if(how == SHUT_RDWR) {
;;;1396       shut_rx = 1;
;;;1397       shut_tx = 1;
;;;1398     } else {
;;;1399       sock_set_errno(sock, EINVAL);
;;;1400       return EINVAL;
;;;1401     }
;;;1402     err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
;;;1403   
;;;1404     sock_set_errno(sock, err_to_errno(err));
;;;1405     return (err == ERR_OK ? 0 : -1);
;;;1406   }
00002c  e8bd87f0          POP      {r4-r10,pc}
                  |L26.48|
000030  e5940000          LDR      r0,[r4,#0]            ;1381
000034  e3500000          CMP      r0,#0                 ;1381
000038  0a000008          BEQ      |L26.96|
00003c  e5940000          LDR      r0,[r4,#0]            ;1382
000040  e5d00000          LDRB     r0,[r0,#0]            ;1382
000044  e3500010          CMP      r0,#0x10              ;1382
000048  0a000009          BEQ      |L26.116|
00004c  e1a00000          MOV      r0,r0                 ;1383
000050  e3a0005f          MOV      r0,#0x5f              ;1383
000054  e5840010          STR      r0,[r4,#0x10]         ;1383
000058  e1a00000          MOV      r0,r0                 ;1383
00005c  eafffff2          B        |L26.44|
                  |L26.96|
000060  e1a00000          MOV      r0,r0                 ;1387
000064  e3a0006b          MOV      r0,#0x6b              ;1387
000068  e5840010          STR      r0,[r4,#0x10]         ;1387
00006c  e1a00000          MOV      r0,r0                 ;1387
000070  eaffffed          B        |L26.44|
                  |L26.116|
000074  e3560000          CMP      r6,#0                 ;1391
000078  1a000001          BNE      |L26.132|
00007c  e3a08001          MOV      r8,#1                 ;1392
000080  ea00000d          B        |L26.188|
                  |L26.132|
000084  e3560001          CMP      r6,#1                 ;1393
000088  1a000001          BNE      |L26.148|
00008c  e3a09001          MOV      r9,#1                 ;1394
000090  ea000009          B        |L26.188|
                  |L26.148|
000094  e3560002          CMP      r6,#2                 ;1395
000098  1a000002          BNE      |L26.168|
00009c  e3a08001          MOV      r8,#1                 ;1396
0000a0  e3a09001          MOV      r9,#1                 ;1397
0000a4  ea000004          B        |L26.188|
                  |L26.168|
0000a8  e1a00000          MOV      r0,r0                 ;1399
0000ac  e3a00016          MOV      r0,#0x16              ;1399
0000b0  e5840010          STR      r0,[r4,#0x10]         ;1399
0000b4  e1a00000          MOV      r0,r0                 ;1399
0000b8  eaffffdb          B        |L26.44|
                  |L26.188|
0000bc  e1a02009          MOV      r2,r9                 ;1402
0000c0  e1a01008          MOV      r1,r8                 ;1402
0000c4  e5940000          LDR      r0,[r4,#0]            ;1402
0000c8  ebfffffe          BL       netconn_shutdown
0000cc  e1a05000          MOV      r5,r0                 ;1402
0000d0  e1a00000          MOV      r0,r0                 ;1404
0000d4  e2650000          RSB      r0,r5,#0              ;1404
0000d8  e3500010          CMP      r0,#0x10              ;1404
0000dc  2a000003          BCS      |L26.240|
0000e0  e59f002c          LDR      r0,|L26.276|
0000e4  e2651000          RSB      r1,r5,#0              ;1404
0000e8  e7900101          LDR      r0,[r0,r1,LSL #2]     ;1404
0000ec  ea000000          B        |L26.244|
                  |L26.240|
0000f0  e3a00005          MOV      r0,#5                 ;1404
                  |L26.244|
0000f4  e5840010          STR      r0,[r4,#0x10]         ;1404
0000f8  e1a00000          MOV      r0,r0                 ;1404
0000fc  e3550000          CMP      r5,#0                 ;1405
000100  1a000001          BNE      |L26.268|
000104  e3a00000          MOV      r0,#0                 ;1405
000108  eaffffc7          B        |L26.44|
                  |L26.268|
00010c  e3e00000          MVN      r0,#0                 ;1405
000110  eaffffc5          B        |L26.44|
;;;1407   
                          ENDP

                  |L26.276|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_socket||, CODE, READONLY, ALIGN=2

                  lwip_socket PROC
;;;948    int
;;;949    lwip_socket(int domain, int type, int protocol)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;950    {
000004  e1a08000          MOV      r8,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a06002          MOV      r6,r2
;;;951      struct netconn *conn;
;;;952      int i;
;;;953    
;;;954      LWIP_UNUSED_ARG(domain);
;;;955    
;;;956      /* create a netconn */
;;;957      switch (type) {
000010  e3570001          CMP      r7,#1
000014  0a000015          BEQ      |L27.112|
000018  e3570002          CMP      r7,#2
00001c  0a000007          BEQ      |L27.64|
000020  e3570003          CMP      r7,#3
000024  1a00001f          BNE      |L27.168|
;;;958      case SOCK_RAW:
;;;959        conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
000028  e20610ff          AND      r1,r6,#0xff
00002c  e59f20c8          LDR      r2,|L27.252|
000030  e3a00040          MOV      r0,#0x40
000034  ebfffffe          BL       netconn_new_with_proto_and_callback
000038  e1a04000          MOV      r4,r0
;;;960        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
;;;961                                     domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
;;;962        break;
00003c  ea00001c          B        |L27.180|
                  |L27.64|
;;;963      case SOCK_DGRAM:
000040  e1a00000          MOV      r0,r0
;;;964        conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
000044  e3560088          CMP      r6,#0x88
000048  1a000001          BNE      |L27.84|
00004c  e3a01021          MOV      r1,#0x21
000050  ea000000          B        |L27.88|
                  |L27.84|
000054  e3a01020          MOV      r1,#0x20
                  |L27.88|
000058  e1a00001          MOV      r0,r1
00005c  e59f2098          LDR      r2,|L27.252|
000060  e3a01000          MOV      r1,#0
000064  ebfffffe          BL       netconn_new_with_proto_and_callback
000068  e1a04000          MOV      r4,r0
;;;965                     NETCONN_UDPLITE : NETCONN_UDP, event_callback);
;;;966        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
;;;967                                     domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
;;;968        break;
00006c  ea000010          B        |L27.180|
                  |L27.112|
;;;969      case SOCK_STREAM:
000070  e1a00000          MOV      r0,r0
;;;970        conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
000074  e59f2080          LDR      r2,|L27.252|
000078  e3a01000          MOV      r1,#0
00007c  e3a00010          MOV      r0,#0x10
000080  ebfffffe          BL       netconn_new_with_proto_and_callback
000084  e1a04000          MOV      r4,r0
;;;971        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
;;;972                                     domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
;;;973        if (conn != NULL) {
000088  e3540000          CMP      r4,#0
00008c  0a000004          BEQ      |L27.164|
;;;974          /* Prevent automatic window updates, we do this on our own! */
;;;975          netconn_set_noautorecved(conn, 1);
000090  e1a00000          MOV      r0,r0
000094  e5d4001c          LDRB     r0,[r4,#0x1c]
000098  e3800008          ORR      r0,r0,#8
00009c  e5c4001c          STRB     r0,[r4,#0x1c]
0000a0  e1a00000          MOV      r0,r0
                  |L27.164|
;;;976        }
;;;977        break;
0000a4  ea000002          B        |L27.180|
                  |L27.168|
;;;978      default:
0000a8  e1a00000          MOV      r0,r0
;;;979        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
;;;980                                     domain, type, protocol));
;;;981        set_errno(EINVAL);
;;;982        return -1;
0000ac  e3e00000          MVN      r0,#0
                  |L27.176|
;;;983      }
;;;984    
;;;985      if (!conn) {
;;;986        LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
;;;987        set_errno(ENOBUFS);
;;;988        return -1;
;;;989      }
;;;990    
;;;991      i = alloc_socket(conn, 0);
;;;992    
;;;993      if (i == -1) {
;;;994        netconn_delete(conn);
;;;995        set_errno(ENFILE);
;;;996        return -1;
;;;997      }
;;;998      conn->socket = i;
;;;999      LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
;;;1000     set_errno(0);
;;;1001     return i;
;;;1002   }
0000b0  e8bd81f0          POP      {r4-r8,pc}
                  |L27.180|
0000b4  e1a00000          MOV      r0,r0                 ;962
0000b8  e3540000          CMP      r4,#0                 ;985
0000bc  1a000001          BNE      |L27.200|
0000c0  e3e00000          MVN      r0,#0                 ;988
0000c4  eafffff9          B        |L27.176|
                  |L27.200|
0000c8  e3a01000          MOV      r1,#0                 ;991
0000cc  e1a00004          MOV      r0,r4                 ;991
0000d0  ebfffffe          BL       alloc_socket
0000d4  e1a05000          MOV      r5,r0                 ;991
0000d8  e3750001          CMN      r5,#1                 ;993
0000dc  1a000003          BNE      |L27.240|
0000e0  e1a00004          MOV      r0,r4                 ;994
0000e4  ebfffffe          BL       netconn_delete
0000e8  e3e00000          MVN      r0,#0                 ;996
0000ec  eaffffef          B        |L27.176|
                  |L27.240|
0000f0  e5845018          STR      r5,[r4,#0x18]         ;998
0000f4  e1a00005          MOV      r0,r5                 ;1001
0000f8  eaffffec          B        |L27.176|
;;;1003   
                          ENDP

                  |L27.252|
                          DCD      event_callback

                          AREA ||i.lwip_socket_init||, CODE, READONLY, ALIGN=2

                  lwip_socket_init PROC
;;;183    void
;;;184    lwip_socket_init(void)
000000  e12fff1e          BX       lr
;;;185    {
;;;186    }
;;;187    
                          ENDP


                          AREA ||i.lwip_write||, CODE, READONLY, ALIGN=2

                  lwip_write PROC
;;;1004   int
;;;1005   lwip_write(int s, const void *data, size_t size)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1006   {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a06002          MOV      r6,r2
;;;1007     return lwip_send(s, data, size, 0);
000010  e3a03000          MOV      r3,#0
000014  e1a02006          MOV      r2,r6
000018  e1a01005          MOV      r1,r5
00001c  e1a00004          MOV      r0,r4
000020  ebfffffe          BL       lwip_send
;;;1008   }
000024  e8bd8070          POP      {r4-r6,pc}
;;;1009   
                          ENDP


                          AREA ||i.tryget_socket||, CODE, READONLY, ALIGN=2

                  tryget_socket PROC
;;;222    static struct lwip_sock *
;;;223    tryget_socket(int s)
000000  e1a01000          MOV      r1,r0
;;;224    {
;;;225      if ((s < 0) || (s >= NUM_SOCKETS)) {
000004  e3510000          CMP      r1,#0
000008  ba000001          BLT      |L30.20|
00000c  e3510004          CMP      r1,#4
000010  ba000001          BLT      |L30.28|
                  |L30.20|
;;;226        return NULL;
000014  e3a00000          MOV      r0,#0
                  |L30.24|
;;;227      }
;;;228      if (!sockets[s].conn) {
;;;229        return NULL;
;;;230      }
;;;231      return &sockets[s];
;;;232    }
000018  e12fff1e          BX       lr
                  |L30.28|
00001c  e0810081          ADD      r0,r1,r1,LSL #1       ;228
000020  e59f2020          LDR      r2,|L30.72|
000024  e7920180          LDR      r0,[r2,r0,LSL #3]     ;228
000028  e3500000          CMP      r0,#0                 ;228
00002c  1a000001          BNE      |L30.56|
000030  e3a00000          MOV      r0,#0                 ;229
000034  eafffff7          B        |L30.24|
                  |L30.56|
000038  e0810081          ADD      r0,r1,r1,LSL #1       ;231
00003c  e59f2004          LDR      r2,|L30.72|
000040  e0820180          ADD      r0,r2,r0,LSL #3       ;231
000044  eafffff3          B        |L30.24|
;;;233    
                          ENDP

                  |L30.72|
                          DCD      sockets

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sockets
                          %        96

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  err_to_errno_table
                          DCD      0x00000000
                          DCD      0x0000000c
                          DCD      0x00000069
                          DCD      0x0000000b
                          DCD      0x00000071
                          DCD      0x00000073
                          DCD      0x00000016
                          DCD      0x0000000b
                          DCD      0x00000062
                          DCD      0x00000072
                          DCD      0x00000067
                          DCD      0x00000068
                          DCD      0x0000006b
                          DCD      0x0000006b
                          DCD      0x00000005
                          DCD      0xffffffff

                          AREA ||.data||, DATA, ALIGN=2

                  select_cb_list
                          DCD      0x00000000
                  select_cb_ctr
                          DCD      0x00000000
