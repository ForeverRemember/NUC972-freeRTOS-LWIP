; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\inet_chksum.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\inet_chksum.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -D__UVISION_VERSION=524 --omf_browse=.\obj\inet_chksum.crf lwip-1.4.1\src\core\ipv4\inet_chksum.c]
                          ARM

                          AREA ||i.inet_chksum||, CODE, READONLY, ALIGN=2

                  inet_chksum PROC
;;;395    u16_t
;;;396    inet_chksum(void *dataptr, u16_t len)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;397    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;398      return ~LWIP_CHKSUM(dataptr, len);
00000c  e1a01005          MOV      r1,r5
000010  e1a00004          MOV      r0,r4
000014  ebfffffe          BL       lwip_standard_chksum
000018  e1e00000          MVN      r0,r0
00001c  e1a00800          LSL      r0,r0,#16
000020  e1a00820          LSR      r0,r0,#16
;;;399    }
000024  e8bd8070          POP      {r4-r6,pc}
;;;400    
                          ENDP


                          AREA ||i.inet_chksum_pbuf||, CODE, READONLY, ALIGN=2

                  inet_chksum_pbuf PROC
;;;408    u16_t
;;;409    inet_chksum_pbuf(struct pbuf *p)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;410    {
000004  e1a06000          MOV      r6,r0
;;;411      u32_t acc;
;;;412      struct pbuf *q;
;;;413      u8_t swapped;
;;;414    
;;;415      acc = 0;
000008  e3a04000          MOV      r4,#0
;;;416      swapped = 0;
00000c  e3a07000          MOV      r7,#0
;;;417      for(q = p; q != NULL; q = q->next) {
000010  e1a05006          MOV      r5,r6
000014  ea000013          B        |L2.104|
                  |L2.24|
;;;418        acc += LWIP_CHKSUM(q->payload, q->len);
000018  e1d510ba          LDRH     r1,[r5,#0xa]
00001c  e5950004          LDR      r0,[r5,#4]
000020  ebfffffe          BL       lwip_standard_chksum
000024  e0844000          ADD      r4,r4,r0
;;;419        acc = FOLD_U32T(acc);
000028  e1a00804          LSL      r0,r4,#16
00002c  e1a00820          LSR      r0,r0,#16
000030  e0804824          ADD      r4,r0,r4,LSR #16
;;;420        if (q->len % 2 != 0) {
000034  e1d500ba          LDRH     r0,[r5,#0xa]
000038  e0801fa0          ADD      r1,r0,r0,LSR #31
00003c  e1a010c1          ASR      r1,r1,#1
000040  e0401081          SUB      r1,r0,r1,LSL #1
000044  e3510000          CMP      r1,#0
000048  0a000005          BEQ      |L2.100|
;;;421          swapped = 1 - swapped;
00004c  e2670001          RSB      r0,r7,#1
000050  e20070ff          AND      r7,r0,#0xff
;;;422          acc = SWAP_BYTES_IN_WORD(acc);
000054  e1a00c04          LSL      r0,r4,#24
000058  e1a00820          LSR      r0,r0,#16
00005c  e2041cff          AND      r1,r4,#0xff00
000060  e1804421          ORR      r4,r0,r1,LSR #8
                  |L2.100|
000064  e5955000          LDR      r5,[r5,#0]            ;417
                  |L2.104|
000068  e3550000          CMP      r5,#0                 ;417
00006c  1affffe9          BNE      |L2.24|
;;;423        }
;;;424      }
;;;425    
;;;426      if (swapped) {
000070  e3570000          CMP      r7,#0
000074  0a000003          BEQ      |L2.136|
;;;427        acc = SWAP_BYTES_IN_WORD(acc);
000078  e1a00c04          LSL      r0,r4,#24
00007c  e1a00820          LSR      r0,r0,#16
000080  e2041cff          AND      r1,r4,#0xff00
000084  e1804421          ORR      r4,r0,r1,LSR #8
                  |L2.136|
;;;428      }
;;;429      return (u16_t)~(acc & 0xffffUL);
000088  e1e00004          MVN      r0,r4
00008c  e1a00800          LSL      r0,r0,#16
000090  e1a00820          LSR      r0,r0,#16
;;;430    }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;431    
                          ENDP


                          AREA ||i.inet_chksum_pseudo||, CODE, READONLY, ALIGN=2

                  inet_chksum_pseudo PROC
;;;271    u16_t
;;;272    inet_chksum_pseudo(struct pbuf *p,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;273           ip_addr_t *src, ip_addr_t *dest,
;;;274           u8_t proto, u16_t proto_len)
;;;275    {
000004  e1a07000          MOV      r7,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a09002          MOV      r9,r2
000010  e1a0a003          MOV      r10,r3
;;;276      u32_t acc;
;;;277      u32_t addr;
;;;278      struct pbuf *q;
;;;279      u8_t swapped;
;;;280    
;;;281      acc = 0;
000014  e3a04000          MOV      r4,#0
;;;282      swapped = 0;
000018  e3a0b000          MOV      r11,#0
;;;283      /* iterate through all pbuf in chain */
;;;284      for(q = p; q != NULL; q = q->next) {
00001c  e1a05007          MOV      r5,r7
000020  ea000013          B        |L3.116|
                  |L3.36|
;;;285        LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
;;;286          (void *)q, (void *)q->next));
;;;287        acc += LWIP_CHKSUM(q->payload, q->len);
000024  e1d510ba          LDRH     r1,[r5,#0xa]
000028  e5950004          LDR      r0,[r5,#4]
00002c  ebfffffe          BL       lwip_standard_chksum
000030  e0844000          ADD      r4,r4,r0
;;;288        /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
;;;289        /* just executing this next line is probably faster that the if statement needed
;;;290           to check whether we really need to execute it, and does no harm */
;;;291        acc = FOLD_U32T(acc);
000034  e1a00804          LSL      r0,r4,#16
000038  e1a00820          LSR      r0,r0,#16
00003c  e0804824          ADD      r4,r0,r4,LSR #16
;;;292        if (q->len % 2 != 0) {
000040  e1d500ba          LDRH     r0,[r5,#0xa]
000044  e0801fa0          ADD      r1,r0,r0,LSR #31
000048  e1a010c1          ASR      r1,r1,#1
00004c  e0401081          SUB      r1,r0,r1,LSL #1
000050  e3510000          CMP      r1,#0
000054  0a000005          BEQ      |L3.112|
;;;293          swapped = 1 - swapped;
000058  e26b0001          RSB      r0,r11,#1
00005c  e200b0ff          AND      r11,r0,#0xff
;;;294          acc = SWAP_BYTES_IN_WORD(acc);
000060  e1a00c04          LSL      r0,r4,#24
000064  e1a00820          LSR      r0,r0,#16
000068  e2041cff          AND      r1,r4,#0xff00
00006c  e1804421          ORR      r4,r0,r1,LSR #8
                  |L3.112|
000070  e5955000          LDR      r5,[r5,#0]            ;284
                  |L3.116|
000074  e3550000          CMP      r5,#0                 ;284
000078  1affffe9          BNE      |L3.36|
;;;295        }
;;;296        /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
;;;297      }
;;;298    
;;;299      if (swapped) {
00007c  e35b0000          CMP      r11,#0
000080  0a000003          BEQ      |L3.148|
;;;300        acc = SWAP_BYTES_IN_WORD(acc);
000084  e1a00c04          LSL      r0,r4,#24
000088  e1a00820          LSR      r0,r0,#16
00008c  e2041cff          AND      r1,r4,#0xff00
000090  e1804421          ORR      r4,r0,r1,LSR #8
                  |L3.148|
;;;301      }
;;;302      addr = ip4_addr_get_u32(src);
000094  e5986000          LDR      r6,[r8,#0]
;;;303      acc += (addr & 0xffffUL);
000098  e1a00806          LSL      r0,r6,#16
00009c  e1a00820          LSR      r0,r0,#16
0000a0  e0844000          ADD      r4,r4,r0
;;;304      acc += ((addr >> 16) & 0xffffUL);
0000a4  e59f005c          LDR      r0,|L3.264|
0000a8  e0000826          AND      r0,r0,r6,LSR #16
0000ac  e0844000          ADD      r4,r4,r0
;;;305      addr = ip4_addr_get_u32(dest);
0000b0  e5996000          LDR      r6,[r9,#0]
;;;306      acc += (addr & 0xffffUL);
0000b4  e1a00806          LSL      r0,r6,#16
0000b8  e1a00820          LSR      r0,r0,#16
0000bc  e0844000          ADD      r4,r4,r0
;;;307      acc += ((addr >> 16) & 0xffffUL);
0000c0  e59f0040          LDR      r0,|L3.264|
0000c4  e0000826          AND      r0,r0,r6,LSR #16
0000c8  e0844000          ADD      r4,r4,r0
;;;308      acc += (u32_t)htons((u16_t)proto);
0000cc  e1a0000a          MOV      r0,r10
0000d0  ebfffffe          BL       lwip_htons
0000d4  e0844000          ADD      r4,r4,r0
;;;309      acc += (u32_t)htons(proto_len);
0000d8  e59d0028          LDR      r0,[sp,#0x28]
0000dc  ebfffffe          BL       lwip_htons
0000e0  e0844000          ADD      r4,r4,r0
;;;310    
;;;311      /* Fold 32-bit sum to 16 bits
;;;312         calling this twice is propably faster than if statements... */
;;;313      acc = FOLD_U32T(acc);
0000e4  e1a00804          LSL      r0,r4,#16
0000e8  e1a00820          LSR      r0,r0,#16
0000ec  e0804824          ADD      r4,r0,r4,LSR #16
;;;314      acc = FOLD_U32T(acc);
0000f0  e3c40801          BIC      r0,r4,#0x10000
0000f4  e0804824          ADD      r4,r0,r4,LSR #16
;;;315      LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
;;;316      return (u16_t)~(acc & 0xffffUL);
0000f8  e1e00004          MVN      r0,r4
0000fc  e1a00800          LSL      r0,r0,#16
000100  e1a00820          LSR      r0,r0,#16
;;;317    }
000104  e8bd9ff0          POP      {r4-r12,pc}
;;;318    
                          ENDP

                  |L3.264|
                          DCD      0x0000ffff

                          AREA ||i.inet_chksum_pseudo_partial||, CODE, READONLY, ALIGN=2

                  inet_chksum_pseudo_partial PROC
;;;331    u16_t
;;;332    inet_chksum_pseudo_partial(struct pbuf *p,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;333           ip_addr_t *src, ip_addr_t *dest,
;;;334           u8_t proto, u16_t proto_len, u16_t chksum_len)
;;;335    {
000004  e1a09000          MOV      r9,r0
000008  e1a0a001          MOV      r10,r1
00000c  e59d503c          LDR      r5,[sp,#0x3c]
;;;336      u32_t acc;
;;;337      u32_t addr;
;;;338      struct pbuf *q;
;;;339      u8_t swapped;
;;;340      u16_t chklen;
;;;341    
;;;342      acc = 0;
000010  e3a04000          MOV      r4,#0
;;;343      swapped = 0;
000014  e3a0b000          MOV      r11,#0
;;;344      /* iterate through all pbuf in chain */
;;;345      for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
000018  e1a06009          MOV      r6,r9
00001c  ea000026          B        |L4.188|
                  |L4.32|
;;;346        LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
;;;347          (void *)q, (void *)q->next));
;;;348        chklen = q->len;
000020  e1d680ba          LDRH     r8,[r6,#0xa]
;;;349        if (chklen > chksum_len) {
000024  e1580005          CMP      r8,r5
000028  da000000          BLE      |L4.48|
;;;350          chklen = chksum_len;
00002c  e1a08005          MOV      r8,r5
                  |L4.48|
;;;351        }
;;;352        acc += LWIP_CHKSUM(q->payload, chklen);
000030  e1a01008          MOV      r1,r8
000034  e5960004          LDR      r0,[r6,#4]
000038  ebfffffe          BL       lwip_standard_chksum
00003c  e0844000          ADD      r4,r4,r0
;;;353        chksum_len -= chklen;
000040  e0450008          SUB      r0,r5,r8
000044  e1a05800          LSL      r5,r0,#16
000048  e1a05825          LSR      r5,r5,#16
;;;354        LWIP_ASSERT("delete me", chksum_len < 0x7fff);
00004c  e1a00000          MOV      r0,r0
000050  e59f0108          LDR      r0,|L4.352|
000054  e1550000          CMP      r5,r0
000058  ba000006          BLT      |L4.120|
00005c  e1a00000          MOV      r0,r0
000060  e28f30fc          ADR      r3,|L4.356|
000064  e59f2120          LDR      r2,|L4.396|
000068  e28f1e12          ADR      r1,|L4.400|
00006c  e28f0f4a          ADR      r0,|L4.412|
000070  ebfffffe          BL       sysprintf
000074  e1a00000          MOV      r0,r0
                  |L4.120|
000078  e1a00000          MOV      r0,r0
;;;355        /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
;;;356        /* fold the upper bit down */
;;;357        acc = FOLD_U32T(acc);
00007c  e1a00804          LSL      r0,r4,#16
000080  e1a00820          LSR      r0,r0,#16
000084  e0804824          ADD      r4,r0,r4,LSR #16
;;;358        if (q->len % 2 != 0) {
000088  e1d600ba          LDRH     r0,[r6,#0xa]
00008c  e0801fa0          ADD      r1,r0,r0,LSR #31
000090  e1a010c1          ASR      r1,r1,#1
000094  e0401081          SUB      r1,r0,r1,LSL #1
000098  e3510000          CMP      r1,#0
00009c  0a000005          BEQ      |L4.184|
;;;359          swapped = 1 - swapped;
0000a0  e26b0001          RSB      r0,r11,#1
0000a4  e200b0ff          AND      r11,r0,#0xff
;;;360          acc = SWAP_BYTES_IN_WORD(acc);
0000a8  e1a00c04          LSL      r0,r4,#24
0000ac  e1a00820          LSR      r0,r0,#16
0000b0  e2041cff          AND      r1,r4,#0xff00
0000b4  e1804421          ORR      r4,r0,r1,LSR #8
                  |L4.184|
0000b8  e5966000          LDR      r6,[r6,#0]            ;345
                  |L4.188|
0000bc  e3560000          CMP      r6,#0                 ;345
0000c0  0a000001          BEQ      |L4.204|
0000c4  e3550000          CMP      r5,#0                 ;345
0000c8  caffffd4          BGT      |L4.32|
                  |L4.204|
;;;361        }
;;;362        /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
;;;363      }
;;;364    
;;;365      if (swapped) {
0000cc  e35b0000          CMP      r11,#0
0000d0  0a000003          BEQ      |L4.228|
;;;366        acc = SWAP_BYTES_IN_WORD(acc);
0000d4  e1a00c04          LSL      r0,r4,#24
0000d8  e1a00820          LSR      r0,r0,#16
0000dc  e2041cff          AND      r1,r4,#0xff00
0000e0  e1804421          ORR      r4,r0,r1,LSR #8
                  |L4.228|
;;;367      }
;;;368      addr = ip4_addr_get_u32(src);
0000e4  e59a7000          LDR      r7,[r10,#0]
;;;369      acc += (addr & 0xffffUL);
0000e8  e1a00807          LSL      r0,r7,#16
0000ec  e1a00820          LSR      r0,r0,#16
0000f0  e0844000          ADD      r4,r4,r0
;;;370      acc += ((addr >> 16) & 0xffffUL);
0000f4  e59f00c8          LDR      r0,|L4.452|
0000f8  e0000827          AND      r0,r0,r7,LSR #16
0000fc  e0844000          ADD      r4,r4,r0
;;;371      addr = ip4_addr_get_u32(dest);
000100  e59d0008          LDR      r0,[sp,#8]
000104  e5907000          LDR      r7,[r0,#0]
;;;372      acc += (addr & 0xffffUL);
000108  e1a00807          LSL      r0,r7,#16
00010c  e1a00820          LSR      r0,r0,#16
000110  e0844000          ADD      r4,r4,r0
;;;373      acc += ((addr >> 16) & 0xffffUL);
000114  e59f00a8          LDR      r0,|L4.452|
000118  e0000827          AND      r0,r0,r7,LSR #16
00011c  e0844000          ADD      r4,r4,r0
;;;374      acc += (u32_t)htons((u16_t)proto);
000120  e59d000c          LDR      r0,[sp,#0xc]
000124  ebfffffe          BL       lwip_htons
000128  e0844000          ADD      r4,r4,r0
;;;375      acc += (u32_t)htons(proto_len);
00012c  e59d0038          LDR      r0,[sp,#0x38]
000130  ebfffffe          BL       lwip_htons
000134  e0844000          ADD      r4,r4,r0
;;;376    
;;;377      /* Fold 32-bit sum to 16 bits
;;;378         calling this twice is propably faster than if statements... */
;;;379      acc = FOLD_U32T(acc);
000138  e1a00804          LSL      r0,r4,#16
00013c  e1a00820          LSR      r0,r0,#16
000140  e0804824          ADD      r4,r0,r4,LSR #16
;;;380      acc = FOLD_U32T(acc);
000144  e3c40801          BIC      r0,r4,#0x10000
000148  e0804824          ADD      r4,r0,r4,LSR #16
;;;381      LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
;;;382      return (u16_t)~(acc & 0xffffUL);
00014c  e1e00004          MVN      r0,r4
000150  e1a00800          LSL      r0,r0,#16
000154  e1a00820          LSR      r0,r0,#16
000158  e28dd010          ADD      sp,sp,#0x10
;;;383    }
00015c  e8bd9ff0          POP      {r4-r12,pc}
;;;384    
                          ENDP

                  |L4.352|
                          DCD      0x00007fff
                  |L4.356|
000164  6c776970          DCB      "lwip-1.4.1\\src\\core\\ipv4\\inet_chksum.c",0
000168  2d312e34
00016c  2e315c73
000170  72635c63
000174  6f72655c
000178  69707634
00017c  5c696e65
000180  745f6368
000184  6b73756d
000188  2e6300  
00018b  00                DCB      0
                  |L4.396|
                          DCD      0x00000162
                  |L4.400|
000190  64656c65          DCB      "delete me",0
000194  7465206d
000198  6500    
00019a  00                DCB      0
00019b  00                DCB      0
                  |L4.412|
00019c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001a0  7274696f
0001a4  6e202225
0001a8  73222066
0001ac  61696c65
0001b0  64206174
0001b4  206c696e
0001b8  65202564
0001bc  20696e20
0001c0  25730a00
                  |L4.452|
                          DCD      0x0000ffff

                          AREA ||i.lwip_standard_chksum||, CODE, READONLY, ALIGN=2

                  lwip_standard_chksum PROC
;;;134    static u16_t
;;;135    lwip_standard_chksum(void *dataptr, int len)
000000  e92d4078          PUSH     {r3-r6,lr}
;;;136    {
000004  e1a04000          MOV      r4,r0
000008  e1a02001          MOV      r2,r1
;;;137      u8_t *pb = (u8_t *)dataptr;
00000c  e1a0c004          MOV      r12,r4
;;;138      u16_t *ps, t = 0;
000010  e3a00000          MOV      r0,#0
000014  e58d0000          STR      r0,[sp,#0]
;;;139      u32_t sum = 0;
000018  e3a01000          MOV      r1,#0
;;;140      int odd = ((mem_ptr_t)pb & 1);
00001c  e20c5001          AND      r5,r12,#1
;;;141    
;;;142      /* Get aligned to u16_t */
;;;143      if (odd && len > 0) {
000020  e3550000          CMP      r5,#0
000024  0a000004          BEQ      |L5.60|
000028  e3520000          CMP      r2,#0
00002c  da000002          BLE      |L5.60|
;;;144        ((u8_t *)&t)[1] = *pb++;
000030  e4dc0001          LDRB     r0,[r12],#1
000034  e5cd0001          STRB     r0,[sp,#1]
;;;145        len--;
000038  e2422001          SUB      r2,r2,#1
                  |L5.60|
;;;146      }
;;;147    
;;;148      /* Add the bulk of the data */
;;;149      ps = (u16_t *)(void *)pb;
00003c  e1a0300c          MOV      r3,r12
;;;150      while (len > 1) {
000040  ea000002          B        |L5.80|
                  |L5.68|
;;;151        sum += *ps++;
000044  e0d300b2          LDRH     r0,[r3],#2
000048  e0811000          ADD      r1,r1,r0
;;;152        len -= 2;
00004c  e2422002          SUB      r2,r2,#2
                  |L5.80|
000050  e3520001          CMP      r2,#1                 ;150
000054  cafffffa          BGT      |L5.68|
;;;153      }
;;;154    
;;;155      /* Consume left-over byte, if any */
;;;156      if (len > 0) {
000058  e3520000          CMP      r2,#0
00005c  da000001          BLE      |L5.104|
;;;157        ((u8_t *)&t)[0] = *(u8_t *)ps;
000060  e5d30000          LDRB     r0,[r3,#0]
000064  e5cd0000          STRB     r0,[sp,#0]
                  |L5.104|
;;;158      }
;;;159    
;;;160      /* Add end bytes */
;;;161      sum += t;
000068  e1dd00b0          LDRH     r0,[sp,#0]
00006c  e0811000          ADD      r1,r1,r0
;;;162    
;;;163      /* Fold 32-bit sum to 16 bits
;;;164         calling this twice is propably faster than if statements... */
;;;165      sum = FOLD_U32T(sum);
000070  e1a00801          LSL      r0,r1,#16
000074  e1a00820          LSR      r0,r0,#16
000078  e0801821          ADD      r1,r0,r1,LSR #16
;;;166      sum = FOLD_U32T(sum);
00007c  e3c10801          BIC      r0,r1,#0x10000
000080  e0801821          ADD      r1,r0,r1,LSR #16
;;;167    
;;;168      /* Swap if alignment was odd */
;;;169      if (odd) {
000084  e3550000          CMP      r5,#0
000088  0a000003          BEQ      |L5.156|
;;;170        sum = SWAP_BYTES_IN_WORD(sum);
00008c  e1a00c01          LSL      r0,r1,#24
000090  e1a00820          LSR      r0,r0,#16
000094  e2016cff          AND      r6,r1,#0xff00
000098  e1801426          ORR      r1,r0,r6,LSR #8
                  |L5.156|
;;;171      }
;;;172    
;;;173      return (u16_t)sum;
00009c  e1a00801          LSL      r0,r1,#16
0000a0  e1a00820          LSR      r0,r0,#16
;;;174    }
0000a4  e8bd8078          POP      {r3-r6,pc}
;;;175    #endif
                          ENDP

