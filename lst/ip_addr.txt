; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\ip_addr.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ip_addr.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\ip_addr.crf lwip-1.4.1\src\core\ipv4\ip_addr.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ip4_addr_isbroadcast PROC
;;;54     u8_t
;;;55     ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
000000  e3700001          CMN      r0,#1
;;;56     {
;;;57       ip_addr_t ipaddr;
;;;58       ip4_addr_set_u32(&ipaddr, addr);
;;;59     
;;;60       /* all ones (broadcast) or all zeroes (old skool broadcast) */
;;;61       if ((~addr == IPADDR_ANY) ||
;;;62           (addr == IPADDR_ANY)) {
000004  13500000          CMPNE    r0,#0
000008  0a00000d          BEQ      |L1.68|
;;;63         return 1;
;;;64       /* no broadcast support on this network interface? */
;;;65       } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
00000c  e5d1202d          LDRB     r2,[r1,#0x2d]
000010  e3120002          TST      r2,#2
;;;66         /* the given address cannot be a broadcast address
;;;67          * nor can we check against any broadcast addresses */
;;;68         return 0;
;;;69       /* address matches network interface address exactly? => no broadcast */
;;;70       } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
000014  15912004          LDRNE    r2,[r1,#4]
000018  11520000          CMPNE    r2,r0
00001c  0a000006          BEQ      |L1.60|
;;;71         return 0;
;;;72       /*  on the same (sub) network... */
;;;73       } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
000020  e5911008          LDR      r1,[r1,#8]
000024  e0003001          AND      r3,r0,r1
000028  e0022001          AND      r2,r2,r1
00002c  e1530002          CMP      r3,r2
;;;74              /* ...and host identifier bits are all ones? =>... */
;;;75               && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
000030  01800001          ORREQ    r0,r0,r1
000034  03700001          CMNEQ    r0,#1
000038  0a000001          BEQ      |L1.68|
                  |L1.60|
;;;76                (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
;;;77         /* => network broadcast address */
;;;78         return 1;
;;;79       } else {
;;;80         return 0;
00003c  e3a00000          MOV      r0,#0
;;;81       }
;;;82     }
000040  e12fff1e          BX       lr
                  |L1.68|
000044  e3a00001          MOV      r0,#1                 ;78
000048  e12fff1e          BX       lr
;;;83     
                          ENDP

                  ip4_addr_netmask_valid PROC
;;;89     u8_t
;;;90     ip4_addr_netmask_valid(u32_t netmask)
00004c  e92d4010          PUSH     {r4,lr}
;;;91     {
;;;92       u32_t mask;
;;;93       u32_t nm_hostorder = lwip_htonl(netmask);
000050  ebfffffe          BL       lwip_htonl
;;;94     
;;;95       /* first, check for the first zero */
;;;96       for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
000054  e3a01102          MOV      r1,#0x80000000
                  |L1.88|
;;;97         if ((nm_hostorder & mask) == 0) {
000058  e1100001          TST      r0,r1
00005c  0a000006          BEQ      |L1.124|
000060  e1b010a1          LSRS     r1,r1,#1              ;96
000064  1afffffb          BNE      |L1.88|
000068  ea000005          B        |L1.132|
                  |L1.108|
;;;98           break;
;;;99         }
;;;100      }
;;;101      /* then check that there is no one */
;;;102      for (; mask != 0; mask >>= 1) {
;;;103        if ((nm_hostorder & mask) != 0) {
00006c  e1100001          TST      r0,r1
;;;104          /* there is a one after the first zero -> invalid */
;;;105          return 0;
000070  13a00000          MOVNE    r0,#0
000074  01a010a1          LSREQ    r1,r1,#1              ;102
;;;106        }
;;;107      }
;;;108      /* no one after the first zero -> valid */
;;;109      return 1;
;;;110    }
000078  18bd8010          POPNE    {r4,pc}
                  |L1.124|
00007c  e3510000          CMP      r1,#0                 ;102
000080  1afffff9          BNE      |L1.108|
                  |L1.132|
000084  e3a00001          MOV      r0,#1                 ;109
000088  e8bd8010          POP      {r4,pc}
;;;111    
                          ENDP

                  ipaddr_aton PROC
;;;151    int
;;;152    ipaddr_aton(const char *cp, ip_addr_t *addr)
00008c  e92d407f          PUSH     {r0-r6,lr}
;;;153    {
;;;154      u32_t val;
;;;155      u8_t base;
;;;156      char c;
;;;157      u32_t parts[4];
;;;158      u32_t *pp = parts;
;;;159    
;;;160      c = *cp;
000090  e5d02000          LDRB     r2,[r0,#0]
000094  e1a06001          MOV      r6,r1                 ;153
000098  e1a0c00d          MOV      r12,sp                ;158
                  |L1.156|
;;;161      for (;;) {
;;;162        /*
;;;163         * Collect number up to ``.''.
;;;164         * Values are specified as for C:
;;;165         * 0x=hex, 0=octal, 1-9=decimal.
;;;166         */
;;;167        if (!isdigit(c))
00009c  e2421030          SUB      r1,r2,#0x30
0000a0  e351000a          CMP      r1,#0xa
0000a4  2a00004a          BCS      |L1.468|
;;;168          return (0);
;;;169        val = 0;
;;;170        base = 10;
;;;171        if (c == '0') {
0000a8  e3520030          CMP      r2,#0x30
0000ac  e3a04000          MOV      r4,#0                 ;169
0000b0  e3a0300a          MOV      r3,#0xa               ;170
0000b4  1a000005          BNE      |L1.208|
;;;172          c = *++cp;
0000b8  e5f02001          LDRB     r2,[r0,#1]!
;;;173          if (c == 'x' || c == 'X') {
0000bc  e3520078          CMP      r2,#0x78
0000c0  13520058          CMPNE    r2,#0x58
;;;174            base = 16;
;;;175            c = *++cp;
;;;176          } else
;;;177            base = 8;
0000c4  13a03008          MOVNE    r3,#8
0000c8  03a03010          MOVEQ    r3,#0x10              ;174
0000cc  0a00001e          BEQ      |L1.332|
                  |L1.208|
;;;178        }
;;;179        for (;;) {
;;;180          if (isdigit(c)) {
0000d0  e2421030          SUB      r1,r2,#0x30
0000d4  e3510009          CMP      r1,#9
;;;181            val = (val * base) + (int)(c - '0');
0000d8  90212394          MLALS    r1,r4,r3,r2
0000dc  92414030          SUBLS    r4,r1,#0x30
0000e0  9a000019          BLS      |L1.332|
;;;182            c = *++cp;
;;;183          } else if (base == 16 && isxdigit(c)) {
0000e4  e3530010          CMP      r3,#0x10
0000e8  0a00000c          BEQ      |L1.288|
                  |L1.236|
;;;184            val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
;;;185            c = *++cp;
;;;186          } else
;;;187            break;
;;;188        }
;;;189        if (c == '.') {
0000ec  e352002e          CMP      r2,#0x2e
0000f0  0a000017          BEQ      |L1.340|
;;;190          /*
;;;191           * Internet format:
;;;192           *  a.b.c.d
;;;193           *  a.b.c   (with c treated as 16 bits)
;;;194           *  a.b (with b treated as 24 bits)
;;;195           */
;;;196          if (pp >= parts + 3) {
;;;197            return (0);
;;;198          }
;;;199          *pp++ = val;
;;;200          c = *++cp;
;;;201        } else
;;;202          break;
;;;203      }
;;;204      /*
;;;205       * Check for trailing characters.
;;;206       */
;;;207      if (c != '\0' && !isspace(c)) {
0000f4  e3520000          CMP      r2,#0
0000f8  13520020          CMPNE    r2,#0x20
0000fc  0a00001a          BEQ      |L1.364|
000100  e352000c          CMP      r2,#0xc
000104  1352000a          CMPNE    r2,#0xa
000108  0a000017          BEQ      |L1.364|
00010c  e352000d          CMP      r2,#0xd
000110  13520009          CMPNE    r2,#9
000114  1352000b          CMPNE    r2,#0xb
000118  0a000013          BEQ      |L1.364|
00011c  ea00002c          B        |L1.468|
                  |L1.288|
000120  e2425061          SUB      r5,r2,#0x61           ;183
000124  e3550005          CMP      r5,#5                 ;183
000128  82421041          SUBHI    r1,r2,#0x41           ;183
00012c  83510005          CMPHI    r1,#5                 ;183
000130  8affffed          BHI      |L1.236|
000134  e3550019          CMP      r5,#0x19              ;184
000138  93a01061          MOVLS    r1,#0x61              ;184
00013c  83a01041          MOVHI    r1,#0x41              ;184
000140  e0421001          SUB      r1,r2,r1              ;184
000144  e281100a          ADD      r1,r1,#0xa            ;184
000148  e1814204          ORR      r4,r1,r4,LSL #4       ;184
                  |L1.332|
00014c  e5f02001          LDRB     r2,[r0,#1]!           ;175
000150  eaffffde          B        |L1.208|
                  |L1.340|
000154  e28d100c          ADD      r1,sp,#0xc            ;189
000158  e15c0001          CMP      r12,r1                ;196
00015c  2a00001c          BCS      |L1.468|
000160  e48c4004          STR      r4,[r12],#4           ;199
000164  e5f02001          LDRB     r2,[r0,#1]!           ;200
000168  eaffffcb          B        |L1.156|
                  |L1.364|
;;;208        return (0);
;;;209      }
;;;210      /*
;;;211       * Concoct the address according to
;;;212       * the number of parts specified.
;;;213       */
;;;214      switch (pp - parts + 1) {
00016c  e1a0000d          MOV      r0,sp
000170  e04c0000          SUB      r0,r12,r0
000174  e3a01001          MOV      r1,#1
000178  e0810140          ADD      r0,r1,r0,ASR #2
00017c  e3500005          CMP      r0,#5
000180  308ff100          ADDCC    pc,pc,r0,LSL #2
000184  ea00001d          B        |L1.512|
000188  ea000011          B        |L1.468|
00018c  ea000020          B        |L1.532|
000190  ea000001          B        |L1.412|
000194  ea000005          B        |L1.432|
000198  ea00000b          B        |L1.460|
                  |L1.412|
;;;215    
;;;216      case 0:
;;;217        return (0);       /* initial nondigit */
;;;218    
;;;219      case 1:             /* a -- 32 bits */
;;;220        break;
;;;221    
;;;222      case 2:             /* a.b -- 8.24 bits */
;;;223        if (val > 0xffffffUL) {
00019c  e3540401          CMP      r4,#0x1000000
;;;224          return (0);
;;;225        }
;;;226        val |= parts[0] << 24;
0001a0  359d0000          LDRCC    r0,[sp,#0]
0001a4  31844c00          ORRCC    r4,r4,r0,LSL #24
0001a8  2a000009          BCS      |L1.468|
0001ac  ea000018          B        |L1.532|
                  |L1.432|
;;;227        break;
;;;228    
;;;229      case 3:             /* a.b.c -- 8.8.16 bits */
;;;230        if (val > 0xffff) {
0001b0  e3540801          CMP      r4,#0x10000
0001b4  2a000006          BCS      |L1.468|
;;;231          return (0);
;;;232        }
;;;233        val |= (parts[0] << 24) | (parts[1] << 16);
0001b8  e59d0000          LDR      r0,[sp,#0]
0001bc  e59d1004          LDR      r1,[sp,#4]
0001c0  e1a00c00          LSL      r0,r0,#24
0001c4  e1800801          ORR      r0,r0,r1,LSL #16
;;;234        break;
0001c8  ea00000a          B        |L1.504|
                  |L1.460|
;;;235    
;;;236      case 4:             /* a.b.c.d -- 8.8.8.8 bits */
;;;237        if (val > 0xff) {
0001cc  e35400ff          CMP      r4,#0xff
0001d0  9a000002          BLS      |L1.480|
                  |L1.468|
;;;238          return (0);
0001d4  e3a00000          MOV      r0,#0
                  |L1.472|
0001d8  e28dd010          ADD      sp,sp,#0x10
;;;239        }
;;;240        val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
;;;241        break;
;;;242      default:
;;;243        LWIP_ASSERT("unhandled", 0);
;;;244        break;
;;;245      }
;;;246      if (addr) {
;;;247        ip4_addr_set_u32(addr, htonl(val));
;;;248      }
;;;249      return (1);
;;;250    }
0001dc  e8bd8070          POP      {r4-r6,pc}
                  |L1.480|
0001e0  e59d0000          LDR      r0,[sp,#0]            ;240
0001e4  e59d1004          LDR      r1,[sp,#4]            ;240
0001e8  e1a00c00          LSL      r0,r0,#24             ;240
0001ec  e1800801          ORR      r0,r0,r1,LSL #16      ;240
0001f0  e59d1008          LDR      r1,[sp,#8]            ;240
0001f4  e1800401          ORR      r0,r0,r1,LSL #8       ;240
                  |L1.504|
0001f8  e1844000          ORR      r4,r4,r0              ;233
0001fc  ea000004          B        |L1.532|
                  |L1.512|
000200  e28f3f42          ADR      r3,|L1.784|
000204  e3a020f3          MOV      r2,#0xf3              ;243
000208  e28f1f49          ADR      r1,|L1.820|
00020c  e28f0f4b          ADR      r0,|L1.832|
000210  ebfffffe          BL       sysprintf
                  |L1.532|
000214  e3560000          CMP      r6,#0                 ;246
000218  0a000002          BEQ      |L1.552|
00021c  e1a00004          MOV      r0,r4                 ;247
000220  ebfffffe          BL       lwip_htonl
000224  e5860000          STR      r0,[r6,#0]            ;247
                  |L1.552|
000228  e3a00001          MOV      r0,#1                 ;249
00022c  eaffffe9          B        |L1.472|
;;;251    
                          ENDP

                  ipaddr_addr PROC
;;;129    u32_t
;;;130    ipaddr_addr(const char *cp)
000230  e92d4008          PUSH     {r3,lr}
;;;131    {
;;;132      ip_addr_t val;
;;;133    
;;;134      if (ipaddr_aton(cp, &val)) {
000234  e1a0100d          MOV      r1,sp
000238  ebfffffe          BL       ipaddr_aton
00023c  e3500000          CMP      r0,#0
;;;135        return ip4_addr_get_u32(&val);
000240  159d0000          LDRNE    r0,[sp,#0]
;;;136      }
;;;137      return (IPADDR_NONE);
000244  03e00000          MVNEQ    r0,#0
;;;138    }
000248  e8bd8008          POP      {r3,pc}
;;;139    
                          ENDP

                  ipaddr_ntoa_r PROC
;;;275     */
;;;276    char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
00024c  e92d5ffc          PUSH     {r2-r12,lr}
;;;277    {
;;;278      u32_t s_addr;
;;;279      char inv[3];
;;;280      char *rp;
;;;281      u8_t *ap;
;;;282      u8_t rem;
;;;283      u8_t n;
;;;284      u8_t i;
;;;285      int len = 0;
;;;286    
;;;287      s_addr = ip4_addr_get_u32(addr);
000250  e5900000          LDR      r0,[r0,#0]
000254  e3a06000          MOV      r6,#0                 ;285
000258  e1a09002          MOV      r9,r2                 ;277
00025c  e1a0b001          MOV      r11,r1                ;277
;;;288    
;;;289      rp = buf;
000260  e1a05001          MOV      r5,r1
;;;290      ap = (u8_t *)&s_addr;
000264  e1a0700d          MOV      r7,sp
;;;291      for(n = 0; n < 4; n++) {
000268  e1a08006          MOV      r8,r6
00026c  e28da004          ADD      r10,sp,#4             ;279
000270  e58d0000          STR      r0,[sp,#0]            ;289
                  |L1.628|
;;;292        i = 0;
000274  e3a04000          MOV      r4,#0
                  |L1.632|
;;;293        do {
;;;294          rem = *ap % (u8_t)10;
000278  e5d70000          LDRB     r0,[r7,#0]
00027c  e3a0100a          MOV      r1,#0xa
000280  ebfffffe          BL       __aeabi_uidivmod
;;;295          *ap /= (u8_t)10;
000284  e2811030          ADD      r1,r1,#0x30
000288  e5c70000          STRB     r0,[r7,#0]
;;;296          inv[i++] = '0' + rem;
00028c  e7ca1004          STRB     r1,[r10,r4]
000290  e2841001          ADD      r1,r4,#1
;;;297        } while(*ap);
000294  e3500000          CMP      r0,#0
000298  e20140ff          AND      r4,r1,#0xff           ;296
00029c  1afffff5          BNE      |L1.632|
                  |L1.672|
;;;298        while(i--) {
0002a0  e2541001          SUBS     r1,r4,#1
;;;299          if (len++ >= buflen) {
;;;300            return NULL;
;;;301          }
;;;302          *rp++ = inv[i];
;;;303        }
;;;304        if (len++ >= buflen) {
0002a4  e1a00006          MOV      r0,r6
0002a8  e20140ff          AND      r4,r1,#0xff           ;298
0002ac  e2866001          ADD      r6,r6,#1
0002b0  3a000004          BCC      |L1.712|
0002b4  e1500009          CMP      r0,r9                 ;299
0002b8  b7da0004          LDRBLT   r0,[r10,r4]           ;302
0002bc  b4c50001          STRBLT   r0,[r5],#1            ;302
0002c0  bafffff6          BLT      |L1.672|
0002c4  ea000001          B        |L1.720|
                  |L1.712|
0002c8  e1500009          CMP      r0,r9
0002cc  ba000001          BLT      |L1.728|
                  |L1.720|
;;;305          return NULL;
0002d0  e3a00000          MOV      r0,#0
;;;306        }
;;;307        *rp++ = '.';
;;;308        ap++;
;;;309      }
;;;310      *--rp = 0;
;;;311      return buf;
;;;312    }
0002d4  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.728|
0002d8  e3a0002e          MOV      r0,#0x2e              ;307
0002dc  e4c50001          STRB     r0,[r5],#1            ;307
0002e0  e2880001          ADD      r0,r8,#1              ;291
0002e4  e20080ff          AND      r8,r0,#0xff           ;291
0002e8  e3580004          CMP      r8,#4                 ;291
0002ec  23a00000          MOVCS    r0,#0                 ;310
0002f0  25450001          STRBCS   r0,[r5,#-1]           ;310
0002f4  e2877001          ADD      r7,r7,#1              ;291
0002f8  21a0000b          MOVCS    r0,r11                ;311
0002fc  3affffdc          BCC      |L1.628|
000300  e8bd9ffc          POP      {r2-r12,pc}
                          ENDP

                  ipaddr_ntoa PROC
;;;260    char *
;;;261    ipaddr_ntoa(const ip_addr_t *addr)
000304  e59f105c          LDR      r1,|L1.872|
;;;262    {
;;;263      static char str[16];
;;;264      return ipaddr_ntoa_r(addr, str, 16);
000308  e3a02010          MOV      r2,#0x10
00030c  eafffffe          B        ipaddr_ntoa_r
;;;265    }
;;;266    
                          ENDP

                  |L1.784|
000310  6c776970          DCB      "lwip-1.4.1\\src\\core\\ipv4\\ip_addr.c",0
000314  2d312e34
000318  2e315c73
00031c  72635c63
000320  6f72655c
000324  69707634
000328  5c69705f
00032c  61646472
000330  2e6300  
000333  00                DCB      0
                  |L1.820|
000334  756e6861          DCB      "unhandled",0
000338  6e646c65
00033c  6400    
00033e  00                DCB      0
00033f  00                DCB      0
                  |L1.832|
000340  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000344  7274696f
000348  6e202225
00034c  73222066
000350  61696c65
000354  64206174
000358  206c696e
00035c  65202564
000360  20696e20
000364  25730a00
                  |L1.872|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ||str||
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ip_addr_any
                          DCD      0x00000000

                          AREA ||area_number.6||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.constdata||
                  ip_addr_broadcast
                          DCD      0xffffffff
