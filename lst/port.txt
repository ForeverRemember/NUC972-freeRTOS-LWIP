; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\port.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\port.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\port.crf FreeRTOS\Source\portable\RVDS\ARM9_NUC970\port.c]
                          ARM

                          AREA ||i.prvSetupTimerInterrupt||, CODE, READONLY, ALIGN=2

                  prvSetupTimerInterrupt PROC
;;;264    
;;;265    static void prvSetupTimerInterrupt( void )
000000  e92d4010          PUSH     {r4,lr}
;;;266    {
;;;267    uint32_t ulCompareMatch;
;;;268    
;;;269    	// enable the Timer 1 clock	
;;;270      outpw(REG_CLK_PCLKEN0, inpw(REG_CLK_PCLKEN0)| 0x200);
000004  e3a0020b          MOV      r0,#0xb0000000
000008  e5900218          LDR      r0,[r0,#0x218]
00000c  e3800c02          ORR      r0,r0,#0x200
000010  e3a0120b          MOV      r1,#0xb0000000
000014  e5810218          STR      r0,[r1,#0x218]
;;;271      outp32(REG_SYS_APBIPRST0, inp32(REG_SYS_APBIPRST0) | BIT9);
000018  e3a0020b          MOV      r0,#0xb0000000
00001c  e5900064          LDR      r0,[r0,#0x64]
000020  e3800c02          ORR      r0,r0,#0x200
000024  e5810064          STR      r0,[r1,#0x64]
;;;272    	outp32(REG_SYS_APBIPRST0, inp32(REG_SYS_APBIPRST0) & ~BIT9);
000028  e3a0020b          MOV      r0,#0xb0000000
00002c  e5900064          LDR      r0,[r0,#0x64]
000030  e3c00c02          BIC      r0,r0,#0x200
000034  e5810064          STR      r0,[r1,#0x64]
;;;273    
;;;274    	/* Calculate the match value required for our wanted tick rate. */
;;;275    	//ulCompareMatch = EXTERNAL_CRYSTAL_CLOCK / configTICK_RATE_HZ;
;;;276    	ulCompareMatch = 12000000 / configTICK_RATE_HZ;
000038  e59f403c          LDR      r4,|L1.124|
;;;277    
;;;278    	/* Protect against divide by zero.  Using an if() statement still results
;;;279    	in a warning - hence the #if. */
;;;280    	#if portPRESCALE_VALUE != 0
;;;281    	{
;;;282    		ulCompareMatch /= ( portPRESCALE_VALUE + 1 );
;;;283    	}
;;;284    	#endif
;;;285    
;;;286    	/* Setup the AIC for the timer. */
;;;287    	#if 0
;;;288    	/* The ISR installed depends on whether the preemptive or cooperative
;;;289    	scheduler is being used. */
;;;290    	#if configUSE_PREEMPTION == 1
;;;291    	{	
;;;292    		sysInstallISR(IRQ_LEVEL_7, TMR1_IRQn, (PVOID)vPreemptiveTick);
;;;293    	}
;;;294    	#else
;;;295    	{
;;;296    		sysInstallISR(IRQ_LEVEL_7, TMR1_IRQn, (PVOID)vNonPreemptiveTick);
;;;297    	}
;;;298    	#endif
;;;299    	#endif
;;;300    	
;;;301    	_sys_bIsAICInitial = TRUE;
00003c  e3a00001          MOV      r0,#1
000040  e59f1038          LDR      r1,|L1.128|
000044  e5c10000          STRB     r0,[r1,#0]  ; _sys_bIsAICInitial
;;;302    	
;;;303    #if configUSE_PREEMPTION == 1	
;;;304    	sysInstallIrqHandler(vPreemptiveTick);
000048  e59f0034          LDR      r0,|L1.132|
00004c  ebfffffe          BL       sysInstallIrqHandler
;;;305    #endif	
;;;306    
;;;307    	sysEnableInterrupt(TMR1_IRQn);
000050  e3a00011          MOV      r0,#0x11
000054  ebfffffe          BL       sysEnableInterrupt
;;;308    
;;;309    	outpw(REG_TMR1_TICR, ulCompareMatch);
000058  e59f0028          LDR      r0,|L1.136|
00005c  e5804014          STR      r4,[r0,#0x14]
;;;310    	outpw(REG_TMR1_TCSR, (inpw(REG_TMR1_TCSR) & 0x81FFFF00) | (0xD << 27));		// 0xC means CEN and IE were enable	
000060  e5900010          LDR      r0,[r0,#0x10]
000064  e3c0047e          BIC      r0,r0,#0x7e000000
000068  e3c000ff          BIC      r0,r0,#0xff
00006c  e380031a          ORR      r0,r0,#0x68000000
000070  e59f1010          LDR      r1,|L1.136|
000074  e5810010          STR      r0,[r1,#0x10]
;;;311    	
;;;312    }
000078  e8bd8010          POP      {r4,pc}
;;;313    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.124|
                          DCD      0x00002ee0
                  |L1.128|
                          DCD      _sys_bIsAICInitial
                  |L1.132|
                          DCD      vPreemptiveTick
                  |L1.136|
                          DCD      0xb8001000

                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;114     */
;;;115    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  e1a03000          MOV      r3,r0
;;;116    {
;;;117    StackType_t *pxOriginalTOS;
;;;118    
;;;119    	/* Setup the initial stack of the task.  The stack is set exactly as 
;;;120    	expected by the portRESTORE_CONTEXT() macro.
;;;121    
;;;122    	Remember where the top of the (simulated) stack is before we place 
;;;123    	anything on it. */
;;;124    	pxOriginalTOS = pxTopOfStack;
;;;125    	
;;;126    	/* To ensure asserts in tasks.c don't fail, although in this case the assert
;;;127    	is not really required. */
;;;128    	pxTopOfStack--;
000004  e2400004          SUB      r0,r0,#4
;;;129    
;;;130    	/* First on the stack is the return address - which in this case is the
;;;131    	start of the task.  The offset is added to make the return address appear
;;;132    	as it would within an IRQ ISR. */
;;;133    	*pxTopOfStack = ( StackType_t ) pxCode + portINSTRUCTION_SIZE;		
000008  e281c004          ADD      r12,r1,#4
00000c  e580c000          STR      r12,[r0,#0]
;;;134    	pxTopOfStack--;
000010  e2400004          SUB      r0,r0,#4
;;;135    
;;;136    	*pxTopOfStack = ( StackType_t ) 0xaaaaaaaa;	/* R14 */
000014  e59fc0d4          LDR      r12,|L2.240|
000018  e580c000          STR      r12,[r0,#0]
;;;137    	pxTopOfStack--;	
00001c  e2400004          SUB      r0,r0,#4
;;;138    	*pxTopOfStack = ( StackType_t ) pxOriginalTOS; /* Stack used when task starts goes in R13. */
000020  e5803000          STR      r3,[r0,#0]
;;;139    	pxTopOfStack--;
000024  e2400004          SUB      r0,r0,#4
;;;140    	*pxTopOfStack = ( StackType_t ) 0x12121212;	/* R12 */
000028  e59fc0c4          LDR      r12,|L2.244|
00002c  e580c000          STR      r12,[r0,#0]
;;;141    	pxTopOfStack--;	
000030  e2400004          SUB      r0,r0,#4
;;;142    	*pxTopOfStack = ( StackType_t ) 0x11111111;	/* R11 */
000034  e59fc0bc          LDR      r12,|L2.248|
000038  e580c000          STR      r12,[r0,#0]
;;;143    	pxTopOfStack--;	
00003c  e2400004          SUB      r0,r0,#4
;;;144    	*pxTopOfStack = ( StackType_t ) 0x10101010;	/* R10 */
000040  e59fc0b4          LDR      r12,|L2.252|
000044  e580c000          STR      r12,[r0,#0]
;;;145    	pxTopOfStack--;	
000048  e2400004          SUB      r0,r0,#4
;;;146    	*pxTopOfStack = ( StackType_t ) 0x09090909;	/* R9 */
00004c  e59fc0ac          LDR      r12,|L2.256|
000050  e580c000          STR      r12,[r0,#0]
;;;147    	pxTopOfStack--;	
000054  e2400004          SUB      r0,r0,#4
;;;148    	*pxTopOfStack = ( StackType_t ) 0x08080808;	/* R8 */
000058  e1ccc1cc          BIC      r12,r12,r12,ASR #3
00005c  e580c000          STR      r12,[r0,#0]
;;;149    	pxTopOfStack--;	
000060  e2400004          SUB      r0,r0,#4
;;;150    	*pxTopOfStack = ( StackType_t ) 0x07070707;	/* R7 */
000064  e04cc1cc          SUB      r12,r12,r12,ASR #3
000068  e580c000          STR      r12,[r0,#0]
;;;151    	pxTopOfStack--;	
00006c  e2400004          SUB      r0,r0,#4
;;;152    	*pxTopOfStack = ( StackType_t ) 0x06060606;	/* R6 */
000070  e1ccc14c          BIC      r12,r12,r12,ASR #2
000074  e580c000          STR      r12,[r0,#0]
;;;153    	pxTopOfStack--;	
000078  e2400004          SUB      r0,r0,#4
;;;154    	*pxTopOfStack = ( StackType_t ) 0x05050505;	/* R5 */
00007c  e02cc0cc          EOR      r12,r12,r12,ASR #1
000080  e580c000          STR      r12,[r0,#0]
;;;155    	pxTopOfStack--;	
000084  e2400004          SUB      r0,r0,#4
;;;156    	*pxTopOfStack = ( StackType_t ) 0x04040404;	/* R4 */
000088  e1ccc14c          BIC      r12,r12,r12,ASR #2
00008c  e580c000          STR      r12,[r0,#0]
;;;157    	pxTopOfStack--;	
000090  e2400004          SUB      r0,r0,#4
;;;158    	*pxTopOfStack = ( StackType_t ) 0x03030303;	/* R3 */
000094  e04cc14c          SUB      r12,r12,r12,ASR #2
000098  e580c000          STR      r12,[r0,#0]
;;;159    	pxTopOfStack--;	
00009c  e2400004          SUB      r0,r0,#4
;;;160    	*pxTopOfStack = ( StackType_t ) 0x02020202;	/* R2 */
0000a0  e1ccc0cc          BIC      r12,r12,r12,ASR #1
0000a4  e580c000          STR      r12,[r0,#0]
;;;161    	pxTopOfStack--;	
0000a8  e2400004          SUB      r0,r0,#4
;;;162    	*pxTopOfStack = ( StackType_t ) 0x01010101;	/* R1 */
0000ac  e1a0c0cc          ASR      r12,r12,#1
0000b0  e580c000          STR      r12,[r0,#0]
;;;163    	pxTopOfStack--;	
0000b4  e2400004          SUB      r0,r0,#4
;;;164    	*pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */
0000b8  e5802000          STR      r2,[r0,#0]
;;;165    	pxTopOfStack--;
0000bc  e2400004          SUB      r0,r0,#4
;;;166    
;;;167    	/* The last thing onto the stack is the status register, which is set for
;;;168    	system mode, with interrupts enabled. */
;;;169    	*pxTopOfStack = ( StackType_t ) portINITIAL_SPSR;
0000c0  e3a0c01f          MOV      r12,#0x1f
0000c4  e580c000          STR      r12,[r0,#0]
;;;170    
;;;171    	if( ( ( uint32_t ) pxCode & 0x01UL ) != 0x00UL )
0000c8  e201c001          AND      r12,r1,#1
0000cc  e35c0000          CMP      r12,#0
0000d0  0a000002          BEQ      |L2.224|
;;;172    	{
;;;173    		/* We want the task to start in thumb mode. */
;;;174    		*pxTopOfStack |= portTHUMB_MODE_BIT;
0000d4  e590c000          LDR      r12,[r0,#0]
0000d8  e38cc020          ORR      r12,r12,#0x20
0000dc  e580c000          STR      r12,[r0,#0]
                  |L2.224|
;;;175    	}
;;;176    
;;;177    	pxTopOfStack--;
0000e0  e2400004          SUB      r0,r0,#4
;;;178    
;;;179    	/* The code generated by the Keil compiler does not maintain separate
;;;180    	stack and frame pointers. The portENTER_CRITICAL macro cannot therefore
;;;181    	use the stack as per other ports.  Instead a variable is used to keep
;;;182    	track of the critical section nesting.  This variable has to be stored
;;;183    	as part of the task context and is initially set to zero. */
;;;184    	*pxTopOfStack = portNO_CRITICAL_SECTION_NESTING;
0000e4  e3a0c000          MOV      r12,#0
0000e8  e580c000          STR      r12,[r0,#0]
;;;185    
;;;186    	return pxTopOfStack;
;;;187    }
0000ec  e12fff1e          BX       lr
;;;188    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.240|
                          DCD      0xaaaaaaaa
                  |L2.244|
                          DCD      0x12121212
                  |L2.248|
                          DCD      0x11111111
                  |L2.252|
                          DCD      0x10101010
                  |L2.256|
                          DCD      0x09090909

                          AREA ||i.systemIrqHandler||, CODE, READONLY, ALIGN=2

                  systemIrqHandler PROC
;;;212    /* Interrupt Handler */
;;;213    void systemIrqHandler(UINT32 _mIPER, UINT32 _mISNR)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;214    {		
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;215        _mIPER = (_mIPER >> 2) & 0x3f;
00000c  e3a0003f          MOV      r0,#0x3f
000010  e0004124          AND      r4,r0,r4,LSR #2
;;;216    		
;;;217        if (_mISNR != 0)
000014  e3550000          CMP      r5,#0
000018  0a000004          BEQ      |L3.48|
;;;218            if (_mIPER == _mISNR)
00001c  e1540005          CMP      r4,r5
000020  1a000002          BNE      |L3.48|
;;;219                (*sysIrqHandlerTable[_mIPER])();
000024  e59f1014          LDR      r1,|L3.64|
000028  e7910104          LDR      r0,[r1,r4,LSL #2]
00002c  e12fff30          BLX      r0
                  |L3.48|
;;;220    		
;;;221        outpw(REG_AIC_EOSCR, 1);
000030  e3a00001          MOV      r0,#1
000034  e59f1008          LDR      r1,|L3.68|
000038  e5810150          STR      r0,[r1,#0x150]
;;;222    }
00003c  e8bd8070          POP      {r4-r6,pc}
;;;223    
                          ENDP

                  |L3.64|
                          DCD      sysIrqHandlerTable
                  |L3.68|
                          DCD      0xb8002000

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=2

                  vPortEndScheduler PROC
;;;203    
;;;204    void vPortEndScheduler( void )
000000  e12fff1e          BX       lr
;;;205    {
;;;206    	/* It is unlikely that the ARM port will require this function as there
;;;207    	is nothing to return to.  If this is required - stop the tick ISR then
;;;208    	return back to main. */
;;;209    }
;;;210    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;314    
;;;315    void vPortEnterCritical( void )
000000  e10f0000          MRS      r0,APSR ; formerly CPSR
;;;316    {
;;;317    	/* Disable interrupts as per portDISABLE_INTERRUPTS(); 							*/
;;;318    	__disable_irq();
000004  e3800080          ORR      r0,r0,#0x80
000008  e121f000          MSR      CPSR_c,r0
;;;319    
;;;320    	/* Now interrupts are disabled ulCriticalNesting can be accessed 
;;;321    	directly.  Increment ulCriticalNesting to keep a count of how many times
;;;322    	portENTER_CRITICAL() has been called. */
;;;323    	ulCriticalNesting++;
00000c  e59f0010          LDR      r0,|L5.36|
000010  e5900000          LDR      r0,[r0,#0]  ; ulCriticalNesting
000014  e2800001          ADD      r0,r0,#1
000018  e59f1004          LDR      r1,|L5.36|
00001c  e5810000          STR      r0,[r1,#0]  ; ulCriticalNesting
;;;324    }
000020  e12fff1e          BX       lr
;;;325    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.36|
                          DCD      ulCriticalNesting

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;326    
;;;327    void vPortExitCritical( void )
000000  e59f003c          LDR      r0,|L6.68|
;;;328    {
;;;329    	if( ulCriticalNesting > portNO_CRITICAL_NESTING )
000004  e5900000          LDR      r0,[r0,#0]  ; ulCriticalNesting
000008  e3500000          CMP      r0,#0
00000c  0a00000b          BEQ      |L6.64|
;;;330    	{
;;;331    		/* Decrement the nesting count as we are leaving a critical section. */
;;;332    		ulCriticalNesting--;
000010  e59f002c          LDR      r0,|L6.68|
000014  e5900000          LDR      r0,[r0,#0]  ; ulCriticalNesting
000018  e2400001          SUB      r0,r0,#1
00001c  e59f1020          LDR      r1,|L6.68|
000020  e5810000          STR      r0,[r1,#0]  ; ulCriticalNesting
;;;333    
;;;334    		/* If the nesting level has reached zero then interrupts should be
;;;335    		re-enabled. */
;;;336    		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
000024  e2810000          ADD      r0,r1,#0
000028  e5900000          LDR      r0,[r0,#0]  ; ulCriticalNesting
00002c  e3500000          CMP      r0,#0
000030  1a000002          BNE      |L6.64|
;;;337    		{
;;;338    			/* Enable interrupts as per portEXIT_CRITICAL(). */
;;;339    			__enable_irq();
000034  e10f0000          MRS      r0,APSR ; formerly CPSR
000038  e3c00080          BIC      r0,r0,#0x80
00003c  e121f000          MSR      CPSR_c,r0
                  |L6.64|
;;;340    		}
;;;341    	}
;;;342    }
000040  e12fff1e          BX       lr
;;;343    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.68|
                          DCD      ulCriticalNesting

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;189    
;;;190    BaseType_t xPortStartScheduler( void )
000000  e92d4010          PUSH     {r4,lr}
;;;191    {
;;;192    	/* Start the timer that generates the tick ISR. */
;;;193    	prvSetupTimerInterrupt();
000004  ebfffffe          BL       prvSetupTimerInterrupt
;;;194    
;;;195    	/* Start the first task.  This is done from portISR.c as ARM mode must be
;;;196    	used. */
;;;197    	vPortStartFirstTask();
000008  ebfffffe          BL       vPortStartFirstTask
;;;198    
;;;199    	/* Should not get here! */
;;;200    	return 0;
00000c  e3a00000          MOV      r0,#0
;;;201    }
000010  e8bd8010          POP      {r4,pc}
;;;202    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  ulCriticalNesting
                          DCD      0x0000270f
