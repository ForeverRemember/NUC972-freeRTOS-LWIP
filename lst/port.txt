; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\port.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\port.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\port.crf FreeRTOS\Source\portable\RVDS\ARM9_NUC970\port.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;114     */
;;;115    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  e281c004          ADD      r12,r1,#4
;;;116    {
;;;117    StackType_t *pxOriginalTOS;
;;;118    
;;;119    	/* Setup the initial stack of the task.  The stack is set exactly as 
;;;120    	expected by the portRESTORE_CONTEXT() macro.
;;;121    
;;;122    	Remember where the top of the (simulated) stack is before we place 
;;;123    	anything on it. */
;;;124    	pxOriginalTOS = pxTopOfStack;
;;;125    	
;;;126    	/* To ensure asserts in tasks.c don't fail, although in this case the assert
;;;127    	is not really required. */
;;;128    	pxTopOfStack--;
;;;129    
;;;130    	/* First on the stack is the return address - which in this case is the
;;;131    	start of the task.  The offset is added to make the return address appear
;;;132    	as it would within an IRQ ISR. */
;;;133    	*pxTopOfStack = ( StackType_t ) pxCode + portINSTRUCTION_SIZE;		
000004  e500c004          STR      r12,[r0,#-4]
;;;134    	pxTopOfStack--;
;;;135    
;;;136    	*pxTopOfStack = ( StackType_t ) 0xaaaaaaaa;	/* R14 */
000008  e59fc188          LDR      r12,|L1.408|
;;;137    	pxTopOfStack--;	
;;;138    	*pxTopOfStack = ( StackType_t ) pxOriginalTOS; /* Stack used when task starts goes in R13. */
;;;139    	pxTopOfStack--;
;;;140    	*pxTopOfStack = ( StackType_t ) 0x12121212;	/* R12 */
;;;141    	pxTopOfStack--;	
;;;142    	*pxTopOfStack = ( StackType_t ) 0x11111111;	/* R11 */
;;;143    	pxTopOfStack--;	
;;;144    	*pxTopOfStack = ( StackType_t ) 0x10101010;	/* R10 */
;;;145    	pxTopOfStack--;	
;;;146    	*pxTopOfStack = ( StackType_t ) 0x09090909;	/* R9 */
;;;147    	pxTopOfStack--;	
;;;148    	*pxTopOfStack = ( StackType_t ) 0x08080808;	/* R8 */
;;;149    	pxTopOfStack--;	
;;;150    	*pxTopOfStack = ( StackType_t ) 0x07070707;	/* R7 */
;;;151    	pxTopOfStack--;	
;;;152    	*pxTopOfStack = ( StackType_t ) 0x06060606;	/* R6 */
;;;153    	pxTopOfStack--;	
;;;154    	*pxTopOfStack = ( StackType_t ) 0x05050505;	/* R5 */
;;;155    	pxTopOfStack--;	
;;;156    	*pxTopOfStack = ( StackType_t ) 0x04040404;	/* R4 */
;;;157    	pxTopOfStack--;	
;;;158    	*pxTopOfStack = ( StackType_t ) 0x03030303;	/* R3 */
;;;159    	pxTopOfStack--;	
;;;160    	*pxTopOfStack = ( StackType_t ) 0x02020202;	/* R2 */
;;;161    	pxTopOfStack--;	
;;;162    	*pxTopOfStack = ( StackType_t ) 0x01010101;	/* R1 */
;;;163    	pxTopOfStack--;	
;;;164    	*pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */
;;;165    	pxTopOfStack--;
;;;166    
;;;167    	/* The last thing onto the stack is the status register, which is set for
;;;168    	system mode, with interrupts enabled. */
;;;169    	*pxTopOfStack = ( StackType_t ) portINITIAL_SPSR;
;;;170    
;;;171    	if( ( ( uint32_t ) pxCode & 0x01UL ) != 0x00UL )
00000c  e3110001          TST      r1,#1
000010  e500c008          STR      r12,[r0,#-8]          ;138
000014  e59fc180          LDR      r12,|L1.412|
000018  e500000c          STR      r0,[r0,#-0xc]         ;138
00001c  e500c010          STR      r12,[r0,#-0x10]       ;140
000020  e59fc178          LDR      r12,|L1.416|
;;;172    	{
;;;173    		/* We want the task to start in thumb mode. */
;;;174    		*pxTopOfStack |= portTHUMB_MODE_BIT;
000024  13a0103f          MOVNE    r1,#0x3f
000028  e500c014          STR      r12,[r0,#-0x14]       ;142
00002c  e59fc170          LDR      r12,|L1.420|
000030  e500c018          STR      r12,[r0,#-0x18]       ;144
000034  e59fc16c          LDR      r12,|L1.424|
000038  e500c01c          STR      r12,[r0,#-0x1c]       ;146
00003c  e1ccc1cc          BIC      r12,r12,r12,ASR #3    ;148
000040  e500c020          STR      r12,[r0,#-0x20]       ;148
000044  e04cc1cc          SUB      r12,r12,r12,ASR #3    ;150
000048  e500c024          STR      r12,[r0,#-0x24]       ;150
00004c  e1ccc14c          BIC      r12,r12,r12,ASR #2    ;152
000050  e500c028          STR      r12,[r0,#-0x28]       ;152
000054  e02cc0cc          EOR      r12,r12,r12,ASR #1    ;154
000058  e500c02c          STR      r12,[r0,#-0x2c]       ;154
00005c  e1ccc14c          BIC      r12,r12,r12,ASR #2    ;156
000060  e500c030          STR      r12,[r0,#-0x30]       ;156
000064  e04cc14c          SUB      r12,r12,r12,ASR #2    ;158
000068  e500c034          STR      r12,[r0,#-0x34]       ;158
00006c  e1ccc0cc          BIC      r12,r12,r12,ASR #1    ;160
000070  e500c038          STR      r12,[r0,#-0x38]       ;160
000074  e5002040          STR      r2,[r0,#-0x40]        ;164
000078  e1a0c0cc          ASR      r12,r12,#1            ;162
00007c  e3a0201f          MOV      r2,#0x1f              ;169
000080  e500c03c          STR      r12,[r0,#-0x3c]       ;164
000084  e5202044          STR      r2,[r0,#-0x44]!       ;171
000088  15801000          STRNE    r1,[r0,#0]
;;;175    	}
;;;176    
;;;177    	pxTopOfStack--;
;;;178    
;;;179    	/* The code generated by the Keil compiler does not maintain separate
;;;180    	stack and frame pointers. The portENTER_CRITICAL macro cannot therefore
;;;181    	use the stack as per other ports.  Instead a variable is used to keep
;;;182    	track of the critical section nesting.  This variable has to be stored
;;;183    	as part of the task context and is initially set to zero. */
;;;184    	*pxTopOfStack = portNO_CRITICAL_SECTION_NESTING;
00008c  e3a01000          MOV      r1,#0
000090  e5201004          STR      r1,[r0,#-4]!
;;;185    
;;;186    	return pxTopOfStack;
;;;187    }
000094  e12fff1e          BX       lr
;;;188    /*-----------------------------------------------------------*/
                          ENDP

                  xPortStartScheduler PROC
;;;189    
;;;190    BaseType_t xPortStartScheduler( void )
000098  e92d4010          PUSH     {r4,lr}
;;;191    {
00009c  e3a0020b          MOV      r0,#0xb0000000
0000a0  e5901218          LDR      r1,[r0,#0x218]
0000a4  e3811c02          ORR      r1,r1,#0x200
0000a8  e5801218          STR      r1,[r0,#0x218]
0000ac  e5901064          LDR      r1,[r0,#0x64]
0000b0  e3811c02          ORR      r1,r1,#0x200
0000b4  e5801064          STR      r1,[r0,#0x64]
0000b8  e5901064          LDR      r1,[r0,#0x64]
0000bc  e3c11c02          BIC      r1,r1,#0x200
0000c0  e5801064          STR      r1,[r0,#0x64]
0000c4  e59f10e4          LDR      r1,|L1.432|
0000c8  e59f40dc          LDR      r4,|L1.428|
0000cc  e3a00001          MOV      r0,#1
0000d0  e5c10000          STRB     r0,[r1,#0]  ; _sys_bIsAICInitial
0000d4  e59f00d8          LDR      r0,|L1.436|
0000d8  ebfffffe          BL       sysInstallIrqHandler
0000dc  e3a00011          MOV      r0,#0x11
0000e0  ebfffffe          BL       sysEnableInterrupt
0000e4  e59f00cc          LDR      r0,|L1.440|
0000e8  e5804014          STR      r4,[r0,#0x14]
0000ec  e5901010          LDR      r1,[r0,#0x10]
0000f0  e3c1147e          BIC      r1,r1,#0x7e000000
0000f4  e3c110ff          BIC      r1,r1,#0xff
0000f8  e381131a          ORR      r1,r1,#0x68000000
0000fc  e5801010          STR      r1,[r0,#0x10]
;;;192    	/* Start the timer that generates the tick ISR. */
;;;193    	prvSetupTimerInterrupt();
;;;194    
;;;195    	/* Start the first task.  This is done from portISR.c as ARM mode must be
;;;196    	used. */
;;;197    	vPortStartFirstTask();
000100  ebfffffe          BL       vPortStartFirstTask
;;;198    
;;;199    	/* Should not get here! */
;;;200    	return 0;
000104  e3a00000          MOV      r0,#0
;;;201    }
000108  e8bd8010          POP      {r4,pc}
;;;202    /*-----------------------------------------------------------*/
                          ENDP

                  vPortEndScheduler PROC
;;;203    
;;;204    void vPortEndScheduler( void )
00010c  e12fff1e          BX       lr
;;;205    {
;;;206    	/* It is unlikely that the ARM port will require this function as there
;;;207    	is nothing to return to.  If this is required - stop the tick ISR then
;;;208    	return back to main. */
;;;209    }
;;;210    /*-----------------------------------------------------------*/
                          ENDP

                  systemIrqHandler PROC
;;;212    /* Interrupt Handler */
;;;213    void systemIrqHandler(UINT32 _mIPER, UINT32 _mISNR)
000110  e1a00c00          LSL      r0,r0,#24
;;;214    {		
000114  e92d4010          PUSH     {r4,lr}
;;;215        _mIPER = (_mIPER >> 2) & 0x3f;
;;;216    		
;;;217        if (_mISNR != 0)
000118  e3510000          CMP      r1,#0
00011c  e1a00d20          LSR      r0,r0,#26             ;215
000120  0a000003          BEQ      |L1.308|
;;;218            if (_mIPER == _mISNR)
000124  e1500001          CMP      r0,r1
;;;219                (*sysIrqHandlerTable[_mIPER])();
000128  059f108c          LDREQ    r1,|L1.444|
00012c  07910100          LDREQ    r0,[r1,r0,LSL #2]
000130  012fff30          BLXEQ    r0
                  |L1.308|
;;;220    		
;;;221        outpw(REG_AIC_EOSCR, 1);
000134  e3a00001          MOV      r0,#1
000138  e59f1080          LDR      r1,|L1.448|
00013c  e5810150          STR      r0,[r1,#0x150]
;;;222    }
000140  e8bd8010          POP      {r4,pc}
;;;223    
                          ENDP

                  vPortEnterCritical PROC
;;;314    
;;;315    void vPortEnterCritical( void )
000144  e10f0000          MRS      r0,APSR ; formerly CPSR
;;;316    {
;;;317    	/* Disable interrupts as per portDISABLE_INTERRUPTS(); 							*/
;;;318    	__disable_irq();
000148  e3800080          ORR      r0,r0,#0x80
00014c  e121f000          MSR      CPSR_c,r0
;;;319    
;;;320    	/* Now interrupts are disabled ulCriticalNesting can be accessed 
;;;321    	directly.  Increment ulCriticalNesting to keep a count of how many times
;;;322    	portENTER_CRITICAL() has been called. */
;;;323    	ulCriticalNesting++;
000150  e59f006c          LDR      r0,|L1.452|
000154  e5901000          LDR      r1,[r0,#0]  ; ulCriticalNesting
000158  e2811001          ADD      r1,r1,#1
00015c  e5801000          STR      r1,[r0,#0]  ; ulCriticalNesting
;;;324    }
000160  e12fff1e          BX       lr
;;;325    /*-----------------------------------------------------------*/
                          ENDP

                  vPortExitCritical PROC
;;;326    
;;;327    void vPortExitCritical( void )
000164  e59f0058          LDR      r0,|L1.452|
;;;328    {
;;;329    	if( ulCriticalNesting > portNO_CRITICAL_NESTING )
000168  e5901000          LDR      r1,[r0,#0]  ; ulCriticalNesting
00016c  e3510000          CMP      r1,#0
;;;330    	{
;;;331    		/* Decrement the nesting count as we are leaving a critical section. */
;;;332    		ulCriticalNesting--;
;;;333    
;;;334    		/* If the nesting level has reached zero then interrupts should be
;;;335    		re-enabled. */
;;;336    		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
;;;337    		{
;;;338    			/* Enable interrupts as per portEXIT_CRITICAL(). */
;;;339    			__enable_irq();
;;;340    		}
;;;341    	}
;;;342    }
000170  012fff1e          BXEQ     lr
000174  e5901000          LDR      r1,[r0,#0]            ;332  ; ulCriticalNesting
000178  e2411001          SUB      r1,r1,#1              ;332
00017c  e5801000          STR      r1,[r0,#0]            ;332  ; ulCriticalNesting
000180  e5900000          LDR      r0,[r0,#0]            ;336  ; ulCriticalNesting
000184  e3500000          CMP      r0,#0                 ;336
000188  010f0000          MRSEQ    r0,APSR ; formerly CPSR;339
00018c  03c00080          BICEQ    r0,r0,#0x80           ;339
000190  0121f000          MSREQ    CPSR_c,r0             ;339
000194  e12fff1e          BX       lr
;;;343    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.408|
                          DCD      0xaaaaaaaa
                  |L1.412|
                          DCD      0x12121212
                  |L1.416|
                          DCD      0x11111111
                  |L1.420|
                          DCD      0x10101010
                  |L1.424|
                          DCD      0x09090909
                  |L1.428|
                          DCD      0x00002ee0
                  |L1.432|
                          DCD      _sys_bIsAICInitial
                  |L1.436|
                          DCD      vPreemptiveTick
                  |L1.440|
                          DCD      0xb8001000
                  |L1.444|
                          DCD      sysIrqHandlerTable
                  |L1.448|
                          DCD      0xb8002000
                  |L1.452|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  ulCriticalNesting
                          DCD      0x0000270f
