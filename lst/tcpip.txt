; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tcpip.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tcpip.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\tcpip.crf lwip-1.4.1\src\api\tcpip.c]
                          ARM

                          AREA ||i.mem_free_callback||, CODE, READONLY, ALIGN=2

                  mem_free_callback PROC
;;;505    err_t
;;;506    mem_free_callback(void *m)
000000  e92d4010          PUSH     {r4,lr}
;;;507    {
000004  e1a04000          MOV      r4,r0
;;;508      return tcpip_callback_with_block(mem_free, m, 0);
000008  e3a02000          MOV      r2,#0
00000c  e1a01004          MOV      r1,r4
000010  e59f0004          LDR      r0,|L1.28|
000014  ebfffffe          BL       tcpip_callback_with_block
;;;509    }
000018  e8bd8010          POP      {r4,pc}
;;;510    
                          ENDP

                  |L1.28|
                          DCD      mem_free

                          AREA ||i.pbuf_free_callback||, CODE, READONLY, ALIGN=2

                  pbuf_free_callback PROC
;;;492    err_t
;;;493    pbuf_free_callback(struct pbuf *p)
000000  e92d4010          PUSH     {r4,lr}
;;;494    {
000004  e1a04000          MOV      r4,r0
;;;495      return tcpip_callback_with_block(pbuf_free_int, p, 0);
000008  e3a02000          MOV      r2,#0
00000c  e1a01004          MOV      r1,r4
000010  e59f0004          LDR      r0,|L2.28|
000014  ebfffffe          BL       tcpip_callback_with_block
;;;496    }
000018  e8bd8010          POP      {r4,pc}
;;;497    
                          ENDP

                  |L2.28|
                          DCD      pbuf_free_int

                          AREA ||i.pbuf_free_int||, CODE, READONLY, ALIGN=2

                  pbuf_free_int PROC
;;;479    static void
;;;480    pbuf_free_int(void *p)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;481    {
000004  e1a04000          MOV      r4,r0
;;;482      struct pbuf *q = (struct pbuf *)p;
000008  e1a05004          MOV      r5,r4
;;;483      pbuf_free(q);
00000c  e1a00005          MOV      r0,r5
000010  ebfffffe          BL       pbuf_free
;;;484    }
000014  e8bd8070          POP      {r4-r6,pc}
;;;485    
                          ENDP


                          AREA ||i.tcpip_callback_with_block||, CODE, READONLY, ALIGN=2

                  tcpip_callback_with_block PROC
;;;210    err_t
;;;211    tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;212    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a07002          MOV      r7,r2
;;;213      struct tcpip_msg *msg;
;;;214    
;;;215      if (sys_mbox_valid(&mbox)) {
000010  e59f0084          LDR      r0,|L4.156|
000014  ebfffffe          BL       sys_mbox_valid
000018  e3500000          CMP      r0,#0
00001c  0a00001c          BEQ      |L4.148|
;;;216        msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
000020  e3a00005          MOV      r0,#5
000024  ebfffffe          BL       memp_malloc
000028  e1a04000          MOV      r4,r0
;;;217        if (msg == NULL) {
00002c  e3540000          CMP      r4,#0
000030  1a000001          BNE      |L4.60|
;;;218          return ERR_MEM;
000034  e3e00000          MVN      r0,#0
                  |L4.56|
;;;219        }
;;;220    
;;;221        msg->type = TCPIP_MSG_CALLBACK;
;;;222        msg->msg.cb.function = function;
;;;223        msg->msg.cb.ctx = ctx;
;;;224        if (block) {
;;;225          sys_mbox_post(&mbox, msg);
;;;226        } else {
;;;227          if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
;;;228            memp_free(MEMP_TCPIP_MSG_API, msg);
;;;229            return ERR_MEM;
;;;230          }
;;;231        }
;;;232        return ERR_OK;
;;;233      }
;;;234      return ERR_VAL;
;;;235    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L4.60|
00003c  e3a00003          MOV      r0,#3                 ;221
000040  e5c40000          STRB     r0,[r4,#0]            ;221
000044  e5845008          STR      r5,[r4,#8]            ;222
000048  e584600c          STR      r6,[r4,#0xc]          ;223
00004c  e3570000          CMP      r7,#0                 ;224
000050  0a000003          BEQ      |L4.100|
000054  e1a01004          MOV      r1,r4                 ;225
000058  e59f003c          LDR      r0,|L4.156|
00005c  ebfffffe          BL       sys_mbox_post
000060  ea000009          B        |L4.140|
                  |L4.100|
000064  e1a01004          MOV      r1,r4                 ;227
000068  e59f002c          LDR      r0,|L4.156|
00006c  ebfffffe          BL       sys_mbox_trypost
000070  e3500000          CMP      r0,#0                 ;227
000074  0a000004          BEQ      |L4.140|
000078  e1a01004          MOV      r1,r4                 ;228
00007c  e3a00005          MOV      r0,#5                 ;228
000080  ebfffffe          BL       memp_free
000084  e3e00000          MVN      r0,#0                 ;229
000088  eaffffea          B        |L4.56|
                  |L4.140|
00008c  e3a00000          MOV      r0,#0                 ;232
000090  eaffffe8          B        |L4.56|
                  |L4.148|
000094  e3e00005          MVN      r0,#5                 ;234
000098  eaffffe6          B        |L4.56|
;;;236    
                          ENDP

                  |L4.156|
                          DCD      mbox

                          AREA ||i.tcpip_callbackmsg_delete||, CODE, READONLY, ALIGN=2

                  tcpip_callbackmsg_delete PROC
;;;424     */
;;;425    void tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg)
000000  e92d4010          PUSH     {r4,lr}
;;;426    {
000004  e1a04000          MOV      r4,r0
;;;427      memp_free(MEMP_TCPIP_MSG_API, msg);
000008  e1a01004          MOV      r1,r4
00000c  e3a00005          MOV      r0,#5
000010  ebfffffe          BL       memp_free
;;;428    }
000014  e8bd8010          POP      {r4,pc}
;;;429    
                          ENDP


                          AREA ||i.tcpip_callbackmsg_new||, CODE, READONLY, ALIGN=2

                  tcpip_callbackmsg_new PROC
;;;407     */
;;;408    struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;409    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;410      struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
00000c  e3a00005          MOV      r0,#5
000010  ebfffffe          BL       memp_malloc
000014  e1a04000          MOV      r4,r0
;;;411      if (msg == NULL) {
000018  e3540000          CMP      r4,#0
00001c  1a000001          BNE      |L6.40|
;;;412        return NULL;
000020  e3a00000          MOV      r0,#0
                  |L6.36|
;;;413      }
;;;414      msg->type = TCPIP_MSG_CALLBACK_STATIC;
;;;415      msg->msg.cb.function = function;
;;;416      msg->msg.cb.ctx = ctx;
;;;417      return (struct tcpip_callback_msg*)msg;
;;;418    }
000024  e8bd8070          POP      {r4-r6,pc}
                  |L6.40|
000028  e3a00004          MOV      r0,#4                 ;414
00002c  e5c40000          STRB     r0,[r4,#0]            ;414
000030  e5845008          STR      r5,[r4,#8]            ;415
000034  e584600c          STR      r6,[r4,#0xc]          ;416
000038  e1a00004          MOV      r0,r4                 ;417
00003c  eafffff8          B        |L6.36|
;;;419    
                          ENDP


                          AREA ||i.tcpip_init||, CODE, READONLY, ALIGN=2

                  tcpip_init PROC
;;;454    void
;;;455    tcpip_init(tcpip_init_done_fn initfunc, void *arg)
000000  e92d4038          PUSH     {r3-r5,lr}
;;;456    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;457      lwip_init();
00000c  ebfffffe          BL       lwip_init
;;;458    
;;;459      tcpip_init_done = initfunc;
000010  e59f0060          LDR      r0,|L7.120|
000014  e5804000          STR      r4,[r0,#0]  ; tcpip_init_done
;;;460      tcpip_init_done_arg = arg;
000018  e59f005c          LDR      r0,|L7.124|
00001c  e5805000          STR      r5,[r0,#0]  ; tcpip_init_done_arg
;;;461      if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
000020  e3a01000          MOV      r1,#0
000024  e59f0054          LDR      r0,|L7.128|
000028  ebfffffe          BL       sys_mbox_new
00002c  e3500000          CMP      r0,#0
000030  0a000008          BEQ      |L7.88|
;;;462        LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
000034  e1a00000          MOV      r0,r0
000038  e1a00000          MOV      r0,r0
00003c  e28f3040          ADR      r3,|L7.132|
000040  e59f2058          LDR      r2,|L7.160|
000044  e28f1058          ADR      r1,|L7.164|
000048  e28f0078          ADR      r0,|L7.200|
00004c  ebfffffe          BL       sysprintf
000050  e1a00000          MOV      r0,r0
000054  e1a00000          MOV      r0,r0
                  |L7.88|
;;;463      }
;;;464    #if LWIP_TCPIP_CORE_LOCKING
;;;465      if(sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
;;;466        LWIP_ASSERT("failed to create lock_tcpip_core", 0);
;;;467      }
;;;468    #endif /* LWIP_TCPIP_CORE_LOCKING */
;;;469    
;;;470      sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
000058  e3a0000b          MOV      r0,#0xb
00005c  e3a03000          MOV      r3,#0
000060  e1a02003          MOV      r2,r3
000064  e59f1084          LDR      r1,|L7.240|
000068  e58d0000          STR      r0,[sp,#0]
00006c  e28f0080          ADR      r0,|L7.244|
000070  ebfffffe          BL       sys_thread_new
;;;471    }
000074  e8bd8038          POP      {r3-r5,pc}
;;;472    
                          ENDP

                  |L7.120|
                          DCD      tcpip_init_done
                  |L7.124|
                          DCD      tcpip_init_done_arg
                  |L7.128|
                          DCD      mbox
                  |L7.132|
000084  6c776970          DCB      "lwip-1.4.1\\src\\api\\tcpip.c",0
000088  2d312e34
00008c  2e315c73
000090  72635c61
000094  70695c74
000098  63706970
00009c  2e6300  
00009f  00                DCB      0
                  |L7.160|
                          DCD      0x000001ce
                  |L7.164|
0000a4  6661696c          DCB      "failed to create tcpip_thread mbox",0
0000a8  65642074
0000ac  6f206372
0000b0  65617465
0000b4  20746370
0000b8  69705f74
0000bc  68726561
0000c0  64206d62
0000c4  6f7800  
0000c7  00                DCB      0
                  |L7.200|
0000c8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000cc  7274696f
0000d0  6e202225
0000d4  73222066
0000d8  61696c65
0000dc  64206174
0000e0  206c696e
0000e4  65202564
0000e8  20696e20
0000ec  25730a00
                  |L7.240|
                          DCD      tcpip_thread
                  |L7.244|
0000f4  74637069          DCB      "tcpip_thread",0
0000f8  705f7468
0000fc  72656164
000100  00      
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0

                          AREA ||i.tcpip_input||, CODE, READONLY, ALIGN=2

                  tcpip_input PROC
;;;160    err_t
;;;161    tcpip_input(struct pbuf *p, struct netif *inp)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;162    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;163    #if LWIP_TCPIP_CORE_LOCKING_INPUT
;;;164      err_t ret;
;;;165      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_input: PACKET %p/%p\n", (void *)p, (void *)inp));
;;;166      LOCK_TCPIP_CORE();
;;;167    #if LWIP_ETHERNET
;;;168      if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
;;;169        ret = ethernet_input(p, inp);
;;;170      } else
;;;171    #endif /* LWIP_ETHERNET */
;;;172      {
;;;173        ret = ip_input(p, inp);
;;;174      }
;;;175      UNLOCK_TCPIP_CORE();
;;;176      return ret;
;;;177    #else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;178      struct tcpip_msg *msg;
;;;179    
;;;180      if (!sys_mbox_valid(&mbox)) {
00000c  e59f006c          LDR      r0,|L8.128|
000010  ebfffffe          BL       sys_mbox_valid
000014  e3500000          CMP      r0,#0
000018  1a000001          BNE      |L8.36|
;;;181        return ERR_VAL;
00001c  e3e00005          MVN      r0,#5
                  |L8.32|
;;;182      }
;;;183      msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
;;;184      if (msg == NULL) {
;;;185        return ERR_MEM;
;;;186      }
;;;187    
;;;188      msg->type = TCPIP_MSG_INPKT;
;;;189      msg->msg.inp.p = p;
;;;190      msg->msg.inp.netif = inp;
;;;191      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
;;;192        memp_free(MEMP_TCPIP_MSG_INPKT, msg);
;;;193        return ERR_MEM;
;;;194      }
;;;195      return ERR_OK;
;;;196    #endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;197    }
000020  e8bd8070          POP      {r4-r6,pc}
                  |L8.36|
000024  e3a00006          MOV      r0,#6                 ;183
000028  ebfffffe          BL       memp_malloc
00002c  e1a04000          MOV      r4,r0                 ;183
000030  e3540000          CMP      r4,#0                 ;184
000034  1a000001          BNE      |L8.64|
000038  e3e00000          MVN      r0,#0                 ;185
00003c  eafffff7          B        |L8.32|
                  |L8.64|
000040  e3a00000          MOV      r0,#0                 ;188
000044  e5c40000          STRB     r0,[r4,#0]            ;188
000048  e5845008          STR      r5,[r4,#8]            ;189
00004c  e584600c          STR      r6,[r4,#0xc]          ;190
000050  e1a01004          MOV      r1,r4                 ;191
000054  e59f0024          LDR      r0,|L8.128|
000058  ebfffffe          BL       sys_mbox_trypost
00005c  e3500000          CMP      r0,#0                 ;191
000060  0a000004          BEQ      |L8.120|
000064  e1a01004          MOV      r1,r4                 ;192
000068  e3a00006          MOV      r0,#6                 ;192
00006c  ebfffffe          BL       memp_free
000070  e3e00000          MVN      r0,#0                 ;193
000074  eaffffe9          B        |L8.32|
                  |L8.120|
000078  e3a00000          MOV      r0,#0                 ;195
00007c  eaffffe7          B        |L8.32|
;;;198    
                          ENDP

                  |L8.128|
                          DCD      mbox

                          AREA ||i.tcpip_thread||, CODE, READONLY, ALIGN=2

                  tcpip_thread PROC
;;;73     static void
;;;74     tcpip_thread(void *arg)
000000  e92d4008          PUSH     {r3,lr}
;;;75     {
;;;76       struct tcpip_msg *msg;
;;;77       LWIP_UNUSED_ARG(arg);
;;;78     
;;;79       if (tcpip_init_done != NULL) {
000004  e59f015c          LDR      r0,|L9.360|
000008  e5900000          LDR      r0,[r0,#0]  ; tcpip_init_done
00000c  e3500000          CMP      r0,#0
000010  0a000004          BEQ      |L9.40|
;;;80         tcpip_init_done(tcpip_init_done_arg);
000014  e59f0150          LDR      r0,|L9.364|
000018  e5900000          LDR      r0,[r0,#0]  ; tcpip_init_done_arg
00001c  e59f1144          LDR      r1,|L9.360|
000020  e5911000          LDR      r1,[r1,#0]  ; tcpip_init_done
000024  e12fff31          BLX      r1
                  |L9.40|
;;;81       }
;;;82     
;;;83       LOCK_TCPIP_CORE();
;;;84       while (1) {                          /* MAIN Loop */
000028  ea00004d          B        |L9.356|
                  |L9.44|
;;;85         UNLOCK_TCPIP_CORE();
;;;86         LWIP_TCPIP_THREAD_ALIVE();
;;;87         /* wait for a message, timeouts are processed while waiting */
;;;88         sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
00002c  e1a0100d          MOV      r1,sp
000030  e59f0138          LDR      r0,|L9.368|
000034  ebfffffe          BL       sys_timeouts_mbox_fetch
;;;89         LOCK_TCPIP_CORE();
;;;90         switch (msg->type) {
000038  e59d0000          LDR      r0,[sp,#0]
00003c  e5d00000          LDRB     r0,[r0,#0]
000040  e3500005          CMP      r0,#5
000044  308ff100          ADDCC    pc,pc,r0,LSL #2
000048  ea000039          B        |L9.308|
00004c  ea000003          B        |L9.96|
000050  ea000016          B        |L9.176|
000054  ea00001e          B        |L9.212|
000058  ea000026          B        |L9.248|
00005c  ea00002e          B        |L9.284|
                  |L9.96|
;;;91     #if LWIP_NETCONN
;;;92         case TCPIP_MSG_API:
;;;93           LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
;;;94           msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
;;;95           break;
;;;96     #endif /* LWIP_NETCONN */
;;;97     
;;;98     #if !LWIP_TCPIP_CORE_LOCKING_INPUT
;;;99         case TCPIP_MSG_INPKT:
000060  e1a00000          MOV      r0,r0
;;;100          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
;;;101    #if LWIP_ETHERNET
;;;102          if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
000064  e59d0000          LDR      r0,[sp,#0]
000068  e590000c          LDR      r0,[r0,#0xc]
00006c  e5d0002d          LDRB     r0,[r0,#0x2d]
000070  e2000060          AND      r0,r0,#0x60
000074  e3500000          CMP      r0,#0
000078  0a000004          BEQ      |L9.144|
;;;103            ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
00007c  e59d2000          LDR      r2,[sp,#0]
000080  e5920008          LDR      r0,[r2,#8]
000084  e592100c          LDR      r1,[r2,#0xc]
000088  ebfffffe          BL       ethernet_input
00008c  ea000003          B        |L9.160|
                  |L9.144|
;;;104          } else
;;;105    #endif /* LWIP_ETHERNET */
;;;106          {
;;;107            ip_input(msg->msg.inp.p, msg->msg.inp.netif);
000090  e59d2000          LDR      r2,[sp,#0]
000094  e5920008          LDR      r0,[r2,#8]
000098  e592100c          LDR      r1,[r2,#0xc]
00009c  ebfffffe          BL       ip_input
                  |L9.160|
;;;108          }
;;;109          memp_free(MEMP_TCPIP_MSG_INPKT, msg);
0000a0  e3a00006          MOV      r0,#6
0000a4  e59d1000          LDR      r1,[sp,#0]
0000a8  ebfffffe          BL       memp_free
;;;110          break;
0000ac  ea00002b          B        |L9.352|
                  |L9.176|
;;;111    #endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;112    
;;;113    #if LWIP_NETIF_API
;;;114        case TCPIP_MSG_NETIFAPI:
;;;115          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: Netif API message %p\n", (void *)msg));
;;;116          msg->msg.netifapimsg->function(&(msg->msg.netifapimsg->msg));
;;;117          break;
;;;118    #endif /* LWIP_NETIF_API */
;;;119    
;;;120    #if LWIP_TCPIP_TIMEOUT
;;;121        case TCPIP_MSG_TIMEOUT:
0000b0  e1a00000          MOV      r0,r0
;;;122          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
;;;123          sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
0000b4  e59d3000          LDR      r3,[sp,#0]
0000b8  e2832008          ADD      r2,r3,#8
0000bc  e8920007          LDM      r2,{r0-r2}
0000c0  ebfffffe          BL       sys_timeout
;;;124          memp_free(MEMP_TCPIP_MSG_API, msg);
0000c4  e3a00005          MOV      r0,#5
0000c8  e59d1000          LDR      r1,[sp,#0]
0000cc  ebfffffe          BL       memp_free
;;;125          break;
0000d0  ea000022          B        |L9.352|
                  |L9.212|
;;;126        case TCPIP_MSG_UNTIMEOUT:
0000d4  e1a00000          MOV      r0,r0
;;;127          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
;;;128          sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
0000d8  e59d2000          LDR      r2,[sp,#0]
0000dc  e592000c          LDR      r0,[r2,#0xc]
0000e0  e5921010          LDR      r1,[r2,#0x10]
0000e4  ebfffffe          BL       sys_untimeout
;;;129          memp_free(MEMP_TCPIP_MSG_API, msg);
0000e8  e3a00005          MOV      r0,#5
0000ec  e59d1000          LDR      r1,[sp,#0]
0000f0  ebfffffe          BL       memp_free
;;;130          break;
0000f4  ea000019          B        |L9.352|
                  |L9.248|
;;;131    #endif /* LWIP_TCPIP_TIMEOUT */
;;;132    
;;;133        case TCPIP_MSG_CALLBACK:
0000f8  e1a00000          MOV      r0,r0
;;;134          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
;;;135          msg->msg.cb.function(msg->msg.cb.ctx);
0000fc  e59d2000          LDR      r2,[sp,#0]
000100  e592000c          LDR      r0,[r2,#0xc]
000104  e5921008          LDR      r1,[r2,#8]
000108  e12fff31          BLX      r1
;;;136          memp_free(MEMP_TCPIP_MSG_API, msg);
00010c  e3a00005          MOV      r0,#5
000110  e59d1000          LDR      r1,[sp,#0]
000114  ebfffffe          BL       memp_free
;;;137          break;
000118  ea000010          B        |L9.352|
                  |L9.284|
;;;138    
;;;139        case TCPIP_MSG_CALLBACK_STATIC:
00011c  e1a00000          MOV      r0,r0
;;;140          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
;;;141          msg->msg.cb.function(msg->msg.cb.ctx);
000120  e59d2000          LDR      r2,[sp,#0]
000124  e592000c          LDR      r0,[r2,#0xc]
000128  e5921008          LDR      r1,[r2,#8]
00012c  e12fff31          BLX      r1
;;;142          break;
000130  ea00000a          B        |L9.352|
                  |L9.308|
;;;143    
;;;144        default:
000134  e1a00000          MOV      r0,r0
;;;145          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
;;;146          LWIP_ASSERT("tcpip_thread: invalid message", 0);
000138  e1a00000          MOV      r0,r0
00013c  e1a00000          MOV      r0,r0
000140  e28f302c          ADR      r3,|L9.372|
000144  e3a02092          MOV      r2,#0x92
000148  e28f1040          ADR      r1,|L9.400|
00014c  e28f005c          ADR      r0,|L9.432|
000150  ebfffffe          BL       sysprintf
000154  e1a00000          MOV      r0,r0
000158  e1a00000          MOV      r0,r0
;;;147          break;
00015c  e1a00000          MOV      r0,r0
                  |L9.352|
000160  e1a00000          MOV      r0,r0                 ;110
                  |L9.356|
000164  eaffffb0          B        |L9.44|
;;;148        }
;;;149      }
;;;150    }
;;;151    
                          ENDP

                  |L9.360|
                          DCD      tcpip_init_done
                  |L9.364|
                          DCD      tcpip_init_done_arg
                  |L9.368|
                          DCD      mbox
                  |L9.372|
000174  6c776970          DCB      "lwip-1.4.1\\src\\api\\tcpip.c",0
000178  2d312e34
00017c  2e315c73
000180  72635c61
000184  70695c74
000188  63706970
00018c  2e6300  
00018f  00                DCB      0
                  |L9.400|
000190  74637069          DCB      "tcpip_thread: invalid message",0
000194  705f7468
000198  72656164
00019c  3a20696e
0001a0  76616c69
0001a4  64206d65
0001a8  73736167
0001ac  6500    
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L9.432|
0001b0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001b4  7274696f
0001b8  6e202225
0001bc  73222066
0001c0  61696c65
0001c4  64206174
0001c8  206c696e
0001cc  65202564
0001d0  20696e20
0001d4  25730a00

                          AREA ||i.tcpip_timeout||, CODE, READONLY, ALIGN=2

                  tcpip_timeout PROC
;;;246    err_t
;;;247    tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;248    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a07002          MOV      r7,r2
;;;249      struct tcpip_msg *msg;
;;;250    
;;;251      if (sys_mbox_valid(&mbox)) {
000010  e59f0054          LDR      r0,|L10.108|
000014  ebfffffe          BL       sys_mbox_valid
000018  e3500000          CMP      r0,#0
00001c  0a000010          BEQ      |L10.100|
;;;252        msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
000020  e3a00005          MOV      r0,#5
000024  ebfffffe          BL       memp_malloc
000028  e1a04000          MOV      r4,r0
;;;253        if (msg == NULL) {
00002c  e3540000          CMP      r4,#0
000030  1a000001          BNE      |L10.60|
;;;254          return ERR_MEM;
000034  e3e00000          MVN      r0,#0
                  |L10.56|
;;;255        }
;;;256    
;;;257        msg->type = TCPIP_MSG_TIMEOUT;
;;;258        msg->msg.tmo.msecs = msecs;
;;;259        msg->msg.tmo.h = h;
;;;260        msg->msg.tmo.arg = arg;
;;;261        sys_mbox_post(&mbox, msg);
;;;262        return ERR_OK;
;;;263      }
;;;264      return ERR_VAL;
;;;265    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L10.60|
00003c  e3a00001          MOV      r0,#1                 ;257
000040  e5c40000          STRB     r0,[r4,#0]            ;257
000044  e5845008          STR      r5,[r4,#8]            ;258
000048  e584600c          STR      r6,[r4,#0xc]          ;259
00004c  e5847010          STR      r7,[r4,#0x10]         ;260
000050  e1a01004          MOV      r1,r4                 ;261
000054  e59f0010          LDR      r0,|L10.108|
000058  ebfffffe          BL       sys_mbox_post
00005c  e3a00000          MOV      r0,#0                 ;262
000060  eafffff4          B        |L10.56|
                  |L10.100|
000064  e3e00005          MVN      r0,#5                 ;264
000068  eafffff2          B        |L10.56|
;;;266    
                          ENDP

                  |L10.108|
                          DCD      mbox

                          AREA ||i.tcpip_trycallback||, CODE, READONLY, ALIGN=2

                  tcpip_trycallback PROC
;;;437    err_t
;;;438    tcpip_trycallback(struct tcpip_callback_msg* msg)
000000  e92d4010          PUSH     {r4,lr}
;;;439    {
000004  e1a04000          MOV      r4,r0
;;;440      if (!sys_mbox_valid(&mbox)) {
000008  e59f0020          LDR      r0,|L11.48|
00000c  ebfffffe          BL       sys_mbox_valid
000010  e3500000          CMP      r0,#0
000014  1a000001          BNE      |L11.32|
;;;441        return ERR_VAL;
000018  e3e00005          MVN      r0,#5
                  |L11.28|
;;;442      }
;;;443      return sys_mbox_trypost(&mbox, msg);
;;;444    }
00001c  e8bd8010          POP      {r4,pc}
                  |L11.32|
000020  e1a01004          MOV      r1,r4                 ;443
000024  e59f0004          LDR      r0,|L11.48|
000028  ebfffffe          BL       sys_mbox_trypost
00002c  eafffffa          B        |L11.28|
;;;445    
                          ENDP

                  |L11.48|
                          DCD      mbox

                          AREA ||i.tcpip_untimeout||, CODE, READONLY, ALIGN=2

                  tcpip_untimeout PROC
;;;275    err_t
;;;276    tcpip_untimeout(sys_timeout_handler h, void *arg)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;277    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;278      struct tcpip_msg *msg;
;;;279    
;;;280      if (sys_mbox_valid(&mbox)) {
00000c  e59f0050          LDR      r0,|L12.100|
000010  ebfffffe          BL       sys_mbox_valid
000014  e3500000          CMP      r0,#0
000018  0a00000f          BEQ      |L12.92|
;;;281        msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
00001c  e3a00005          MOV      r0,#5
000020  ebfffffe          BL       memp_malloc
000024  e1a04000          MOV      r4,r0
;;;282        if (msg == NULL) {
000028  e3540000          CMP      r4,#0
00002c  1a000001          BNE      |L12.56|
;;;283          return ERR_MEM;
000030  e3e00000          MVN      r0,#0
                  |L12.52|
;;;284        }
;;;285    
;;;286        msg->type = TCPIP_MSG_UNTIMEOUT;
;;;287        msg->msg.tmo.h = h;
;;;288        msg->msg.tmo.arg = arg;
;;;289        sys_mbox_post(&mbox, msg);
;;;290        return ERR_OK;
;;;291      }
;;;292      return ERR_VAL;
;;;293    }
000034  e8bd8070          POP      {r4-r6,pc}
                  |L12.56|
000038  e3a00002          MOV      r0,#2                 ;286
00003c  e5c40000          STRB     r0,[r4,#0]            ;286
000040  e584500c          STR      r5,[r4,#0xc]          ;287
000044  e5846010          STR      r6,[r4,#0x10]         ;288
000048  e1a01004          MOV      r1,r4                 ;289
00004c  e59f0010          LDR      r0,|L12.100|
000050  ebfffffe          BL       sys_mbox_post
000054  e3a00000          MOV      r0,#0                 ;290
000058  eafffff5          B        |L12.52|
                  |L12.92|
00005c  e3e00005          MVN      r0,#5                 ;292
000060  eafffff3          B        |L12.52|
;;;294    #endif /* LWIP_TCPIP_TIMEOUT */
                          ENDP

                  |L12.100|
                          DCD      mbox

                          AREA ||.data||, DATA, ALIGN=2

                  tcpip_init_done
                          DCD      0x00000000
                  tcpip_init_done_arg
                          DCD      0x00000000
                  mbox
                          DCD      0x00000000
