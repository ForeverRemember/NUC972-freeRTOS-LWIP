; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\system_nuc970.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\system_nuc970.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\system_nuc970.crf Driver\Source\system_nuc970.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sysGetCacheState PROC
;;;399    
;;;400    BOOL sysGetCacheState()
000000  e59f05b8          LDR      r0,|L1.1472|
;;;401    {
;;;402        return _sys_IsCacheOn;
000004  e5d00000          LDRB     r0,[r0,#0]  ; _sys_IsCacheOn
;;;403    }
000008  e12fff1e          BX       lr
;;;404    
                          ENDP

                  sysGetPhyPageAddr PROC
;;;40     
;;;41     unsigned int sysGetPhyPageAddr(unsigned int vaddr)
00000c  e59f25ac          LDR      r2,|L1.1472|
;;;42     {
;;;43         int table_num, page_num;
;;;44         unsigned int base_addr, page_base, page_offset, phy_addr;
;;;45         volatile _CTable *PageTabPtr;
;;;46     
;;;47         if (vaddr & 0x80000000)
000010  e3100102          TST      r0,#0x80000000
000014  e5d22000          LDRB     r2,[r2,#0]  ; _sys_IsCacheOn
;;;48             PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000018  159f15a4          LDRNE    r1,|L1.1476|
;;;49         else
;;;50             PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
00001c  059f15a4          LDREQ    r1,|L1.1480|
;;;51     
;;;52         if (sysGetCacheState() == TRUE)
000020  e3520001          CMP      r2,#1
;;;53             PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
;;;54     
;;;55         base_addr = vaddr & 0x7FFFF000;
;;;56         table_num = base_addr / 0x100000;
;;;57         page_num = (base_addr & 0xFF000) >> 12;
;;;58     
;;;59         page_base = (*(PageTabPtr+table_num)).page[page_num] & 0xFFFFF000;
;;;60         page_offset = vaddr & 0xFFF;
;;;61         phy_addr = page_base + page_offset;
;;;62     
;;;63         return phy_addr;
;;;64     
;;;65     } /* end sysGetPHYAddr */
000024  e59f25a0          LDR      r2,|L1.1484|
000028  03811102          ORREQ    r1,r1,#0x80000000     ;53
00002c  e0022a20          AND      r2,r2,r0,LSR #20
000030  e3a030ff          MOV      r3,#0xff
000034  e0033620          AND      r3,r3,r0,LSR #12
000038  e0811502          ADD      r1,r1,r2,LSL #10      ;59
00003c  e7911103          LDR      r1,[r1,r3,LSL #2]     ;59
000040  e1a00a00          LSL      r0,r0,#20             ;60
000044  e1a01621          LSR      r1,r1,#12             ;59
000048  e1a01601          LSL      r1,r1,#12             ;59
00004c  e1a00a20          LSR      r0,r0,#20             ;60
000050  e0800001          ADD      r0,r0,r1              ;61
000054  e12fff1e          BX       lr
;;;66     
                          ENDP

                  sysSetCachePages PROC
;;;67     
;;;68     int sysSetCachePages(unsigned int vaddr, int size, int cache_flag)
000058  e92d40f8          PUSH     {r3-r7,lr}
;;;69     {
00005c  e59fc55c          LDR      r12,|L1.1472|
;;;70         int i, cnt, table_num, page_num, cache_mode;
;;;71         unsigned volatile int baseaddr, temp;
;;;72         volatile _CTable *PageTabPtr;
;;;73     
;;;74         if (vaddr & 0x80000000)
000060  e3100102          TST      r0,#0x80000000
000064  e5dcc000          LDRB     r12,[r12,#0]  ; _sys_IsCacheOn
;;;75             PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000068  159f3554          LDRNE    r3,|L1.1476|
;;;76         else
;;;77             PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
00006c  059f3554          LDREQ    r3,|L1.1480|
;;;78     
;;;79         if (sysGetCacheState() == TRUE)
000070  e35c0001          CMP      r12,#1
;;;80             PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
;;;81     
;;;82         vaddr &= 0x7FFFFFFF;    //ignore the non-cacheable bit 31
000074  e3c0c102          BIC      r12,r0,#0x80000000
000078  03833102          ORREQ    r3,r3,#0x80000000     ;80
;;;83         //if ( _IsInitMMUTable == FALSE ) return -1;
;;;84         if ((vaddr + size) > (_CoarsePageSize << 20)) return -1;
00007c  e08c0001          ADD      r0,r12,r1
000080  e3500302          CMP      r0,#0x8000000
;;;85     
;;;86         if (vaddr & 0xFFF)  return -1;  /* MUST 4K Boundary */
000084  91b00a0c          LSLSLS   r0,r12,#20
;;;87         if (size % 4096)    return -1;  /* MUST 4K multiple size */
000088  01b00a01          LSLSEQ   r0,r1,#20
00008c  13e00000          MVNNE    r0,#0
000090  1a000019          BNE      |L1.252|
;;;88     
;;;89         /* for flat mapping address */
;;;90         cnt = size / 4096;
000094  e1a00fc1          ASR      r0,r1,#31
;;;91     
;;;92         if (cache_flag == CACHE_WRITE_BACK) /* write back mode */
000098  e3520000          CMP      r2,#0
00009c  e0810a20          ADD      r0,r1,r0,LSR #20      ;90
0000a0  e1a05640          ASR      r5,r0,#12             ;90
;;;93             cache_mode = 0x0C;
0000a4  03a0400c          MOVEQ    r4,#0xc
0000a8  0a000002          BEQ      |L1.184|
;;;94         else if (cache_flag == CACHE_WRITE_THROUGH) /* write through mode */
0000ac  e3520001          CMP      r2,#1
;;;95             cache_mode = 0x08;
0000b0  03a04008          MOVEQ    r4,#8
;;;96         else
;;;97             cache_mode = 0; /* Non-cacheable, non-buffered */
0000b4  13a04000          MOVNE    r4,#0
                  |L1.184|
;;;98     
;;;99         for (i=0; i<cnt; i++)
0000b8  e3a00000          MOV      r0,#0
;;;100        {
;;;101            baseaddr = vaddr + i * 4096;
;;;102            table_num = baseaddr / 0x100000;
;;;103            page_num =  (baseaddr & 0xFF000) >> 12; /* bits [19:12] for level two table index */
;;;104    
;;;105            temp = (*(PageTabPtr+table_num)).page[page_num] & 0xFFFFFFF3;
;;;106            temp |= cache_mode; /* cache mode */
;;;107            (*(PageTabPtr+table_num)).page[page_num] = temp;
;;;108        }
;;;109    
;;;110        //sysFlushCache(D_CACHE);
;;;111    
;;;112        return 0;
;;;113    
;;;114    } /* end sysSetCachePages */
0000bc  e3a060ff          MOV      r6,#0xff
0000c0  ea00000a          B        |L1.240|
                  |L1.196|
0000c4  e08c1600          ADD      r1,r12,r0,LSL #12     ;101
0000c8  e1a02a21          LSR      r2,r1,#20             ;102
0000cc  e58d1000          STR      r1,[sp,#0]            ;101
0000d0  e0061621          AND      r1,r6,r1,LSR #12
0000d4  e0832502          ADD      r2,r3,r2,LSL #10      ;105
0000d8  e7927101          LDR      r7,[r2,r1,LSL #2]     ;105
0000dc  e3c7700c          BIC      r7,r7,#0xc            ;105
0000e0  e1877004          ORR      r7,r7,r4              ;106
0000e4  e58d7000          STR      r7,[sp,#0]            ;106
0000e8  e7827101          STR      r7,[r2,r1,LSL #2]     ;107
0000ec  e2800001          ADD      r0,r0,#1              ;107
                  |L1.240|
0000f0  e1500005          CMP      r0,r5                 ;99
0000f4  a3a00000          MOVGE    r0,#0                 ;112
0000f8  bafffff1          BLT      |L1.196|
                  |L1.252|
0000fc  e8bd80f8          POP      {r3-r7,pc}
;;;115    
                          ENDP

                  sysInitPageTable PROC
;;;117    
;;;118    int sysInitPageTable(unsigned int vaddr, unsigned int phy_addr, int size, int cache_flag, int rev_flag)
000100  e92d43fc          PUSH     {r2-r9,lr}
;;;119    {
000104  e59f44b4          LDR      r4,|L1.1472|
;;;120        int i, cnt, table_num, page_num, cache_mode, addr_offset;
;;;121        unsigned volatile int phy_base_addr, vbase_addr, temp;
;;;122        volatile _CTable *PageTabPtr;
;;;123    
;;;124        if (vaddr & 0x80000000)
000108  e3100102          TST      r0,#0x80000000
00010c  e5d44000          LDRB     r4,[r4,#0]  ; _sys_IsCacheOn
000110  e59d6024          LDR      r6,[sp,#0x24]
;;;125            PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000114  159fc4a8          LDRNE    r12,|L1.1476|
;;;126        else
;;;127            PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
000118  059fc4a8          LDREQ    r12,|L1.1480|
;;;128    
;;;129        if (sysGetCacheState() == TRUE)
00011c  e3540001          CMP      r4,#1
;;;130            PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
;;;131    
;;;132        //if ( _IsInitMMUTable == FALSE ) return -1;
;;;133        vaddr &= 0x7FFFFFFF;    //ignore the non-cacheable bit 31
000120  e3c04102          BIC      r4,r0,#0x80000000
000124  038cc102          ORREQ    r12,r12,#0x80000000   ;130
;;;134        if ((vaddr + size) > (_CoarsePageSize << 20)) return -1;
000128  e0840002          ADD      r0,r4,r2
00012c  e3500302          CMP      r0,#0x8000000
;;;135        if (vaddr & 0xFFFFF)    return -1;  /* MUST 1M Boundary */
000130  91b00604          LSLSLS   r0,r4,#12
;;;136        if (size % 4096)        return -1;  /* MUST 4K multiple size */
000134  01b00a02          LSLSEQ   r0,r2,#20
000138  13e00000          MVNNE    r0,#0
00013c  1a000026          BNE      |L1.476|
;;;137    
;;;138        /* Pages count */
;;;139        cnt = size / 4096;
000140  e1a00fc2          ASR      r0,r2,#31
;;;140    
;;;141        if (cache_flag == CACHE_WRITE_BACK) /* write back mode */
000144  e3530000          CMP      r3,#0
000148  e0820a20          ADD      r0,r2,r0,LSR #20      ;139
00014c  e1a07640          ASR      r7,r0,#12             ;139
;;;142            cache_mode = 0x0C;
000150  03a0300c          MOVEQ    r3,#0xc
000154  0a000002          BEQ      |L1.356|
;;;143        else if (cache_flag == CACHE_WRITE_THROUGH) /* write through mode */
000158  e3530001          CMP      r3,#1
;;;144            cache_mode = 0x08;
00015c  03a03008          MOVEQ    r3,#8
;;;145        else
;;;146            cache_mode = 0; /* Non-cacheable, non-buffered */
000160  13a03000          MOVNE    r3,#0
                  |L1.356|
;;;147    
;;;148    
;;;149        if (rev_flag == MMU_DIRECT_MAPPING)
000164  e3560000          CMP      r6,#0
;;;150            phy_base_addr = phy_addr;
;;;151        else
;;;152            phy_base_addr = phy_addr + size - 4096;
000168  10810002          ADDNE    r0,r1,r2
00016c  058d1004          STREQ    r1,[sp,#4]            ;150
000170  12400a01          SUBNE    r0,r0,#0x1000
000174  158d0004          STRNE    r0,[sp,#4]
;;;153    
;;;154        addr_offset = 4096;
000178  e3a01a01          MOV      r1,#0x1000
;;;155        for (i=0; i<cnt; i++)
00017c  e3a00000          MOV      r0,#0
;;;156        {
;;;157            vbase_addr = vaddr + i * 4096;
;;;158            table_num = vbase_addr / 0x100000;
;;;159            page_num =  (vbase_addr & 0xFF000) >> 12; /* bits [19:12] for level two table index */
;;;160    
;;;161            temp = phy_base_addr & 0xFFFFF000;
;;;162            temp |= 0xFF0; /* access permission, 11 for read/write */
;;;163            temp |= cache_mode; /* cache mode */
;;;164            temp |= 0x02;  /* small page */
;;;165    
;;;166            (*(PageTabPtr+table_num)).page[page_num] = temp;
;;;167    
;;;168            if (rev_flag == MMU_DIRECT_MAPPING)
;;;169                phy_base_addr += addr_offset;
;;;170            else
;;;171                phy_base_addr -= addr_offset;
;;;172        }
;;;173    
;;;174        return 0;
;;;175    
;;;176    } /* end sysInitPageTable */
000180  e3a080ff          MOV      r8,#0xff
                  |L1.388|
000184  e1500007          CMP      r0,r7                 ;155
000188  a3a00000          MOVGE    r0,#0                 ;174
00018c  aa000012          BGE      |L1.476|
000190  e59d9004          LDR      r9,[sp,#4]            ;161
000194  e0842600          ADD      r2,r4,r0,LSL #12      ;157
000198  e1a09629          LSR      r9,r9,#12             ;161
00019c  e1a09609          LSL      r9,r9,#12             ;161
0001a0  e3899eff          ORR      r9,r9,#0xff0          ;162
0001a4  e1a05a22          LSR      r5,r2,#20             ;158
0001a8  e1899003          ORR      r9,r9,r3              ;163
0001ac  e3899002          ORR      r9,r9,#2              ;164
0001b0  e0082622          AND      r2,r8,r2,LSR #12
0001b4  e08c5505          ADD      r5,r12,r5,LSL #10     ;166
0001b8  e58d9000          STR      r9,[sp,#0]            ;166
0001bc  e7859102          STR      r9,[r5,r2,LSL #2]     ;166
0001c0  e59d2004          LDR      r2,[sp,#4]            ;171
0001c4  e3560000          CMP      r6,#0                 ;168
0001c8  00822001          ADDEQ    r2,r2,r1              ;169
0001cc  10422001          SUBNE    r2,r2,r1              ;171
0001d0  e2800001          ADD      r0,r0,#1              ;171
0001d4  e58d2004          STR      r2,[sp,#4]            ;171
0001d8  eaffffe9          B        |L1.388|
                  |L1.476|
0001dc  e8bd83fc          POP      {r2-r9,pc}
;;;177    
                          ENDP

                  sysSetMMUMappingMethod PROC
;;;178    
;;;179    int sysSetMMUMappingMethod(int mode)
0001e0  e59f13d8          LDR      r1,|L1.1472|
;;;180    {
;;;181        _MMUMappingMode = mode;
0001e4  e5810004          STR      r0,[r1,#4]  ; _MMUMappingMode
;;;182    
;;;183        return 0;
0001e8  e3a00000          MOV      r0,#0
;;;184    
;;;185    } /* end sysSetMMUMappingMethod */
0001ec  e12fff1e          BX       lr
;;;186    
                          ENDP

                  sysGetSdramSizebyMB PROC
;;;273    
;;;274    INT32 sysGetSdramSizebyMB()
0001f0  e92d400c          PUSH     {r2,r3,lr}
;;;275    {
;;;276        unsigned int volatile reg, totalsize=0;
0001f4  e3a00000          MOV      r0,#0
0001f8  e58d0000          STR      r0,[sp,#0]
;;;277    
;;;278        reg = inpw(SDIC_BA+0x10) & 0x07;
0001fc  e59f03cc          LDR      r0,|L1.1488|
000200  e5900000          LDR      r0,[r0,#0]
000204  e2000007          AND      r0,r0,#7
;;;279        switch(reg)
000208  e3500008          CMP      r0,#8
00020c  e58d0004          STR      r0,[sp,#4]            ;278
000210  308ff100          ADDCC    pc,pc,r0,LSL #2
000214  ea00000b          B        |L1.584|
000218  ea00000a          B        |L1.584|
00021c  ea000005          B        |L1.568|
000220  ea000006          B        |L1.576|
000224  ea000016          B        |L1.644|
000228  ea000017          B        |L1.652|
00022c  ea000018          B        |L1.660|
000230  ea000019          B        |L1.668|
000234  ea00001a          B        |L1.676|
                  |L1.568|
;;;280        {
;;;281            case 1:
;;;282                totalsize += 2;
000238  e3a00002          MOV      r0,#2
;;;283                break;
00023c  ea000000          B        |L1.580|
                  |L1.576|
;;;284    
;;;285            case 2:
;;;286                totalsize += 4;
000240  e3a00004          MOV      r0,#4
                  |L1.580|
000244  e58d0000          STR      r0,[sp,#0]            ;282
                  |L1.584|
;;;287                break;
;;;288    
;;;289            case 3:
;;;290                totalsize += 8;
;;;291                break;
;;;292    
;;;293            case 4:
;;;294                totalsize += 16;
;;;295                break;
;;;296    
;;;297            case 5:
;;;298                totalsize += 32;
;;;299                break;
;;;300    
;;;301            case 6:
;;;302                totalsize += 64;
;;;303                break;
;;;304    
;;;305            case 7:
;;;306                totalsize += 128;
;;;307                break;
;;;308        }
;;;309    
;;;310        reg = inpw(SDIC_BA+0x14) & 0x07;
000248  e59f0384          LDR      r0,|L1.1492|
00024c  e5900000          LDR      r0,[r0,#0]
000250  e2000007          AND      r0,r0,#7
;;;311        switch(reg)
000254  e3500008          CMP      r0,#8
000258  e58d0004          STR      r0,[sp,#4]            ;310
00025c  308ff100          ADDCC    pc,pc,r0,LSL #2
000260  ea000017          B        |L1.708|
000264  ea000016          B        |L1.708|
000268  ea00000f          B        |L1.684|
00026c  ea000011          B        |L1.696|
000270  ea000017          B        |L1.724|
000274  ea000019          B        |L1.736|
000278  ea00001b          B        |L1.748|
00027c  ea00001d          B        |L1.760|
000280  ea00001f          B        |L1.772|
                  |L1.644|
000284  e3a00008          MOV      r0,#8                 ;290
000288  eaffffed          B        |L1.580|
                  |L1.652|
00028c  e3a00010          MOV      r0,#0x10              ;294
000290  eaffffeb          B        |L1.580|
                  |L1.660|
000294  e3a00020          MOV      r0,#0x20              ;298
000298  eaffffe9          B        |L1.580|
                  |L1.668|
00029c  e3a00040          MOV      r0,#0x40              ;302
0002a0  eaffffe7          B        |L1.580|
                  |L1.676|
0002a4  e3a00080          MOV      r0,#0x80              ;306
0002a8  eaffffe5          B        |L1.580|
                  |L1.684|
;;;312        {
;;;313            case 1:
;;;314                totalsize += 2;
0002ac  e59d0000          LDR      r0,[sp,#0]
0002b0  e2800002          ADD      r0,r0,#2
;;;315                break;
0002b4  ea000001          B        |L1.704|
                  |L1.696|
;;;316    
;;;317            case 2:
;;;318                totalsize += 4;
0002b8  e59d0000          LDR      r0,[sp,#0]
0002bc  e2800004          ADD      r0,r0,#4
                  |L1.704|
0002c0  e58d0000          STR      r0,[sp,#0]            ;314
                  |L1.708|
;;;319                break;
;;;320    
;;;321            case 3:
;;;322                totalsize += 8;
;;;323                break;
;;;324    
;;;325            case 4:
;;;326                totalsize += 16;
;;;327                break;
;;;328    
;;;329            case 5:
;;;330                totalsize += 32;
;;;331                break;
;;;332    
;;;333            case 6:
;;;334                totalsize += 64;
;;;335                break;
;;;336    
;;;337            case 7:
;;;338                totalsize += 128;
;;;339                break;
;;;340        }
;;;341    
;;;342        if (totalsize != 0)
0002c4  e59d0000          LDR      r0,[sp,#0]
0002c8  e3500000          CMP      r0,#0
;;;343            return totalsize;
;;;344        else
;;;345            return 1;
0002cc  03a00001          MOVEQ    r0,#1
;;;346    }
0002d0  e8bd800c          POP      {r2,r3,pc}
                  |L1.724|
0002d4  e59d0000          LDR      r0,[sp,#0]            ;322
0002d8  e2800008          ADD      r0,r0,#8              ;322
0002dc  eafffff7          B        |L1.704|
                  |L1.736|
0002e0  e59d0000          LDR      r0,[sp,#0]            ;326
0002e4  e2800010          ADD      r0,r0,#0x10           ;326
0002e8  eafffff4          B        |L1.704|
                  |L1.748|
0002ec  e59d0000          LDR      r0,[sp,#0]            ;330
0002f0  e2800020          ADD      r0,r0,#0x20           ;330
0002f4  eafffff1          B        |L1.704|
                  |L1.760|
0002f8  e59d0000          LDR      r0,[sp,#0]            ;334
0002fc  e2800040          ADD      r0,r0,#0x40           ;334
000300  eaffffee          B        |L1.704|
                  |L1.772|
000304  e59d0000          LDR      r0,[sp,#0]            ;338
000308  e2800080          ADD      r0,r0,#0x80           ;338
00030c  eaffffeb          B        |L1.704|
;;;347    
                          ENDP

                  sysInitMMUTable PROC
;;;187    
;;;188    int sysInitMMUTable(int cache_mode)
000310  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;189    {
;;;190        unsigned volatile int temp;
;;;191        int i, size, ramsize;
;;;192    
;;;193        if (_IsInitMMUTable == FALSE)
000314  e59f92a4          LDR      r9,|L1.1472|
000318  e24dd008          SUB      sp,sp,#8              ;189
00031c  e5d90001          LDRB     r0,[r9,#1]  ; _IsInitMMUTable
000320  e3500000          CMP      r0,#0
000324  0a000003          BEQ      |L1.824|
                  |L1.808|
;;;194        {
;;;195            ramsize = sysGetSdramSizebyMB();
;;;196    
;;;197            //flat mapping for 4GB, 4096 section table, each size is 1MB
;;;198            temp = 0xC00;   /* (11:10) access permission, R/W */
;;;199            temp |= 0x1E0;  /* (8:5) domain 15 */
;;;200            temp |= 0x10;   /* bit 4 must be 1 */
;;;201            temp |= 0x00;   /* bit 3:2 for cache control bits, cache disabled */
;;;202            temp |= 0x02;   /* set as 1Mb section */
;;;203    
;;;204            for (i=0; i<4096; i++)
;;;205            {
;;;206                _mmuSectionTable[i] = (unsigned int)(temp | (i << 20));
;;;207            }
;;;208    
;;;209            //Inside SDRAM, divide each section into 256 small pages, each page size is 4KB
;;;210            if (ramsize > _CoarsePageSize) size = _CoarsePageSize;  //maximum 128MB
;;;211            else                           size = ramsize;
;;;212    
;;;213            /* first 1M always direct mapping */
;;;214            sysInitPageTable(0, 0, 0x100000, cache_mode, MMU_DIRECT_MAPPING);
;;;215            temp = ((unsigned int)_mmuCoarsePageTable  & 0xFFFFFC00); /*  coarse table base address */
;;;216            temp |= 0x1E0;  /* (8:5) domain 15 */
;;;217            temp |= 0x10;   /* bit 4 must be 1 */
;;;218            temp |= 0x01;   /* Coarse page table */
;;;219            _mmuSectionTable[0] = temp;
;;;220    
;;;221            /* Create a shadow area at 0x80000000 for non-cacheable region */
;;;222            sysInitPageTable(0x80000000, 0x0, 0x100000, CACHE_DISABLE, MMU_DIRECT_MAPPING);
;;;223            temp = ((unsigned int)_mmuCoarsePageTable_NonCache  & 0xFFFFFC00); /*  coarse table base address */
;;;224            temp |= 0x1E0;  /* (8:5) domain 15 */
;;;225            temp |= 0x10;   /* bit 4 must be 1 */
;;;226            temp |= 0x01;   /* Coarse page table */
;;;227            _mmuSectionTable[0x800] = temp;
;;;228    
;;;229            /* Mapping the other memory */
;;;230            for (i=1; i< size; i++)
;;;231            {
;;;232                temp = (((unsigned int)_mmuCoarsePageTable + (unsigned int)i*1024) & 0xFFFFFC00); /*  coarse table base address */
;;;233                //temp = ((unsigned int)(0x604000 + i*1024) & 0xFFFFFC00); /* coarse table base address */
;;;234                temp |= 0x1E0;  /* (8:5) domain 15 */
;;;235                temp |= 0x10;   /* bit 4 must be 1 */
;;;236                temp |= 0x01;   /* Coarse page table */
;;;237    
;;;238                if (_MMUMappingMode == MMU_DIRECT_MAPPING)
;;;239                    sysInitPageTable((i << 20), (i << 20), 0x100000, cache_mode, MMU_DIRECT_MAPPING); /* direct mapping */
;;;240                else
;;;241                    sysInitPageTable((i << 20), (i << 20), 0x100000, cache_mode, MMU_INVERSE_MAPPING); /* inverse mapping for each 1MB area */
;;;242    
;;;243                _mmuSectionTable[i] = temp;
;;;244            }
;;;245    
;;;246            //Create shadow non-cacheabel region
;;;247            for (i=1; i< size; i++)
;;;248            {
;;;249                temp = (((unsigned int)_mmuCoarsePageTable_NonCache + (unsigned int)i*1024) & 0xFFFFFC00); /*  coarse table base address */
;;;250                //temp = ((unsigned int)(0x604000 + i*1024) & 0xFFFFFC00); /* coarse table base address */
;;;251                temp |= 0x1E0;  /* (8:5) domain 15 */
;;;252                temp |= 0x10;   /* bit 4 must be 1 */
;;;253                temp |= 0x01;   /* Coarse page table */
;;;254    
;;;255                if (_MMUMappingMode == MMU_DIRECT_MAPPING)
;;;256                    sysInitPageTable(((i << 20) | 0x80000000), (i << 20), 0x100000, CACHE_DISABLE, MMU_DIRECT_MAPPING); /* direct mapping */
;;;257                else
;;;258                    sysInitPageTable(((i << 20) | 0x80000000), (i << 20), 0x100000, CACHE_DISABLE, MMU_INVERSE_MAPPING); /* inverse mapping for each 1MB area */
;;;259    
;;;260                _mmuSectionTable[0x800+i] = temp;
;;;261            }
;;;262    
;;;263            _IsInitMMUTable = TRUE;
;;;264        }
;;;265    
;;;266        //moved here by cmn [2007/01/27]
;;;267        //set CP15 registers
;;;268        sysSetupCP15((unsigned int)_mmuSectionTable);
000328  e59f02a8          LDR      r0,|L1.1496|
00032c  ebfffffe          BL       sysSetupCP15
;;;269    
;;;270        return 0;
000330  e3a00000          MOV      r0,#0
;;;271    
;;;272    } /* end sysInitMMUTable */
000334  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.824|
000338  ebfffffe          BL       sysGetSdramSizebyMB
00033c  e59f1298          LDR      r1,|L1.1500|
000340  e59f6290          LDR      r6,|L1.1496|
000344  e58d1004          STR      r1,[sp,#4]            ;202
000348  e3a01000          MOV      r1,#0                 ;204
                  |L1.844|
00034c  e59d2004          LDR      r2,[sp,#4]            ;206
000350  e1822a01          ORR      r2,r2,r1,LSL #20      ;206
000354  e7862101          STR      r2,[r6,r1,LSL #2]     ;206
000358  e2811001          ADD      r1,r1,#1              ;206
00035c  e3510a01          CMP      r1,#0x1000            ;204
000360  bafffff9          BLT      |L1.844|
000364  e3500080          CMP      r0,#0x80              ;210
000368  e3a07000          MOV      r7,#0                 ;214
00036c  d1a05000          MOVLE    r5,r0                 ;211
000370  e59d3008          LDR      r3,[sp,#8]            ;214
000374  c3a05080          MOVGT    r5,#0x80              ;210
000378  e3a02601          MOV      r2,#0x100000          ;214
00037c  e1a01007          MOV      r1,r7                 ;214
000380  e1a00007          MOV      r0,r7                 ;214
000384  e58d7000          STR      r7,[sp,#0]            ;214
000388  ebfffffe          BL       sysInitPageTable
00038c  e59fb234          LDR      r11,|L1.1480|
000390  e3e03000          MVN      r3,#0                 ;222
000394  e38b0e1e          ORR      r0,r11,#0x1e0         ;216
000398  e3800010          ORR      r0,r0,#0x10           ;217
00039c  e3800001          ORR      r0,r0,#1              ;218
0003a0  e58d0004          STR      r0,[sp,#4]            ;219
0003a4  e5860000          STR      r0,[r6,#0]            ;222  ; _mmuSectionTable
0003a8  e3a02601          MOV      r2,#0x100000          ;222
0003ac  e3a01000          MOV      r1,#0                 ;222
0003b0  e3a00102          MOV      r0,#0x80000000        ;222
0003b4  e58d7000          STR      r7,[sp,#0]            ;222
0003b8  ebfffffe          BL       sysInitPageTable
0003bc  e28ba802          ADD      r10,r11,#0x20000      ;223
0003c0  e38a0e1e          ORR      r0,r10,#0x1e0         ;224
0003c4  e3800010          ORR      r0,r0,#0x10           ;225
0003c8  e3800001          ORR      r0,r0,#1              ;226
0003cc  e1a01000          MOV      r1,r0                 ;227
0003d0  e58d0004          STR      r0,[sp,#4]            ;226
0003d4  e24b0a02          SUB      r0,r11,#0x2000        ;227
0003d8  e3a04001          MOV      r4,#1                 ;230
0003dc  e1a08004          MOV      r8,r4                 ;230
0003e0  e5801000          STR      r1,[r0,#0]            ;230  ; _mmuSectionTable
                  |L1.996|
0003e4  e1540005          CMP      r4,r5                 ;230
0003e8  a3a04001          MOVGE    r4,#1                 ;247
0003ec  a3a0b102          MOVGE    r11,#0x80000000       ;222
0003f0  aa000024          BGE      |L1.1160|
0003f4  e08b0504          ADD      r0,r11,r4,LSL #10     ;232
0003f8  e3800e1e          ORR      r0,r0,#0x1e0          ;234
0003fc  e3800010          ORR      r0,r0,#0x10           ;235
000400  e3800001          ORR      r0,r0,#1              ;236
000404  e58d0004          STR      r0,[sp,#4]            ;238
000408  e5990004          LDR      r0,[r9,#4]            ;238  ; _MMUMappingMode
00040c  e59d3008          LDR      r3,[sp,#8]            ;241
000410  e3500000          CMP      r0,#0                 ;238
000414  e1a00a04          LSL      r0,r4,#20             ;241
000418  058d7000          STREQ    r7,[sp,#0]            ;239
00041c  e3a02601          MOV      r2,#0x100000          ;241
000420  e1a01000          MOV      r1,r0                 ;241
000424  158d8000          STRNE    r8,[sp,#0]            ;241
000428  ebfffffe          BL       sysInitPageTable
00042c  e59d0004          LDR      r0,[sp,#4]            ;243
000430  e7860104          STR      r0,[r6,r4,LSL #2]     ;243
000434  e2844001          ADD      r4,r4,#1              ;243
000438  eaffffe9          B        |L1.996|
                  |L1.1084|
00043c  e08a0504          ADD      r0,r10,r4,LSL #10     ;249
000440  e3800e1e          ORR      r0,r0,#0x1e0          ;251
000444  e3800010          ORR      r0,r0,#0x10           ;252
000448  e3800001          ORR      r0,r0,#1              ;253
00044c  e58d0004          STR      r0,[sp,#4]            ;255
000450  e5990004          LDR      r0,[r9,#4]            ;255  ; _MMUMappingMode
000454  e1a01a04          LSL      r1,r4,#20             ;258
000458  e3500000          CMP      r0,#0                 ;255
00045c  058d7000          STREQ    r7,[sp,#0]            ;256
000460  e18b0a04          ORR      r0,r11,r4,LSL #20     ;258
000464  e3e03000          MVN      r3,#0                 ;258
000468  e3a02601          MOV      r2,#0x100000          ;258
00046c  158d8000          STRNE    r8,[sp,#0]            ;258
000470  ebfffffe          BL       sysInitPageTable
000474  e0860104          ADD      r0,r6,r4,LSL #2       ;260
000478  e59d1004          LDR      r1,[sp,#4]            ;260
00047c  e2800a02          ADD      r0,r0,#0x2000         ;260
000480  e2844001          ADD      r4,r4,#1              ;260
000484  e5801000          STR      r1,[r0,#0]            ;260
                  |L1.1160|
000488  e1540005          CMP      r4,r5                 ;247
00048c  a5c98001          STRBGE   r8,[r9,#1]            ;263  ; _IsInitMMUTable
000490  baffffe9          BLT      |L1.1084|
000494  eaffffa3          B        |L1.808|
;;;273    
                          ENDP

                  sysFlushCache PROC
;;;347    
;;;348    void sysFlushCache(INT32 nCacheType)
000498  e3500006          CMP      r0,#6
;;;349    {
00049c  e92d4010          PUSH     {r4,lr}
;;;350        int temp;
;;;351    
;;;352        switch (nCacheType)
;;;353        {
;;;354            case I_CACHE:
;;;355                __asm
;;;356                {
;;;357                    /*----- flush I-cache -----*/
;;;358                    MOV temp, 0x0
0004a0  03a00000          MOVEQ    r0,#0
;;;359                    MCR p15, 0, temp, c7, c5, 0 /* invalidate I cache */
0004a4  0e070f15          MCREQ    p15,#0x0,r0,c7,c5,#0
;;;360                }
;;;361                break;
;;;362    
;;;363            case D_CACHE:
;;;364                sys_flush_and_clean_dcache();
;;;365                __asm
;;;366                {
;;;367                    /*----- flush D-cache & write buffer -----*/
;;;368                    MOV temp, 0x0
;;;369                    MCR p15, 0, temp, c7, c10, 4 /* drain write buffer */
;;;370                }
;;;371                break;
;;;372    
;;;373            case I_D_CACHE:
;;;374                sys_flush_and_clean_dcache();
;;;375                __asm
;;;376                {
;;;377                    /*----- flush I, D cache & write buffer -----*/
;;;378                    MOV temp, 0x0
;;;379                    MCR p15, 0, temp, c7, c5, 0 /* invalidate I cache */
;;;380                    MCR p15, 0, temp, c7, c10, 4 /* drain write buffer */
;;;381                }
;;;382                break;
;;;383    
;;;384            default:
;;;385                ;
;;;386        }
;;;387    }
0004a8  08bd8010          POPEQ    {r4,pc}
0004ac  e3500007          CMP      r0,#7                 ;352
0004b0  0a000006          BEQ      |L1.1232|
0004b4  e3500008          CMP      r0,#8                 ;352
0004b8  18bd8010          POPNE    {r4,pc}
0004bc  ebfffffe          BL       sys_flush_and_clean_dcache
0004c0  e3a00000          MOV      r0,#0                 ;378
0004c4  ee070f15          MCR      p15,#0x0,r0,c7,c5,#0  ;379
0004c8  ee070f9a          MCR      p15,#0x0,r0,c7,c10,#4 ;380
0004cc  e8bd8010          POP      {r4,pc}
                  |L1.1232|
0004d0  ebfffffe          BL       sys_flush_and_clean_dcache
0004d4  e3a00000          MOV      r0,#0                 ;368
0004d8  ee070f9a          MCR      p15,#0x0,r0,c7,c10,#4 ;369
0004dc  e8bd8010          POP      {r4,pc}
;;;388    
                          ENDP

                  sysInvalidCache PROC
;;;389    void sysInvalidCache()
0004e0  e3a00000          MOV      r0,#0
;;;390    {
;;;391        int temp;
;;;392    
;;;393        __asm
;;;394        {
;;;395            MOV temp, 0x0
;;;396            MCR p15, 0, temp, c7, c7, 0 /* invalidate I and D cache */
0004e4  ee070f17          MCR      p15,#0x0,r0,c7,c7,#0
;;;397        }
;;;398    }
0004e8  e12fff1e          BX       lr
;;;399    
                          ENDP

                  sysGetCacheMode PROC
;;;405    
;;;406    INT32 sysGetCacheMode()
0004ec  e59f00cc          LDR      r0,|L1.1472|
;;;407    {
;;;408        return _sys_CacheMode;
0004f0  e5900008          LDR      r0,[r0,#8]  ; _sys_CacheMode
;;;409    }
0004f4  e12fff1e          BX       lr
;;;410    
                          ENDP

                  _sysLockCode PROC
;;;411    
;;;412    INT32 _sysLockCode(UINT32 addr, INT32 size)
0004f8  ee192f30          MRC      p15,#0x0,r2,c9,c0,#1
;;;413    {
;;;414        int i, cnt, temp;
;;;415    
;;;416        __asm
;;;417        {
;;;418            /* use way3 to lock instructions */
;;;419            MRC p15, 0, temp, c9, c0, 1 ;
;;;420            ORR temp, temp, 0x07 ;
0004fc  e3822007          ORR      r2,r2,#7
;;;421            MCR p15, 0, temp, c9, c0, 1 ;
000500  ee092f30          MCR      p15,#0x0,r2,c9,c0,#1
;;;422        }
;;;423    
;;;424        if (size % 16)  cnt = (size/16) + 1;
000504  e311000f          TST      r1,#0xf
000508  e1a02fc1          ASR      r2,r1,#31
00050c  e0811e22          ADD      r1,r1,r2,LSR #28
000510  13a02001          MOVNE    r2,#1
000514  10822241          ADDNE    r2,r2,r1,ASR #4
;;;425        else            cnt = size / 16;
000518  01a02241          ASREQ    r2,r1,#4
;;;426    
;;;427        for (i=0; i<cnt; i++)
00051c  e3a01000          MOV      r1,#0
                  |L1.1312|
000520  e1510002          CMP      r1,r2
;;;428        {
;;;429            __asm
;;;430            {
;;;431                MCR p15, 0, addr, c7, c13, 1;
000524  be070f3d          MCRLT    p15,#0x0,r0,c7,c13,#1
000528  b2800010          ADDLT    r0,r0,#0x10
00052c  b2811001          ADDLT    r1,r1,#1
;;;432            }
;;;433    
;;;434            addr += 16;
;;;435        }
;;;436    
;;;437    
;;;438        __asm
;;;439        {
;;;440            /* use way3 to lock instructions */
;;;441            MRC p15, 0, temp, c9, c0, 1 ;
000530  ae190f30          MRCGE    p15,#0x0,r0,c9,c0,#1
;;;442            BIC temp, temp, 0x07 ;
000534  a3c00007          BICGE    r0,r0,#7
;;;443            ORR temp, temp, 0x08 ;
000538  a3800008          ORRGE    r0,r0,#8
;;;444            MCR p15, 0, temp, c9, c0, 1 ;
00053c  ae090f30          MCRGE    p15,#0x0,r0,c9,c0,#1
;;;445        }
;;;446    
;;;447        return 0;
000540  a3a00000          MOVGE    r0,#0
000544  bafffff5          BLT      |L1.1312|
;;;448    
;;;449    }
000548  e12fff1e          BX       lr
;;;450    
                          ENDP

                  _sysUnLockCode PROC
;;;451    
;;;452    INT32 _sysUnLockCode()
00054c  ee190f30          MRC      p15,#0x0,r0,c9,c0,#1
;;;453    {
;;;454        int temp;
;;;455    
;;;456        /* unlock I-cache way 3 */
;;;457        __asm
;;;458        {
;;;459            MRC p15, 0, temp, c9, c0, 1;
;;;460            BIC temp, temp, 0x08 ;
000550  e3c00008          BIC      r0,r0,#8
;;;461            MCR p15, 0, temp, c9, c0, 1;
000554  ee090f30          MCR      p15,#0x0,r0,c9,c0,#1
;;;462    
;;;463        }
;;;464    
;;;465        return 0;
000558  e3a00000          MOV      r0,#0
;;;466    }
00055c  e12fff1e          BX       lr
;;;467    
                          ENDP

                  sysEnableCache PROC
;;;477     */
;;;478    INT32 sysEnableCache(UINT32 uCacheOpMode)
000560  e92d4010          PUSH     {r4,lr}
;;;479    {
000564  e1a04000          MOV      r4,r0
;;;480        sysInitMMUTable(uCacheOpMode);
000568  ebfffffe          BL       sysInitMMUTable
;;;481        _sys_IsCacheOn = TRUE;
00056c  e59f104c          LDR      r1,|L1.1472|
000570  e3a02001          MOV      r2,#1
000574  e5c12000          STRB     r2,[r1,#0]  ; _sys_IsCacheOn
;;;482        _sys_CacheMode = uCacheOpMode;
000578  e5814008          STR      r4,[r1,#8]  ; _sys_CacheMode
;;;483    
;;;484        return 0;
00057c  e3a00000          MOV      r0,#0
;;;485    }
000580  e8bd8010          POP      {r4,pc}
;;;486    
                          ENDP

                  sysDisableCache PROC
;;;491     */
;;;492    void sysDisableCache(void)
000584  e92d4010          PUSH     {r4,lr}
;;;493    {
;;;494        int temp;
;;;495    
;;;496        sys_flush_and_clean_dcache();
000588  ebfffffe          BL       sys_flush_and_clean_dcache
;;;497        __asm
;;;498        {
;;;499            /*----- flush I, D cache & write buffer -----*/
;;;500            MOV temp, 0x0
00058c  e3a00000          MOV      r0,#0
;;;501            MCR p15, 0, temp, c7, c5, 0 /* flush I cache */
000590  ee070f15          MCR      p15,#0x0,r0,c7,c5,#0
;;;502            MCR p15, 0, temp, c7, c6, 0 /* flush D cache */
000594  ee070f16          MCR      p15,#0x0,r0,c7,c6,#0
;;;503            MCR p15, 0, temp, c7, c10,4 /* drain write buffer */
000598  ee070f9a          MCR      p15,#0x0,r0,c7,c10,#4
;;;504    
;;;505            /*----- disable Protection Unit -----*/
;;;506            MRC p15, 0, temp, c1, c0, 0     /* read Control register */
00059c  ee110f10          MRC      p15,#0x0,r0,c1,c0,#0
;;;507            BIC temp, temp, 0x01
0005a0  e3c00001          BIC      r0,r0,#1
;;;508            MCR p15, 0, temp, c1, c0, 0     /* write Control register */
0005a4  ee010f10          MCR      p15,#0x0,r0,c1,c0,#0
;;;509        }
;;;510        _sys_IsCacheOn = FALSE;
0005a8  e59f0010          LDR      r0,|L1.1472|
0005ac  e3a01000          MOV      r1,#0
0005b0  e5c01000          STRB     r1,[r0,#0]  ; _sys_IsCacheOn
;;;511        _sys_CacheMode = CACHE_DISABLE;
0005b4  e3e01000          MVN      r1,#0
0005b8  e5801008          STR      r1,[r0,#8]  ; _sys_CacheMode
;;;512    
;;;513    }
0005bc  e8bd8010          POP      {r4,pc}
;;;514    
                          ENDP

                  |L1.1472|
                          DCD      ||.data||
                  |L1.1476|
                          DCD      ||.bss||+0x24000
                  |L1.1480|
                          DCD      ||.bss||+0x4000
                  |L1.1484|
                          DCD      0x000007ff
                  |L1.1488|
                          DCD      0xb0001810
                  |L1.1492|
                          DCD      0xb0001814
                  |L1.1496|
                          DCD      ||.bss||
                  |L1.1500|
                          DCD      0x00000df2

                          AREA ||.bss||, DATA, NOINIT, ALIGN=14

                  _mmuSectionTable
                          %        16384
                  _mmuCoarsePageTable
                          %        131072
                  _mmuCoarsePageTable_NonCache
                          %        131072

                          AREA ||.data||, DATA, ALIGN=2

                  _sys_IsCacheOn
000000  00                DCB      0x00
                  _IsInitMMUTable
000001  000000            DCB      0x00,0x00,0x00
                  _MMUMappingMode
                          DCD      0x00000000
                  _sys_CacheMode
                          DCD      0x00000000
