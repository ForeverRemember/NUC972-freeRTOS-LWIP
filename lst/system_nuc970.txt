; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\system_nuc970.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\system_nuc970.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\system_nuc970.crf Driver\Source\system_nuc970.c]
                          ARM

                          AREA ||i._sysLockCode||, CODE, READONLY, ALIGN=2

                  _sysLockCode PROC
;;;411    
;;;412    INT32 _sysLockCode(UINT32 addr, INT32 size)
000000  e92d4030          PUSH     {r4,r5,lr}
;;;413    {
000004  e1a03000          MOV      r3,r0
;;;414        int i, cnt, temp;
;;;415    
;;;416        __asm
;;;417        {
;;;418            /* use way3 to lock instructions */
;;;419            MRC p15, 0, temp, c9, c0, 1 ;
000008  ee192f30          MRC      p15,#0x0,r2,c9,c0,#1
;;;420            ORR temp, temp, 0x07 ;
00000c  e3822007          ORR      r2,r2,#7
;;;421            MCR p15, 0, temp, c9, c0, 1 ;
000010  ee092f30          MCR      p15,#0x0,r2,c9,c0,#1
;;;422        }
;;;423    
;;;424        if (size % 16)  cnt = (size/16) + 1;
000014  e1a05fc1          ASR      r5,r1,#31
000018  e0815e25          ADD      r5,r1,r5,LSR #28
00001c  e1a05245          ASR      r5,r5,#4
000020  e0415205          SUB      r5,r1,r5,LSL #4
000024  e3550000          CMP      r5,#0
000028  0a000005          BEQ      |L1.68|
00002c  e1a00001          MOV      r0,r1
000030  e1a05fc1          ASR      r5,r1,#31
000034  e0815e25          ADD      r5,r1,r5,LSR #28
000038  e1a05245          ASR      r5,r5,#4
00003c  e2854001          ADD      r4,r5,#1
000040  ea000003          B        |L1.84|
                  |L1.68|
;;;425        else            cnt = size / 16;
000044  e1a00001          MOV      r0,r1
000048  e1a05fc1          ASR      r5,r1,#31
00004c  e0815e25          ADD      r5,r1,r5,LSR #28
000050  e1a04245          ASR      r4,r5,#4
                  |L1.84|
;;;426    
;;;427        for (i=0; i<cnt; i++)
000054  e3a0c000          MOV      r12,#0
000058  ea000002          B        |L1.104|
                  |L1.92|
;;;428        {
;;;429            __asm
;;;430            {
;;;431                MCR p15, 0, addr, c7, c13, 1;
00005c  ee073f3d          MCR      p15,#0x0,r3,c7,c13,#1
;;;432            }
;;;433    
;;;434            addr += 16;
000060  e2833010          ADD      r3,r3,#0x10
000064  e28cc001          ADD      r12,r12,#1            ;427
                  |L1.104|
000068  e15c0004          CMP      r12,r4                ;427
00006c  bafffffa          BLT      |L1.92|
;;;435        }
;;;436    
;;;437    
;;;438        __asm
;;;439        {
;;;440            /* use way3 to lock instructions */
;;;441            MRC p15, 0, temp, c9, c0, 1 ;
000070  ee192f30          MRC      p15,#0x0,r2,c9,c0,#1
;;;442            BIC temp, temp, 0x07 ;
000074  e3c22007          BIC      r2,r2,#7
;;;443            ORR temp, temp, 0x08 ;
000078  e3822008          ORR      r2,r2,#8
;;;444            MCR p15, 0, temp, c9, c0, 1 ;
00007c  ee092f30          MCR      p15,#0x0,r2,c9,c0,#1
;;;445        }
;;;446    
;;;447        return 0;
000080  e3a00000          MOV      r0,#0
;;;448    
;;;449    }
000084  e8bd8030          POP      {r4,r5,pc}
;;;450    
                          ENDP


                          AREA ||i._sysUnLockCode||, CODE, READONLY, ALIGN=2

                  _sysUnLockCode PROC
;;;451    
;;;452    INT32 _sysUnLockCode()
000000  ee191f30          MRC      p15,#0x0,r1,c9,c0,#1
;;;453    {
;;;454        int temp;
;;;455    
;;;456        /* unlock I-cache way 3 */
;;;457        __asm
;;;458        {
;;;459            MRC p15, 0, temp, c9, c0, 1;
;;;460            BIC temp, temp, 0x08 ;
000004  e3c11008          BIC      r1,r1,#8
;;;461            MCR p15, 0, temp, c9, c0, 1;
000008  ee091f30          MCR      p15,#0x0,r1,c9,c0,#1
;;;462    
;;;463        }
;;;464    
;;;465        return 0;
00000c  e3a00000          MOV      r0,#0
;;;466    }
000010  e12fff1e          BX       lr
;;;467    
                          ENDP


                          AREA ||i.sysDisableCache||, CODE, READONLY, ALIGN=2

                  sysDisableCache PROC
;;;491     */
;;;492    void sysDisableCache(void)
000000  e92d4010          PUSH     {r4,lr}
;;;493    {
;;;494        int temp;
;;;495    
;;;496        sys_flush_and_clean_dcache();
000004  ebfffffe          BL       sys_flush_and_clean_dcache
;;;497        __asm
;;;498        {
;;;499            /*----- flush I, D cache & write buffer -----*/
;;;500            MOV temp, 0x0
000008  e3a04000          MOV      r4,#0
;;;501            MCR p15, 0, temp, c7, c5, 0 /* flush I cache */
00000c  ee074f15          MCR      p15,#0x0,r4,c7,c5,#0
;;;502            MCR p15, 0, temp, c7, c6, 0 /* flush D cache */
000010  ee074f16          MCR      p15,#0x0,r4,c7,c6,#0
;;;503            MCR p15, 0, temp, c7, c10,4 /* drain write buffer */
000014  ee074f9a          MCR      p15,#0x0,r4,c7,c10,#4
;;;504    
;;;505            /*----- disable Protection Unit -----*/
;;;506            MRC p15, 0, temp, c1, c0, 0     /* read Control register */
000018  ee114f10          MRC      p15,#0x0,r4,c1,c0,#0
;;;507            BIC temp, temp, 0x01
00001c  e3c44001          BIC      r4,r4,#1
;;;508            MCR p15, 0, temp, c1, c0, 0     /* write Control register */
000020  ee014f10          MCR      p15,#0x0,r4,c1,c0,#0
;;;509        }
;;;510        _sys_IsCacheOn = FALSE;
000024  e3a00000          MOV      r0,#0
000028  e59f1010          LDR      r1,|L3.64|
00002c  e5c10000          STRB     r0,[r1,#0]  ; _sys_IsCacheOn
;;;511        _sys_CacheMode = CACHE_DISABLE;
000030  e3e00000          MVN      r0,#0
000034  e59f1008          LDR      r1,|L3.68|
000038  e5810000          STR      r0,[r1,#0]  ; _sys_CacheMode
;;;512    
;;;513    }
00003c  e8bd8010          POP      {r4,pc}
;;;514    
                          ENDP

                  |L3.64|
                          DCD      _sys_IsCacheOn
                  |L3.68|
                          DCD      _sys_CacheMode

                          AREA ||i.sysEnableCache||, CODE, READONLY, ALIGN=2

                  sysEnableCache PROC
;;;477     */
;;;478    INT32 sysEnableCache(UINT32 uCacheOpMode)
000000  e92d4010          PUSH     {r4,lr}
;;;479    {
000004  e1a04000          MOV      r4,r0
;;;480        sysInitMMUTable(uCacheOpMode);
000008  e1a00004          MOV      r0,r4
00000c  ebfffffe          BL       sysInitMMUTable
;;;481        _sys_IsCacheOn = TRUE;
000010  e3a00001          MOV      r0,#1
000014  e59f1010          LDR      r1,|L4.44|
000018  e5c10000          STRB     r0,[r1,#0]  ; _sys_IsCacheOn
;;;482        _sys_CacheMode = uCacheOpMode;
00001c  e59f000c          LDR      r0,|L4.48|
000020  e5804000          STR      r4,[r0,#0]  ; _sys_CacheMode
;;;483    
;;;484        return 0;
000024  e3a00000          MOV      r0,#0
;;;485    }
000028  e8bd8010          POP      {r4,pc}
;;;486    
                          ENDP

                  |L4.44|
                          DCD      _sys_IsCacheOn
                  |L4.48|
                          DCD      _sys_CacheMode

                          AREA ||i.sysFlushCache||, CODE, READONLY, ALIGN=2

                  sysFlushCache PROC
;;;347    
;;;348    void sysFlushCache(INT32 nCacheType)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;349    {
000004  e1a05000          MOV      r5,r0
;;;350        int temp;
;;;351    
;;;352        switch (nCacheType)
000008  e3550006          CMP      r5,#6
00000c  0a000004          BEQ      |L5.36|
000010  e3550007          CMP      r5,#7
000014  0a000006          BEQ      |L5.52|
000018  e3550008          CMP      r5,#8
00001c  1a00000f          BNE      |L5.96|
000020  ea000008          B        |L5.72|
                  |L5.36|
;;;353        {
;;;354            case I_CACHE:
000024  e1a00000          MOV      r0,r0
;;;355                __asm
;;;356                {
;;;357                    /*----- flush I-cache -----*/
;;;358                    MOV temp, 0x0
000028  e3a04000          MOV      r4,#0
;;;359                    MCR p15, 0, temp, c7, c5, 0 /* invalidate I cache */
00002c  ee074f15          MCR      p15,#0x0,r4,c7,c5,#0
;;;360                }
;;;361                break;
000030  ea00000c          B        |L5.104|
                  |L5.52|
;;;362    
;;;363            case D_CACHE:
000034  e1a00000          MOV      r0,r0
;;;364                sys_flush_and_clean_dcache();
000038  ebfffffe          BL       sys_flush_and_clean_dcache
;;;365                __asm
;;;366                {
;;;367                    /*----- flush D-cache & write buffer -----*/
;;;368                    MOV temp, 0x0
00003c  e3a04000          MOV      r4,#0
;;;369                    MCR p15, 0, temp, c7, c10, 4 /* drain write buffer */
000040  ee074f9a          MCR      p15,#0x0,r4,c7,c10,#4
;;;370                }
;;;371                break;
000044  ea000007          B        |L5.104|
                  |L5.72|
;;;372    
;;;373            case I_D_CACHE:
000048  e1a00000          MOV      r0,r0
;;;374                sys_flush_and_clean_dcache();
00004c  ebfffffe          BL       sys_flush_and_clean_dcache
;;;375                __asm
;;;376                {
;;;377                    /*----- flush I, D cache & write buffer -----*/
;;;378                    MOV temp, 0x0
000050  e3a04000          MOV      r4,#0
;;;379                    MCR p15, 0, temp, c7, c5, 0 /* invalidate I cache */
000054  ee074f15          MCR      p15,#0x0,r4,c7,c5,#0
;;;380                    MCR p15, 0, temp, c7, c10, 4 /* drain write buffer */
000058  ee074f9a          MCR      p15,#0x0,r4,c7,c10,#4
;;;381                }
;;;382                break;
00005c  ea000001          B        |L5.104|
                  |L5.96|
;;;383    
;;;384            default:
000060  e1a00000          MOV      r0,r0
000064  e1a00000          MOV      r0,r0                 ;352
                  |L5.104|
000068  e1a00000          MOV      r0,r0                 ;361
;;;385                ;
;;;386        }
;;;387    }
00006c  e8bd8070          POP      {r4-r6,pc}
;;;388    
                          ENDP


                          AREA ||i.sysGetCacheMode||, CODE, READONLY, ALIGN=2

                  sysGetCacheMode PROC
;;;405    
;;;406    INT32 sysGetCacheMode()
000000  e59f0004          LDR      r0,|L6.12|
;;;407    {
;;;408        return _sys_CacheMode;
000004  e5900000          LDR      r0,[r0,#0]  ; _sys_CacheMode
;;;409    }
000008  e12fff1e          BX       lr
;;;410    
                          ENDP

                  |L6.12|
                          DCD      _sys_CacheMode

                          AREA ||i.sysGetCacheState||, CODE, READONLY, ALIGN=2

                  sysGetCacheState PROC
;;;399    
;;;400    BOOL sysGetCacheState()
000000  e59f0004          LDR      r0,|L7.12|
;;;401    {
;;;402        return _sys_IsCacheOn;
000004  e5d00000          LDRB     r0,[r0,#0]  ; _sys_IsCacheOn
;;;403    }
000008  e12fff1e          BX       lr
;;;404    
                          ENDP

                  |L7.12|
                          DCD      _sys_IsCacheOn

                          AREA ||i.sysGetPhyPageAddr||, CODE, READONLY, ALIGN=2

                  sysGetPhyPageAddr PROC
;;;40     
;;;41     unsigned int sysGetPhyPageAddr(unsigned int vaddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;42     {
000004  e1a01000          MOV      r1,r0
;;;43         int table_num, page_num;
;;;44         unsigned int base_addr, page_base, page_offset, phy_addr;
;;;45         volatile _CTable *PageTabPtr;
;;;46     
;;;47         if (vaddr & 0x80000000)
000008  e2010102          AND      r0,r1,#0x80000000
00000c  e3500000          CMP      r0,#0
000010  0a000001          BEQ      |L8.28|
;;;48             PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000014  e59f204c          LDR      r2,|L8.104|
000018  ea000000          B        |L8.32|
                  |L8.28|
;;;49         else
;;;50             PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
00001c  e59f2048          LDR      r2,|L8.108|
                  |L8.32|
;;;51     
;;;52         if (sysGetCacheState() == TRUE)
000020  ebfffffe          BL       sysGetCacheState
000024  e3500001          CMP      r0,#1
000028  1a000000          BNE      |L8.48|
;;;53             PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
00002c  e3822102          ORR      r2,r2,#0x80000000
                  |L8.48|
;;;54     
;;;55         base_addr = vaddr & 0x7FFFF000;
000030  e3c1313e          BIC      r3,r1,#0x8000000f
000034  e3c33eff          BIC      r3,r3,#0xff0
;;;56         table_num = base_addr / 0x100000;
000038  e1a04a23          LSR      r4,r3,#20
;;;57         page_num = (base_addr & 0xFF000) >> 12;
00003c  e2030aff          AND      r0,r3,#0xff000
000040  e1a05620          LSR      r5,r0,#12
;;;58     
;;;59         page_base = (*(PageTabPtr+table_num)).page[page_num] & 0xFFFFF000;
000044  e0820504          ADD      r0,r2,r4,LSL #10
000048  e7900105          LDR      r0,[r0,r5,LSL #2]
00004c  e1a06620          LSR      r6,r0,#12
000050  e1a06606          LSL      r6,r6,#12
;;;60         page_offset = vaddr & 0xFFF;
000054  e1a07a01          LSL      r7,r1,#20
000058  e1a07a27          LSR      r7,r7,#20
;;;61         phy_addr = page_base + page_offset;
00005c  e0868007          ADD      r8,r6,r7
;;;62     
;;;63         return phy_addr;
000060  e1a00008          MOV      r0,r8
;;;64     
;;;65     } /* end sysGetPHYAddr */
000064  e8bd81f0          POP      {r4-r8,pc}
;;;66     
                          ENDP

                  |L8.104|
                          DCD      _mmuCoarsePageTable_NonCache
                  |L8.108|
                          DCD      _mmuCoarsePageTable

                          AREA ||i.sysGetSdramSizebyMB||, CODE, READONLY, ALIGN=2

                  sysGetSdramSizebyMB PROC
;;;273    
;;;274    INT32 sysGetSdramSizebyMB()
000000  e92d400c          PUSH     {r2,r3,lr}
;;;275    {
;;;276        unsigned int volatile reg, totalsize=0;
000004  e3a00000          MOV      r0,#0
000008  e58d0000          STR      r0,[sp,#0]
;;;277    
;;;278        reg = inpw(SDIC_BA+0x10) & 0x07;
00000c  e59f01b4          LDR      r0,|L9.456|
000010  e5900000          LDR      r0,[r0,#0]
000014  e2000007          AND      r0,r0,#7
000018  e58d0004          STR      r0,[sp,#4]
;;;279        switch(reg)
00001c  e59d0004          LDR      r0,[sp,#4]
000020  e3500008          CMP      r0,#8
000024  308ff100          ADDCC    pc,pc,r0,LSL #2
000028  ea00002a          B        |L9.216|
00002c  ea000029          B        |L9.216|
000030  ea000005          B        |L9.76|
000034  ea000009          B        |L9.96|
000038  ea00000d          B        |L9.116|
00003c  ea000011          B        |L9.136|
000040  ea000015          B        |L9.156|
000044  ea000019          B        |L9.176|
000048  ea00001d          B        |L9.196|
                  |L9.76|
;;;280        {
;;;281            case 1:
00004c  e1a00000          MOV      r0,r0
;;;282                totalsize += 2;
000050  e59d0000          LDR      r0,[sp,#0]
000054  e2800002          ADD      r0,r0,#2
000058  e58d0000          STR      r0,[sp,#0]
;;;283                break;
00005c  ea00001d          B        |L9.216|
                  |L9.96|
;;;284    
;;;285            case 2:
000060  e1a00000          MOV      r0,r0
;;;286                totalsize += 4;
000064  e59d0000          LDR      r0,[sp,#0]
000068  e2800004          ADD      r0,r0,#4
00006c  e58d0000          STR      r0,[sp,#0]
;;;287                break;
000070  ea000018          B        |L9.216|
                  |L9.116|
;;;288    
;;;289            case 3:
000074  e1a00000          MOV      r0,r0
;;;290                totalsize += 8;
000078  e59d0000          LDR      r0,[sp,#0]
00007c  e2800008          ADD      r0,r0,#8
000080  e58d0000          STR      r0,[sp,#0]
;;;291                break;
000084  ea000013          B        |L9.216|
                  |L9.136|
;;;292    
;;;293            case 4:
000088  e1a00000          MOV      r0,r0
;;;294                totalsize += 16;
00008c  e59d0000          LDR      r0,[sp,#0]
000090  e2800010          ADD      r0,r0,#0x10
000094  e58d0000          STR      r0,[sp,#0]
;;;295                break;
000098  ea00000e          B        |L9.216|
                  |L9.156|
;;;296    
;;;297            case 5:
00009c  e1a00000          MOV      r0,r0
;;;298                totalsize += 32;
0000a0  e59d0000          LDR      r0,[sp,#0]
0000a4  e2800020          ADD      r0,r0,#0x20
0000a8  e58d0000          STR      r0,[sp,#0]
;;;299                break;
0000ac  ea000009          B        |L9.216|
                  |L9.176|
;;;300    
;;;301            case 6:
0000b0  e1a00000          MOV      r0,r0
;;;302                totalsize += 64;
0000b4  e59d0000          LDR      r0,[sp,#0]
0000b8  e2800040          ADD      r0,r0,#0x40
0000bc  e58d0000          STR      r0,[sp,#0]
;;;303                break;
0000c0  ea000004          B        |L9.216|
                  |L9.196|
;;;304    
;;;305            case 7:
0000c4  e1a00000          MOV      r0,r0
;;;306                totalsize += 128;
0000c8  e59d0000          LDR      r0,[sp,#0]
0000cc  e2800080          ADD      r0,r0,#0x80
0000d0  e58d0000          STR      r0,[sp,#0]
;;;307                break;
0000d4  e1a00000          MOV      r0,r0
                  |L9.216|
0000d8  e1a00000          MOV      r0,r0                 ;283
;;;308        }
;;;309    
;;;310        reg = inpw(SDIC_BA+0x14) & 0x07;
0000dc  e59f00e8          LDR      r0,|L9.460|
0000e0  e5900000          LDR      r0,[r0,#0]
0000e4  e2000007          AND      r0,r0,#7
0000e8  e58d0004          STR      r0,[sp,#4]
;;;311        switch(reg)
0000ec  e59d0004          LDR      r0,[sp,#4]
0000f0  e3500008          CMP      r0,#8
0000f4  308ff100          ADDCC    pc,pc,r0,LSL #2
0000f8  ea00002a          B        |L9.424|
0000fc  ea000029          B        |L9.424|
000100  ea000005          B        |L9.284|
000104  ea000009          B        |L9.304|
000108  ea00000d          B        |L9.324|
00010c  ea000011          B        |L9.344|
000110  ea000015          B        |L9.364|
000114  ea000019          B        |L9.384|
000118  ea00001d          B        |L9.404|
                  |L9.284|
;;;312        {
;;;313            case 1:
00011c  e1a00000          MOV      r0,r0
;;;314                totalsize += 2;
000120  e59d0000          LDR      r0,[sp,#0]
000124  e2800002          ADD      r0,r0,#2
000128  e58d0000          STR      r0,[sp,#0]
;;;315                break;
00012c  ea00001d          B        |L9.424|
                  |L9.304|
;;;316    
;;;317            case 2:
000130  e1a00000          MOV      r0,r0
;;;318                totalsize += 4;
000134  e59d0000          LDR      r0,[sp,#0]
000138  e2800004          ADD      r0,r0,#4
00013c  e58d0000          STR      r0,[sp,#0]
;;;319                break;
000140  ea000018          B        |L9.424|
                  |L9.324|
;;;320    
;;;321            case 3:
000144  e1a00000          MOV      r0,r0
;;;322                totalsize += 8;
000148  e59d0000          LDR      r0,[sp,#0]
00014c  e2800008          ADD      r0,r0,#8
000150  e58d0000          STR      r0,[sp,#0]
;;;323                break;
000154  ea000013          B        |L9.424|
                  |L9.344|
;;;324    
;;;325            case 4:
000158  e1a00000          MOV      r0,r0
;;;326                totalsize += 16;
00015c  e59d0000          LDR      r0,[sp,#0]
000160  e2800010          ADD      r0,r0,#0x10
000164  e58d0000          STR      r0,[sp,#0]
;;;327                break;
000168  ea00000e          B        |L9.424|
                  |L9.364|
;;;328    
;;;329            case 5:
00016c  e1a00000          MOV      r0,r0
;;;330                totalsize += 32;
000170  e59d0000          LDR      r0,[sp,#0]
000174  e2800020          ADD      r0,r0,#0x20
000178  e58d0000          STR      r0,[sp,#0]
;;;331                break;
00017c  ea000009          B        |L9.424|
                  |L9.384|
;;;332    
;;;333            case 6:
000180  e1a00000          MOV      r0,r0
;;;334                totalsize += 64;
000184  e59d0000          LDR      r0,[sp,#0]
000188  e2800040          ADD      r0,r0,#0x40
00018c  e58d0000          STR      r0,[sp,#0]
;;;335                break;
000190  ea000004          B        |L9.424|
                  |L9.404|
;;;336    
;;;337            case 7:
000194  e1a00000          MOV      r0,r0
;;;338                totalsize += 128;
000198  e59d0000          LDR      r0,[sp,#0]
00019c  e2800080          ADD      r0,r0,#0x80
0001a0  e58d0000          STR      r0,[sp,#0]
;;;339                break;
0001a4  e1a00000          MOV      r0,r0
                  |L9.424|
0001a8  e1a00000          MOV      r0,r0                 ;315
;;;340        }
;;;341    
;;;342        if (totalsize != 0)
0001ac  e59d0000          LDR      r0,[sp,#0]
0001b0  e3500000          CMP      r0,#0
0001b4  0a000001          BEQ      |L9.448|
;;;343            return totalsize;
0001b8  e59d0000          LDR      r0,[sp,#0]
                  |L9.444|
;;;344        else
;;;345            return 1;
;;;346    }
0001bc  e8bd800c          POP      {r2,r3,pc}
                  |L9.448|
0001c0  e3a00001          MOV      r0,#1                 ;345
0001c4  eafffffc          B        |L9.444|
;;;347    
                          ENDP

                  |L9.456|
                          DCD      0xb0001810
                  |L9.460|
                          DCD      0xb0001814

                          AREA ||i.sysInitMMUTable||, CODE, READONLY, ALIGN=2

                  sysInitMMUTable PROC
;;;187    
;;;188    int sysInitMMUTable(int cache_mode)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;189    {
000004  e1a07000          MOV      r7,r0
;;;190        unsigned volatile int temp;
;;;191        int i, size, ramsize;
;;;192    
;;;193        if (_IsInitMMUTable == FALSE)
000008  e59f02a0          LDR      r0,|L10.688|
00000c  e5d00000          LDRB     r0,[r0,#0]  ; _IsInitMMUTable
000010  e3500000          CMP      r0,#0
000014  1a0000a1          BNE      |L10.672|
;;;194        {
;;;195            ramsize = sysGetSdramSizebyMB();
000018  ebfffffe          BL       sysGetSdramSizebyMB
00001c  e1a06000          MOV      r6,r0
;;;196    
;;;197            //flat mapping for 4GB, 4096 section table, each size is 1MB
;;;198            temp = 0xC00;   /* (11:10) access permission, R/W */
000020  e3a00b03          MOV      r0,#0xc00
000024  e58d0004          STR      r0,[sp,#4]
;;;199            temp |= 0x1E0;  /* (8:5) domain 15 */
000028  e59d0004          LDR      r0,[sp,#4]
00002c  e3800e1e          ORR      r0,r0,#0x1e0
000030  e58d0004          STR      r0,[sp,#4]
;;;200            temp |= 0x10;   /* bit 4 must be 1 */
000034  e59d0004          LDR      r0,[sp,#4]
000038  e3800010          ORR      r0,r0,#0x10
00003c  e58d0004          STR      r0,[sp,#4]
;;;201            temp |= 0x00;   /* bit 3:2 for cache control bits, cache disabled */
000040  e59d0004          LDR      r0,[sp,#4]
000044  e58d0004          STR      r0,[sp,#4]
;;;202            temp |= 0x02;   /* set as 1Mb section */
000048  e59d0004          LDR      r0,[sp,#4]
00004c  e3800002          ORR      r0,r0,#2
000050  e58d0004          STR      r0,[sp,#4]
;;;203    
;;;204            for (i=0; i<4096; i++)
000054  e3a04000          MOV      r4,#0
000058  ea000004          B        |L10.112|
                  |L10.92|
;;;205            {
;;;206                _mmuSectionTable[i] = (unsigned int)(temp | (i << 20));
00005c  e59d0004          LDR      r0,[sp,#4]
000060  e1800a04          ORR      r0,r0,r4,LSL #20
000064  e59f1248          LDR      r1,|L10.692|
000068  e7810104          STR      r0,[r1,r4,LSL #2]
00006c  e2844001          ADD      r4,r4,#1              ;204
                  |L10.112|
000070  e3540a01          CMP      r4,#0x1000            ;204
000074  bafffff8          BLT      |L10.92|
;;;207            }
;;;208    
;;;209            //Inside SDRAM, divide each section into 256 small pages, each page size is 4KB
;;;210            if (ramsize > _CoarsePageSize) size = _CoarsePageSize;  //maximum 128MB
000078  e3560080          CMP      r6,#0x80
00007c  da000001          BLE      |L10.136|
000080  e3a05080          MOV      r5,#0x80
000084  ea000000          B        |L10.140|
                  |L10.136|
;;;211            else                           size = ramsize;
000088  e1a05006          MOV      r5,r6
                  |L10.140|
;;;212    
;;;213            /* first 1M always direct mapping */
;;;214            sysInitPageTable(0, 0, 0x100000, cache_mode, MMU_DIRECT_MAPPING);
00008c  e3a00000          MOV      r0,#0
000090  e1a03007          MOV      r3,r7
000094  e3a02601          MOV      r2,#0x100000
000098  e58d0000          STR      r0,[sp,#0]
00009c  e1a01000          MOV      r1,r0
0000a0  ebfffffe          BL       sysInitPageTable
;;;215            temp = ((unsigned int)_mmuCoarsePageTable  & 0xFFFFFC00); /*  coarse table base address */
0000a4  e59f020c          LDR      r0,|L10.696|
0000a8  e1a00520          LSR      r0,r0,#10
0000ac  e1a00500          LSL      r0,r0,#10
0000b0  e58d0004          STR      r0,[sp,#4]
;;;216            temp |= 0x1E0;  /* (8:5) domain 15 */
0000b4  e59d0004          LDR      r0,[sp,#4]
0000b8  e3800e1e          ORR      r0,r0,#0x1e0
0000bc  e58d0004          STR      r0,[sp,#4]
;;;217            temp |= 0x10;   /* bit 4 must be 1 */
0000c0  e59d0004          LDR      r0,[sp,#4]
0000c4  e3800010          ORR      r0,r0,#0x10
0000c8  e58d0004          STR      r0,[sp,#4]
;;;218            temp |= 0x01;   /* Coarse page table */
0000cc  e59d0004          LDR      r0,[sp,#4]
0000d0  e3800001          ORR      r0,r0,#1
0000d4  e58d0004          STR      r0,[sp,#4]
;;;219            _mmuSectionTable[0] = temp;
0000d8  e59f11d4          LDR      r1,|L10.692|
0000dc  e59d0004          LDR      r0,[sp,#4]
0000e0  e5810000          STR      r0,[r1,#0]  ; _mmuSectionTable
;;;220    
;;;221            /* Create a shadow area at 0x80000000 for non-cacheable region */
;;;222            sysInitPageTable(0x80000000, 0x0, 0x100000, CACHE_DISABLE, MMU_DIRECT_MAPPING);
0000e4  e3a00000          MOV      r0,#0
0000e8  e3e03000          MVN      r3,#0
0000ec  e3a02601          MOV      r2,#0x100000
0000f0  e58d0000          STR      r0,[sp,#0]
0000f4  e1a01000          MOV      r1,r0
0000f8  e3a00102          MOV      r0,#0x80000000
0000fc  ebfffffe          BL       sysInitPageTable
;;;223            temp = ((unsigned int)_mmuCoarsePageTable_NonCache  & 0xFFFFFC00); /*  coarse table base address */
000100  e59f01b4          LDR      r0,|L10.700|
000104  e1a00520          LSR      r0,r0,#10
000108  e1a00500          LSL      r0,r0,#10
00010c  e58d0004          STR      r0,[sp,#4]
;;;224            temp |= 0x1E0;  /* (8:5) domain 15 */
000110  e59d0004          LDR      r0,[sp,#4]
000114  e3800e1e          ORR      r0,r0,#0x1e0
000118  e58d0004          STR      r0,[sp,#4]
;;;225            temp |= 0x10;   /* bit 4 must be 1 */
00011c  e59d0004          LDR      r0,[sp,#4]
000120  e3800010          ORR      r0,r0,#0x10
000124  e58d0004          STR      r0,[sp,#4]
;;;226            temp |= 0x01;   /* Coarse page table */
000128  e59d0004          LDR      r0,[sp,#4]
00012c  e3800001          ORR      r0,r0,#1
000130  e58d0004          STR      r0,[sp,#4]
;;;227            _mmuSectionTable[0x800] = temp;
000134  e59f1184          LDR      r1,|L10.704|
000138  e59d0004          LDR      r0,[sp,#4]
00013c  e5810000          STR      r0,[r1,#0]  ; _mmuSectionTable
;;;228    
;;;229            /* Mapping the other memory */
;;;230            for (i=1; i< size; i++)
000140  e3a04001          MOV      r4,#1
000144  ea000024          B        |L10.476|
                  |L10.328|
;;;231            {
;;;232                temp = (((unsigned int)_mmuCoarsePageTable + (unsigned int)i*1024) & 0xFFFFFC00); /*  coarse table base address */
000148  e59f0168          LDR      r0,|L10.696|
00014c  e0800504          ADD      r0,r0,r4,LSL #10
000150  e1a00520          LSR      r0,r0,#10
000154  e1a00500          LSL      r0,r0,#10
000158  e58d0004          STR      r0,[sp,#4]
;;;233                //temp = ((unsigned int)(0x604000 + i*1024) & 0xFFFFFC00); /* coarse table base address */
;;;234                temp |= 0x1E0;  /* (8:5) domain 15 */
00015c  e59d0004          LDR      r0,[sp,#4]
000160  e3800e1e          ORR      r0,r0,#0x1e0
000164  e58d0004          STR      r0,[sp,#4]
;;;235                temp |= 0x10;   /* bit 4 must be 1 */
000168  e59d0004          LDR      r0,[sp,#4]
00016c  e3800010          ORR      r0,r0,#0x10
000170  e58d0004          STR      r0,[sp,#4]
;;;236                temp |= 0x01;   /* Coarse page table */
000174  e59d0004          LDR      r0,[sp,#4]
000178  e3800001          ORR      r0,r0,#1
00017c  e58d0004          STR      r0,[sp,#4]
;;;237    
;;;238                if (_MMUMappingMode == MMU_DIRECT_MAPPING)
000180  e59f013c          LDR      r0,|L10.708|
000184  e5900000          LDR      r0,[r0,#0]  ; _MMUMappingMode
000188  e3500000          CMP      r0,#0
00018c  1a000007          BNE      |L10.432|
;;;239                    sysInitPageTable((i << 20), (i << 20), 0x100000, cache_mode, MMU_DIRECT_MAPPING); /* direct mapping */
000190  e3a00000          MOV      r0,#0
000194  e1a01a04          LSL      r1,r4,#20
000198  e58d0000          STR      r0,[sp,#0]
00019c  e1a00a04          LSL      r0,r4,#20
0001a0  e1a03007          MOV      r3,r7
0001a4  e3a02601          MOV      r2,#0x100000
0001a8  ebfffffe          BL       sysInitPageTable
0001ac  ea000006          B        |L10.460|
                  |L10.432|
;;;240                else
;;;241                    sysInitPageTable((i << 20), (i << 20), 0x100000, cache_mode, MMU_INVERSE_MAPPING); /* inverse mapping for each 1MB area */
0001b0  e3a00001          MOV      r0,#1
0001b4  e1a01a04          LSL      r1,r4,#20
0001b8  e58d0000          STR      r0,[sp,#0]
0001bc  e1a00a04          LSL      r0,r4,#20
0001c0  e1a03007          MOV      r3,r7
0001c4  e3a02601          MOV      r2,#0x100000
0001c8  ebfffffe          BL       sysInitPageTable
                  |L10.460|
;;;242    
;;;243                _mmuSectionTable[i] = temp;
0001cc  e59f10e0          LDR      r1,|L10.692|
0001d0  e59d0004          LDR      r0,[sp,#4]
0001d4  e7810104          STR      r0,[r1,r4,LSL #2]
0001d8  e2844001          ADD      r4,r4,#1              ;230
                  |L10.476|
0001dc  e1540005          CMP      r4,r5                 ;230
0001e0  baffffd8          BLT      |L10.328|
;;;244            }
;;;245    
;;;246            //Create shadow non-cacheabel region
;;;247            for (i=1; i< size; i++)
0001e4  e3a04001          MOV      r4,#1
0001e8  ea000027          B        |L10.652|
                  |L10.492|
;;;248            {
;;;249                temp = (((unsigned int)_mmuCoarsePageTable_NonCache + (unsigned int)i*1024) & 0xFFFFFC00); /*  coarse table base address */
0001ec  e59f00c8          LDR      r0,|L10.700|
0001f0  e0800504          ADD      r0,r0,r4,LSL #10
0001f4  e1a00520          LSR      r0,r0,#10
0001f8  e1a00500          LSL      r0,r0,#10
0001fc  e58d0004          STR      r0,[sp,#4]
;;;250                //temp = ((unsigned int)(0x604000 + i*1024) & 0xFFFFFC00); /* coarse table base address */
;;;251                temp |= 0x1E0;  /* (8:5) domain 15 */
000200  e59d0004          LDR      r0,[sp,#4]
000204  e3800e1e          ORR      r0,r0,#0x1e0
000208  e58d0004          STR      r0,[sp,#4]
;;;252                temp |= 0x10;   /* bit 4 must be 1 */
00020c  e59d0004          LDR      r0,[sp,#4]
000210  e3800010          ORR      r0,r0,#0x10
000214  e58d0004          STR      r0,[sp,#4]
;;;253                temp |= 0x01;   /* Coarse page table */
000218  e59d0004          LDR      r0,[sp,#4]
00021c  e3800001          ORR      r0,r0,#1
000220  e58d0004          STR      r0,[sp,#4]
;;;254    
;;;255                if (_MMUMappingMode == MMU_DIRECT_MAPPING)
000224  e59f0098          LDR      r0,|L10.708|
000228  e5900000          LDR      r0,[r0,#0]  ; _MMUMappingMode
00022c  e3500000          CMP      r0,#0
000230  1a000008          BNE      |L10.600|
;;;256                    sysInitPageTable(((i << 20) | 0x80000000), (i << 20), 0x100000, CACHE_DISABLE, MMU_DIRECT_MAPPING); /* direct mapping */
000234  e3a00000          MOV      r0,#0
000238  e1a01a04          LSL      r1,r4,#20
00023c  e3a02102          MOV      r2,#0x80000000
000240  e58d0000          STR      r0,[sp,#0]
000244  e1820a04          ORR      r0,r2,r4,LSL #20
000248  e3e03000          MVN      r3,#0
00024c  e3a02601          MOV      r2,#0x100000
000250  ebfffffe          BL       sysInitPageTable
000254  ea000007          B        |L10.632|
                  |L10.600|
;;;257                else
;;;258                    sysInitPageTable(((i << 20) | 0x80000000), (i << 20), 0x100000, CACHE_DISABLE, MMU_INVERSE_MAPPING); /* inverse mapping for each 1MB area */
000258  e3a00001          MOV      r0,#1
00025c  e1a01a04          LSL      r1,r4,#20
000260  e3a02102          MOV      r2,#0x80000000
000264  e58d0000          STR      r0,[sp,#0]
000268  e1820a04          ORR      r0,r2,r4,LSL #20
00026c  e3e03000          MVN      r3,#0
000270  e3a02601          MOV      r2,#0x100000
000274  ebfffffe          BL       sysInitPageTable
                  |L10.632|
;;;259    
;;;260                _mmuSectionTable[0x800+i] = temp;
000278  e2841b02          ADD      r1,r4,#0x800
00027c  e59f2030          LDR      r2,|L10.692|
000280  e59d0004          LDR      r0,[sp,#4]
000284  e7820101          STR      r0,[r2,r1,LSL #2]
000288  e2844001          ADD      r4,r4,#1              ;247
                  |L10.652|
00028c  e1540005          CMP      r4,r5                 ;247
000290  baffffd5          BLT      |L10.492|
;;;261            }
;;;262    
;;;263            _IsInitMMUTable = TRUE;
000294  e3a00001          MOV      r0,#1
000298  e59f1010          LDR      r1,|L10.688|
00029c  e5c10000          STRB     r0,[r1,#0]  ; _IsInitMMUTable
                  |L10.672|
;;;264        }
;;;265    
;;;266        //moved here by cmn [2007/01/27]
;;;267        //set CP15 registers
;;;268        sysSetupCP15((unsigned int)_mmuSectionTable);
0002a0  e59f000c          LDR      r0,|L10.692|
0002a4  ebfffffe          BL       sysSetupCP15
;;;269    
;;;270        return 0;
0002a8  e3a00000          MOV      r0,#0
;;;271    
;;;272    } /* end sysInitMMUTable */
0002ac  e8bd81fc          POP      {r2-r8,pc}
;;;273    
                          ENDP

                  |L10.688|
                          DCD      _IsInitMMUTable
                  |L10.692|
                          DCD      _mmuSectionTable
                  |L10.696|
                          DCD      _mmuCoarsePageTable
                  |L10.700|
                          DCD      _mmuCoarsePageTable_NonCache
                  |L10.704|
                          DCD      _mmuSectionTable+0x2000
                  |L10.708|
                          DCD      _MMUMappingMode

                          AREA ||i.sysInitPageTable||, CODE, READONLY, ALIGN=2

                  sysInitPageTable PROC
;;;117    
;;;118    int sysInitPageTable(unsigned int vaddr, unsigned int phy_addr, int size, int cache_flag, int rev_flag)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;119    {
000004  e1a04000          MOV      r4,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a07003          MOV      r7,r3
;;;120        int i, cnt, table_num, page_num, cache_mode, addr_offset;
;;;121        unsigned volatile int phy_base_addr, vbase_addr, temp;
;;;122        volatile _CTable *PageTabPtr;
;;;123    
;;;124        if (vaddr & 0x80000000)
000010  e2040102          AND      r0,r4,#0x80000000
000014  e3500000          CMP      r0,#0
000018  0a000001          BEQ      |L11.36|
;;;125            PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
00001c  e59f515c          LDR      r5,|L11.384|
000020  ea000000          B        |L11.40|
                  |L11.36|
;;;126        else
;;;127            PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
000024  e59f5158          LDR      r5,|L11.388|
                  |L11.40|
;;;128    
;;;129        if (sysGetCacheState() == TRUE)
000028  ebfffffe          BL       sysGetCacheState
00002c  e3500001          CMP      r0,#1
000030  1a000000          BNE      |L11.56|
;;;130            PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
000034  e3855102          ORR      r5,r5,#0x80000000
                  |L11.56|
;;;131    
;;;132        //if ( _IsInitMMUTable == FALSE ) return -1;
;;;133        vaddr &= 0x7FFFFFFF;    //ignore the non-cacheable bit 31
000038  e3c44102          BIC      r4,r4,#0x80000000
;;;134        if ((vaddr + size) > (_CoarsePageSize << 20)) return -1;
00003c  e0840002          ADD      r0,r4,r2
000040  e3500302          CMP      r0,#0x8000000
000044  9a000001          BLS      |L11.80|
000048  e3e00000          MVN      r0,#0
                  |L11.76|
;;;135        if (vaddr & 0xFFFFF)    return -1;  /* MUST 1M Boundary */
;;;136        if (size % 4096)        return -1;  /* MUST 4K multiple size */
;;;137    
;;;138        /* Pages count */
;;;139        cnt = size / 4096;
;;;140    
;;;141        if (cache_flag == CACHE_WRITE_BACK) /* write back mode */
;;;142            cache_mode = 0x0C;
;;;143        else if (cache_flag == CACHE_WRITE_THROUGH) /* write through mode */
;;;144            cache_mode = 0x08;
;;;145        else
;;;146            cache_mode = 0; /* Non-cacheable, non-buffered */
;;;147    
;;;148    
;;;149        if (rev_flag == MMU_DIRECT_MAPPING)
;;;150            phy_base_addr = phy_addr;
;;;151        else
;;;152            phy_base_addr = phy_addr + size - 4096;
;;;153    
;;;154        addr_offset = 4096;
;;;155        for (i=0; i<cnt; i++)
;;;156        {
;;;157            vbase_addr = vaddr + i * 4096;
;;;158            table_num = vbase_addr / 0x100000;
;;;159            page_num =  (vbase_addr & 0xFF000) >> 12; /* bits [19:12] for level two table index */
;;;160    
;;;161            temp = phy_base_addr & 0xFFFFF000;
;;;162            temp |= 0xFF0; /* access permission, 11 for read/write */
;;;163            temp |= cache_mode; /* cache mode */
;;;164            temp |= 0x02;  /* small page */
;;;165    
;;;166            (*(PageTabPtr+table_num)).page[page_num] = temp;
;;;167    
;;;168            if (rev_flag == MMU_DIRECT_MAPPING)
;;;169                phy_base_addr += addr_offset;
;;;170            else
;;;171                phy_base_addr -= addr_offset;
;;;172        }
;;;173    
;;;174        return 0;
;;;175    
;;;176    } /* end sysInitPageTable */
00004c  e8bd8ffe          POP      {r1-r11,pc}
                  |L11.80|
000050  e1a00604          LSL      r0,r4,#12             ;135
000054  e1a00620          LSR      r0,r0,#12             ;135
000058  e3500000          CMP      r0,#0                 ;135
00005c  0a000001          BEQ      |L11.104|
000060  e3e00000          MVN      r0,#0                 ;135
000064  eafffff8          B        |L11.76|
                  |L11.104|
000068  e1a0cfc2          ASR      r12,r2,#31            ;136
00006c  e082ca2c          ADD      r12,r2,r12,LSR #20    ;136
000070  e1a0c64c          ASR      r12,r12,#12           ;136
000074  e042c60c          SUB      r12,r2,r12,LSL #12    ;136
000078  e35c0000          CMP      r12,#0                ;136
00007c  0a000001          BEQ      |L11.136|
000080  e3e00000          MVN      r0,#0                 ;136
000084  eafffff0          B        |L11.76|
                  |L11.136|
000088  e1a00002          MOV      r0,r2                 ;139
00008c  e1a0cfc2          ASR      r12,r2,#31            ;139
000090  e082ca2c          ADD      r12,r2,r12,LSR #20    ;139
000094  e1a0964c          ASR      r9,r12,#12            ;139
000098  e3570000          CMP      r7,#0                 ;141
00009c  1a000001          BNE      |L11.168|
0000a0  e3a0300c          MOV      r3,#0xc               ;142
0000a4  ea000004          B        |L11.188|
                  |L11.168|
0000a8  e3570001          CMP      r7,#1                 ;143
0000ac  1a000001          BNE      |L11.184|
0000b0  e3a03008          MOV      r3,#8                 ;144
0000b4  ea000000          B        |L11.188|
                  |L11.184|
0000b8  e3a03000          MOV      r3,#0                 ;146
                  |L11.188|
0000bc  e59d0030          LDR      r0,[sp,#0x30]         ;149
0000c0  e3500000          CMP      r0,#0                 ;149
0000c4  1a000001          BNE      |L11.208|
0000c8  e58d6008          STR      r6,[sp,#8]            ;150
0000cc  ea000002          B        |L11.220|
                  |L11.208|
0000d0  e0860002          ADD      r0,r6,r2              ;152
0000d4  e2400a01          SUB      r0,r0,#0x1000         ;152
0000d8  e58d0008          STR      r0,[sp,#8]            ;152
                  |L11.220|
0000dc  e3a08a01          MOV      r8,#0x1000            ;154
0000e0  e3a01000          MOV      r1,#0                 ;155
0000e4  ea000021          B        |L11.368|
                  |L11.232|
0000e8  e0840601          ADD      r0,r4,r1,LSL #12      ;157
0000ec  e58d0004          STR      r0,[sp,#4]            ;157
0000f0  e59d0004          LDR      r0,[sp,#4]            ;158
0000f4  e1a0aa20          LSR      r10,r0,#20            ;158
0000f8  e59d0004          LDR      r0,[sp,#4]            ;159
0000fc  e2000aff          AND      r0,r0,#0xff000        ;159
000100  e1a0b620          LSR      r11,r0,#12            ;159
000104  e59d0008          LDR      r0,[sp,#8]            ;161
000108  e1a00620          LSR      r0,r0,#12             ;161
00010c  e1a00600          LSL      r0,r0,#12             ;161
000110  e58d0000          STR      r0,[sp,#0]            ;161
000114  e59d0000          LDR      r0,[sp,#0]            ;162
000118  e3800eff          ORR      r0,r0,#0xff0          ;162
00011c  e58d0000          STR      r0,[sp,#0]            ;162
000120  e59d0000          LDR      r0,[sp,#0]            ;163
000124  e1800003          ORR      r0,r0,r3              ;163
000128  e58d0000          STR      r0,[sp,#0]            ;163
00012c  e59d0000          LDR      r0,[sp,#0]            ;164
000130  e3800002          ORR      r0,r0,#2              ;164
000134  e58d0000          STR      r0,[sp,#0]            ;164
000138  e085c50a          ADD      r12,r5,r10,LSL #10    ;166
00013c  e59d0000          LDR      r0,[sp,#0]            ;166
000140  e78c010b          STR      r0,[r12,r11,LSL #2]   ;166
000144  e59d0030          LDR      r0,[sp,#0x30]         ;168
000148  e3500000          CMP      r0,#0                 ;168
00014c  1a000003          BNE      |L11.352|
000150  e59d0008          LDR      r0,[sp,#8]            ;169
000154  e0800008          ADD      r0,r0,r8              ;169
000158  e58d0008          STR      r0,[sp,#8]            ;169
00015c  ea000002          B        |L11.364|
                  |L11.352|
000160  e59d0008          LDR      r0,[sp,#8]            ;171
000164  e0400008          SUB      r0,r0,r8              ;171
000168  e58d0008          STR      r0,[sp,#8]            ;171
                  |L11.364|
00016c  e2811001          ADD      r1,r1,#1              ;155
                  |L11.368|
000170  e1510009          CMP      r1,r9                 ;155
000174  baffffdb          BLT      |L11.232|
000178  e3a00000          MOV      r0,#0                 ;174
00017c  eaffffb2          B        |L11.76|
;;;177    
                          ENDP

                  |L11.384|
                          DCD      _mmuCoarsePageTable_NonCache
                  |L11.388|
                          DCD      _mmuCoarsePageTable

                          AREA ||i.sysInvalidCache||, CODE, READONLY, ALIGN=2

                  sysInvalidCache PROC
;;;388    
;;;389    void sysInvalidCache()
000000  e3a00000          MOV      r0,#0
;;;390    {
;;;391        int temp;
;;;392    
;;;393        __asm
;;;394        {
;;;395            MOV temp, 0x0
;;;396            MCR p15, 0, temp, c7, c7, 0 /* invalidate I and D cache */
000004  ee070f17          MCR      p15,#0x0,r0,c7,c7,#0
;;;397        }
;;;398    }
000008  e12fff1e          BX       lr
;;;399    
                          ENDP


                          AREA ||i.sysSetCachePages||, CODE, READONLY, ALIGN=2

                  sysSetCachePages PROC
;;;67     
;;;68     int sysSetCachePages(unsigned int vaddr, int size, int cache_flag)
000000  e92d43fc          PUSH     {r2-r9,lr}
;;;69     {
000004  e1a03000          MOV      r3,r0
000008  e1a06002          MOV      r6,r2
;;;70         int i, cnt, table_num, page_num, cache_mode;
;;;71         unsigned volatile int baseaddr, temp;
;;;72         volatile _CTable *PageTabPtr;
;;;73     
;;;74         if (vaddr & 0x80000000)
00000c  e2030102          AND      r0,r3,#0x80000000
000010  e3500000          CMP      r0,#0
000014  0a000001          BEQ      |L13.32|
;;;75             PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000018  e59f40f8          LDR      r4,|L13.280|
00001c  ea000000          B        |L13.36|
                  |L13.32|
;;;76         else
;;;77             PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
000020  e59f40f4          LDR      r4,|L13.284|
                  |L13.36|
;;;78     
;;;79         if (sysGetCacheState() == TRUE)
000024  ebfffffe          BL       sysGetCacheState
000028  e3500001          CMP      r0,#1
00002c  1a000000          BNE      |L13.52|
;;;80             PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
000030  e3844102          ORR      r4,r4,#0x80000000
                  |L13.52|
;;;81     
;;;82         vaddr &= 0x7FFFFFFF;    //ignore the non-cacheable bit 31
000034  e3c33102          BIC      r3,r3,#0x80000000
;;;83         //if ( _IsInitMMUTable == FALSE ) return -1;
;;;84         if ((vaddr + size) > (_CoarsePageSize << 20)) return -1;
000038  e0830001          ADD      r0,r3,r1
00003c  e3500302          CMP      r0,#0x8000000
000040  9a000001          BLS      |L13.76|
000044  e3e00000          MVN      r0,#0
                  |L13.72|
;;;85     
;;;86         if (vaddr & 0xFFF)  return -1;  /* MUST 4K Boundary */
;;;87         if (size % 4096)    return -1;  /* MUST 4K multiple size */
;;;88     
;;;89         /* for flat mapping address */
;;;90         cnt = size / 4096;
;;;91     
;;;92         if (cache_flag == CACHE_WRITE_BACK) /* write back mode */
;;;93             cache_mode = 0x0C;
;;;94         else if (cache_flag == CACHE_WRITE_THROUGH) /* write through mode */
;;;95             cache_mode = 0x08;
;;;96         else
;;;97             cache_mode = 0; /* Non-cacheable, non-buffered */
;;;98     
;;;99         for (i=0; i<cnt; i++)
;;;100        {
;;;101            baseaddr = vaddr + i * 4096;
;;;102            table_num = baseaddr / 0x100000;
;;;103            page_num =  (baseaddr & 0xFF000) >> 12; /* bits [19:12] for level two table index */
;;;104    
;;;105            temp = (*(PageTabPtr+table_num)).page[page_num] & 0xFFFFFFF3;
;;;106            temp |= cache_mode; /* cache mode */
;;;107            (*(PageTabPtr+table_num)).page[page_num] = temp;
;;;108        }
;;;109    
;;;110        //sysFlushCache(D_CACHE);
;;;111    
;;;112        return 0;
;;;113    
;;;114    } /* end sysSetCachePages */
000048  e8bd83fc          POP      {r2-r9,pc}
                  |L13.76|
00004c  e1a00a03          LSL      r0,r3,#20             ;86
000050  e1a00a20          LSR      r0,r0,#20             ;86
000054  e3500000          CMP      r0,#0                 ;86
000058  0a000001          BEQ      |L13.100|
00005c  e3e00000          MVN      r0,#0                 ;86
000060  eafffff8          B        |L13.72|
                  |L13.100|
000064  e1a0cfc1          ASR      r12,r1,#31            ;87
000068  e081ca2c          ADD      r12,r1,r12,LSR #20    ;87
00006c  e1a0c64c          ASR      r12,r12,#12           ;87
000070  e041c60c          SUB      r12,r1,r12,LSL #12    ;87
000074  e35c0000          CMP      r12,#0                ;87
000078  0a000001          BEQ      |L13.132|
00007c  e3e00000          MVN      r0,#0                 ;87
000080  eafffff0          B        |L13.72|
                  |L13.132|
000084  e1a00001          MOV      r0,r1                 ;90
000088  e1a0cfc1          ASR      r12,r1,#31            ;90
00008c  e081ca2c          ADD      r12,r1,r12,LSR #20    ;90
000090  e1a0964c          ASR      r9,r12,#12            ;90
000094  e3560000          CMP      r6,#0                 ;92
000098  1a000001          BNE      |L13.164|
00009c  e3a0500c          MOV      r5,#0xc               ;93
0000a0  ea000004          B        |L13.184|
                  |L13.164|
0000a4  e3560001          CMP      r6,#1                 ;94
0000a8  1a000001          BNE      |L13.180|
0000ac  e3a05008          MOV      r5,#8                 ;95
0000b0  ea000000          B        |L13.184|
                  |L13.180|
0000b4  e3a05000          MOV      r5,#0                 ;97
                  |L13.184|
0000b8  e3a02000          MOV      r2,#0                 ;99
0000bc  ea000011          B        |L13.264|
                  |L13.192|
0000c0  e0830602          ADD      r0,r3,r2,LSL #12      ;101
0000c4  e58d0004          STR      r0,[sp,#4]            ;101
0000c8  e59d0004          LDR      r0,[sp,#4]            ;102
0000cc  e1a07a20          LSR      r7,r0,#20             ;102
0000d0  e59d0004          LDR      r0,[sp,#4]            ;103
0000d4  e2000aff          AND      r0,r0,#0xff000        ;103
0000d8  e1a08620          LSR      r8,r0,#12             ;103
0000dc  e0840507          ADD      r0,r4,r7,LSL #10      ;105
0000e0  e7900108          LDR      r0,[r0,r8,LSL #2]     ;105
0000e4  e3c0000c          BIC      r0,r0,#0xc            ;105
0000e8  e58d0000          STR      r0,[sp,#0]            ;105
0000ec  e59d0000          LDR      r0,[sp,#0]            ;106
0000f0  e1800005          ORR      r0,r0,r5              ;106
0000f4  e58d0000          STR      r0,[sp,#0]            ;106
0000f8  e084c507          ADD      r12,r4,r7,LSL #10     ;107
0000fc  e59d0000          LDR      r0,[sp,#0]            ;107
000100  e78c0108          STR      r0,[r12,r8,LSL #2]    ;107
000104  e2822001          ADD      r2,r2,#1              ;99
                  |L13.264|
000108  e1520009          CMP      r2,r9                 ;99
00010c  baffffeb          BLT      |L13.192|
000110  e3a00000          MOV      r0,#0                 ;112
000114  eaffffcb          B        |L13.72|
;;;115    
                          ENDP

                  |L13.280|
                          DCD      _mmuCoarsePageTable_NonCache
                  |L13.284|
                          DCD      _mmuCoarsePageTable

                          AREA ||i.sysSetMMUMappingMethod||, CODE, READONLY, ALIGN=2

                  sysSetMMUMappingMethod PROC
;;;178    
;;;179    int sysSetMMUMappingMethod(int mode)
000000  e1a01000          MOV      r1,r0
;;;180    {
;;;181        _MMUMappingMode = mode;
000004  e59f0008          LDR      r0,|L14.20|
000008  e5801000          STR      r1,[r0,#0]  ; _MMUMappingMode
;;;182    
;;;183        return 0;
00000c  e3a00000          MOV      r0,#0
;;;184    
;;;185    } /* end sysSetMMUMappingMethod */
000010  e12fff1e          BX       lr
;;;186    
                          ENDP

                  |L14.20|
                          DCD      _MMUMappingMode

                          AREA ||.bss||, DATA, NOINIT, ALIGN=14

                  _mmuSectionTable
                          %        16384
                  _mmuCoarsePageTable
                          %        131072
                  _mmuCoarsePageTable_NonCache
                          %        131072

                          AREA ||.data||, DATA, ALIGN=2

                  _sys_IsCacheOn
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  _sys_CacheMode
                          DCD      0x00000000
                  _IsInitMMUTable
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  _MMUMappingMode
                          DCD      0x00000000
