; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\ethernetif.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ethernetif.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\ethernetif.crf lwip-1.4.1\netif\ethernetif.c]
                          ARM

                          AREA ||i.ethernetif_init0||, CODE, READONLY, ALIGN=2

                  ethernetif_init0 PROC
;;;496    err_t
;;;497    ethernetif_init0(struct netif *netif)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;498    {
000004  e1a04000          MOV      r4,r0
;;;499        struct ethernetif *ethernetif;
;;;500    
;;;501        LWIP_ASSERT("netif != NULL", (netif != NULL));
000008  e1a00000          MOV      r0,r0
00000c  e3540000          CMP      r4,#0
000010  1a000006          BNE      |L1.48|
000014  e1a00000          MOV      r0,r0
000018  e28f3074          ADR      r3,|L1.148|
00001c  e59f2090          LDR      r2,|L1.180|
000020  e28f1090          ADR      r1,|L1.184|
000024  e28f009c          ADR      r0,|L1.200|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L1.48|
000030  e1a00000          MOV      r0,r0
;;;502    
;;;503        _netif0 = netif;
000034  e59f00b4          LDR      r0,|L1.240|
000038  e5804000          STR      r4,[r0,#0]  ; _netif0
;;;504        ethernetif = mem_malloc(sizeof(struct ethernetif));
00003c  e3a00004          MOV      r0,#4
000040  ebfffffe          BL       mem_malloc
000044  e1a05000          MOV      r5,r0
;;;505        if (ethernetif == NULL) {
000048  e3550000          CMP      r5,#0
00004c  1a000001          BNE      |L1.88|
;;;506            LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
;;;507            return ERR_MEM;
000050  e3e00000          MVN      r0,#0
                  |L1.84|
;;;508        }
;;;509    
;;;510    #if LWIP_NETIF_HOSTNAME
;;;511        /* Initialize interface hostname */
;;;512        netif->hostname = "nuc970";
;;;513    #endif /* LWIP_NETIF_HOSTNAME */
;;;514    
;;;515        /*
;;;516         * Initialize the snmp variables and counters inside the struct netif.
;;;517         * The last argument should be replaced with your link speed, in units
;;;518         * of bits per second.
;;;519         */
;;;520        NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
;;;521    
;;;522        netif->state = ethernetif;
;;;523        netif->name[0] = IFNAME;
;;;524        netif->name[1] = IFNAME0;
;;;525        /* We directly use etharp_output() here to save a function call.
;;;526         * You can instead declare your own function an call etharp_output()
;;;527         * from it if you have to do some checks before sending (e.g. if link
;;;528         * is available...) */
;;;529        netif->output = etharp_output;
;;;530        netif->linkoutput = low_level_output0;
;;;531    
;;;532        ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
;;;533    
;;;534        /* initialize the hardware */
;;;535        low_level_init0(netif);
;;;536    
;;;537        return ERR_OK;
;;;538    }
000054  e8bd8070          POP      {r4-r6,pc}
                  |L1.88|
000058  e584501c          STR      r5,[r4,#0x1c]         ;522
00005c  e3a00065          MOV      r0,#0x65              ;523
000060  e5c4002e          STRB     r0,[r4,#0x2e]         ;523
000064  e3a00030          MOV      r0,#0x30              ;524
000068  e5c4002f          STRB     r0,[r4,#0x2f]         ;524
00006c  e59f0080          LDR      r0,|L1.244|
000070  e5840014          STR      r0,[r4,#0x14]         ;529
000074  e59f007c          LDR      r0,|L1.248|
000078  e5840018          STR      r0,[r4,#0x18]         ;530
00007c  e2840027          ADD      r0,r4,#0x27           ;532
000080  e5850000          STR      r0,[r5,#0]            ;532
000084  e1a00004          MOV      r0,r4                 ;535
000088  ebfffffe          BL       low_level_init0
00008c  e3a00000          MOV      r0,#0                 ;537
000090  eaffffef          B        |L1.84|
;;;539    
                          ENDP

                  |L1.148|
000094  6c776970          DCB      "lwip-1.4.1\\netif\\ethernetif.c",0
000098  2d312e34
00009c  2e315c6e
0000a0  65746966
0000a4  5c657468
0000a8  65726e65
0000ac  7469662e
0000b0  6300    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L1.180|
                          DCD      0x000001f5
                  |L1.184|
0000b8  6e657469          DCB      "netif != NULL",0
0000bc  6620213d
0000c0  204e554c
0000c4  4c00    
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L1.200|
0000c8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000cc  7274696f
0000d0  6e202225
0000d4  73222066
0000d8  61696c65
0000dc  64206174
0000e0  206c696e
0000e4  65202564
0000e8  20696e20
0000ec  25730a00
                  |L1.240|
                          DCD      _netif0
                  |L1.244|
                          DCD      etharp_output
                  |L1.248|
                          DCD      low_level_output0

                          AREA ||i.ethernetif_input0||, CODE, READONLY, ALIGN=2

                  ethernetif_input0 PROC
;;;353    void
;;;354    ethernetif_input0(u16_t len, u8_t *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;355    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;356        struct eth_hdr *ethhdr;
;;;357        struct pbuf *p;
;;;358    
;;;359    
;;;360        /* move received packet into a new pbuf */
;;;361        p = low_level_input(NULL, len, buf);
00000c  e1a02006          MOV      r2,r6
000010  e1a01005          MOV      r1,r5
000014  e3a00000          MOV      r0,#0
000018  ebfffffe          BL       low_level_input
00001c  e1a04000          MOV      r4,r0
;;;362        /* no packet could be read, silently ignore this */
;;;363        if (p == NULL) return;
000020  e3540000          CMP      r4,#0
000024  1a000000          BNE      |L2.44|
                  |L2.40|
;;;364    
;;;365    
;;;366        /* points to packet payload, which starts with an Ethernet header */
;;;367        ethhdr = p->payload;
;;;368    
;;;369        switch (htons(ethhdr->type)) {
;;;370        /* IP or ARP packet? */
;;;371        case ETHTYPE_IP:
;;;372        case ETHTYPE_ARP:
;;;373    #if PPPOE_SUPPORT
;;;374        /* PPPoE packet? */
;;;375        case ETHTYPE_PPPOEDISC:
;;;376        case ETHTYPE_PPPOE:
;;;377    #endif /* PPPOE_SUPPORT */
;;;378            /* full packet send to tcpip_thread to process */
;;;379            if (_netif0->input(p, _netif0)!=ERR_OK) {
;;;380                LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
;;;381                pbuf_free(p);
;;;382                p = NULL;
;;;383            }
;;;384            break;
;;;385    
;;;386        default:
;;;387            pbuf_free(p);
;;;388            p = NULL;
;;;389            break;
;;;390        }
;;;391    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L2.44|
00002c  e5947004          LDR      r7,[r4,#4]            ;367
000030  e5d7100d          LDRB     r1,[r7,#0xd]          ;369
000034  e5d7200c          LDRB     r2,[r7,#0xc]          ;369
000038  e1820401          ORR      r0,r2,r1,LSL #8       ;369
00003c  ebfffffe          BL       lwip_htons
000040  e3500b02          CMP      r0,#0x800             ;369
000044  0a000004          BEQ      |L2.92|
000048  e2400b02          SUB      r0,r0,#0x800          ;369
00004c  e2400006          SUB      r0,r0,#6              ;369
000050  e3500000          CMP      r0,#0                 ;369
000054  1a00000f          BNE      |L2.152|
000058  ea000001          B        |L2.100|
                  |L2.92|
00005c  e1a00000          MOV      r0,r0                 ;371
000060  e1a00000          MOV      r0,r0                 ;372
                  |L2.100|
000064  e59f004c          LDR      r0,|L2.184|
000068  e5900000          LDR      r0,[r0,#0]            ;379  ; _netif0
00006c  e5902010          LDR      r2,[r0,#0x10]         ;379
000070  e59f0040          LDR      r0,|L2.184|
000074  e5901000          LDR      r1,[r0,#0]            ;379  ; _netif0
000078  e1a00004          MOV      r0,r4                 ;379
00007c  e12fff32          BLX      r2                    ;379
000080  e3500000          CMP      r0,#0                 ;379
000084  0a000002          BEQ      |L2.148|
000088  e1a00004          MOV      r0,r4                 ;381
00008c  ebfffffe          BL       pbuf_free
000090  e3a04000          MOV      r4,#0                 ;382
                  |L2.148|
000094  ea000004          B        |L2.172|
                  |L2.152|
000098  e1a00000          MOV      r0,r0                 ;386
00009c  e1a00004          MOV      r0,r4                 ;387
0000a0  ebfffffe          BL       pbuf_free
0000a4  e3a04000          MOV      r4,#0                 ;388
0000a8  e1a00000          MOV      r0,r0                 ;389
                  |L2.172|
0000ac  e1a00000          MOV      r0,r0                 ;384
0000b0  e1a00000          MOV      r0,r0
0000b4  eaffffdb          B        |L2.40|
;;;392    
                          ENDP

                  |L2.184|
                          DCD      _netif0

                          AREA ||i.ethernetif_input1||, CODE, READONLY, ALIGN=2

                  ethernetif_input1 PROC
;;;444    void
;;;445    ethernetif_input1(u16_t len, u8_t *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;446    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;447        struct eth_hdr *ethhdr;
;;;448        struct pbuf *p;
;;;449    
;;;450    
;;;451        /* move received packet into a new pbuf */
;;;452        p = low_level_input(NULL, len, buf);
00000c  e1a02006          MOV      r2,r6
000010  e1a01005          MOV      r1,r5
000014  e3a00000          MOV      r0,#0
000018  ebfffffe          BL       low_level_input
00001c  e1a04000          MOV      r4,r0
;;;453        /* no packet could be read, silently ignore this */
;;;454        if (p == NULL) return;
000020  e3540000          CMP      r4,#0
000024  1a000000          BNE      |L3.44|
                  |L3.40|
;;;455    
;;;456    
;;;457        /* points to packet payload, which starts with an Ethernet header */
;;;458        ethhdr = p->payload;
;;;459    
;;;460        switch (htons(ethhdr->type)) {
;;;461        /* IP or ARP packet? */
;;;462        case ETHTYPE_IP:
;;;463        case ETHTYPE_ARP:
;;;464    #if PPPOE_SUPPORT
;;;465        /* PPPoE packet? */
;;;466        case ETHTYPE_PPPOEDISC:
;;;467        case ETHTYPE_PPPOE:
;;;468    #endif /* PPPOE_SUPPORT */
;;;469            /* full packet send to tcpip_thread to process */
;;;470            if (_netif1->input(p, _netif1)!=ERR_OK) {
;;;471                LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
;;;472                pbuf_free(p);
;;;473                p = NULL;
;;;474            }
;;;475            break;
;;;476    
;;;477        default:
;;;478            pbuf_free(p);
;;;479            p = NULL;
;;;480            break;
;;;481        }
;;;482    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L3.44|
00002c  e5947004          LDR      r7,[r4,#4]            ;458
000030  e5d7100d          LDRB     r1,[r7,#0xd]          ;460
000034  e5d7200c          LDRB     r2,[r7,#0xc]          ;460
000038  e1820401          ORR      r0,r2,r1,LSL #8       ;460
00003c  ebfffffe          BL       lwip_htons
000040  e3500b02          CMP      r0,#0x800             ;460
000044  0a000004          BEQ      |L3.92|
000048  e2400b02          SUB      r0,r0,#0x800          ;460
00004c  e2400006          SUB      r0,r0,#6              ;460
000050  e3500000          CMP      r0,#0                 ;460
000054  1a00000f          BNE      |L3.152|
000058  ea000001          B        |L3.100|
                  |L3.92|
00005c  e1a00000          MOV      r0,r0                 ;462
000060  e1a00000          MOV      r0,r0                 ;463
                  |L3.100|
000064  e59f004c          LDR      r0,|L3.184|
000068  e5900000          LDR      r0,[r0,#0]            ;470  ; _netif1
00006c  e5902010          LDR      r2,[r0,#0x10]         ;470
000070  e59f0040          LDR      r0,|L3.184|
000074  e5901000          LDR      r1,[r0,#0]            ;470  ; _netif1
000078  e1a00004          MOV      r0,r4                 ;470
00007c  e12fff32          BLX      r2                    ;470
000080  e3500000          CMP      r0,#0                 ;470
000084  0a000002          BEQ      |L3.148|
000088  e1a00004          MOV      r0,r4                 ;472
00008c  ebfffffe          BL       pbuf_free
000090  e3a04000          MOV      r4,#0                 ;473
                  |L3.148|
000094  ea000004          B        |L3.172|
                  |L3.152|
000098  e1a00000          MOV      r0,r0                 ;477
00009c  e1a00004          MOV      r0,r4                 ;478
0000a0  ebfffffe          BL       pbuf_free
0000a4  e3a04000          MOV      r4,#0                 ;479
0000a8  e1a00000          MOV      r0,r0                 ;480
                  |L3.172|
0000ac  e1a00000          MOV      r0,r0                 ;475
0000b0  e1a00000          MOV      r0,r0
0000b4  eaffffdb          B        |L3.40|
;;;483    
                          ENDP

                  |L3.184|
                          DCD      _netif1

                          AREA ||i.ethernetif_input_new||, CODE, READONLY, ALIGN=2

                  ethernetif_input_new PROC
;;;397    //ethernetif_input0(u16_t len, u8_t *buf)
;;;398    ethernetif_input_new( void * pvParameters )
000000  e1a00000          MOV      r0,r0
;;;399    {
;;;400        struct eth_hdr *ethhdr;
;;;401        struct pbuf *p = NULL;
;;;402        u16_t len;
;;;403        u8_t *buf;
;;;404        int ret;
;;;405        unsigned int status;
;;;406        
;;;407        while (1)
000004  ea000027          B        |L4.168|
                  |L4.8|
;;;408        {
;;;409            if (xSemaphoreTake( s_xSemaphore, 100)==pdTRUE)
000008  e3a03000          MOV      r3,#0
00000c  e3a02064          MOV      r2,#0x64
000010  e1a01003          MOV      r1,r3
000014  e59f0090          LDR      r0,|L4.172|
000018  e5900000          LDR      r0,[r0,#0]  ; s_xSemaphore
00001c  ebfffffe          BL       xQueueGenericReceive
000020  e3500001          CMP      r0,#1
000024  1a00001f          BNE      |L4.168|
;;;410            {
;;;411                #if 1
;;;412                do {
000028  e1a00000          MOV      r0,r0
                  |L4.44|
;;;413    			
;;;414                    status = cur_rx_desc_ptr->status1;
00002c  e59f007c          LDR      r0,|L4.176|
000030  e5900000          LDR      r0,[r0,#0]  ; cur_rx_desc_ptr
000034  e5904000          LDR      r4,[r0,#0]
;;;415                        
;;;416                    if(status & OWNERSHIP_EMAC)
000038  e2040102          AND      r0,r4,#0x80000000
00003c  e3500000          CMP      r0,#0
000040  0a000000          BEQ      |L4.72|
;;;417                        break;
000044  ea000013          B        |L4.152|
                  |L4.72|
;;;418    
;;;419                    if (status & RXFD_RXGD)
000048  e2040601          AND      r0,r4,#0x100000
00004c  e3500000          CMP      r0,#0
000050  0a000006          BEQ      |L4.112|
;;;420                    {
;;;421                        len = status & 0xFFFF;
000054  e1a05804          LSL      r5,r4,#16
000058  e1a05825          LSR      r5,r5,#16
;;;422                        ethernetif_input0(len, cur_rx_desc_ptr->buf);
00005c  e59f004c          LDR      r0,|L4.176|
000060  e5900000          LDR      r0,[r0,#0]  ; cur_rx_desc_ptr
000064  e5901004          LDR      r1,[r0,#4]
000068  e1a00005          MOV      r0,r5
00006c  ebfffffe          BL       ethernetif_input0
                  |L4.112|
;;;423                    }
;;;424                    cur_rx_desc_ptr->status1 = OWNERSHIP_EMAC;
000070  e3a00102          MOV      r0,#0x80000000
000074  e59f1034          LDR      r1,|L4.176|
000078  e5911000          LDR      r1,[r1,#0]  ; cur_rx_desc_ptr
00007c  e5810000          STR      r0,[r1,#0]
;;;425                    cur_rx_desc_ptr = cur_rx_desc_ptr->next;
000080  e59f0028          LDR      r0,|L4.176|
000084  e5900000          LDR      r0,[r0,#0]  ; cur_rx_desc_ptr
000088  e590000c          LDR      r0,[r0,#0xc]
00008c  e59f101c          LDR      r1,|L4.176|
000090  e5810000          STR      r0,[r1,#0]  ; cur_rx_desc_ptr
;;;426    
;;;427                } while (1);
000094  eaffffe4          B        |L4.44|
                  |L4.152|
000098  e1a00000          MOV      r0,r0                 ;417
;;;428                ETH0_TRIGGER_RX();
00009c  e3a00000          MOV      r0,#0
0000a0  e59f100c          LDR      r1,|L4.180|
0000a4  e58100a4          STR      r0,[r1,#0xa4]
                  |L4.168|
0000a8  eaffffd6          B        |L4.8|
;;;429                #endif
;;;430            }
;;;431        }
;;;432    }
;;;433    
                          ENDP

                  |L4.172|
                          DCD      s_xSemaphore
                  |L4.176|
                          DCD      cur_rx_desc_ptr
                  |L4.180|
                          DCD      0xb0002000

                          AREA ||i.low_level_init0||, CODE, READONLY, ALIGN=2

                  low_level_init0 PROC
;;;93     static void
;;;94     low_level_init0(struct netif *netif)
000000  e92d401c          PUSH     {r2-r4,lr}
;;;95     {
000004  e1a04000          MOV      r4,r0
;;;96     
;;;97         /* set MAC hardware address length */
;;;98         netif->hwaddr_len = ETHARP_HWADDR_LEN;
000008  e3a00006          MOV      r0,#6
00000c  e5c40026          STRB     r0,[r4,#0x26]
;;;99     
;;;100        /* set MAC hardware address */
;;;101        if(my_mac_addr0 != NULL) {
;;;102            netif->hwaddr[0] = my_mac_addr0[0];
000010  e59f015c          LDR      r0,|L5.372|
000014  e5d00000          LDRB     r0,[r0,#0]  ; my_mac_addr0
000018  e5c40027          STRB     r0,[r4,#0x27]
;;;103            netif->hwaddr[1] = my_mac_addr0[1];
00001c  e59f0150          LDR      r0,|L5.372|
000020  e5d00001          LDRB     r0,[r0,#1]  ; my_mac_addr0
000024  e5c40028          STRB     r0,[r4,#0x28]
;;;104            netif->hwaddr[2] = my_mac_addr0[2];
000028  e59f0144          LDR      r0,|L5.372|
00002c  e5d00002          LDRB     r0,[r0,#2]  ; my_mac_addr0
000030  e5c40029          STRB     r0,[r4,#0x29]
;;;105            netif->hwaddr[3] = my_mac_addr0[3];
000034  e59f0138          LDR      r0,|L5.372|
000038  e5d00003          LDRB     r0,[r0,#3]  ; my_mac_addr0
00003c  e5c4002a          STRB     r0,[r4,#0x2a]
;;;106            netif->hwaddr[4] = my_mac_addr0[4];
000040  e59f012c          LDR      r0,|L5.372|
000044  e5d00004          LDRB     r0,[r0,#4]  ; my_mac_addr0
000048  e5c4002b          STRB     r0,[r4,#0x2b]
;;;107            netif->hwaddr[5] = my_mac_addr0[5];
00004c  e59f0120          LDR      r0,|L5.372|
000050  e5d00005          LDRB     r0,[r0,#5]  ; my_mac_addr0
000054  e5c4002c          STRB     r0,[r4,#0x2c]
;;;108        } else {
;;;109            netif->hwaddr[0] = 0x00;
;;;110            netif->hwaddr[1] = 0x00;
;;;111            netif->hwaddr[2] = 0x00;
;;;112            netif->hwaddr[3] = 0x51;
;;;113            netif->hwaddr[4] = 0x68;
;;;114            netif->hwaddr[5] = 0x88;
;;;115        }
;;;116    
;;;117        /* maximum transfer unit */
;;;118        netif->mtu = 1500;
000058  e59f0118          LDR      r0,|L5.376|
00005c  e1c402b4          STRH     r0,[r4,#0x24]
;;;119    
;;;120        /* device capabilities */
;;;121        netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
000060  e3a00032          MOV      r0,#0x32
000064  e5c4002d          STRB     r0,[r4,#0x2d]
;;;122    #ifdef LWIP_IGMP
;;;123        netif->flags |= NETIF_FLAG_IGMP;
000068  e5d4002d          LDRB     r0,[r4,#0x2d]
00006c  e3800080          ORR      r0,r0,#0x80
000070  e5c4002d          STRB     r0,[r4,#0x2d]
;;;124    #endif
;;;125        
;;;126      /* create binary semaphore used for informing ethernetif of frame reception */
;;;127      if (s_xSemaphore == NULL)
000074  e59f0100          LDR      r0,|L5.380|
000078  e5900000          LDR      r0,[r0,#0]  ; s_xSemaphore
00007c  e3500000          CMP      r0,#0
000080  1a000015          BNE      |L5.220|
;;;128      {
;;;129        vSemaphoreCreateBinary(s_xSemaphore);
000084  e3a02003          MOV      r2,#3
000088  e3a01000          MOV      r1,#0
00008c  e3a00001          MOV      r0,#1
000090  ebfffffe          BL       xQueueGenericCreate
000094  e59f10e0          LDR      r1,|L5.380|
000098  e5810000          STR      r0,[r1,#0]  ; s_xSemaphore
00009c  e2810000          ADD      r0,r1,#0
0000a0  e5900000          LDR      r0,[r0,#0]  ; s_xSemaphore
0000a4  e3500000          CMP      r0,#0
0000a8  0a000005          BEQ      |L5.196|
0000ac  e3a03000          MOV      r3,#0
0000b0  e1a02003          MOV      r2,r3
0000b4  e1a01003          MOV      r1,r3
0000b8  e59f00bc          LDR      r0,|L5.380|
0000bc  e5900000          LDR      r0,[r0,#0]  ; s_xSemaphore
0000c0  ebfffffe          BL       xQueueGenericSend
                  |L5.196|
;;;130        xSemaphoreTake( s_xSemaphore, 0);
0000c4  e3a03000          MOV      r3,#0
0000c8  e1a02003          MOV      r2,r3
0000cc  e1a01003          MOV      r1,r3
0000d0  e59f00a4          LDR      r0,|L5.380|
0000d4  e5900000          LDR      r0,[r0,#0]  ; s_xSemaphore
0000d8  ebfffffe          BL       xQueueGenericReceive
                  |L5.220|
;;;131      }
;;;132      if (xTxSemaphore == NULL)
0000dc  e59f009c          LDR      r0,|L5.384|
0000e0  e5900000          LDR      r0,[r0,#0]  ; xTxSemaphore
0000e4  e3500000          CMP      r0,#0
0000e8  1a000015          BNE      |L5.324|
;;;133      {
;;;134        vSemaphoreCreateBinary(xTxSemaphore);
0000ec  e3a02003          MOV      r2,#3
0000f0  e3a01000          MOV      r1,#0
0000f4  e3a00001          MOV      r0,#1
0000f8  ebfffffe          BL       xQueueGenericCreate
0000fc  e59f107c          LDR      r1,|L5.384|
000100  e5810000          STR      r0,[r1,#0]  ; xTxSemaphore
000104  e2810000          ADD      r0,r1,#0
000108  e5900000          LDR      r0,[r0,#0]  ; xTxSemaphore
00010c  e3500000          CMP      r0,#0
000110  0a000005          BEQ      |L5.300|
000114  e3a03000          MOV      r3,#0
000118  e1a02003          MOV      r2,r3
00011c  e1a01003          MOV      r1,r3
000120  e59f0058          LDR      r0,|L5.384|
000124  e5900000          LDR      r0,[r0,#0]  ; xTxSemaphore
000128  ebfffffe          BL       xQueueGenericSend
                  |L5.300|
;;;135        xSemaphoreGive( xTxSemaphore);
00012c  e3a03000          MOV      r3,#0
000130  e1a02003          MOV      r2,r3
000134  e1a01003          MOV      r1,r3
000138  e59f0040          LDR      r0,|L5.384|
00013c  e5900000          LDR      r0,[r0,#0]  ; xTxSemaphore
000140  ebfffffe          BL       xQueueGenericSend
                  |L5.324|
;;;136      }
;;;137      
;;;138      xTaskCreate(ethernetif_input_new, "Eth_if", 512, NULL,
000144  e3a00000          MOV      r0,#0
000148  e3a0101f          MOV      r1,#0x1f
00014c  e58d0004          STR      r0,[sp,#4]
000150  e1a03000          MOV      r3,r0
000154  e3a02c02          MOV      r2,#0x200
000158  e58d1000          STR      r1,[sp,#0]
00015c  e28f1020          ADR      r1,|L5.388|
000160  e59f0024          LDR      r0,|L5.396|
000164  ebfffffe          BL       xTaskCreate
;;;139                  configMAX_PRIORITIES - 1,NULL);
;;;140        ETH0_init(netif->hwaddr);
000168  e2840027          ADD      r0,r4,#0x27
00016c  ebfffffe          BL       ETH0_init
;;;141    }
000170  e8bd801c          POP      {r2-r4,pc}
;;;142    
                          ENDP

                  |L5.372|
                          DCD      my_mac_addr0
                  |L5.376|
                          DCD      0x000005dc
                  |L5.380|
                          DCD      s_xSemaphore
                  |L5.384|
                          DCD      xTxSemaphore
                  |L5.388|
000184  4574685f          DCB      "Eth_if",0
000188  696600  
00018b  00                DCB      0
                  |L5.396|
                          DCD      ethernetif_input_new

                          AREA ||i.low_level_init1||, CODE, READONLY, ALIGN=2

                  low_level_init1 PROC
;;;150    static void
;;;151    low_level_init1(struct netif *netif)
000000  e3a01006          MOV      r1,#6
;;;152    {
;;;153    
;;;154        /* set MAC hardware address length */
;;;155        netif->hwaddr_len = ETHARP_HWADDR_LEN;
000004  e5c01026          STRB     r1,[r0,#0x26]
;;;156    
;;;157        /* set MAC hardware address */
;;;158        if(my_mac_addr1 != NULL) {
;;;159            netif->hwaddr[0] = my_mac_addr1[0];
000008  e59f1060          LDR      r1,|L6.112|
00000c  e5d11000          LDRB     r1,[r1,#0]  ; my_mac_addr1
000010  e5c01027          STRB     r1,[r0,#0x27]
;;;160            netif->hwaddr[1] = my_mac_addr1[1];
000014  e59f1054          LDR      r1,|L6.112|
000018  e5d11001          LDRB     r1,[r1,#1]  ; my_mac_addr1
00001c  e5c01028          STRB     r1,[r0,#0x28]
;;;161            netif->hwaddr[2] = my_mac_addr1[2];
000020  e59f1048          LDR      r1,|L6.112|
000024  e5d11002          LDRB     r1,[r1,#2]  ; my_mac_addr1
000028  e5c01029          STRB     r1,[r0,#0x29]
;;;162            netif->hwaddr[3] = my_mac_addr1[3];
00002c  e59f103c          LDR      r1,|L6.112|
000030  e5d11003          LDRB     r1,[r1,#3]  ; my_mac_addr1
000034  e5c0102a          STRB     r1,[r0,#0x2a]
;;;163            netif->hwaddr[4] = my_mac_addr1[4];
000038  e59f1030          LDR      r1,|L6.112|
00003c  e5d11004          LDRB     r1,[r1,#4]  ; my_mac_addr1
000040  e5c0102b          STRB     r1,[r0,#0x2b]
;;;164            netif->hwaddr[5] = my_mac_addr1[5];
000044  e59f1024          LDR      r1,|L6.112|
000048  e5d11005          LDRB     r1,[r1,#5]  ; my_mac_addr1
00004c  e5c0102c          STRB     r1,[r0,#0x2c]
;;;165        } else {
;;;166            netif->hwaddr[0] = 0x00;
;;;167            netif->hwaddr[1] = 0x00;
;;;168            netif->hwaddr[2] = 0x00;
;;;169            netif->hwaddr[3] = 0x59;
;;;170            netif->hwaddr[4] = 0x48;
;;;171            netif->hwaddr[5] = 0x88;
;;;172        }
;;;173        /* maximum transfer unit */
;;;174        netif->mtu = 1500;
000050  e59f101c          LDR      r1,|L6.116|
000054  e1c012b4          STRH     r1,[r0,#0x24]
;;;175    
;;;176        /* device capabilities */
;;;177        netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
000058  e3a01032          MOV      r1,#0x32
00005c  e5c0102d          STRB     r1,[r0,#0x2d]
;;;178    #ifdef LWIP_IGMP
;;;179        netif->flags |= NETIF_FLAG_IGMP;
000060  e5d0102d          LDRB     r1,[r0,#0x2d]
000064  e3811080          ORR      r1,r1,#0x80
000068  e5c0102d          STRB     r1,[r0,#0x2d]
;;;180    #endif
;;;181    
;;;182    		
;;;183    //    ETH1_init(netif->hwaddr);
;;;184    		
;;;185    }
00006c  e12fff1e          BX       lr
;;;186    
                          ENDP

                  |L6.112|
                          DCD      my_mac_addr1
                  |L6.116|
                          DCD      0x000005dc

                          AREA ||i.low_level_input||, CODE, READONLY, ALIGN=2

                  low_level_input PROC
;;;296    static struct pbuf *
;;;297    low_level_input(struct netif *netif, u16_t len, u8_t *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;298    {
000004  e1a08000          MOV      r8,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a07002          MOV      r7,r2
;;;299        struct pbuf *p=NULL, *q;
000010  e3a06000          MOV      r6,#0
;;;300    
;;;301    #if ETH_PAD_SIZE
;;;302        len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
;;;303    #endif
;;;304        
;;;305        /* We allocate a pbuf chain of pbufs from the pool. */
;;;306        p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
000014  e3a02003          MOV      r2,#3
000018  e1a01005          MOV      r1,r5
00001c  e1a00002          MOV      r0,r2
000020  ebfffffe          BL       pbuf_alloc
000024  e1a06000          MOV      r6,r0
;;;307    
;;;308        if (p != NULL) {
000028  e3560000          CMP      r6,#0
00002c  0a00000d          BEQ      |L7.104|
;;;309    
;;;310    #if ETH_PAD_SIZE
;;;311            pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
;;;312    #endif
;;;313    
;;;314    
;;;315            len = 0;
000030  e3a05000          MOV      r5,#0
;;;316            /* We iterate over the pbuf chain until we have read the entire
;;;317            * packet into the pbuf. */
;;;318            for(q = p; q != NULL; q = q->next) {
000034  e1a04006          MOV      r4,r6
000038  ea000008          B        |L7.96|
                  |L7.60|
;;;319                memcpy((u8_t*)q->payload, (u8_t*)&buf[len], q->len);
00003c  e1d420ba          LDRH     r2,[r4,#0xa]
000040  e0871005          ADD      r1,r7,r5
000044  e5940004          LDR      r0,[r4,#4]
000048  ebfffffe          BL       __aeabi_memcpy
;;;320                len = len + q->len;
00004c  e1d400ba          LDRH     r0,[r4,#0xa]
000050  e0800005          ADD      r0,r0,r5
000054  e1a05800          LSL      r5,r0,#16
000058  e1a05825          LSR      r5,r5,#16
00005c  e5944000          LDR      r4,[r4,#0]            ;318
                  |L7.96|
000060  e3540000          CMP      r4,#0                 ;318
000064  1afffff4          BNE      |L7.60|
                  |L7.104|
;;;321            }
;;;322    
;;;323    
;;;324    #if ETH_PAD_SIZE
;;;325            pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
;;;326    #endif
;;;327    
;;;328            LINK_STATS_INC(link.recv);
;;;329        } else {
;;;330            // do nothing. drop the packet
;;;331            LINK_STATS_INC(link.memerr);
;;;332            LINK_STATS_INC(link.drop);
;;;333        }
;;;334    
;;;335        return p;
000068  e1a00006          MOV      r0,r6
;;;336    }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;337    
                          ENDP


                          AREA ||i.low_level_output0||, CODE, READONLY, ALIGN=2

                  low_level_output0 PROC
;;;203    static err_t
;;;204    low_level_output0(struct netif *netif, struct pbuf *p)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;205    {
000004  e1a08000          MOV      r8,r0
000008  e1a06001          MOV      r6,r1
;;;206        struct pbuf *q;
;;;207        u8_t *buf = NULL;
00000c  e3a07000          MOV      r7,#0
;;;208        u16_t len = 0;
000010  e3a05000          MOV      r5,#0
;;;209    
;;;210        if (xSemaphoreTake(xTxSemaphore, 250))
000014  e3a03000          MOV      r3,#0
000018  e3a020fa          MOV      r2,#0xfa
00001c  e1a01003          MOV      r1,r3
000020  e59f009c          LDR      r0,|L8.196|
000024  e5900000          LDR      r0,[r0,#0]  ; xTxSemaphore
000028  ebfffffe          BL       xQueueGenericReceive
00002c  e3500000          CMP      r0,#0
000030  0a000021          BEQ      |L8.188|
;;;211        {
;;;212            buf = ETH0_get_tx_buf();
000034  ebfffffe          BL       ETH0_get_tx_buf
000038  e1a07000          MOV      r7,r0
;;;213            if(buf == NULL)
00003c  e3570000          CMP      r7,#0
000040  1a000007          BNE      |L8.100|
;;;214            {
;;;215                xSemaphoreGive(xTxSemaphore);
000044  e3a03000          MOV      r3,#0
000048  e1a02003          MOV      r2,r3
00004c  e1a01003          MOV      r1,r3
000050  e59f006c          LDR      r0,|L8.196|
000054  e5900000          LDR      r0,[r0,#0]  ; xTxSemaphore
000058  ebfffffe          BL       xQueueGenericSend
;;;216                return ERR_MEM;
00005c  e3e00000          MVN      r0,#0
                  |L8.96|
;;;217            }
;;;218        #if ETH_PAD_SIZE
;;;219            pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
;;;220        #endif
;;;221    
;;;222            for(q = p; q != NULL; q = q->next) {
;;;223                memcpy((u8_t*)&buf[len], q->payload, q->len);
;;;224                len = len + q->len;
;;;225            }
;;;226    
;;;227            ETH0_trigger_tx(len, NULL);
;;;228    
;;;229    
;;;230        #if ETH_PAD_SIZE
;;;231            pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
;;;232        #endif
;;;233    
;;;234            LINK_STATS_INC(link.xmit);
;;;235            xSemaphoreGive(xTxSemaphore);
;;;236        }
;;;237        return ERR_OK;
;;;238    }
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L8.100|
000064  e1a04006          MOV      r4,r6                 ;222
000068  ea000008          B        |L8.144|
                  |L8.108|
00006c  e1d420ba          LDRH     r2,[r4,#0xa]          ;223
000070  e0870005          ADD      r0,r7,r5              ;223
000074  e5941004          LDR      r1,[r4,#4]            ;223
000078  ebfffffe          BL       __aeabi_memcpy
00007c  e1d400ba          LDRH     r0,[r4,#0xa]          ;224
000080  e0800005          ADD      r0,r0,r5              ;224
000084  e1a05800          LSL      r5,r0,#16             ;224
000088  e1a05825          LSR      r5,r5,#16             ;224
00008c  e5944000          LDR      r4,[r4,#0]            ;222
                  |L8.144|
000090  e3540000          CMP      r4,#0                 ;222
000094  1afffff4          BNE      |L8.108|
000098  e3a01000          MOV      r1,#0                 ;227
00009c  e1a00005          MOV      r0,r5                 ;227
0000a0  ebfffffe          BL       ETH0_trigger_tx
0000a4  e3a03000          MOV      r3,#0                 ;235
0000a8  e1a02003          MOV      r2,r3                 ;235
0000ac  e1a01003          MOV      r1,r3                 ;235
0000b0  e59f000c          LDR      r0,|L8.196|
0000b4  e5900000          LDR      r0,[r0,#0]            ;235  ; xTxSemaphore
0000b8  ebfffffe          BL       xQueueGenericSend
                  |L8.188|
0000bc  e3a00000          MOV      r0,#0                 ;237
0000c0  eaffffe6          B        |L8.96|
;;;239    
                          ENDP

                  |L8.196|
                          DCD      xTxSemaphore

                          AREA ||.data||, DATA, ALIGN=2

                  s_xSemaphore
                          DCD      0x00000000
                  xTxSemaphore
                          DCD      0x00000000
                  _netif0
                          DCD      0x00000000
                  _netif1
                          DCD      0x00000000
                  my_mac_addr0
000010  00000055          DCB      0x00,0x00,0x00,0x55
000014  6677              DCB      0x66,0x77
                  my_mac_addr1
000016  0000              DCB      0x00,0x00
000018  00000001          DCB      0x00,0x00,0x00,0x01
