; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\nuc970_eth0.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\nuc970_eth0.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -D__UVISION_VERSION=524 --omf_browse=.\obj\nuc970_eth0.crf lwip-1.4.1\netif\nuc970_eth0.c]
                          ARM

                          AREA ||i.ETH0_RX_IRQHandler||, CODE, READONLY, ALIGN=2

                  ETH0_RX_IRQHandler PROC
;;;198    extern xSemaphoreHandle s_xSemaphore;
;;;199    void ETH0_RX_IRQHandler(void)
000000  e92d4038          PUSH     {r3-r5,lr}
;;;200    {
;;;201        unsigned int status;
;;;202        BaseType_t xtast_woken;
;;;203        
;;;204        status = inpw(REG_EMAC0_MISTA) & 0xFFFF;
000004  e59f0024          LDR      r0,|L1.48|
000008  e59000b0          LDR      r0,[r0,#0xb0]
00000c  e1a04800          LSL      r4,r0,#16
000010  e1a04824          LSR      r4,r4,#16
;;;205        outpw(REG_EMAC0_MISTA, status);
000014  e59f0014          LDR      r0,|L1.48|
000018  e58040b0          STR      r4,[r0,#0xb0]
;;;206        
;;;207        if (status & 0x800) {
;;;208            // Shouldn't goes here, unless descriptor corrupted
;;;209        }
;;;210    xSemaphoreGiveFromISR(s_xSemaphore, &xtast_woken);
00001c  e1a0100d          MOV      r1,sp
000020  e59f000c          LDR      r0,|L1.52|
000024  e5900000          LDR      r0,[r0,#0]  ; s_xSemaphore
000028  ebfffffe          BL       xQueueGiveFromISR
;;;211    //    do {
;;;212    //        status = cur_rx_desc_ptr->status1;
;;;213    
;;;214    //        if(status & OWNERSHIP_EMAC)
;;;215    //            break;
;;;216    
;;;217    //        if (status & RXFD_RXGD) {
;;;218    
;;;219    //            ethernetif_input0(status & 0xFFFF, cur_rx_desc_ptr->buf);
;;;220    
;;;221    
;;;222    //        }
;;;223    
;;;224    //        cur_rx_desc_ptr->status1 = OWNERSHIP_EMAC;
;;;225    //        cur_rx_desc_ptr = cur_rx_desc_ptr->next;
;;;226    
;;;227    //    } while (1);
;;;228    
;;;229    //    ETH0_TRIGGER_RX();
;;;230    
;;;231    }
00002c  e8bd8038          POP      {r3-r5,pc}
;;;232    
                          ENDP

                  |L1.48|
                          DCD      0xb0002000
                  |L1.52|
                          DCD      s_xSemaphore

                          AREA ||i.ETH0_TX_IRQHandler||, CODE, READONLY, ALIGN=2

                  ETH0_TX_IRQHandler PROC
;;;232    
;;;233    void ETH0_TX_IRQHandler(void)
000000  e59f2058          LDR      r2,|L2.96|
;;;234    {
;;;235        unsigned int cur_entry, status;
;;;236    
;;;237        status = inpw(REG_EMAC0_MISTA) & 0xFFFF0000;
000004  e59220b0          LDR      r2,[r2,#0xb0]
000008  e1a01822          LSR      r1,r2,#16
00000c  e1a01801          LSL      r1,r1,#16
;;;238        outpw(REG_EMAC0_MISTA, status);
000010  e59f2048          LDR      r2,|L2.96|
000014  e58210b0          STR      r1,[r2,#0xb0]
;;;239    
;;;240        if(status & 0x1000000) {
000018  e2012401          AND      r2,r1,#0x1000000
00001c  e3520000          CMP      r2,#0
000020  0a000000          BEQ      |L2.40|
                  |L2.36|
;;;241            // Shouldn't goes here, unless descriptor corrupted
;;;242            return;
;;;243        }
;;;244    
;;;245        cur_entry = inpw(REG_EMAC0_CTXDSA);
;;;246    
;;;247        while (cur_entry != (u32_t)fin_tx_desc_ptr) {
;;;248    
;;;249            fin_tx_desc_ptr = fin_tx_desc_ptr->next;
;;;250        }
;;;251    
;;;252    }
000024  e12fff1e          BX       lr
                  |L2.40|
000028  e59f2030          LDR      r2,|L2.96|
00002c  e59200cc          LDR      r0,[r2,#0xcc]         ;245
000030  ea000004          B        |L2.72|
                  |L2.52|
000034  e59f2028          LDR      r2,|L2.100|
000038  e5922000          LDR      r2,[r2,#0]            ;249  ; fin_tx_desc_ptr
00003c  e592200c          LDR      r2,[r2,#0xc]          ;249
000040  e59f301c          LDR      r3,|L2.100|
000044  e5832000          STR      r2,[r3,#0]            ;249  ; fin_tx_desc_ptr
                  |L2.72|
000048  e59f2014          LDR      r2,|L2.100|
00004c  e5922000          LDR      r2,[r2,#0]            ;247  ; fin_tx_desc_ptr
000050  e1500002          CMP      r0,r2                 ;247
000054  1afffff6          BNE      |L2.52|
000058  e1a00000          MOV      r0,r0
00005c  eafffff0          B        |L2.36|
;;;253    
                          ENDP

                  |L2.96|
                          DCD      0xb0002000
                  |L2.100|
                          DCD      fin_tx_desc_ptr

                          AREA ||i.ETH0_get_tx_buf||, CODE, READONLY, ALIGN=2

                  ETH0_get_tx_buf PROC
;;;304    
;;;305    u8_t *ETH0_get_tx_buf(void)
000000  e59f0028          LDR      r0,|L3.48|
;;;306    {
;;;307        if(cur_tx_desc_ptr->status1 & OWNERSHIP_EMAC)
000004  e5900000          LDR      r0,[r0,#0]  ; cur_tx_desc_ptr
000008  e5900000          LDR      r0,[r0,#0]
00000c  e2000102          AND      r0,r0,#0x80000000
000010  e3500000          CMP      r0,#0
000014  0a000001          BEQ      |L3.32|
;;;308            return(NULL);
000018  e3a00000          MOV      r0,#0
                  |L3.28|
;;;309        else
;;;310            return(cur_tx_desc_ptr->buf);
;;;311    }
00001c  e12fff1e          BX       lr
                  |L3.32|
000020  e59f0008          LDR      r0,|L3.48|
000024  e5900000          LDR      r0,[r0,#0]            ;310  ; cur_tx_desc_ptr
000028  e5900004          LDR      r0,[r0,#4]            ;310
00002c  eafffffa          B        |L3.28|
;;;312    
                          ENDP

                  |L3.48|
                          DCD      cur_tx_desc_ptr

                          AREA ||i.ETH0_halt||, CODE, READONLY, ALIGN=2

                  ETH0_halt PROC
;;;188    
;;;189    void ETH0_halt(void)
000000  e59f0014          LDR      r0,|L4.28|
;;;190    {
;;;191    
;;;192        outpw(REG_EMAC0_MCMDR, inpw(REG_EMAC0_MCMDR) & ~0x101); // disable tx/rx on
000004  e5900090          LDR      r0,[r0,#0x90]
000008  e3c00c01          BIC      r0,r0,#0x100
00000c  e3c00001          BIC      r0,r0,#1
000010  e59f1004          LDR      r1,|L4.28|
000014  e5810090          STR      r0,[r1,#0x90]
;;;193        
;;;194    }
000018  e12fff1e          BX       lr
;;;195    #include "FreeRtos.h"
                          ENDP

                  |L4.28|
                          DCD      0xb0002000

                          AREA ||i.ETH0_init||, CODE, READONLY, ALIGN=2

                  ETH0_init PROC
;;;273    
;;;274    void ETH0_init(u8_t *mac_addr)
000000  e92d4010          PUSH     {r4,lr}
;;;275    {
000004  e1a04000          MOV      r4,r0
;;;276    
;;;277        outpw(REG_CLK_HCLKEN, inpw(REG_CLK_HCLKEN) | (1 << 16));            // EMAC0 clk
000008  e3a0020b          MOV      r0,#0xb0000000
00000c  e5900210          LDR      r0,[r0,#0x210]
000010  e3800801          ORR      r0,r0,#0x10000
000014  e3a0120b          MOV      r1,#0xb0000000
000018  e5810210          STR      r0,[r1,#0x210]
;;;278        outpw(REG_CLK_DIVCTL8, (inpw(REG_CLK_DIVCTL8) & ~0xFF) | 0xA0);     // MDC clk divider
00001c  e3a0020b          MOV      r0,#0xb0000000
000020  e5900240          LDR      r0,[r0,#0x240]
000024  e3c000ff          BIC      r0,r0,#0xff
000028  e38000a0          ORR      r0,r0,#0xa0
00002c  e5810240          STR      r0,[r1,#0x240]
;;;279        
;;;280        // Multi function pin setting
;;;281        outpw(REG_SYS_GPF_MFPL, 0x11111111);
000030  e59f00a4          LDR      r0,|L5.220|
000034  e5810098          STR      r0,[r1,#0x98]
;;;282        outpw(REG_SYS_GPF_MFPH, (inpw(REG_SYS_GPF_MFPH) & ~0xFF) | 0x11);
000038  e3a0020b          MOV      r0,#0xb0000000
00003c  e590009c          LDR      r0,[r0,#0x9c]
000040  e3c000ff          BIC      r0,r0,#0xff
000044  e3800011          ORR      r0,r0,#0x11
000048  e581009c          STR      r0,[r1,#0x9c]
;;;283        
;;;284        // Reset MAC
;;;285        outpw(REG_EMAC0_MCMDR, 0x1000000);
00004c  e3a00401          MOV      r0,#0x1000000
000050  e18115c0          ORR      r1,r1,r0,ASR #11
000054  e5810090          STR      r0,[r1,#0x90]
;;;286    
;;;287        init_tx_desc();
000058  ebfffffe          BL       init_tx_desc
;;;288        init_rx_desc();
00005c  ebfffffe          BL       init_rx_desc
;;;289    
;;;290        set_mac_addr(mac_addr);  // need to reconfigure hardware address 'cos we just RESET emc...
000060  e1a00004          MOV      r0,r4
000064  ebfffffe          BL       set_mac_addr
;;;291        reset_phy();
000068  ebfffffe          BL       reset_phy
;;;292    
;;;293        outpw(REG_EMAC0_MCMDR, inpw(REG_EMAC0_MCMDR) | 0x121); // strip CRC, TX on, Rx on
00006c  e59f006c          LDR      r0,|L5.224|
000070  e5900090          LDR      r0,[r0,#0x90]
000074  e3800c01          ORR      r0,r0,#0x100
000078  e3800021          ORR      r0,r0,#0x21
00007c  e59f105c          LDR      r1,|L5.224|
000080  e5810090          STR      r0,[r1,#0x90]
;;;294        outpw(REG_EMAC0_MIEN, inpw(REG_EMAC0_MIEN) | 0x01250C11);  // Except tx/rx ok, enable rdu, txabt, tx/rx bus error.
000084  e1a00001          MOV      r0,r1
000088  e59000ac          LDR      r0,[r0,#0xac]
00008c  e59f1050          LDR      r1,|L5.228|
000090  e1800001          ORR      r0,r0,r1
000094  e59f1044          LDR      r1,|L5.224|
000098  e58100ac          STR      r0,[r1,#0xac]
;;;295        sysInstallISR(IRQ_LEVEL_1, EMC0_TX_IRQn, (PVOID)ETH0_TX_IRQHandler);
00009c  e59f2044          LDR      r2,|L5.232|
0000a0  e3a01015          MOV      r1,#0x15
0000a4  e3a00001          MOV      r0,#1
0000a8  ebfffffe          BL       sysInstallISR
;;;296        sysInstallISR(IRQ_LEVEL_1, EMC0_RX_IRQn, (PVOID)ETH0_RX_IRQHandler);
0000ac  e59f2038          LDR      r2,|L5.236|
0000b0  e3a01013          MOV      r1,#0x13
0000b4  e3a00001          MOV      r0,#1
0000b8  ebfffffe          BL       sysInstallISR
;;;297        sysEnableInterrupt(EMC0_TX_IRQn);
0000bc  e3a00015          MOV      r0,#0x15
0000c0  ebfffffe          BL       sysEnableInterrupt
;;;298        sysEnableInterrupt(EMC0_RX_IRQn);
0000c4  e3a00013          MOV      r0,#0x13
0000c8  ebfffffe          BL       sysEnableInterrupt
;;;299        ETH0_TRIGGER_RX();
0000cc  e3a00000          MOV      r0,#0
0000d0  e59f1008          LDR      r1,|L5.224|
0000d4  e58100a4          STR      r0,[r1,#0xa4]
;;;300        
;;;301    //    sysSetTimerEvent(TIMER0, 200, (PVOID)chk_link);  // check link status every 2 sec
;;;302    }
0000d8  e8bd8010          POP      {r4,pc}
;;;303    
                          ENDP

                  |L5.220|
                          DCD      0x11111111
                  |L5.224|
                          DCD      0xb0002000
                  |L5.228|
                          DCD      0x01250c11
                  |L5.232|
                          DCD      ETH0_TX_IRQHandler
                  |L5.236|
                          DCD      ETH0_RX_IRQHandler

                          AREA ||i.ETH0_trigger_tx||, CODE, READONLY, ALIGN=2

                  ETH0_trigger_tx PROC
;;;312    
;;;313    void ETH0_trigger_tx(u16_t length, struct pbuf *p)
000000  e1a02001          MOV      r2,r1
;;;314    {
;;;315        struct eth_descriptor volatile *desc;
;;;316        cur_tx_desc_ptr->status2 = (unsigned int)length;
000004  e59f3044          LDR      r3,|L6.80|
000008  e5933000          LDR      r3,[r3,#0]  ; cur_tx_desc_ptr
00000c  e5830008          STR      r0,[r3,#8]
;;;317        desc = cur_tx_desc_ptr->next;    // in case TX is transmitting and overwrite next pointer before we can update cur_tx_desc_ptr
000010  e59f3038          LDR      r3,|L6.80|
000014  e5933000          LDR      r3,[r3,#0]  ; cur_tx_desc_ptr
000018  e593100c          LDR      r1,[r3,#0xc]
;;;318        cur_tx_desc_ptr->status1 |= OWNERSHIP_EMAC;
00001c  e59f302c          LDR      r3,|L6.80|
000020  e5933000          LDR      r3,[r3,#0]  ; cur_tx_desc_ptr
000024  e5933000          LDR      r3,[r3,#0]
000028  e3833102          ORR      r3,r3,#0x80000000
00002c  e59fc01c          LDR      r12,|L6.80|
000030  e59cc000          LDR      r12,[r12,#0]  ; cur_tx_desc_ptr
000034  e58c3000          STR      r3,[r12,#0]
;;;319        cur_tx_desc_ptr = desc;
000038  e59f3010          LDR      r3,|L6.80|
00003c  e5831000          STR      r1,[r3,#0]  ; cur_tx_desc_ptr
;;;320    
;;;321        ETH0_TRIGGER_TX();
000040  e3a03000          MOV      r3,#0
000044  e59fc008          LDR      r12,|L6.84|
000048  e58c30a0          STR      r3,[r12,#0xa0]
;;;322    
;;;323    }
00004c  e12fff1e          BX       lr
;;;324    
                          ENDP

                  |L6.80|
                          DCD      cur_tx_desc_ptr
                  |L6.84|
                          DCD      0xb0002000

                          AREA ||i.chk_link||, CODE, READONLY, ALIGN=2

                  chk_link PROC
;;;253    
;;;254    static void chk_link(void)
000000  e92d4010          PUSH     {r4,lr}
;;;255    {
;;;256        unsigned int reg;
;;;257    
;;;258        reg = mdio_read(CONFIG_PHY_ADDR, MII_BMSR);
000004  e3a01001          MOV      r1,#1
000008  e3a00000          MOV      r0,#0
00000c  ebfffffe          BL       mdio_read
000010  e1a04000          MOV      r4,r0
;;;259    
;;;260        if (reg & BMSR_LSTATUS) {
000014  e2040004          AND      r0,r4,#4
000018  e3500000          CMP      r0,#0
00001c  0a00000e          BEQ      |L7.92|
;;;261            if (!plugged) {
000020  e59f006c          LDR      r0,|L7.148|
000024  e5900000          LDR      r0,[r0,#0]  ; plugged
000028  e3500000          CMP      r0,#0
00002c  1a000017          BNE      |L7.144|
;;;262                plugged = 1;
000030  e3a00001          MOV      r0,#1
000034  e59f1058          LDR      r1,|L7.148|
000038  e5810000          STR      r0,[r1,#0]  ; plugged
;;;263                reset_phy();
00003c  ebfffffe          BL       reset_phy
;;;264                outpw(REG_EMAC0_MCMDR, inpw(REG_EMAC0_MCMDR) | 0x101);
000040  e59f0050          LDR      r0,|L7.152|
000044  e5900090          LDR      r0,[r0,#0x90]
000048  e3800c01          ORR      r0,r0,#0x100
00004c  e3800001          ORR      r0,r0,#1
000050  e59f1040          LDR      r1,|L7.152|
000054  e5810090          STR      r0,[r1,#0x90]
000058  ea00000c          B        |L7.144|
                  |L7.92|
;;;265            }
;;;266        } else {
;;;267            if (plugged) {
00005c  e59f0030          LDR      r0,|L7.148|
000060  e5900000          LDR      r0,[r0,#0]  ; plugged
000064  e3500000          CMP      r0,#0
000068  0a000008          BEQ      |L7.144|
;;;268                plugged = 0;
00006c  e3a00000          MOV      r0,#0
000070  e59f101c          LDR      r1,|L7.148|
000074  e5810000          STR      r0,[r1,#0]  ; plugged
;;;269                outpw(REG_EMAC0_MCMDR, inpw(REG_EMAC0_MCMDR) & ~0x101);
000078  e59f0018          LDR      r0,|L7.152|
00007c  e5900090          LDR      r0,[r0,#0x90]
000080  e3c00c01          BIC      r0,r0,#0x100
000084  e3c00001          BIC      r0,r0,#1
000088  e59f1008          LDR      r1,|L7.152|
00008c  e5810090          STR      r0,[r1,#0x90]
                  |L7.144|
;;;270            }
;;;271        }
;;;272    }
000090  e8bd8010          POP      {r4,pc}
;;;273    
                          ENDP

                  |L7.148|
                          DCD      plugged
                  |L7.152|
                          DCD      0xb0002000

                          AREA ||i.init_rx_desc||, CODE, READONLY, ALIGN=2

                  init_rx_desc PROC
;;;156    
;;;157    static void init_rx_desc(void)
000000  e59f1088          LDR      r1,|L8.144|
;;;158    {
;;;159        u32_t i;
;;;160    
;;;161    
;;;162        cur_rx_desc_ptr = (struct eth_descriptor *)((UINT)(&rx_desc[0]) | 0x80000000);
000004  e3811102          ORR      r1,r1,#0x80000000
000008  e59f2084          LDR      r2,|L8.148|
00000c  e5821000          STR      r1,[r2,#0]  ; cur_rx_desc_ptr
;;;163    
;;;164        for(i = 0; i < RX_DESCRIPTOR_NUM; i++) {
000010  e3a00000          MOV      r0,#0
000014  ea000016          B        |L8.116|
                  |L8.24|
;;;165            rx_desc[i].status1 = OWNERSHIP_EMAC;
000018  e3a01102          MOV      r1,#0x80000000
00001c  e59f206c          LDR      r2,|L8.144|
000020  e7821200          STR      r1,[r2,r0,LSL #4]
;;;166            rx_desc[i].buf = (unsigned char *)((UINT)(&rx_buf[i][0]) | 0x80000000);
000024  e0601280          RSB      r1,r0,r0,LSL #5
000028  e0811300          ADD      r1,r1,r0,LSL #6
00002c  e59f2064          LDR      r2,|L8.152|
000030  e0821201          ADD      r1,r2,r1,LSL #4
000034  e3811102          ORR      r1,r1,#0x80000000
000038  e59f2050          LDR      r2,|L8.144|
00003c  e0822200          ADD      r2,r2,r0,LSL #4
000040  e5821004          STR      r1,[r2,#4]
;;;167            rx_desc[i].status2 = 0;
000044  e3a01000          MOV      r1,#0
000048  e59f2040          LDR      r2,|L8.144|
00004c  e0822200          ADD      r2,r2,r0,LSL #4
000050  e5821008          STR      r1,[r2,#8]
;;;168            rx_desc[i].next = (struct eth_descriptor *)((UINT)(&rx_desc[(i + 1) % RX_DESCRIPTOR_NUM]) | 0x80000000);
000054  e2801001          ADD      r1,r0,#1
000058  e2011003          AND      r1,r1,#3
00005c  e59f202c          LDR      r2,|L8.144|
000060  e0821201          ADD      r1,r2,r1,LSL #4
000064  e3811102          ORR      r1,r1,#0x80000000
000068  e0822200          ADD      r2,r2,r0,LSL #4
00006c  e582100c          STR      r1,[r2,#0xc]
000070  e2800001          ADD      r0,r0,#1              ;164
                  |L8.116|
000074  e3500004          CMP      r0,#4                 ;164
000078  3affffe6          BCC      |L8.24|
;;;169        }
;;;170        outpw(REG_EMAC0_RXDLSA, (unsigned int)&rx_desc[0] | 0x80000000);
00007c  e59f100c          LDR      r1,|L8.144|
000080  e3811102          ORR      r1,r1,#0x80000000
000084  e59f2010          LDR      r2,|L8.156|
000088  e582108c          STR      r1,[r2,#0x8c]
;;;171        return;
;;;172    }
00008c  e12fff1e          BX       lr
;;;173    
                          ENDP

                  |L8.144|
                          DCD      rx_desc
                  |L8.148|
                          DCD      cur_rx_desc_ptr
                  |L8.152|
                          DCD      rx_buf
                  |L8.156|
                          DCD      0xb0002000

                          AREA ||i.init_tx_desc||, CODE, READONLY, ALIGN=2

                  init_tx_desc PROC
;;;139    
;;;140    static void init_tx_desc(void)
000000  e59f1090          LDR      r1,|L9.152|
;;;141    {
;;;142        u32_t i;
;;;143    
;;;144    
;;;145        cur_tx_desc_ptr = fin_tx_desc_ptr = (struct eth_descriptor *)((UINT)(&tx_desc[0]) | 0x80000000);
000004  e3811102          ORR      r1,r1,#0x80000000
000008  e59f208c          LDR      r2,|L9.156|
00000c  e5821000          STR      r1,[r2,#0]  ; fin_tx_desc_ptr
000010  e59f2088          LDR      r2,|L9.160|
000014  e5821000          STR      r1,[r2,#0]  ; cur_tx_desc_ptr
;;;146    
;;;147        for(i = 0; i < TX_DESCRIPTOR_NUM; i++) {
000018  e3a00000          MOV      r0,#0
00001c  ea000016          B        |L9.124|
                  |L9.32|
;;;148            tx_desc[i].status1 = TXFD_PADEN | TXFD_CRCAPP | TXFD_INTEN;
000020  e3a01007          MOV      r1,#7
000024  e59f206c          LDR      r2,|L9.152|
000028  e7821200          STR      r1,[r2,r0,LSL #4]
;;;149            tx_desc[i].buf = (unsigned char *)((UINT)(&tx_buf[i][0]) | 0x80000000);
00002c  e0601280          RSB      r1,r0,r0,LSL #5
000030  e0811300          ADD      r1,r1,r0,LSL #6
000034  e59f2068          LDR      r2,|L9.164|
000038  e0821201          ADD      r1,r2,r1,LSL #4
00003c  e3811102          ORR      r1,r1,#0x80000000
000040  e59f2050          LDR      r2,|L9.152|
000044  e0822200          ADD      r2,r2,r0,LSL #4
000048  e5821004          STR      r1,[r2,#4]
;;;150            tx_desc[i].status2 = 0;
00004c  e3a01000          MOV      r1,#0
000050  e59f2040          LDR      r2,|L9.152|
000054  e0822200          ADD      r2,r2,r0,LSL #4
000058  e5821008          STR      r1,[r2,#8]
;;;151            tx_desc[i].next = (struct eth_descriptor *)((UINT)(&tx_desc[(i + 1) % TX_DESCRIPTOR_NUM]) | 0x80000000);
00005c  e2801001          ADD      r1,r0,#1
000060  e2011003          AND      r1,r1,#3
000064  e59f202c          LDR      r2,|L9.152|
000068  e0821201          ADD      r1,r2,r1,LSL #4
00006c  e3811102          ORR      r1,r1,#0x80000000
000070  e0822200          ADD      r2,r2,r0,LSL #4
000074  e582100c          STR      r1,[r2,#0xc]
000078  e2800001          ADD      r0,r0,#1              ;147
                  |L9.124|
00007c  e3500004          CMP      r0,#4                 ;147
000080  3affffe6          BCC      |L9.32|
;;;152        }
;;;153        outpw(REG_EMAC0_TXDLSA, (unsigned int)&tx_desc[0] | 0x80000000);
000084  e59f100c          LDR      r1,|L9.152|
000088  e3811102          ORR      r1,r1,#0x80000000
00008c  e59f2014          LDR      r2,|L9.168|
000090  e5821088          STR      r1,[r2,#0x88]
;;;154        return;
;;;155    }
000094  e12fff1e          BX       lr
;;;156    
                          ENDP

                  |L9.152|
                          DCD      tx_desc
                  |L9.156|
                          DCD      fin_tx_desc_ptr
                  |L9.160|
                          DCD      cur_tx_desc_ptr
                  |L9.164|
                          DCD      tx_buf
                  |L9.168|
                          DCD      0xb0002000

                          AREA ||i.mdio_read||, CODE, READONLY, ALIGN=2

                  mdio_read PROC
;;;66     
;;;67     static u16_t mdio_read(u8_t addr, u8_t reg)
000000  e1a02000          MOV      r2,r0
;;;68     {
;;;69         outpw(REG_EMAC0_MIIDA, (addr << 8) | reg | 0xA0000);
000004  e1810402          ORR      r0,r1,r2,LSL #8
000008  e380080a          ORR      r0,r0,#0xa0000
00000c  e59f302c          LDR      r3,|L10.64|
000010  e5830098          STR      r0,[r3,#0x98]
;;;70         while (inpw(REG_EMAC0_MIIDA) & 0x20000);    // wait busy flag clear
000014  e1a00000          MOV      r0,r0
                  |L10.24|
000018  e59f0020          LDR      r0,|L10.64|
00001c  e5900098          LDR      r0,[r0,#0x98]
000020  e2000802          AND      r0,r0,#0x20000
000024  e3500000          CMP      r0,#0
000028  1afffffa          BNE      |L10.24|
;;;71     
;;;72         return inpw(REG_EMAC0_MIID);
00002c  e59f000c          LDR      r0,|L10.64|
000030  e5900094          LDR      r0,[r0,#0x94]
000034  e1a00800          LSL      r0,r0,#16
000038  e1a00820          LSR      r0,r0,#16
;;;73     }
00003c  e12fff1e          BX       lr
;;;74     
                          ENDP

                  |L10.64|
                          DCD      0xb0002000

                          AREA ||i.mdio_write||, CODE, READONLY, ALIGN=2

                  mdio_write PROC
;;;55     
;;;56     static void mdio_write(u8_t addr, u8_t reg, u16_t val)
000000  e59f302c          LDR      r3,|L11.52|
;;;57     {
;;;58         
;;;59         outpw(REG_EMAC0_MIID, val);
000004  e5832094          STR      r2,[r3,#0x94]
;;;60         outpw(REG_EMAC0_MIIDA, (addr << 8) | reg | 0xB0000);
000008  e1813400          ORR      r3,r1,r0,LSL #8
00000c  e383380b          ORR      r3,r3,#0xb0000
000010  e59fc01c          LDR      r12,|L11.52|
000014  e58c3098          STR      r3,[r12,#0x98]
;;;61     
;;;62         while (inpw(REG_EMAC0_MIIDA) & 0x20000);    // wait busy flag clear
000018  e1a00000          MOV      r0,r0
                  |L11.28|
00001c  e59f3010          LDR      r3,|L11.52|
000020  e5933098          LDR      r3,[r3,#0x98]
000024  e2033802          AND      r3,r3,#0x20000
000028  e3530000          CMP      r3,#0
00002c  1afffffa          BNE      |L11.28|
;;;63     
;;;64     }
000030  e12fff1e          BX       lr
;;;65     
                          ENDP

                  |L11.52|
                          DCD      0xb0002000

                          AREA ||i.reset_phy||, CODE, READONLY, ALIGN=2

                  reset_phy PROC
;;;74     
;;;75     static int reset_phy(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;76     {
;;;77     
;;;78         u16_t reg;
;;;79         u32_t delay;
;;;80     
;;;81     
;;;82         mdio_write(CONFIG_PHY_ADDR, MII_BMCR, BMCR_RESET);
000004  e3a02902          MOV      r2,#0x8000
000008  e3a01000          MOV      r1,#0
00000c  e1a00001          MOV      r0,r1
000010  ebfffffe          BL       mdio_write
;;;83     
;;;84         delay = 2000;
000014  e3a05e7d          MOV      r5,#0x7d0
;;;85         while(delay-- > 0) {
000018  ea000006          B        |L12.56|
                  |L12.28|
;;;86             if((mdio_read(CONFIG_PHY_ADDR, MII_BMCR) & BMCR_RESET) == 0)
00001c  e3a01000          MOV      r1,#0
000020  e1a00001          MOV      r0,r1
000024  ebfffffe          BL       mdio_read
000028  e2000902          AND      r0,r0,#0x8000
00002c  e3500000          CMP      r0,#0
000030  1a000000          BNE      |L12.56|
;;;87                 break;
000034  ea000002          B        |L12.68|
                  |L12.56|
000038  e2550000          SUBS     r0,r5,#0              ;85
00003c  e2455001          SUB      r5,r5,#1              ;85
000040  1afffff5          BNE      |L12.28|
                  |L12.68|
000044  e1a00000          MOV      r0,r0
;;;88     
;;;89         }
;;;90     
;;;91         if(delay == 0) {
000048  e3550000          CMP      r5,#0
00004c  1a000003          BNE      |L12.96|
;;;92             sysprintf("Reset phy failed\n");
000050  e28f0e17          ADR      r0,|L12.456|
000054  ebfffffe          BL       sysprintf
;;;93             return(-1);
000058  e3e00000          MVN      r0,#0
                  |L12.92|
;;;94         }
;;;95     
;;;96         mdio_write(CONFIG_PHY_ADDR, MII_ADVERTISE, ADVERTISE_CSMA |
;;;97                    ADVERTISE_10HALF |
;;;98                    ADVERTISE_10FULL |
;;;99                    ADVERTISE_100HALF |
;;;100                   ADVERTISE_100FULL);
;;;101    
;;;102        reg = mdio_read(CONFIG_PHY_ADDR, MII_BMCR);
;;;103        mdio_write(CONFIG_PHY_ADDR, MII_BMCR, reg | BMCR_ANRESTART);
;;;104    
;;;105        delay = 200000;
;;;106        while(delay-- > 0) {
;;;107            if((mdio_read(CONFIG_PHY_ADDR, MII_BMSR) & (BMSR_ANEGCOMPLETE | BMSR_LSTATUS))
;;;108                    == (BMSR_ANEGCOMPLETE | BMSR_LSTATUS))
;;;109                break;
;;;110        }
;;;111    
;;;112        if(delay == 0) {
;;;113            sysprintf("AN failed. Set to 100 FULL\n");
;;;114            outpw(REG_EMAC0_MCMDR, inpw(REG_EMAC0_MCMDR) | 0x140000);
;;;115            plugged = 0;
;;;116            return(-1);
;;;117        } else {
;;;118            reg = mdio_read(CONFIG_PHY_ADDR, MII_LPA);
;;;119            plugged = 1;
;;;120    
;;;121            if(reg & ADVERTISE_100FULL) {
;;;122                sysprintf("100 full\n");
;;;123                outpw(REG_EMAC0_MCMDR, inpw(REG_EMAC0_MCMDR) | 0x140000);
;;;124            } else if(reg & ADVERTISE_100HALF) {
;;;125                sysprintf("100 half\n");
;;;126                outpw(REG_EMAC0_MCMDR, (inpw(REG_EMAC0_MCMDR) & ~0x40000) | 0x100000);
;;;127            } else if(reg & ADVERTISE_10FULL) {
;;;128                sysprintf("10 full\n");
;;;129                outpw(REG_EMAC0_MCMDR, (inpw(REG_EMAC0_MCMDR) & ~0x100000) | 0x40000);
;;;130            } else {
;;;131                sysprintf("10 half\n");
;;;132                outpw(REG_EMAC0_MCMDR, inpw(REG_EMAC0_MCMDR) & ~0x140000);
;;;133            }
;;;134        }
;;;135    
;;;136        return(0);
;;;137    }
00005c  e8bd8070          POP      {r4-r6,pc}
                  |L12.96|
000060  e59f2174          LDR      r2,|L12.476|
000064  e3a01004          MOV      r1,#4                 ;96
000068  e3a00000          MOV      r0,#0                 ;96
00006c  ebfffffe          BL       mdio_write
000070  e3a01000          MOV      r1,#0                 ;102
000074  e1a00001          MOV      r0,r1                 ;102
000078  ebfffffe          BL       mdio_read
00007c  e1a04000          MOV      r4,r0                 ;102
000080  e3842c02          ORR      r2,r4,#0x200          ;103
000084  e3a01000          MOV      r1,#0                 ;103
000088  e1a00001          MOV      r0,r1                 ;103
00008c  ebfffffe          BL       mdio_write
000090  e59f5148          LDR      r5,|L12.480|
000094  ea000006          B        |L12.180|
                  |L12.152|
000098  e3a01001          MOV      r1,#1                 ;107
00009c  e3a00000          MOV      r0,#0                 ;107
0000a0  ebfffffe          BL       mdio_read
0000a4  e2000024          AND      r0,r0,#0x24           ;107
0000a8  e3500024          CMP      r0,#0x24              ;107
0000ac  1a000000          BNE      |L12.180|
0000b0  ea000002          B        |L12.192|
                  |L12.180|
0000b4  e2550000          SUBS     r0,r5,#0              ;106
0000b8  e2455001          SUB      r5,r5,#1              ;106
0000bc  1afffff5          BNE      |L12.152|
                  |L12.192|
0000c0  e1a00000          MOV      r0,r0                 ;109
0000c4  e3550000          CMP      r5,#0                 ;112
0000c8  1a00000b          BNE      |L12.252|
0000cc  e28f0e11          ADR      r0,|L12.484|
0000d0  ebfffffe          BL       sysprintf
0000d4  e59f0124          LDR      r0,|L12.512|
0000d8  e5900090          LDR      r0,[r0,#0x90]         ;114
0000dc  e3800705          ORR      r0,r0,#0x140000       ;114
0000e0  e59f1118          LDR      r1,|L12.512|
0000e4  e5810090          STR      r0,[r1,#0x90]         ;114
0000e8  e3a00000          MOV      r0,#0                 ;115
0000ec  e59f1110          LDR      r1,|L12.516|
0000f0  e5810000          STR      r0,[r1,#0]            ;115  ; plugged
0000f4  e3e00000          MVN      r0,#0                 ;116
0000f8  eaffffd7          B        |L12.92|
                  |L12.252|
0000fc  e3a01005          MOV      r1,#5                 ;118
000100  e3a00000          MOV      r0,#0                 ;118
000104  ebfffffe          BL       mdio_read
000108  e1a04000          MOV      r4,r0                 ;118
00010c  e3a00001          MOV      r0,#1                 ;119
000110  e59f10ec          LDR      r1,|L12.516|
000114  e5810000          STR      r0,[r1,#0]            ;119  ; plugged
000118  e2040c01          AND      r0,r4,#0x100          ;121
00011c  e3500000          CMP      r0,#0                 ;121
000120  0a000007          BEQ      |L12.324|
000124  e28f00dc          ADR      r0,|L12.520|
000128  ebfffffe          BL       sysprintf
00012c  e59f00cc          LDR      r0,|L12.512|
000130  e5900090          LDR      r0,[r0,#0x90]         ;123
000134  e3800705          ORR      r0,r0,#0x140000       ;123
000138  e59f10c0          LDR      r1,|L12.512|
00013c  e5810090          STR      r0,[r1,#0x90]         ;123
000140  ea00001e          B        |L12.448|
                  |L12.324|
000144  e2040080          AND      r0,r4,#0x80           ;124
000148  e3500000          CMP      r0,#0                 ;124
00014c  0a000008          BEQ      |L12.372|
000150  e28f00bc          ADR      r0,|L12.532|
000154  ebfffffe          BL       sysprintf
000158  e59f00a0          LDR      r0,|L12.512|
00015c  e5900090          LDR      r0,[r0,#0x90]         ;126
000160  e3c00701          BIC      r0,r0,#0x40000        ;126
000164  e3800601          ORR      r0,r0,#0x100000       ;126
000168  e59f1090          LDR      r1,|L12.512|
00016c  e5810090          STR      r0,[r1,#0x90]         ;126
000170  ea000012          B        |L12.448|
                  |L12.372|
000174  e2040040          AND      r0,r4,#0x40           ;127
000178  e3500000          CMP      r0,#0                 ;127
00017c  0a000008          BEQ      |L12.420|
000180  e28f0098          ADR      r0,|L12.544|
000184  ebfffffe          BL       sysprintf
000188  e59f0070          LDR      r0,|L12.512|
00018c  e5900090          LDR      r0,[r0,#0x90]         ;129
000190  e3c00601          BIC      r0,r0,#0x100000       ;129
000194  e3800701          ORR      r0,r0,#0x40000        ;129
000198  e59f1060          LDR      r1,|L12.512|
00019c  e5810090          STR      r0,[r1,#0x90]         ;129
0001a0  ea000006          B        |L12.448|
                  |L12.420|
0001a4  e28f0080          ADR      r0,|L12.556|
0001a8  ebfffffe          BL       sysprintf
0001ac  e59f004c          LDR      r0,|L12.512|
0001b0  e5900090          LDR      r0,[r0,#0x90]         ;132
0001b4  e3c00705          BIC      r0,r0,#0x140000       ;132
0001b8  e59f1040          LDR      r1,|L12.512|
0001bc  e5810090          STR      r0,[r1,#0x90]         ;132
                  |L12.448|
0001c0  e3a00000          MOV      r0,#0                 ;136
0001c4  eaffffa4          B        |L12.92|
;;;138    
                          ENDP

                  |L12.456|
0001c8  52657365          DCB      "Reset phy failed\n",0
0001cc  74207068
0001d0  79206661
0001d4  696c6564
0001d8  0a00    
0001da  00                DCB      0
0001db  00                DCB      0
                  |L12.476|
                          DCD      0x000001e1
                  |L12.480|
                          DCD      0x00030d40
                  |L12.484|
0001e4  414e2066          DCB      "AN failed. Set to 100 FULL\n",0
0001e8  61696c65
0001ec  642e2053
0001f0  65742074
0001f4  6f203130
0001f8  30204655
0001fc  4c4c0a00
                  |L12.512|
                          DCD      0xb0002000
                  |L12.516|
                          DCD      plugged
                  |L12.520|
000208  31303020          DCB      "100 full\n",0
00020c  66756c6c
000210  0a00    
000212  00                DCB      0
000213  00                DCB      0
                  |L12.532|
000214  31303020          DCB      "100 half\n",0
000218  68616c66
00021c  0a00    
00021e  00                DCB      0
00021f  00                DCB      0
                  |L12.544|
000220  31302066          DCB      "10 full\n",0
000224  756c6c0a
000228  00      
000229  00                DCB      0
00022a  00                DCB      0
00022b  00                DCB      0
                  |L12.556|
00022c  31302068          DCB      "10 half\n",0
000230  616c660a
000234  00      
000235  00                DCB      0
000236  00                DCB      0
000237  00                DCB      0

                          AREA ||i.set_mac_addr||, CODE, READONLY, ALIGN=2

                  set_mac_addr PROC
;;;173    
;;;174    static void set_mac_addr(u8_t *addr)
000000  e5d01000          LDRB     r1,[r0,#0]
;;;175    {
;;;176    
;;;177        outpw(REG_EMAC0_CAMxM_Reg(0), (addr[0] << 24) |
000004  e1a01c01          LSL      r1,r1,#24
000008  e5d02001          LDRB     r2,[r0,#1]
00000c  e1811802          ORR      r1,r1,r2,LSL #16
000010  e5d02002          LDRB     r2,[r0,#2]
000014  e1811402          ORR      r1,r1,r2,LSL #8
000018  e5d02003          LDRB     r2,[r0,#3]
00001c  e1811002          ORR      r1,r1,r2
000020  e59f202c          LDR      r2,|L13.84|
000024  e5821008          STR      r1,[r2,#8]
;;;178                                      (addr[1] << 16) |
;;;179                                      (addr[2] << 8) |
;;;180                                      addr[3]);
;;;181        outpw(REG_EMAC0_CAMxL_Reg(0), (addr[4] << 24) |
000028  e5d01004          LDRB     r1,[r0,#4]
00002c  e1a01c01          LSL      r1,r1,#24
000030  e5d02005          LDRB     r2,[r0,#5]
000034  e1811802          ORR      r1,r1,r2,LSL #16
000038  e59f2014          LDR      r2,|L13.84|
00003c  e582100c          STR      r1,[r2,#0xc]
;;;182                                      (addr[5] << 16));
;;;183        outpw(REG_EMAC0_CAMCMR, 0x16);
000040  e3a01016          MOV      r1,#0x16
000044  e5821000          STR      r1,[r2,#0]
;;;184        outpw(REG_EMAC0_CAMEN, 1);    // Enable CAM entry 0
000048  e3a01001          MOV      r1,#1
00004c  e5821004          STR      r1,[r2,#4]
;;;185    
;;;186    }
000050  e12fff1e          BX       lr
;;;187    
                          ENDP

                  |L13.84|
                          DCD      0xb0002000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  rx_desc
                          %        64
                  tx_desc
                          %        64
                  rx_buf
                          %        6080
                  tx_buf
                          %        6080

                          AREA ||.data||, DATA, ALIGN=2

                  cur_tx_desc_ptr
                          DCD      0x00000000
                  cur_rx_desc_ptr
                          DCD      0x00000000
                  fin_tx_desc_ptr
                          DCD      0x00000000
                  plugged
                          DCD      0x00000000
