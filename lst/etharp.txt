; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\etharp.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\etharp.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\etharp.crf lwip-1.4.1\src\netif\etharp.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  etharp_free_entry PROC
;;;176    static void
;;;177    etharp_free_entry(int i)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;178    {
;;;179      /* remove from SNMP ARP index tree */
;;;180      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
;;;181      /* and empty packet queue */
;;;182      if (arp_table[i].q != NULL) {
000004  e59f62f8          LDR      r6,|L1.772|
000008  e0804100          ADD      r4,r0,r0,LSL #2
00000c  e7960104          LDR      r0,[r6,r4,LSL #2]
000010  e3a05000          MOV      r5,#0
000014  e3500000          CMP      r0,#0
000018  0a000001          BEQ      |L1.36|
;;;183        /* remove all queued packets */
;;;184        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;185        free_etharp_q(arp_table[i].q);
00001c  ebfffffe          BL       pbuf_free
;;;186        arp_table[i].q = NULL;
000020  e7865104          STR      r5,[r6,r4,LSL #2]
                  |L1.36|
;;;187      }
;;;188      /* recycle entry for re-use */
;;;189      arp_table[i].state = ETHARP_STATE_EMPTY;
000024  e0860104          ADD      r0,r6,r4,LSL #2
000028  e5c05012          STRB     r5,[r0,#0x12]
;;;190    #ifdef LWIP_DEBUG
;;;191      /* for debugging, clean out the complete entry */
;;;192      arp_table[i].ctime = 0;
00002c  e5c05013          STRB     r5,[r0,#0x13]
;;;193      arp_table[i].netif = NULL;
;;;194      ip_addr_set_zero(&arp_table[i].ipaddr);
000030  e5805008          STR      r5,[r0,#8]
;;;195      arp_table[i].ethaddr = ethzero;
000034  e5a05004          STR      r5,[r0,#4]!
000038  e8bd4070          POP      {r4-r6,lr}
00003c  e59f12c4          LDR      r1,|L1.776|
000040  e3a02006          MOV      r2,#6
000044  e2800008          ADD      r0,r0,#8
000048  eafffffe          B        __aeabi_memcpy
;;;196    #endif /* LWIP_DEBUG */
;;;197    }
;;;198    
                          ENDP

                  etharp_tmr PROC
;;;205    void
;;;206    etharp_tmr(void)
00004c  e92d4070          PUSH     {r4-r6,lr}
;;;207    {
;;;208      u8_t i;
;;;209    
;;;210      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
;;;211      /* remove expired entries from the ARP table */
;;;212      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
;;;213        u8_t state = arp_table[i].state;
000050  e59f52ac          LDR      r5,|L1.772|
000054  e3a04000          MOV      r4,#0                 ;212
                  |L1.88|
000058  e0840104          ADD      r0,r4,r4,LSL #2
00005c  e0850100          ADD      r0,r5,r0,LSL #2
000060  e5d02012          LDRB     r2,[r0,#0x12]
;;;214        if (state != ETHARP_STATE_EMPTY
000064  e3520000          CMP      r2,#0
000068  0a00000f          BEQ      |L1.172|
;;;215    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;216          && (state != ETHARP_STATE_STATIC)
;;;217    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;218          ) {
;;;219          arp_table[i].ctime++;
00006c  e5d01013          LDRB     r1,[r0,#0x13]
000070  e2811001          ADD      r1,r1,#1
000074  e20110ff          AND      r1,r1,#0xff
;;;220          if ((arp_table[i].ctime >= ARP_MAXAGE) ||
000078  e35100f0          CMP      r1,#0xf0
00007c  e5c01013          STRB     r1,[r0,#0x13]         ;219
000080  2a000007          BCS      |L1.164|
;;;221              ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
000084  e3520001          CMP      r2,#1
000088  0a000003          BEQ      |L1.156|
;;;222               (arp_table[i].ctime >= ARP_MAXPENDING))) {
;;;223            /* pending or stable entry has become old! */
;;;224            LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
;;;225                 arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
;;;226            /* clean up entries that have just been expired */
;;;227            etharp_free_entry(i);
;;;228          }
;;;229          else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
00008c  e3520003          CMP      r2,#3
;;;230            /* Reset state to stable, so that the next transmitted packet will
;;;231               re-send an ARP request. */
;;;232            arp_table[i].state = ETHARP_STATE_STABLE;
000090  03a01002          MOVEQ    r1,#2
000094  05c01012          STRBEQ   r1,[r0,#0x12]
000098  ea000003          B        |L1.172|
                  |L1.156|
00009c  e3510002          CMP      r1,#2                 ;222
0000a0  3a000001          BCC      |L1.172|
                  |L1.164|
0000a4  e1a00004          MOV      r0,r4                 ;227
0000a8  ebfffffe          BL       etharp_free_entry
                  |L1.172|
0000ac  e2840001          ADD      r0,r4,#1              ;212
0000b0  e20040ff          AND      r4,r0,#0xff           ;212
0000b4  e354000a          CMP      r4,#0xa               ;212
0000b8  3affffe6          BCC      |L1.88|
;;;233          }
;;;234    #if ARP_QUEUEING
;;;235          /* still pending entry? (not expired) */
;;;236          if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;237            /* resend an ARP query here? */
;;;238          }
;;;239    #endif /* ARP_QUEUEING */
;;;240        }
;;;241      }
;;;242    }
0000bc  e8bd8070          POP      {r4-r6,pc}
;;;243    
                          ENDP

                  etharp_find_entry PROC
;;;265    static s8_t
;;;266    etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
0000c0  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;267    {
0000c4  e1a08000          MOV      r8,r0
;;;268      s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
0000c8  e3a0000a          MOV      r0,#0xa
0000cc  e24dd014          SUB      sp,sp,#0x14           ;267
;;;269      s8_t empty = ARP_TABLE_SIZE;
;;;270      u8_t i = 0, age_pending = 0, age_stable = 0;
0000d0  e3a04000          MOV      r4,#0
0000d4  e1a07000          MOV      r7,r0                 ;269
0000d8  e1a0a004          MOV      r10,r4
;;;271      /* oldest entry with packets on queue */
;;;272      s8_t old_queue = ARP_TABLE_SIZE;
0000dc  e1a0b000          MOV      r11,r0
;;;273      /* its age */
;;;274      u8_t age_queue = 0;
0000e0  e1a09004          MOV      r9,r4
0000e4  e58d0000          STR      r0,[sp,#0]            ;268
0000e8  e58d0008          STR      r0,[sp,#8]            ;268
0000ec  e58d4004          STR      r4,[sp,#4]            ;270
                  |L1.240|
;;;275    
;;;276      /**
;;;277       * a) do a search through the cache, remember candidates
;;;278       * b) select candidate entry
;;;279       * c) create new entry
;;;280       */
;;;281    
;;;282      /* a) in a single search sweep, do all of this
;;;283       * 1) remember the first empty entry (if any)
;;;284       * 2) remember the oldest stable entry (if any)
;;;285       * 3) remember the oldest pending entry without queued packets (if any)
;;;286       * 4) remember the oldest pending entry with queued packets (if any)
;;;287       * 5) search for a matching IP entry, either pending or stable
;;;288       *    until 5 matches, or all entries are searched for.
;;;289       */
;;;290    
;;;291      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
;;;292        u8_t state = arp_table[i].state;
0000f0  e59f120c          LDR      r1,|L1.772|
0000f4  e0840104          ADD      r0,r4,r4,LSL #2
0000f8  e0816100          ADD      r6,r1,r0,LSL #2
0000fc  e58d000c          STR      r0,[sp,#0xc]
000100  e5d65012          LDRB     r5,[r6,#0x12]
;;;293        /* no empty entry found yet and now we do find one? */
;;;294        if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
000104  e357000a          CMP      r7,#0xa
000108  0a000013          BEQ      |L1.348|
;;;295          LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
;;;296          /* remember first empty entry */
;;;297          empty = i;
;;;298        } else if (state != ETHARP_STATE_EMPTY) {
00010c  e3550000          CMP      r5,#0
000110  0a000020          BEQ      |L1.408|
                  |L1.276|
;;;299          LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
000114  e3550001          CMP      r5,#1
000118  13550002          CMPNE    r5,#2
00011c  2a000004          BCS      |L1.308|
000120  e59f2204          LDR      r2,|L1.812|
000124  e28f3e1e          ADR      r3,|L1.780|
000128  e28f1c02          ADR      r1,|L1.816|
00012c  e28f0f8f          ADR      r0,|L1.880|
000130  ebfffffe          BL       sysprintf
                  |L1.308|
;;;300            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
;;;301          /* if given, does IP address match IP address in ARP entry? */
;;;302          if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
000134  e3580000          CMP      r8,#0
000138  0a00000c          BEQ      |L1.368|
00013c  e5980000          LDR      r0,[r8,#0]
000140  e5961004          LDR      r1,[r6,#4]
000144  e1500001          CMP      r0,r1
000148  1a000008          BNE      |L1.368|
                  |L1.332|
;;;303            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
;;;304            /* found exact IP address match, simply bail out */
;;;305            return i;
00014c  e1a00c04          LSL      r0,r4,#24
000150  e1a00c40          ASR      r0,r0,#24
                  |L1.340|
000154  e28dd01c          ADD      sp,sp,#0x1c
;;;306          }
;;;307          /* pending entry? */
;;;308          if (state == ETHARP_STATE_PENDING) {
;;;309            /* pending with queued packets? */
;;;310            if (arp_table[i].q != NULL) {
;;;311              if (arp_table[i].ctime >= age_queue) {
;;;312                old_queue = i;
;;;313                age_queue = arp_table[i].ctime;
;;;314              }
;;;315            } else
;;;316            /* pending without queued packets? */
;;;317            {
;;;318              if (arp_table[i].ctime >= age_pending) {
;;;319                old_pending = i;
;;;320                age_pending = arp_table[i].ctime;
;;;321              }
;;;322            }
;;;323          /* stable entry? */
;;;324          } else if (state >= ETHARP_STATE_STABLE) {
;;;325    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;326            /* don't record old_stable for static entries since they never expire */
;;;327            if (state < ETHARP_STATE_STATIC)
;;;328    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;329            {
;;;330              /* remember entry with oldest stable entry in oldest, its age in maxtime */
;;;331              if (arp_table[i].ctime >= age_stable) {
;;;332                old_stable = i;
;;;333                age_stable = arp_table[i].ctime;
;;;334              }
;;;335            }
;;;336          }
;;;337        }
;;;338      }
;;;339      /* { we have no match } => try to create a new entry */
;;;340       
;;;341      /* don't create new entry, only search? */
;;;342      if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
;;;343          /* or no empty entry found and not allowed to recycle? */
;;;344          ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
;;;345        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
;;;346        return (s8_t)ERR_MEM;
;;;347      }
;;;348      
;;;349      /* b) choose the least destructive entry to recycle:
;;;350       * 1) empty entry
;;;351       * 2) oldest stable entry
;;;352       * 3) oldest pending entry without queued packets
;;;353       * 4) oldest pending entry with queued packets
;;;354       * 
;;;355       * { ETHARP_FLAG_TRY_HARD is set at this point }
;;;356       */ 
;;;357    
;;;358      /* 1) empty entry available? */
;;;359      if (empty < ARP_TABLE_SIZE) {
;;;360        i = empty;
;;;361        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
;;;362      } else {
;;;363        /* 2) found recyclable stable entry? */
;;;364        if (old_stable < ARP_TABLE_SIZE) {
;;;365          /* recycle oldest stable*/
;;;366          i = old_stable;
;;;367          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
;;;368          /* no queued packets should exist on stable entries */
;;;369          LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
;;;370        /* 3) found recyclable pending entry without queued packets? */
;;;371        } else if (old_pending < ARP_TABLE_SIZE) {
;;;372          /* recycle oldest pending */
;;;373          i = old_pending;
;;;374          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
;;;375        /* 4) found recyclable pending entry with queued packets? */
;;;376        } else if (old_queue < ARP_TABLE_SIZE) {
;;;377          /* recycle oldest pending (queued packets are free in etharp_free_entry) */
;;;378          i = old_queue;
;;;379          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;380          /* no empty or recyclable entries found */
;;;381        } else {
;;;382          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
;;;383          return (s8_t)ERR_MEM;
;;;384        }
;;;385    
;;;386        /* { empty or recyclable entry found } */
;;;387        LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;388        etharp_free_entry(i);
;;;389      }
;;;390    
;;;391      LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;392      LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
;;;393        arp_table[i].state == ETHARP_STATE_EMPTY);
;;;394    
;;;395      /* IP address given? */
;;;396      if (ipaddr != NULL) {
;;;397        /* set IP address */
;;;398        ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
;;;399      }
;;;400      arp_table[i].ctime = 0;
;;;401      return (err_t)i;
;;;402    }
000158  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.348|
00015c  e3550000          CMP      r5,#0                 ;294
000160  01a07c04          LSLEQ    r7,r4,#24             ;297
000164  01a07c47          ASREQ    r7,r7,#24             ;297
000168  1affffe9          BNE      |L1.276|
00016c  ea000009          B        |L1.408|
                  |L1.368|
000170  e3550001          CMP      r5,#1                 ;308
000174  0a00000f          BEQ      |L1.440|
000178  e3550002          CMP      r5,#2                 ;324
00017c  25d60013          LDRBCS   r0,[r6,#0x13]         ;331
000180  2150000a          CMPCS    r0,r10                ;331
000184  3a000003          BCC      |L1.408|
000188  e1a01c04          LSL      r1,r4,#24             ;332
00018c  e1a01c41          ASR      r1,r1,#24             ;332
000190  e1a0a000          MOV      r10,r0                ;333
000194  e58d1008          STR      r1,[sp,#8]            ;333
                  |L1.408|
000198  e2840001          ADD      r0,r4,#1              ;291
00019c  e20040ff          AND      r4,r0,#0xff           ;291
0001a0  e354000a          CMP      r4,#0xa               ;291
0001a4  3affffd1          BCC      |L1.240|
0001a8  e59d0018          LDR      r0,[sp,#0x18]         ;342
0001ac  e3100002          TST      r0,#2                 ;342
0001b0  1a000051          BNE      |L1.764|
0001b4  ea000012          B        |L1.516|
                  |L1.440|
0001b8  e59f0144          LDR      r0,|L1.772|
0001bc  e59d100c          LDR      r1,[sp,#0xc]          ;310
0001c0  e7900101          LDR      r0,[r0,r1,LSL #2]     ;310
0001c4  e3500000          CMP      r0,#0                 ;310
0001c8  e5d60013          LDRB     r0,[r6,#0x13]         ;318
0001cc  0a000004          BEQ      |L1.484|
0001d0  e1500009          CMP      r0,r9                 ;311
0001d4  21a0bc04          LSLCS    r11,r4,#24            ;312
0001d8  21a0bc4b          ASRCS    r11,r11,#24           ;312
0001dc  21a09000          MOVCS    r9,r0                 ;313
0001e0  eaffffec          B        |L1.408|
                  |L1.484|
0001e4  e59d1004          LDR      r1,[sp,#4]            ;318
0001e8  e1500001          CMP      r0,r1                 ;318
0001ec  3affffe9          BCC      |L1.408|
0001f0  e1a01c04          LSL      r1,r4,#24             ;319
0001f4  e1a01c41          ASR      r1,r1,#24             ;319
0001f8  e58d0004          STR      r0,[sp,#4]            ;320
0001fc  e58d1000          STR      r1,[sp,#0]            ;320
000200  eaffffe4          B        |L1.408|
                  |L1.516|
000204  e357000a          CMP      r7,#0xa               ;344
000208  b20740ff          ANDLT    r4,r7,#0xff           ;360
00020c  0a000001          BEQ      |L1.536|
000210  aa000003          BGE      |L1.548|
000214  ea000019          B        |L1.640|
                  |L1.536|
000218  e59d0018          LDR      r0,[sp,#0x18]         ;344
00021c  e3100001          TST      r0,#1                 ;344
000220  0a000035          BEQ      |L1.764|
                  |L1.548|
000224  e59d0008          LDR      r0,[sp,#8]            ;364
000228  e350000a          CMP      r0,#0xa               ;364
00022c  aa00002b          BGE      |L1.736|
000230  e20040ff          AND      r4,r0,#0xff           ;366
000234  e59f00c8          LDR      r0,|L1.772|
000238  e0841104          ADD      r1,r4,r4,LSL #2       ;369
00023c  e7900101          LDR      r0,[r0,r1,LSL #2]     ;369
000240  e3500000          CMP      r0,#0                 ;369
000244  0a000004          BEQ      |L1.604|
000248  e59f2148          LDR      r2,|L1.920|
00024c  e28f30b8          ADR      r3,|L1.780|
000250  e28f1f51          ADR      r1,|L1.924|
000254  e28f0f45          ADR      r0,|L1.880|
000258  ebfffffe          BL       sysprintf
                  |L1.604|
00025c  e354000a          CMP      r4,#0xa               ;387
000260  3a000004          BCC      |L1.632|
000264  e59f2148          LDR      r2,|L1.948|
000268  e28f309c          ADR      r3,|L1.780|
00026c  e28f1f51          ADR      r1,|L1.952|
000270  e28f00f8          ADR      r0,|L1.880|
000274  ebfffffe          BL       sysprintf
                  |L1.632|
000278  e1a00004          MOV      r0,r4                 ;388
00027c  ebfffffe          BL       etharp_free_entry
                  |L1.640|
000280  e354000a          CMP      r4,#0xa               ;391
000284  3a000004          BCC      |L1.668|
000288  e59f213c          LDR      r2,|L1.972|
00028c  e28f3078          ADR      r3,|L1.780|
000290  e28f1e12          ADR      r1,|L1.952|
000294  e28f00d4          ADR      r0,|L1.880|
000298  ebfffffe          BL       sysprintf
                  |L1.668|
00029c  e59f0060          LDR      r0,|L1.772|
0002a0  e0841104          ADD      r1,r4,r4,LSL #2       ;392
0002a4  e0805101          ADD      r5,r0,r1,LSL #2       ;392
0002a8  e5d50012          LDRB     r0,[r5,#0x12]         ;392
0002ac  e3500000          CMP      r0,#0                 ;392
0002b0  0a000004          BEQ      |L1.712|
0002b4  e28f3050          ADR      r3,|L1.780|
0002b8  e3a02f62          MOV      r2,#0x188             ;392
0002bc  e28f1f43          ADR      r1,|L1.976|
0002c0  e28f00a8          ADR      r0,|L1.880|
0002c4  ebfffffe          BL       sysprintf
                  |L1.712|
0002c8  e3580000          CMP      r8,#0                 ;396
0002cc  15980000          LDRNE    r0,[r8,#0]            ;398
0002d0  15850004          STRNE    r0,[r5,#4]            ;398
0002d4  e3a00000          MOV      r0,#0                 ;400
0002d8  e5c50013          STRB     r0,[r5,#0x13]         ;400
0002dc  eaffff9a          B        |L1.332|
                  |L1.736|
0002e0  e59d0000          LDR      r0,[sp,#0]            ;371
0002e4  e350000a          CMP      r0,#0xa               ;371
0002e8  b20040ff          ANDLT    r4,r0,#0xff           ;373
0002ec  baffffda          BLT      |L1.604|
0002f0  e35b000a          CMP      r11,#0xa              ;376
0002f4  b20b40ff          ANDLT    r4,r11,#0xff          ;378
0002f8  baffffd7          BLT      |L1.604|
                  |L1.764|
0002fc  e3e00000          MVN      r0,#0                 ;383
000300  eaffff93          B        |L1.340|
                  |L1.772|
                          DCD      ||.bss||
                  |L1.776|
                          DCD      ||.constdata||+0x6
                  |L1.780|
00030c  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
000310  2d312e34
000314  2e315c73
000318  72635c6e
00031c  65746966
000320  5c657468
000324  6172702e
000328  6300    
00032a  00                DCB      0
00032b  00                DCB      0
                  |L1.812|
                          DCD      0x0000012b
                  |L1.816|
000330  73746174          DCB      "state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_"
000334  65203d3d
000338  20455448
00033c  4152505f
000340  53544154
000344  455f5045
000348  4e44494e
00034c  47207c7c
000350  20737461
000354  7465203e
000358  3d204554
00035c  48415250
000360  5f535441
000364  54455f  
000367  53544142          DCB      "STABLE",0
00036b  4c4500  
00036e  00                DCB      0
00036f  00                DCB      0
                  |L1.880|
000370  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000374  7274696f
000378  6e202225
00037c  73222066
000380  61696c65
000384  64206174
000388  206c696e
00038c  65202564
000390  20696e20
000394  25730a00
                  |L1.920|
                          DCD      0x00000171
                  |L1.924|
00039c  6172705f          DCB      "arp_table[i].q == NULL",0
0003a0  7461626c
0003a4  655b695d
0003a8  2e71203d
0003ac  3d204e55
0003b0  4c4c00  
0003b3  00                DCB      0
                  |L1.948|
                          DCD      0x00000183
                  |L1.952|
0003b8  69203c20          DCB      "i < ARP_TABLE_SIZE",0
0003bc  4152505f
0003c0  5441424c
0003c4  455f5349
0003c8  5a4500  
0003cb  00                DCB      0
                  |L1.972|
                          DCD      0x00000187
                  |L1.976|
0003d0  6172705f          DCB      "arp_table[i].state == ETHARP_STATE_EMPTY",0
0003d4  7461626c
0003d8  655b695d
0003dc  2e737461
0003e0  7465203d
0003e4  3d204554
0003e8  48415250
0003ec  5f535441
0003f0  54455f45
0003f4  4d505459
0003f8  00      
0003f9  00                DCB      0
0003fa  00                DCB      0
0003fb  00                DCB      0
                          ENDP

                  etharp_send_ip PROC
;;;414    static err_t
;;;415    etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
0003fc  e92d41f0          PUSH     {r4-r8,lr}
;;;416    {
000400  e1a05000          MOV      r5,r0
;;;417      struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
;;;418    
;;;419      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
000404  e5d00026          LDRB     r0,[r0,#0x26]
000408  e5914004          LDR      r4,[r1,#4]            ;417
00040c  e1a07003          MOV      r7,r3                 ;416
000410  e3500006          CMP      r0,#6
000414  e1a08002          MOV      r8,r2                 ;416
000418  e1a06001          MOV      r6,r1                 ;416
00041c  0a000004          BEQ      |L1.1076|
000420  e59f23b4          LDR      r2,|L1.2012|
000424  e59f13b4          LDR      r1,|L1.2016|
000428  e24f3f49          ADR      r3,|L1.780|
00042c  e24f00c4          ADR      r0,|L1.880|
000430  ebfffffe          BL       sysprintf
                  |L1.1076|
;;;420                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;421      ETHADDR32_COPY(&ethhdr->dest, dst);
000434  e3a02006          MOV      r2,#6
000438  e1a01007          MOV      r1,r7
00043c  e1a00004          MOV      r0,r4
000440  ebfffffe          BL       __aeabi_memcpy
;;;422      ETHADDR16_COPY(&ethhdr->src, src);
000444  e3a02006          MOV      r2,#6
000448  e1a01008          MOV      r1,r8
00044c  e2840006          ADD      r0,r4,#6
000450  ebfffffe          BL       __aeabi_memcpy
;;;423      ethhdr->type = PP_HTONS(ETHTYPE_IP);
000454  e3a00008          MOV      r0,#8
000458  e5c4000c          STRB     r0,[r4,#0xc]
00045c  e3a00000          MOV      r0,#0
000460  e5c4000d          STRB     r0,[r4,#0xd]
;;;424      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
;;;425      /* send the packet */
;;;426      return netif->linkoutput(netif, p);
000464  e5952018          LDR      r2,[r5,#0x18]
000468  e1a01006          MOV      r1,r6
00046c  e1a00005          MOV      r0,r5
000470  e8bd41f0          POP      {r4-r8,lr}
000474  e12fff12          BX       r2
;;;427    }
;;;428    
                          ENDP

                  etharp_update_arp_entry PROC
;;;447    static err_t
;;;448    etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
000478  e92d41f0          PUSH     {r4-r8,lr}
;;;449    {
00047c  e1a06000          MOV      r6,r0
;;;450      s8_t i;
;;;451      LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
000480  e5d00026          LDRB     r0,[r0,#0x26]
000484  e1a05003          MOV      r5,r3                 ;449
000488  e1a07002          MOV      r7,r2                 ;449
00048c  e3500006          CMP      r0,#6
000490  e1a04001          MOV      r4,r1                 ;449
000494  0a000004          BEQ      |L1.1196|
000498  e59f2344          LDR      r2,|L1.2020|
00049c  e24f3f66          ADR      r3,|L1.780|
0004a0  e28f1d0d          ADR      r1,|L1.2024|
0004a4  e24f0f4f          ADR      r0,|L1.880|
0004a8  ebfffffe          BL       sysprintf
                  |L1.1196|
;;;452      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
;;;453        ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
;;;454        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
;;;455        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
;;;456      /* non-unicast address? */
;;;457      if (ip_addr_isany(ipaddr) ||
0004ac  e3540000          CMP      r4,#0
0004b0  15940000          LDRNE    r0,[r4,#0]
0004b4  13500000          CMPNE    r0,#0
0004b8  0a000025          BEQ      |L1.1364|
;;;458          ip_addr_isbroadcast(ipaddr, netif) ||
0004bc  e1a01006          MOV      r1,r6
0004c0  ebfffffe          BL       ip4_addr_isbroadcast
0004c4  e3500000          CMP      r0,#0
0004c8  1a000021          BNE      |L1.1364|
;;;459          ip_addr_ismulticast(ipaddr)) {
0004cc  e5d40000          LDRB     r0,[r4,#0]
0004d0  e20000f0          AND      r0,r0,#0xf0
0004d4  e35000e0          CMP      r0,#0xe0
0004d8  0a00001d          BEQ      |L1.1364|
;;;460        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
;;;461        return ERR_ARG;
;;;462      }
;;;463      /* find or create ARP entry */
;;;464      i = etharp_find_entry(ipaddr, flags);
0004dc  e1a01005          MOV      r1,r5
0004e0  e1a00004          MOV      r0,r4
0004e4  ebfffffe          BL       etharp_find_entry
;;;465      /* bail out if no entry could be found */
;;;466      if (i < 0) {
0004e8  e3500000          CMP      r0,#0
;;;467        return (err_t)i;
;;;468      }
;;;469    
;;;470    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;471      if (flags & ETHARP_FLAG_STATIC_ENTRY) {
;;;472        /* record static type */
;;;473        arp_table[i].state = ETHARP_STATE_STATIC;
;;;474      } else
;;;475    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;476      {
;;;477        /* mark it stable */
;;;478        arp_table[i].state = ETHARP_STATE_STABLE;
;;;479      }
;;;480    
;;;481      /* record network interface */
;;;482      arp_table[i].netif = netif;
;;;483      /* insert in SNMP ARP index tree */
;;;484      snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
;;;485    
;;;486      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
;;;487      /* update address */
;;;488      ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
;;;489      /* reset time stamp */
;;;490      arp_table[i].ctime = 0;
;;;491      /* this is where we will send out queued packets! */
;;;492    #if ARP_QUEUEING
;;;493      while (arp_table[i].q != NULL) {
;;;494        struct pbuf *p;
;;;495        /* remember remainder of queue */
;;;496        struct etharp_q_entry *q = arp_table[i].q;
;;;497        /* pop first item off the queue */
;;;498        arp_table[i].q = q->next;
;;;499        /* get the packet pointer */
;;;500        p = q->p;
;;;501        /* now queue entry can be freed */
;;;502        memp_free(MEMP_ARP_QUEUE, q);
;;;503    #else /* ARP_QUEUEING */
;;;504      if (arp_table[i].q != NULL) {
;;;505        struct pbuf *p = arp_table[i].q;
;;;506        arp_table[i].q = NULL;
;;;507    #endif /* ARP_QUEUEING */
;;;508        /* send the queued IP packet */
;;;509        etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
;;;510        /* free the queued IP packet */
;;;511        pbuf_free(p);
;;;512      }
;;;513      return ERR_OK;
;;;514    }
0004ec  b8bd81f0          POPLT    {r4-r8,pc}
0004f0  e0805100          ADD      r5,r0,r0,LSL #2       ;478
0004f4  e51f81f8          LDR      r8,|L1.772|
0004f8  e3a01002          MOV      r1,#2                 ;478
0004fc  e0884105          ADD      r4,r8,r5,LSL #2       ;478
000500  e5c41012          STRB     r1,[r4,#0x12]         ;478
000504  e284000c          ADD      r0,r4,#0xc            ;488
000508  e3a02006          MOV      r2,#6                 ;488
00050c  e1a01007          MOV      r1,r7                 ;488
000510  e5846008          STR      r6,[r4,#8]            ;482
000514  ebfffffe          BL       __aeabi_memcpy
000518  e3a00000          MOV      r0,#0                 ;490
00051c  e5c40013          STRB     r0,[r4,#0x13]         ;490
000520  e7984105          LDR      r4,[r8,r5,LSL #2]     ;504
000524  e3540000          CMP      r4,#0                 ;504
000528  0a000007          BEQ      |L1.1356|
00052c  e7880105          STR      r0,[r8,r5,LSL #2]     ;506
000530  e1a03007          MOV      r3,r7                 ;509
000534  e2862027          ADD      r2,r6,#0x27           ;509
000538  e1a01004          MOV      r1,r4                 ;509
00053c  e1a00006          MOV      r0,r6                 ;509
000540  ebfffffe          BL       etharp_send_ip
000544  e1a00004          MOV      r0,r4                 ;511
000548  ebfffffe          BL       pbuf_free
                  |L1.1356|
00054c  e3a00000          MOV      r0,#0                 ;513
000550  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1364|
000554  e3e0000d          MVN      r0,#0xd               ;461
000558  e8bd81f0          POP      {r4-r8,pc}
;;;515    
                          ENDP

                  etharp_cleanup_netif PROC
;;;578     */
;;;579    void etharp_cleanup_netif(struct netif *netif)
00055c  e92d4070          PUSH     {r4-r6,lr}
;;;580    {
;;;581      u8_t i;
;;;582    
;;;583      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
;;;584        u8_t state = arp_table[i].state;
000560  e51f6264          LDR      r6,|L1.772|
000564  e1a05000          MOV      r5,r0                 ;580
000568  e3a04000          MOV      r4,#0                 ;583
                  |L1.1388|
00056c  e0840104          ADD      r0,r4,r4,LSL #2
000570  e0860100          ADD      r0,r6,r0,LSL #2
000574  e5d01012          LDRB     r1,[r0,#0x12]
;;;585        if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
000578  e3510000          CMP      r1,#0
00057c  0a000003          BEQ      |L1.1424|
000580  e5900008          LDR      r0,[r0,#8]
000584  e1500005          CMP      r0,r5
;;;586          etharp_free_entry(i);
000588  01a00004          MOVEQ    r0,r4
00058c  0bfffffe          BLEQ     etharp_free_entry
                  |L1.1424|
000590  e2840001          ADD      r0,r4,#1              ;583
000594  e20040ff          AND      r4,r0,#0xff           ;583
000598  e354000a          CMP      r4,#0xa               ;583
00059c  3afffff2          BCC      |L1.1388|
;;;587        }
;;;588      }
;;;589    }
0005a0  e8bd8070          POP      {r4-r6,pc}
;;;590    
                          ENDP

                  etharp_find_addr PROC
;;;602    s8_t
;;;603    etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
0005a4  e92d4070          PUSH     {r4-r6,lr}
;;;604             struct eth_addr **eth_ret, ip_addr_t **ip_ret)
;;;605    {
0005a8  e1b05002          MOVS     r5,r2
0005ac  e1a04003          MOV      r4,r3
;;;606      s8_t i;
;;;607    
;;;608      LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
0005b0  13540000          CMPNE    r4,#0
0005b4  e1a06001          MOV      r6,r1                 ;605
0005b8  1a000004          BNE      |L1.1488|
0005bc  e24f3fae          ADR      r3,|L1.780|
0005c0  e3a02e26          MOV      r2,#0x260
0005c4  e28f1f91          ADR      r1,|L1.2064|
0005c8  e24f0e26          ADR      r0,|L1.880|
0005cc  ebfffffe          BL       sysprintf
                  |L1.1488|
;;;609        eth_ret != NULL && ip_ret != NULL);
;;;610    
;;;611      LWIP_UNUSED_ARG(netif);
;;;612    
;;;613      i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
0005d0  e3a01002          MOV      r1,#2
0005d4  e1a00006          MOV      r0,r6
0005d8  ebfffffe          BL       etharp_find_entry
;;;614      if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
0005dc  e3500000          CMP      r0,#0
0005e0  ba00000a          BLT      |L1.1552|
0005e4  e51f12e8          LDR      r1,|L1.772|
0005e8  e0802100          ADD      r2,r0,r0,LSL #2
0005ec  e0811102          ADD      r1,r1,r2,LSL #2
0005f0  e5d12012          LDRB     r2,[r1,#0x12]
0005f4  e3520002          CMP      r2,#2
0005f8  3a000004          BCC      |L1.1552|
;;;615          *eth_ret = &arp_table[i].ethaddr;
0005fc  e281200c          ADD      r2,r1,#0xc
000600  e2811004          ADD      r1,r1,#4
;;;616          *ip_ret = &arp_table[i].ipaddr;
000604  e5852000          STR      r2,[r5,#0]
000608  e5841000          STR      r1,[r4,#0]
;;;617          return i;
;;;618      }
;;;619      return -1;
;;;620    }
00060c  e8bd8070          POP      {r4-r6,pc}
                  |L1.1552|
000610  e3e00000          MVN      r0,#0                 ;619
000614  e8bd8070          POP      {r4-r6,pc}
;;;621    
                          ENDP

                  etharp_arp_input PROC
;;;687    static void
;;;688    etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
000618  e92d47fc          PUSH     {r2-r10,lr}
;;;689    {
00061c  e1b05000          MOVS     r5,r0
000620  e1a09001          MOV      r9,r1
000624  e1a08002          MOV      r8,r2
000628  0a00000e          BEQ      |L1.1640|
;;;690      struct etharp_hdr *hdr;
;;;691      struct eth_hdr *ethhdr;
;;;692      /* these are aligned properly, whereas the ARP header fields might not be */
;;;693      ip_addr_t sipaddr, dipaddr;
;;;694      u8_t for_us;
;;;695    #if LWIP_AUTOIP
;;;696      const u8_t * ethdst_hwaddr;
;;;697    #endif /* LWIP_AUTOIP */
;;;698    
;;;699      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
;;;700    
;;;701      /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
;;;702         since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
;;;703      if (p->len < SIZEOF_ETHARP_PACKET) {
00062c  e1d800ba          LDRH     r0,[r8,#0xa]
000630  e350002a          CMP      r0,#0x2a
000634  3a000011          BCC      |L1.1664|
;;;704        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;705          ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
;;;706          (s16_t)SIZEOF_ETHARP_PACKET));
;;;707        ETHARP_STATS_INC(etharp.lenerr);
;;;708        ETHARP_STATS_INC(etharp.drop);
;;;709        pbuf_free(p);
;;;710        return;
;;;711      }
;;;712    
;;;713      ethhdr = (struct eth_hdr *)p->payload;
000638  e5987004          LDR      r7,[r8,#4]
;;;714      hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;715    #if ETHARP_SUPPORT_VLAN
;;;716      if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
;;;717        hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
;;;718      }
;;;719    #endif /* ETHARP_SUPPORT_VLAN */
;;;720    
;;;721      /* RFC 826 "Packet Reception": */
;;;722      if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
00063c  e5d7000f          LDRB     r0,[r7,#0xf]
000640  e5d7100e          LDRB     r1,[r7,#0xe]
000644  e287400e          ADD      r4,r7,#0xe            ;714
000648  e1810400          ORR      r0,r1,r0,LSL #8
00064c  e3500c01          CMP      r0,#0x100
;;;723          (hdr->hwlen != ETHARP_HWADDR_LEN) ||
000650  05d40004          LDRBEQ   r0,[r4,#4]
000654  03500006          CMPEQ    r0,#6
;;;724          (hdr->protolen != sizeof(ip_addr_t)) ||
000658  05d40005          LDRBEQ   r0,[r4,#5]
00065c  03500004          CMPEQ    r0,#4
000660  1a000006          BNE      |L1.1664|
000664  ea000007          B        |L1.1672|
                  |L1.1640|
000668  e59f21c4          LDR      r2,|L1.2100|
00066c  e24f3fda          ADR      r3,|L1.780|
000670  e28f1d07          ADR      r1,|L1.2104|
000674  e24f0fc3          ADR      r0,|L1.880|
000678  ebfffffe          BL       sysprintf
;;;725          (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
;;;726        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;727          ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
;;;728          hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
;;;729        ETHARP_STATS_INC(etharp.proterr);
;;;730        ETHARP_STATS_INC(etharp.drop);
;;;731        pbuf_free(p);
;;;732        return;
;;;733      }
;;;734      ETHARP_STATS_INC(etharp.recv);
;;;735    
;;;736    #if LWIP_AUTOIP
;;;737      /* We have to check if a host already has configured our random
;;;738       * created link local address and continously check if there is
;;;739       * a host with this IP-address so we can detect collisions */
;;;740      autoip_arp_reply(netif, hdr);
;;;741    #endif /* LWIP_AUTOIP */
;;;742    
;;;743      /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;744       * structure packing (not using structure copy which breaks strict-aliasing rules). */
;;;745      IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
;;;746      IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
;;;747    
;;;748      /* this interface is not configured? */
;;;749      if (ip_addr_isany(&netif->ip_addr)) {
;;;750        for_us = 0;
;;;751      } else {
;;;752        /* ARP packet directed to us? */
;;;753        for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
;;;754      }
;;;755    
;;;756      /* ARP message directed to us?
;;;757          -> add IP address in ARP cache; assume requester wants to talk to us,
;;;758             can result in directly sending the queued packets for this host.
;;;759         ARP message not directed to us?
;;;760          ->  update the source IP address in the cache, if present */
;;;761      etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
;;;762                       for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
;;;763    
;;;764      /* now act on the message itself */
;;;765      switch (hdr->opcode) {
;;;766      /* ARP request? */
;;;767      case PP_HTONS(ARP_REQUEST):
;;;768        /* ARP request. If it asked for our address, we send out a
;;;769         * reply. In any case, we time-stamp any existing ARP entry,
;;;770         * and possiby send out an IP packet that was queued on it. */
;;;771    
;;;772        LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
;;;773        /* ARP request for our address? */
;;;774        if (for_us) {
;;;775    
;;;776          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
;;;777          /* Re-use pbuf to send ARP reply.
;;;778             Since we are re-using an existing pbuf, we can't call etharp_raw since
;;;779             that would allocate a new pbuf. */
;;;780          hdr->opcode = htons(ARP_REPLY);
;;;781    
;;;782          IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
;;;783          IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
;;;784    
;;;785          LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;786                      (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;787    #if LWIP_AUTOIP
;;;788          /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;789           * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;790           * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;791          ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
;;;792    #endif /* LWIP_AUTOIP */
;;;793    
;;;794          ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
;;;795    #if LWIP_AUTOIP
;;;796          ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;797    #else  /* LWIP_AUTOIP */
;;;798          ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
;;;799    #endif /* LWIP_AUTOIP */
;;;800          ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
;;;801          ETHADDR16_COPY(&ethhdr->src, ethaddr);
;;;802    
;;;803          /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
;;;804             are already correct, we tested that before */
;;;805    
;;;806          /* return ARP reply */
;;;807          netif->linkoutput(netif, p);
;;;808        /* we are not configured? */
;;;809        } else if (ip_addr_isany(&netif->ip_addr)) {
;;;810          /* { for_us == 0 and netif->ip_addr.addr == 0 } */
;;;811          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
;;;812        /* request was not directed to us */
;;;813        } else {
;;;814          /* { for_us == 0 and netif->ip_addr.addr != 0 } */
;;;815          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
;;;816        }
;;;817        break;
;;;818      case PP_HTONS(ARP_REPLY):
;;;819        /* ARP reply. We already updated the ARP cache earlier. */
;;;820        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
;;;821    #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
;;;822        /* DHCP wants to know about ARP replies from any host with an
;;;823         * IP address also offered to us by the DHCP server. We do not
;;;824         * want to take a duplicate IP address on a single network.
;;;825         * @todo How should we handle redundant (fail-over) interfaces? */
;;;826        dhcp_arp_reply(netif, &sipaddr);
;;;827    #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
;;;828        break;
;;;829      default:
;;;830        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
;;;831        ETHARP_STATS_INC(etharp.err);
;;;832        break;
;;;833      }
;;;834      /* free ARP packet */
;;;835      pbuf_free(p);
;;;836    }
00067c  e8bd87fc          POP      {r2-r10,pc}
                  |L1.1664|
000680  e1a00002          MOV      r0,r2                 ;709
000684  ea000052          B        |L1.2004|
                  |L1.1672|
000688  e5d40003          LDRB     r0,[r4,#3]            ;725
00068c  e5d41002          LDRB     r1,[r4,#2]            ;725
000690  e1810400          ORR      r0,r1,r0,LSL #8       ;725
000694  e3500008          CMP      r0,#8                 ;725
000698  1afffff8          BNE      |L1.1664|
00069c  e3a02004          MOV      r2,#4                 ;745
0006a0  e284100e          ADD      r1,r4,#0xe            ;745
0006a4  e1a0000d          MOV      r0,sp                 ;745
0006a8  ebfffffe          BL       __aeabi_memcpy
0006ac  e3a02004          MOV      r2,#4                 ;746
0006b0  e2841018          ADD      r1,r4,#0x18           ;746
0006b4  e28d0004          ADD      r0,sp,#4              ;746
0006b8  ebfffffe          BL       __aeabi_memcpy
0006bc  e3750004          CMN      r5,#4                 ;749
0006c0  15950004          LDRNE    r0,[r5,#4]            ;749
0006c4  13500000          CMPNE    r0,#0                 ;749
0006c8  0a000003          BEQ      |L1.1756|
0006cc  e59d1004          LDR      r1,[sp,#4]            ;753
0006d0  e1510000          CMP      r1,r0                 ;753
0006d4  03a06001          MOVEQ    r6,#1                 ;753
0006d8  0a000000          BEQ      |L1.1760|
                  |L1.1756|
0006dc  e3a06000          MOV      r6,#0                 ;753
                  |L1.1760|
0006e0  e3560000          CMP      r6,#0                 ;761
0006e4  13a03001          MOVNE    r3,#1                 ;762
0006e8  03a03002          MOVEQ    r3,#2                 ;762
0006ec  e2842008          ADD      r2,r4,#8              ;762
0006f0  e1a0100d          MOV      r1,sp                 ;762
0006f4  e1a00005          MOV      r0,r5                 ;762
0006f8  ebfffffe          BL       etharp_update_arp_entry
0006fc  e5d40007          LDRB     r0,[r4,#7]            ;765
000700  e5d41006          LDRB     r1,[r4,#6]            ;765
000704  e1810400          ORR      r0,r1,r0,LSL #8       ;765
000708  e3500c01          CMP      r0,#0x100             ;765
00070c  0a000004          BEQ      |L1.1828|
000710  e3500c02          CMP      r0,#0x200             ;765
000714  01a0100d          MOVEQ    r1,sp                 ;826
000718  01a00005          MOVEQ    r0,r5                 ;826
00071c  0bfffffe          BLEQ     dhcp_arp_reply
000720  ea00002a          B        |L1.2000|
                  |L1.1828|
000724  e3560000          CMP      r6,#0                 ;774
000728  0a000028          BEQ      |L1.2000|
00072c  e3a00002          MOV      r0,#2                 ;780
000730  ebfffffe          BL       lwip_htons
000734  e5c40006          STRB     r0,[r4,#6]            ;780
000738  e1a00420          LSR      r0,r0,#8              ;780
00073c  e5c40007          STRB     r0,[r4,#7]            ;780
000740  e3a02004          MOV      r2,#4                 ;782
000744  e284100e          ADD      r1,r4,#0xe            ;782
000748  e2840018          ADD      r0,r4,#0x18           ;782
00074c  ebfffffe          BL       __aeabi_memcpy
000750  e3a02004          MOV      r2,#4                 ;783
000754  e2851004          ADD      r1,r5,#4              ;783
000758  e284000e          ADD      r0,r4,#0xe            ;783
00075c  ebfffffe          BL       __aeabi_memcpy
000760  e5d50026          LDRB     r0,[r5,#0x26]         ;785
000764  e3500006          CMP      r0,#6                 ;785
000768  0a000004          BEQ      |L1.1920|
00076c  e59f30d4          LDR      r3,|L1.2120|
000770  e59f20d4          LDR      r2,|L1.2124|
000774  e59f1064          LDR      r1,|L1.2016|
000778  e59f00d0          LDR      r0,|L1.2128|
00077c  ebfffffe          BL       sysprintf
                  |L1.1920|
000780  e3a02006          MOV      r2,#6                 ;794
000784  e2841008          ADD      r1,r4,#8              ;794
000788  e2840012          ADD      r0,r4,#0x12           ;794
00078c  ebfffffe          BL       __aeabi_memcpy
000790  e3a02006          MOV      r2,#6                 ;798
000794  e2841008          ADD      r1,r4,#8              ;798
000798  e1a00007          MOV      r0,r7                 ;798
00079c  ebfffffe          BL       __aeabi_memcpy
0007a0  e3a02006          MOV      r2,#6                 ;800
0007a4  e1a01009          MOV      r1,r9                 ;800
0007a8  e2840008          ADD      r0,r4,#8              ;800
0007ac  ebfffffe          BL       __aeabi_memcpy
0007b0  e3a02006          MOV      r2,#6                 ;801
0007b4  e1a01009          MOV      r1,r9                 ;801
0007b8  e2870006          ADD      r0,r7,#6              ;801
0007bc  ebfffffe          BL       __aeabi_memcpy
0007c0  e5952018          LDR      r2,[r5,#0x18]         ;807
0007c4  e1a01008          MOV      r1,r8                 ;807
0007c8  e1a00005          MOV      r0,r5                 ;807
0007cc  e12fff32          BLX      r2                    ;807
                  |L1.2000|
0007d0  e1a00008          MOV      r0,r8                 ;835
                  |L1.2004|
0007d4  ebfffffe          BL       pbuf_free
0007d8  e8bd87fc          POP      {r2-r10,pc}
                  |L1.2012|
                          DCD      0x000001a3
                  |L1.2016|
                          DCD      ||.conststring||
                  |L1.2020|
                          DCD      0x000001c3
                  |L1.2024|
0007e8  6e657469          DCB      "netif->hwaddr_len == ETHARP_HWADDR_LEN",0
0007ec  662d3e68
0007f0  77616464
0007f4  725f6c65
0007f8  6e203d3d
0007fc  20455448
000800  4152505f
000804  48574144
000808  44525f4c
00080c  454e00  
00080f  00                DCB      0
                  |L1.2064|
000810  6574685f          DCB      "eth_ret != NULL && ip_ret != NULL",0
000814  72657420
000818  213d204e
00081c  554c4c20
000820  26262069
000824  705f7265
000828  7420213d
00082c  204e554c
000830  4c00    
000832  00                DCB      0
000833  00                DCB      0
                  |L1.2100|
                          DCD      0x000002bb
                  |L1.2104|
000838  6e657469          DCB      "netif != NULL",0
00083c  6620213d
000840  204e554c
000844  4c00    
000846  00                DCB      0
000847  00                DCB      0
                  |L1.2120|
                          DCD      ||.text||+0x30c
                  |L1.2124|
                          DCD      0x00000311
                  |L1.2128|
                          DCD      ||.text||+0x370
                          ENDP

                  etharp_raw PROC
;;;1174   err_t
;;;1175   etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
000854  e92d5fff          PUSH     {r0-r12,lr}
;;;1176              const struct eth_addr *ethdst_addr,
;;;1177              const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
;;;1178              const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
;;;1179              const u16_t opcode)
;;;1180   {
000858  e59da044          LDR      r10,[sp,#0x44]
00085c  e59db03c          LDR      r11,[sp,#0x3c]
000860  e1b07000          MOVS     r7,r0
000864  e1a08003          MOV      r8,r3
000868  e1a09002          MOV      r9,r2
00086c  1a000004          BNE      |L1.2180|
;;;1181     struct pbuf *p;
;;;1182     err_t result = ERR_OK;
;;;1183     struct eth_hdr *ethhdr;
;;;1184     struct etharp_hdr *hdr;
;;;1185   #if LWIP_AUTOIP
;;;1186     const u8_t * ethdst_hwaddr;
;;;1187   #endif /* LWIP_AUTOIP */
;;;1188   
;;;1189     LWIP_ASSERT("netif != NULL", netif != NULL);
000870  e51f3030          LDR      r3,|L1.2120|
000874  e59f239c          LDR      r2,|L1.3096|
000878  e51f0030          LDR      r0,|L1.2128|
00087c  e24f104c          ADR      r1,|L1.2104|
000880  ebfffffe          BL       sysprintf
                  |L1.2180|
;;;1190   
;;;1191     /* allocate a pbuf for the outgoing ARP request packet */
;;;1192     p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
000884  e3a02000          MOV      r2,#0
000888  e3a0102a          MOV      r1,#0x2a
00088c  e3a00003          MOV      r0,#3
000890  ebfffffe          BL       pbuf_alloc
000894  e1b05000          MOVS     r5,r0
;;;1193     /* could allocate a pbuf for an ARP request? */
;;;1194     if (p == NULL) {
;;;1195       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;1196         ("etharp_raw: could not allocate pbuf for ARP request.\n"));
;;;1197       ETHARP_STATS_INC(etharp.memerr);
;;;1198       return ERR_MEM;
000898  03e00000          MVNEQ    r0,#0
00089c  0a000046          BEQ      |L1.2492|
;;;1199     }
;;;1200     LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
0008a0  e1d500ba          LDRH     r0,[r5,#0xa]
0008a4  e350002a          CMP      r0,#0x2a
0008a8  2a000004          BCS      |L1.2240|
0008ac  e51f306c          LDR      r3,|L1.2120|
0008b0  e51f0068          LDR      r0,|L1.2128|
0008b4  e3a02e4b          MOV      r2,#0x4b0
0008b8  e28f1fd7          ADR      r1,|L1.3100|
0008bc  ebfffffe          BL       sysprintf
                  |L1.2240|
;;;1201                 (p->len >= SIZEOF_ETHARP_PACKET));
;;;1202   
;;;1203     ethhdr = (struct eth_hdr *)p->payload;
0008c0  e5956004          LDR      r6,[r5,#4]
;;;1204     hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;1205     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
;;;1206     hdr->opcode = htons(opcode);
0008c4  e1a0000a          MOV      r0,r10
0008c8  e286400e          ADD      r4,r6,#0xe            ;1204
0008cc  ebfffffe          BL       lwip_htons
0008d0  e5c40006          STRB     r0,[r4,#6]
0008d4  e1a00420          LSR      r0,r0,#8
0008d8  e5c40007          STRB     r0,[r4,#7]
;;;1207   
;;;1208     LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
0008dc  e5d70026          LDRB     r0,[r7,#0x26]
0008e0  e3500006          CMP      r0,#6
0008e4  0a000004          BEQ      |L1.2300|
0008e8  e51f30a8          LDR      r3,|L1.2120|
0008ec  e59f235c          LDR      r2,|L1.3152|
0008f0  e51f1118          LDR      r1,|L1.2016|
0008f4  e51f00ac          LDR      r0,|L1.2128|
0008f8  ebfffffe          BL       sysprintf
                  |L1.2300|
;;;1209                 (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;1210   #if LWIP_AUTOIP
;;;1211     /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;1212      * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;1213      * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;1214     ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
;;;1215   #endif /* LWIP_AUTOIP */
;;;1216     /* Write the ARP MAC-Addresses */
;;;1217     ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
0008fc  e3a02006          MOV      r2,#6
000900  e1a01008          MOV      r1,r8
000904  e2840008          ADD      r0,r4,#8
000908  ebfffffe          BL       __aeabi_memcpy
;;;1218     ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
00090c  e3a02006          MOV      r2,#6
000910  e1a0100b          MOV      r1,r11
000914  e2840012          ADD      r0,r4,#0x12
000918  ebfffffe          BL       __aeabi_memcpy
;;;1219     /* Write the Ethernet MAC-Addresses */
;;;1220   #if LWIP_AUTOIP
;;;1221     ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;1222   #else  /* LWIP_AUTOIP */
;;;1223     ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
00091c  e3a02006          MOV      r2,#6
000920  e1a01009          MOV      r1,r9
000924  e1a00006          MOV      r0,r6
000928  ebfffffe          BL       __aeabi_memcpy
;;;1224   #endif /* LWIP_AUTOIP */
;;;1225     ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
00092c  e59d1004          LDR      r1,[sp,#4]
000930  e3a02006          MOV      r2,#6
000934  e2860006          ADD      r0,r6,#6
000938  ebfffffe          BL       __aeabi_memcpy
;;;1226     /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;1227      * structure packing. */ 
;;;1228     IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
00093c  e59d1038          LDR      r1,[sp,#0x38]
000940  e3a02004          MOV      r2,#4
000944  e284000e          ADD      r0,r4,#0xe
000948  ebfffffe          BL       __aeabi_memcpy
;;;1229     IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
00094c  e59d1040          LDR      r1,[sp,#0x40]
000950  e3a02004          MOV      r2,#4
000954  e2840018          ADD      r0,r4,#0x18
000958  ebfffffe          BL       __aeabi_memcpy
;;;1230   
;;;1231     hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
00095c  e3a00c01          MOV      r0,#0x100
000960  e5c40000          STRB     r0,[r4,#0]
000964  e1a00420          LSR      r0,r0,#8
000968  e5c40001          STRB     r0,[r4,#1]
;;;1232     hdr->proto = PP_HTONS(ETHTYPE_IP);
00096c  e3a00008          MOV      r0,#8
000970  e5c40002          STRB     r0,[r4,#2]
000974  e3a00000          MOV      r0,#0
000978  e5c40003          STRB     r0,[r4,#3]
;;;1233     /* set hwlen and protolen */
;;;1234     hdr->hwlen = ETHARP_HWADDR_LEN;
00097c  e3a00006          MOV      r0,#6
000980  e5c40004          STRB     r0,[r4,#4]
;;;1235     hdr->protolen = sizeof(ip_addr_t);
000984  e3a00004          MOV      r0,#4
000988  e5c40005          STRB     r0,[r4,#5]
;;;1236   
;;;1237     ethhdr->type = PP_HTONS(ETHTYPE_ARP);
00098c  e59f02c0          LDR      r0,|L1.3156|
;;;1238     /* send ARP query */
;;;1239     result = netif->linkoutput(netif, p);
000990  e1a01005          MOV      r1,r5
000994  e5c6000c          STRB     r0,[r6,#0xc]          ;1237
000998  e1a00420          LSR      r0,r0,#8              ;1237
00099c  e5c6000d          STRB     r0,[r6,#0xd]          ;1237
0009a0  e5972018          LDR      r2,[r7,#0x18]
0009a4  e1a00007          MOV      r0,r7
0009a8  e12fff32          BLX      r2
0009ac  e1a04000          MOV      r4,r0
;;;1240     ETHARP_STATS_INC(etharp.xmit);
;;;1241     /* free ARP query packet */
;;;1242     pbuf_free(p);
0009b0  e1a00005          MOV      r0,r5
0009b4  ebfffffe          BL       pbuf_free
;;;1243     p = NULL;
;;;1244     /* could not allocate pbuf for ARP request */
;;;1245   
;;;1246     return result;
0009b8  e1a00004          MOV      r0,r4
                  |L1.2492|
0009bc  e28dd010          ADD      sp,sp,#0x10
;;;1247   }
0009c0  e8bd9ff0          POP      {r4-r12,pc}
;;;1248   
                          ENDP

                  etharp_request PROC
;;;1258   err_t
;;;1259   etharp_request(struct netif *netif, ip_addr_t *ipaddr)
0009c4  e92d401f          PUSH     {r0-r4,lr}
;;;1260   {
;;;1261     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
;;;1262     return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
0009c8  e51f36c8          LDR      r3,|L1.776|
0009cc  e3a02001          MOV      r2,#1
0009d0  e58d3004          STR      r3,[sp,#4]
0009d4  e280c004          ADD      r12,r0,#4
0009d8  e2803027          ADD      r3,r0,#0x27
0009dc  e58d1008          STR      r1,[sp,#8]
0009e0  e58d200c          STR      r2,[sp,#0xc]
0009e4  e59f226c          LDR      r2,|L1.3160|
0009e8  e1a01003          MOV      r1,r3
0009ec  e58dc000          STR      r12,[sp,#0]
0009f0  ebfffffe          BL       etharp_raw
0009f4  e28dd010          ADD      sp,sp,#0x10
;;;1263                       (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
;;;1264                       ipaddr, ARP_REQUEST);
;;;1265   }
0009f8  e8bd8010          POP      {r4,pc}
;;;1266   #endif /* LWIP_ARP */
                          ENDP

                  etharp_output_to_arp_index PROC
;;;841    static err_t
;;;842    etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
0009fc  e92d4070          PUSH     {r4-r6,lr}
;;;843    {
000a00  e1a05000          MOV      r5,r0
;;;844      LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
000a04  e51f0708          LDR      r0,|L1.772|
000a08  e1a06001          MOV      r6,r1                 ;843
000a0c  e0821102          ADD      r1,r2,r2,LSL #2
000a10  e0804101          ADD      r4,r0,r1,LSL #2
000a14  e5d40012          LDRB     r0,[r4,#0x12]
000a18  e3500002          CMP      r0,#2
000a1c  2a000004          BCS      |L1.2612|
000a20  e51f31e0          LDR      r3,|L1.2120|
000a24  e51f01dc          LDR      r0,|L1.2128|
000a28  e3a02fd3          MOV      r2,#0x34c
000a2c  e28f1f8a          ADR      r1,|L1.3164|
000a30  ebfffffe          BL       sysprintf
                  |L1.2612|
;;;845                  arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
;;;846      /* if arp table entry is about to expire: re-request it,
;;;847         but only if its state is ETHARP_STATE_STABLE to prevent flooding the
;;;848         network with ARP requests if this address is used frequently. */
;;;849      if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
000a34  e5d40012          LDRB     r0,[r4,#0x12]
000a38  e3500002          CMP      r0,#2
000a3c  1a000008          BNE      |L1.2660|
;;;850          (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
000a40  e5d40013          LDRB     r0,[r4,#0x13]
000a44  e35000e4          CMP      r0,#0xe4
000a48  3a000005          BCC      |L1.2660|
;;;851        if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
000a4c  e2841004          ADD      r1,r4,#4
000a50  e1a00005          MOV      r0,r5
000a54  ebfffffe          BL       etharp_request
000a58  e3500000          CMP      r0,#0
;;;852          arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
000a5c  03a00003          MOVEQ    r0,#3
000a60  05c40012          STRBEQ   r0,[r4,#0x12]
                  |L1.2660|
;;;853        }
;;;854      }
;;;855      
;;;856      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
000a64  e284300c          ADD      r3,r4,#0xc
000a68  e2852027          ADD      r2,r5,#0x27
000a6c  e1a01006          MOV      r1,r6
000a70  e1a00005          MOV      r0,r5
000a74  e8bd4070          POP      {r4-r6,lr}
000a78  eafffffe          B        etharp_send_ip
;;;857        &arp_table[arp_idx].ethaddr);
;;;858    }
;;;859    
                          ENDP

                  etharp_query PROC
;;;1015   err_t
;;;1016   etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
000a7c  e92d4ff8          PUSH     {r3-r11,lr}
;;;1017   {
000a80  e1a0b000          MOV      r11,r0
;;;1018     struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
000a84  e2800027          ADD      r0,r0,#0x27
;;;1019     err_t result = ERR_MEM;
;;;1020     s8_t i; /* ARP entry index */
;;;1021   
;;;1022     /* non-unicast address? */
;;;1023     if (ip_addr_isbroadcast(ipaddr, netif) ||
000a88  e58d0000          STR      r0,[sp,#0]
000a8c  e5910000          LDR      r0,[r1,#0]
000a90  e1a0a001          MOV      r10,r1                ;1017
000a94  e1a07002          MOV      r7,r2                 ;1017
000a98  e3e04000          MVN      r4,#0                 ;1019
000a9c  e1a0100b          MOV      r1,r11
000aa0  ebfffffe          BL       ip4_addr_isbroadcast
000aa4  e3500000          CMP      r0,#0
000aa8  1a000020          BNE      |L1.2864|
;;;1024         ip_addr_ismulticast(ipaddr) ||
000aac  e59a0000          LDR      r0,[r10,#0]
000ab0  e20010f0          AND      r1,r0,#0xf0
000ab4  e35100e0          CMP      r1,#0xe0
;;;1025         ip_addr_isany(ipaddr)) {
000ab8  135a0000          CMPNE    r10,#0
000abc  13500000          CMPNE    r0,#0
000ac0  0a00001a          BEQ      |L1.2864|
;;;1026       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
;;;1027       return ERR_ARG;
;;;1028     }
;;;1029   
;;;1030     /* find entry in ARP cache, ask to create entry if queueing packet */
;;;1031     i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
000ac4  e3a01001          MOV      r1,#1
000ac8  e1a0000a          MOV      r0,r10
000acc  ebfffffe          BL       etharp_find_entry
000ad0  e1b05000          MOVS     r5,r0
;;;1032   
;;;1033     /* could not find or create entry? */
;;;1034     if (i < 0) {
000ad4  4a000016          BMI      |L1.2868|
;;;1035       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
;;;1036       if (q) {
;;;1037         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
;;;1038         ETHARP_STATS_INC(etharp.memerr);
;;;1039       }
;;;1040       return (err_t)i;
;;;1041     }
;;;1042   
;;;1043     /* mark a fresh entry as pending (we just sent a request) */
;;;1044     if (arp_table[i].state == ETHARP_STATE_EMPTY) {
000ad8  e51f97dc          LDR      r9,|L1.772|
000adc  e0858105          ADD      r8,r5,r5,LSL #2
000ae0  e0896108          ADD      r6,r9,r8,LSL #2
000ae4  e5d60012          LDRB     r0,[r6,#0x12]
000ae8  e3500000          CMP      r0,#0
;;;1045       arp_table[i].state = ETHARP_STATE_PENDING;
000aec  03a00001          MOVEQ    r0,#1
000af0  05c60012          STRBEQ   r0,[r6,#0x12]
;;;1046     }
;;;1047   
;;;1048     /* { i is either a STABLE or (new or existing) PENDING entry } */
;;;1049     LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
000af4  13500001          CMPNE    r0,#1
000af8  0a00000e          BEQ      |L1.2872|
000afc  e3500002          CMP      r0,#2
000b00  2a000007          BCS      |L1.2852|
000b04  e51f32c4          LDR      r3,|L1.2120|
000b08  e59f217c          LDR      r2,|L1.3212|
000b0c  e51f02c4          LDR      r0,|L1.2128|
000b10  e28f1f5e          ADR      r1,|L1.3216|
000b14  ebfffffe          BL       sysprintf
;;;1050     ((arp_table[i].state == ETHARP_STATE_PENDING) ||
;;;1051      (arp_table[i].state >= ETHARP_STATE_STABLE)));
;;;1052   
;;;1053     /* do we have a pending entry? or an implicit query request? */
;;;1054     if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
000b18  e5d60012          LDRB     r0,[r6,#0x12]
000b1c  e3500001          CMP      r0,#1
000b20  0a000004          BEQ      |L1.2872|
                  |L1.2852|
000b24  e3570000          CMP      r7,#0
000b28  1a000008          BNE      |L1.2896|
000b2c  ea000001          B        |L1.2872|
                  |L1.2864|
000b30  e3e0000d          MVN      r0,#0xd               ;1027
                  |L1.2868|
;;;1055       /* try to resolve it; send out ARP request */
;;;1056       result = etharp_request(netif, ipaddr);
;;;1057       if (result != ERR_OK) {
;;;1058         /* ARP request couldn't be sent */
;;;1059         /* We don't re-send arp request in etharp_tmr, but we still queue packets,
;;;1060            since this failure could be temporary, and the next packet calling
;;;1061            etharp_query again could lead to sending the queued packets. */
;;;1062       }
;;;1063       if (q == NULL) {
;;;1064         return result;
;;;1065       }
;;;1066     }
;;;1067   
;;;1068     /* packet given? */
;;;1069     LWIP_ASSERT("q != NULL", q != NULL);
;;;1070     /* stable entry? */
;;;1071     if (arp_table[i].state >= ETHARP_STATE_STABLE) {
;;;1072       /* we have a valid IP->Ethernet address mapping */
;;;1073       ETHARP_SET_HINT(netif, i);
;;;1074       /* send the packet */
;;;1075       result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
;;;1076     /* pending entry? (either just created or already pending */
;;;1077     } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;1078       /* entry is still pending, queue the given packet 'q' */
;;;1079       struct pbuf *p;
;;;1080       int copy_needed = 0;
;;;1081       /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
;;;1082        * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
;;;1083        * PBUF_ROMs can be left as they are, since ROM must not get changed. */
;;;1084       p = q;
;;;1085       while (p) {
;;;1086         LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
;;;1087         if(p->type != PBUF_ROM) {
;;;1088           copy_needed = 1;
;;;1089           break;
;;;1090         }
;;;1091         p = p->next;
;;;1092       }
;;;1093       if(copy_needed) {
;;;1094         /* copy the whole packet into new pbufs */
;;;1095         p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;1096         if(p != NULL) {
;;;1097           if (pbuf_copy(p, q) != ERR_OK) {
;;;1098             pbuf_free(p);
;;;1099             p = NULL;
;;;1100           }
;;;1101         }
;;;1102       } else {
;;;1103         /* referencing the old pbuf is enough */
;;;1104         p = q;
;;;1105         pbuf_ref(p);
;;;1106       }
;;;1107       /* packet could be taken over? */
;;;1108       if (p != NULL) {
;;;1109         /* queue packet ... */
;;;1110   #if ARP_QUEUEING
;;;1111         struct etharp_q_entry *new_entry;
;;;1112         /* allocate a new arp queue entry */
;;;1113         new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
;;;1114         if (new_entry != NULL) {
;;;1115           new_entry->next = 0;
;;;1116           new_entry->p = p;
;;;1117           if(arp_table[i].q != NULL) {
;;;1118             /* queue was already existent, append the new entry to the end */
;;;1119             struct etharp_q_entry *r;
;;;1120             r = arp_table[i].q;
;;;1121             while (r->next != NULL) {
;;;1122               r = r->next;
;;;1123             }
;;;1124             r->next = new_entry;
;;;1125           } else {
;;;1126             /* queue did not exist, first item in queue */
;;;1127             arp_table[i].q = new_entry;
;;;1128           }
;;;1129           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1130           result = ERR_OK;
;;;1131         } else {
;;;1132           /* the pool MEMP_ARP_QUEUE is empty */
;;;1133           pbuf_free(p);
;;;1134           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1135           result = ERR_MEM;
;;;1136         }
;;;1137   #else /* ARP_QUEUEING */
;;;1138         /* always queue one packet per ARP request only, freeing a previously queued packet */
;;;1139         if (arp_table[i].q != NULL) {
;;;1140           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1141           pbuf_free(arp_table[i].q);
;;;1142         }
;;;1143         arp_table[i].q = p;
;;;1144         result = ERR_OK;
;;;1145         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1146   #endif /* ARP_QUEUEING */
;;;1147       } else {
;;;1148         ETHARP_STATS_INC(etharp.memerr);
;;;1149         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1150         result = ERR_MEM;
;;;1151       }
;;;1152     }
;;;1153     return result;
;;;1154   }
000b34  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.2872|
000b38  e1a0100a          MOV      r1,r10                ;1056
000b3c  e1a0000b          MOV      r0,r11                ;1056
000b40  ebfffffe          BL       etharp_request
000b44  e3570000          CMP      r7,#0                 ;1063
000b48  e1a04000          MOV      r4,r0                 ;1056
000b4c  08bd8ff8          POPEQ    {r3-r11,pc}
                  |L1.2896|
000b50  e5d60012          LDRB     r0,[r6,#0x12]         ;1071
000b54  e3500002          CMP      r0,#2                 ;1071
000b58  3a000008          BCC      |L1.2944|
000b5c  e59f0154          LDR      r0,|L1.3256|
000b60  e286300c          ADD      r3,r6,#0xc            ;1075
000b64  e5c05000          STRB     r5,[r0,#0]            ;1073  ; etharp_cached_entry
000b68  e59d2000          LDR      r2,[sp,#0]            ;1075
000b6c  e1a01007          MOV      r1,r7                 ;1075
000b70  e1a0000b          MOV      r0,r11                ;1075
000b74  ebfffffe          BL       etharp_send_ip
000b78  e1a04000          MOV      r4,r0                 ;1075
000b7c  ea000062          B        |L1.3340|
                  |L1.2944|
000b80  e3500001          CMP      r0,#1                 ;1077
000b84  059f6130          LDREQ    r6,|L1.3260|
000b88  03a05000          MOVEQ    r5,#0                 ;1080
000b8c  01a04007          MOVEQ    r4,r7                 ;1084
000b90  1a00005d          BNE      |L1.3340|
                  |L1.2964|
000b94  e1d400ba          LDRH     r0,[r4,#0xa]          ;1086
000b98  e1d410b8          LDRH     r1,[r4,#8]            ;1086
000b9c  e1500001          CMP      r0,r1                 ;1086
000ba0  1a000007          BNE      |L1.3012|
000ba4  e5940000          LDR      r0,[r4,#0]            ;1086
000ba8  e3500000          CMP      r0,#0                 ;1086
000bac  0a000004          BEQ      |L1.3012|
000bb0  e51f3370          LDR      r3,|L1.2120|
000bb4  e51f036c          LDR      r0,|L1.2128|
000bb8  e1a02006          MOV      r2,r6                 ;1086
000bbc  e28f10fc          ADR      r1,|L1.3264|
000bc0  ebfffffe          BL       sysprintf
                  |L1.3012|
000bc4  e5d4000c          LDRB     r0,[r4,#0xc]          ;1087
000bc8  e3500001          CMP      r0,#1                 ;1087
000bcc  1a000004          BNE      |L1.3044|
000bd0  e5944000          LDR      r4,[r4,#0]            ;1091
000bd4  e3540000          CMP      r4,#0                 ;1085
000bd8  1affffed          BNE      |L1.2964|
000bdc  e3550000          CMP      r5,#0                 ;1093
000be0  0a00003d          BEQ      |L1.3292|
                  |L1.3044|
000be4  e1d410b8          LDRH     r1,[r4,#8]            ;1095
000be8  e3a02000          MOV      r2,#0                 ;1095
000bec  e3a00003          MOV      r0,#3                 ;1095
000bf0  ebfffffe          BL       pbuf_alloc
000bf4  e1b05000          MOVS     r5,r0                 ;1095
000bf8  0a000042          BEQ      |L1.3336|
000bfc  e1a01007          MOV      r1,r7                 ;1097
000c00  ebfffffe          BL       pbuf_copy
000c04  e3500000          CMP      r0,#0                 ;1097
000c08  0a000038          BEQ      |L1.3312|
000c0c  e1a00005          MOV      r0,r5                 ;1098
000c10  ebfffffe          BL       pbuf_free
000c14  ea00003b          B        |L1.3336|
                  |L1.3096|
                          DCD      0x000004a5
                  |L1.3100|
000c1c  63686563          DCB      "check that first pbuf can hold struct etharp_hdr",0
000c20  6b207468
000c24  61742066
000c28  69727374
000c2c  20706275
000c30  66206361
000c34  6e20686f
000c38  6c642073
000c3c  74727563
000c40  74206574
000c44  68617270
000c48  5f686472
000c4c  00      
000c4d  00                DCB      0
000c4e  00                DCB      0
000c4f  00                DCB      0
                  |L1.3152|
                          DCD      0x000004b8
                  |L1.3156|
                          DCD      0x00000608
                  |L1.3160|
                          DCD      ||.constdata||
                  |L1.3164|
000c5c  6172705f          DCB      "arp_table[arp_idx].state >= ETHARP_STATE_STABLE",0
000c60  7461626c
000c64  655b6172
000c68  705f6964
000c6c  785d2e73
000c70  74617465
000c74  203e3d20
000c78  45544841
000c7c  52505f53
000c80  54415445
000c84  5f535441
000c88  424c4500
                  |L1.3212|
                          DCD      0x00000419
                  |L1.3216|
000c90  6172705f          DCB      "arp_table[i].state == PENDING or STABLE",0
000c94  7461626c
000c98  655b695d
000c9c  2e737461
000ca0  7465203d
000ca4  3d205045
000ca8  4e44494e
000cac  47206f72
000cb0  20535441
000cb4  424c4500
                  |L1.3256|
                          DCD      ||.data||
                  |L1.3260|
                          DCD      0x0000043e
                  |L1.3264|
000cc0  6e6f2070          DCB      "no packet queues allowed!",0
000cc4  61636b65
000cc8  74207175
000ccc  65756573
000cd0  20616c6c
000cd4  6f776564
000cd8  2100    
000cda  00                DCB      0
000cdb  00                DCB      0
                  |L1.3292|
000cdc  e1a05007          MOV      r5,r7                 ;1104
000ce0  e1a00007          MOV      r0,r7                 ;1105
000ce4  ebfffffe          BL       pbuf_ref
000ce8  e3550000          CMP      r5,#0                 ;1108
000cec  0a000005          BEQ      |L1.3336|
                  |L1.3312|
000cf0  e7990108          LDR      r0,[r9,r8,LSL #2]     ;1139
000cf4  e3500000          CMP      r0,#0                 ;1139
000cf8  1bfffffe          BLNE     pbuf_free
000cfc  e3a04000          MOV      r4,#0                 ;1144
000d00  e7895108          STR      r5,[r9,r8,LSL #2]     ;1143
000d04  ea000000          B        |L1.3340|
                  |L1.3336|
000d08  e3e04000          MVN      r4,#0                 ;1150
                  |L1.3340|
000d0c  e1a00004          MOV      r0,r4                 ;1153
000d10  e8bd8ff8          POP      {r3-r11,pc}
;;;1155   
                          ENDP

                  etharp_output PROC
;;;878    err_t
;;;879    etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
000d14  e92d407c          PUSH     {r2-r6,lr}
;;;880    {
000d18  e1b05000          MOVS     r5,r0
000d1c  e1a04002          MOV      r4,r2
000d20  e1a06001          MOV      r6,r1
000d24  1a000004          BNE      |L1.3388|
;;;881      struct eth_addr *dest;
;;;882      struct eth_addr mcastaddr;
;;;883      ip_addr_t *dst_addr = ipaddr;
;;;884    
;;;885      LWIP_ASSERT("netif != NULL", netif != NULL);
000d28  e51f34e8          LDR      r3,|L1.2120|
000d2c  e59f22a8          LDR      r2,|L1.4060|
000d30  e59f12a8          LDR      r1,|L1.4064|
000d34  e51f04ec          LDR      r0,|L1.2128|
000d38  ebfffffe          BL       sysprintf
                  |L1.3388|
;;;886      LWIP_ASSERT("q != NULL", q != NULL);
000d3c  e3560000          CMP      r6,#0
000d40  1a000004          BNE      |L1.3416|
000d44  e51f3504          LDR      r3,|L1.2120|
000d48  e59f2294          LDR      r2,|L1.4068|
000d4c  e51f0504          LDR      r0,|L1.2128|
000d50  e28f1e29          ADR      r1,|L1.4072|
000d54  ebfffffe          BL       sysprintf
                  |L1.3416|
;;;887      LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
000d58  e3540000          CMP      r4,#0
000d5c  1a000004          BNE      |L1.3444|
000d60  e51f3520          LDR      r3,|L1.2120|
000d64  e59f2288          LDR      r2,|L1.4084|
000d68  e51f0520          LDR      r0,|L1.2128|
000d6c  e28f1fa1          ADR      r1,|L1.4088|
000d70  ebfffffe          BL       sysprintf
                  |L1.3444|
;;;888    
;;;889      /* make room for Ethernet header - should not fail */
;;;890      if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
000d74  e3a0100e          MOV      r1,#0xe
000d78  e1a00006          MOV      r0,r6
000d7c  ebfffffe          BL       pbuf_header
000d80  e3500000          CMP      r0,#0
;;;891        /* bail out */
;;;892        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;893          ("etharp_output: could not allocate room for header.\n"));
;;;894        LINK_STATS_INC(link.lenerr);
;;;895        return ERR_BUF;
000d84  13e00001          MVNNE    r0,#1
000d88  1a000037          BNE      |L1.3692|
;;;896      }
;;;897    
;;;898      /* Determine on destination hardware address. Broadcasts and multicasts
;;;899       * are special, other IP addresses are looked up in the ARP table. */
;;;900    
;;;901      /* broadcast destination IP address? */
;;;902      if (ip_addr_isbroadcast(ipaddr, netif)) {
000d8c  e5940000          LDR      r0,[r4,#0]
000d90  e1a01005          MOV      r1,r5
000d94  ebfffffe          BL       ip4_addr_isbroadcast
000d98  e3500000          CMP      r0,#0
;;;903        /* broadcast on Ethernet also */
;;;904        dest = (struct eth_addr *)&ethbroadcast;
000d9c  151f314c          LDRNE    r3,|L1.3160|
000da0  1a00002d          BNE      |L1.3676|
;;;905      /* multicast destination IP address? */
;;;906      } else if (ip_addr_ismulticast(ipaddr)) {
000da4  e5940000          LDR      r0,[r4,#0]
000da8  e20010f0          AND      r1,r0,#0xf0
000dac  e35100e0          CMP      r1,#0xe0
000db0  0a00001b          BEQ      |L1.3620|
;;;907        /* Hash IP multicast address to MAC address.*/
;;;908        mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
;;;909        mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
;;;910        mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
;;;911        mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
;;;912        mcastaddr.addr[4] = ip4_addr3(ipaddr);
;;;913        mcastaddr.addr[5] = ip4_addr4(ipaddr);
;;;914        /* destination Ethernet address is multicast */
;;;915        dest = &mcastaddr;
;;;916      /* unicast destination IP address? */
;;;917      } else {
;;;918        s8_t i;
;;;919        /* outside local network? if so, this can neither be a global broadcast nor
;;;920           a subnet broadcast. */
;;;921        if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
000db4  e5951008          LDR      r1,[r5,#8]
000db8  e5953004          LDR      r3,[r5,#4]
000dbc  e0002001          AND      r2,r0,r1
000dc0  e0011003          AND      r1,r1,r3
000dc4  e1520001          CMP      r2,r1
;;;922            !ip_addr_islinklocal(ipaddr)) {
000dc8  159f1238          LDRNE    r1,|L1.4104|
000dcc  11510800          CMPNE    r1,r0,LSL #16
000dd0  0a000005          BEQ      |L1.3564|
;;;923    #if LWIP_AUTOIP
;;;924          struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
;;;925            sizeof(struct eth_hdr));
;;;926          /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
;;;927             a link-local source address must always be "directly to its destination
;;;928             on the same physical link. The host MUST NOT send the packet to any
;;;929             router for forwarding". */
;;;930          if (!ip_addr_islinklocal(&iphdr->src))
;;;931    #endif /* LWIP_AUTOIP */
;;;932          {
;;;933            /* interface has default gateway? */
;;;934            if (!ip_addr_isany(&netif->gw)) {
000dd4  e375000c          CMN      r5,#0xc
000dd8  1595000c          LDRNE    r0,[r5,#0xc]
000ddc  13500000          CMPNE    r0,#0
;;;935              /* send to hardware address of default gateway IP address */
;;;936              dst_addr = &(netif->gw);
;;;937            /* no default gateway available */
;;;938            } else {
;;;939              /* no route to destination error (default gateway missing) */
;;;940              return ERR_RTE;
000de0  03e00003          MVNEQ    r0,#3
000de4  1285400c          ADDNE    r4,r5,#0xc            ;936
000de8  0a00001f          BEQ      |L1.3692|
                  |L1.3564|
;;;941            }
;;;942          }
;;;943        }
;;;944    #if LWIP_NETIF_HWADDRHINT
;;;945        if (netif->addr_hint != NULL) {
;;;946          /* per-pcb cached entry was given */
;;;947          u8_t etharp_cached_entry = *(netif->addr_hint);
;;;948          if (etharp_cached_entry < ARP_TABLE_SIZE) {
;;;949    #endif /* LWIP_NETIF_HWADDRHINT */
;;;950            if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
000dec  e51f313c          LDR      r3,|L1.3256|
000df0  e51f2af4          LDR      r2,|L1.772|
000df4  e5d30000          LDRB     r0,[r3,#0]  ; etharp_cached_entry
000df8  e0801100          ADD      r1,r0,r0,LSL #2
000dfc  e0821101          ADD      r1,r2,r1,LSL #2
000e00  e5d1c012          LDRB     r12,[r1,#0x12]
000e04  e35c0002          CMP      r12,#2
;;;951                (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
000e08  2594c000          LDRCS    r12,[r4,#0]
000e0c  25911004          LDRCS    r1,[r1,#4]
000e10  215c0001          CMPCS    r12,r1
;;;952              /* the per-pcb-cached entry is stable and the right one! */
;;;953              ETHARP_STATS_INC(etharp.cachehit);
;;;954              return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
;;;955            }
;;;956    #if LWIP_NETIF_HWADDRHINT
;;;957          }
;;;958        }
;;;959    #endif /* LWIP_NETIF_HWADDRHINT */
;;;960    
;;;961        /* find stable entry: do this here since this is a critical path for
;;;962           throughput and etharp_find_entry() is kind of slow */
;;;963        for (i = 0; i < ARP_TABLE_SIZE; i++) {
000e14  13a00000          MOVNE    r0,#0
000e18  01a02000          MOVEQ    r2,r0
000e1c  0a00001d          BEQ      |L1.3736|
000e20  ea000012          B        |L1.3696|
                  |L1.3620|
000e24  e3a00001          MOV      r0,#1                 ;908
000e28  e5cd0000          STRB     r0,[sp,#0]            ;908
000e2c  e3a00000          MOV      r0,#0                 ;909
000e30  e5cd0001          STRB     r0,[sp,#1]            ;909
000e34  e3a0005e          MOV      r0,#0x5e              ;910
000e38  e5cd0002          STRB     r0,[sp,#2]            ;910
000e3c  e5d40001          LDRB     r0,[r4,#1]            ;911
000e40  e1a0300d          MOV      r3,sp                 ;915
000e44  e200007f          AND      r0,r0,#0x7f           ;911
000e48  e5cd0003          STRB     r0,[sp,#3]            ;911
000e4c  e5d40002          LDRB     r0,[r4,#2]            ;912
000e50  e5cd0004          STRB     r0,[sp,#4]            ;912
000e54  e5d40003          LDRB     r0,[r4,#3]            ;913
000e58  e5cd0005          STRB     r0,[sp,#5]            ;913
                  |L1.3676|
;;;964          if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
;;;965              (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
;;;966            /* found an existing, stable entry */
;;;967            ETHARP_SET_HINT(netif, i);
;;;968            return etharp_output_to_arp_index(netif, q, i);
;;;969          }
;;;970        }
;;;971        /* no stable entry found, use the (slower) query function:
;;;972           queue on destination Ethernet address belonging to ipaddr */
;;;973        return etharp_query(netif, dst_addr, q);
;;;974      }
;;;975    
;;;976      /* continuation for multicast/broadcast destinations */
;;;977      /* obtain source Ethernet address of the given interface */
;;;978      /* send packet directly on the link */
;;;979      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
000e5c  e2852027          ADD      r2,r5,#0x27
000e60  e1a01006          MOV      r1,r6
000e64  e1a00005          MOV      r0,r5
000e68  ebfffffe          BL       etharp_send_ip
                  |L1.3692|
;;;980    }
000e6c  e8bd807c          POP      {r2-r6,pc}
                  |L1.3696|
000e70  e0801100          ADD      r1,r0,r0,LSL #2       ;964
000e74  e0821101          ADD      r1,r2,r1,LSL #2       ;964
000e78  e5d1c012          LDRB     r12,[r1,#0x12]        ;964
000e7c  e35c0002          CMP      r12,#2                ;964
000e80  2594c000          LDRCS    r12,[r4,#0]           ;965
000e84  25911004          LDRCS    r1,[r1,#4]            ;965
000e88  215c0001          CMPCS    r12,r1                ;965
000e8c  020020ff          ANDEQ    r2,r0,#0xff           ;967
000e90  05c32000          STRBEQ   r2,[r3,#0]            ;967  ; etharp_cached_entry
000e94  1a000003          BNE      |L1.3752|
                  |L1.3736|
000e98  e1a01006          MOV      r1,r6                 ;968
000e9c  e1a00005          MOV      r0,r5                 ;968
000ea0  ebfffffe          BL       etharp_output_to_arp_index
000ea4  e8bd807c          POP      {r2-r6,pc}
                  |L1.3752|
000ea8  e2800001          ADD      r0,r0,#1              ;968
000eac  e1a00c00          LSL      r0,r0,#24             ;963
000eb0  e1a00c40          ASR      r0,r0,#24             ;963
000eb4  e350000a          CMP      r0,#0xa               ;963
000eb8  baffffec          BLT      |L1.3696|
000ebc  e1a02006          MOV      r2,r6                 ;973
000ec0  e1a01004          MOV      r1,r4                 ;973
000ec4  e1a00005          MOV      r0,r5                 ;973
000ec8  ebfffffe          BL       etharp_query
000ecc  e8bd807c          POP      {r2-r6,pc}
;;;981    
                          ENDP

                  ethernet_input PROC
;;;1276   err_t
;;;1277   ethernet_input(struct pbuf *p, struct netif *netif)
000ed0  e92d4070          PUSH     {r4-r6,lr}
;;;1278   {
000ed4  e1a04000          MOV      r4,r0
;;;1279     struct eth_hdr* ethhdr;
;;;1280     u16_t type;
;;;1281   #if LWIP_ARP || ETHARP_SUPPORT_VLAN
;;;1282     s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
;;;1283   #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
;;;1284   
;;;1285     if (p->len <= SIZEOF_ETH_HDR) {
000ed8  e1d000ba          LDRH     r0,[r0,#0xa]
000edc  e1a05001          MOV      r5,r1                 ;1278
000ee0  e350000e          CMP      r0,#0xe
000ee4  9a000039          BLS      |L1.4048|
;;;1286       /* a packet with only an ethernet header (or less) is not valid for us */
;;;1287       ETHARP_STATS_INC(etharp.proterr);
;;;1288       ETHARP_STATS_INC(etharp.drop);
;;;1289       goto free_and_return;
;;;1290     }
;;;1291   
;;;1292     /* points to packet payload, which starts with an Ethernet header */
;;;1293     ethhdr = (struct eth_hdr *)p->payload;
000ee8  e5940004          LDR      r0,[r4,#4]
;;;1294     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
;;;1295       ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", type:%"X16_F"\n",
;;;1296        (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
;;;1297        (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
;;;1298        (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
;;;1299        (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
;;;1300        (unsigned)htons(ethhdr->type)));
;;;1301   
;;;1302     type = ethhdr->type;
000eec  e5d0100d          LDRB     r1,[r0,#0xd]
000ef0  e5d0200c          LDRB     r2,[r0,#0xc]
000ef4  e1826401          ORR      r6,r2,r1,LSL #8
;;;1303   #if ETHARP_SUPPORT_VLAN
;;;1304     if (type == PP_HTONS(ETHTYPE_VLAN)) {
;;;1305       struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
;;;1306       if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
;;;1307         /* a packet with only an ethernet/vlan header (or less) is not valid for us */
;;;1308         ETHARP_STATS_INC(etharp.proterr);
;;;1309         ETHARP_STATS_INC(etharp.drop);
;;;1310         goto free_and_return;
;;;1311       }
;;;1312   #if defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
;;;1313   #ifdef ETHARP_VLAN_CHECK_FN
;;;1314       if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
;;;1315   #elif defined(ETHARP_VLAN_CHECK)
;;;1316       if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
;;;1317   #endif
;;;1318         /* silently ignore this packet: not for our VLAN */
;;;1319         pbuf_free(p);
;;;1320         return ERR_OK;
;;;1321       }
;;;1322   #endif /* defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
;;;1323       type = vlan->tpid;
;;;1324       ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
;;;1325     }
;;;1326   #endif /* ETHARP_SUPPORT_VLAN */
;;;1327   
;;;1328   #if LWIP_ARP_FILTER_NETIF
;;;1329     netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
;;;1330   #endif /* LWIP_ARP_FILTER_NETIF*/
;;;1331   
;;;1332     if (ethhdr->dest.addr[0] & 1) {
000ef8  e5d01000          LDRB     r1,[r0,#0]
000efc  e3110001          TST      r1,#1
000f00  0a000011          BEQ      |L1.3916|
;;;1333       /* this might be a multicast or broadcast packet */
;;;1334       if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
000f04  e3510001          CMP      r1,#1
000f08  0a000007          BEQ      |L1.3884|
;;;1335         if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
;;;1336             (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
;;;1337           /* mark the pbuf as link-layer multicast */
;;;1338           p->flags |= PBUF_FLAG_LLMCAST;
;;;1339         }
;;;1340       } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
000f0c  e51f12bc          LDR      r1,|L1.3160|
000f10  e3a02006          MOV      r2,#6
000f14  ebfffffe          BL       memcmp
000f18  e3500000          CMP      r0,#0
;;;1341         /* mark the pbuf as link-layer broadcast */
;;;1342         p->flags |= PBUF_FLAG_LLBCAST;
000f1c  05d4000d          LDRBEQ   r0,[r4,#0xd]
000f20  03800008          ORREQ    r0,r0,#8
000f24  0a000007          BEQ      |L1.3912|
000f28  ea000007          B        |L1.3916|
                  |L1.3884|
000f2c  e5d01001          LDRB     r1,[r0,#1]            ;1335
000f30  e3510000          CMP      r1,#0                 ;1335
000f34  05d00002          LDRBEQ   r0,[r0,#2]            ;1336
000f38  0350005e          CMPEQ    r0,#0x5e              ;1336
000f3c  05d4000d          LDRBEQ   r0,[r4,#0xd]          ;1338
000f40  03800010          ORREQ    r0,r0,#0x10           ;1338
000f44  1a000000          BNE      |L1.3916|
                  |L1.3912|
000f48  e5c4000d          STRB     r0,[r4,#0xd]
                  |L1.3916|
;;;1343       }
;;;1344     }
;;;1345   
;;;1346     switch (type) {
000f4c  e3560008          CMP      r6,#8
000f50  0a000003          BEQ      |L1.3940|
000f54  e2460b01          SUB      r0,r6,#0x400
000f58  e2500f82          SUBS     r0,r0,#0x208
000f5c  0a000012          BEQ      |L1.4012|
000f60  ea00001a          B        |L1.4048|
                  |L1.3940|
;;;1347   #if LWIP_ARP
;;;1348       /* IP packet? */
;;;1349       case PP_HTONS(ETHTYPE_IP):
;;;1350         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
000f64  e5d5002d          LDRB     r0,[r5,#0x2d]
000f68  e3100020          TST      r0,#0x20
000f6c  0a000017          BEQ      |L1.4048|
;;;1351           goto free_and_return;
;;;1352         }
;;;1353   #if ETHARP_TRUST_IP_MAC
;;;1354         /* update ARP table */
;;;1355         etharp_ip_input(netif, p);
;;;1356   #endif /* ETHARP_TRUST_IP_MAC */
;;;1357         /* skip Ethernet header */
;;;1358         if(pbuf_header(p, -ip_hdr_offset)) {
000f70  e3e0100d          MVN      r1,#0xd
000f74  e1a00004          MOV      r0,r4
000f78  ebfffffe          BL       pbuf_header
000f7c  e3500000          CMP      r0,#0
000f80  0a000005          BEQ      |L1.3996|
;;;1359           LWIP_ASSERT("Can't move over header in packet", 0);
000f84  e51f3744          LDR      r3,|L1.2120|
000f88  e59f207c          LDR      r2,|L1.4108|
000f8c  e51f0744          LDR      r0,|L1.2128|
000f90  e28f1078          ADR      r1,|L1.4112|
000f94  ebfffffe          BL       sysprintf
;;;1360           goto free_and_return;
000f98  ea00000c          B        |L1.4048|
                  |L1.3996|
;;;1361         } else {
;;;1362           /* pass to IP layer */
;;;1363           ip_input(p, netif);
000f9c  e1a01005          MOV      r1,r5
000fa0  e1a00004          MOV      r0,r4
000fa4  ebfffffe          BL       ip_input
000fa8  ea000006          B        |L1.4040|
                  |L1.4012|
;;;1364         }
;;;1365         break;
;;;1366         
;;;1367       case PP_HTONS(ETHTYPE_ARP):
;;;1368         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
000fac  e5d5002d          LDRB     r0,[r5,#0x2d]
000fb0  e3100020          TST      r0,#0x20
000fb4  0a000005          BEQ      |L1.4048|
;;;1369           goto free_and_return;
;;;1370         }
;;;1371         /* pass p to ARP module */
;;;1372         etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
000fb8  e1a02004          MOV      r2,r4
000fbc  e2851027          ADD      r1,r5,#0x27
000fc0  e1a00005          MOV      r0,r5
000fc4  ebfffffe          BL       etharp_arp_input
                  |L1.4040|
;;;1373         break;
;;;1374   #endif /* LWIP_ARP */
;;;1375   #if PPPOE_SUPPORT
;;;1376       case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
;;;1377         pppoe_disc_input(netif, p);
;;;1378         break;
;;;1379   
;;;1380       case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
;;;1381         pppoe_data_input(netif, p);
;;;1382         break;
;;;1383   #endif /* PPPOE_SUPPORT */
;;;1384   
;;;1385       default:
;;;1386         ETHARP_STATS_INC(etharp.proterr);
;;;1387         ETHARP_STATS_INC(etharp.drop);
;;;1388         goto free_and_return;
;;;1389     }
;;;1390   
;;;1391     /* This means the pbuf is freed or consumed,
;;;1392        so the caller doesn't have to free it again */
;;;1393     return ERR_OK;
000fc8  e3a00000          MOV      r0,#0
;;;1394   
;;;1395   free_and_return:
;;;1396     pbuf_free(p);
;;;1397     return ERR_OK;
;;;1398   }
000fcc  e8bd8070          POP      {r4-r6,pc}
                  |L1.4048|
000fd0  e1a00004          MOV      r0,r4                 ;1396
000fd4  ebfffffe          BL       pbuf_free
000fd8  eafffffa          B        |L1.4040|
                  |L1.4060|
                          DCD      0x00000375
                  |L1.4064|
                          DCD      ||.text||+0x838
                  |L1.4068|
                          DCD      0x00000376
                  |L1.4072|
000fe8  7120213d          DCB      "q != NULL",0
000fec  204e554c
000ff0  4c00    
000ff2  00                DCB      0
000ff3  00                DCB      0
                  |L1.4084|
                          DCD      0x00000377
                  |L1.4088|
000ff8  69706164          DCB      "ipaddr != NULL",0
000ffc  64722021
001000  3d204e55
001004  4c4c00  
001007  00                DCB      0
                  |L1.4104|
                          DCD      0xfea90000
                  |L1.4108|
                          DCD      0x0000054f
                  |L1.4112|
001010  43616e27          DCB      "Can't move over header in packet",0
001014  74206d6f
001018  7665206f
00101c  76657220
001020  68656164
001024  65722069
001028  6e207061
00102c  636b6574
001030  00      
001031  00                DCB      0
001032  00                DCB      0
001033  00                DCB      0
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  arp_table
                          %        200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ethbroadcast
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff
                  ethzero
000006  0000              DCB      0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  6e657469          DCB      "netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN"
000004  662d3e68
000008  77616464
00000c  725f6c65
000010  6e206d75
000014  73742062
000018  65207468
00001c  65207361
000020  6d652061
000024  73204554
000028  48415250
00002c  5f485741
000030  4444525f
000034  4c454e  
000037  20666f72          DCB      " for etharp!",0
00003b  20657468
00003f  61727021
000043  00      

                          AREA ||.data||, DATA, ALIGN=0

                  etharp_cached_entry
000000  00                DCB      0x00
