; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\etharp.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\etharp.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\etharp.crf lwip-1.4.1\src\netif\etharp.c]
                          ARM

                          AREA ||i.etharp_arp_input||, CODE, READONLY, ALIGN=2

                  etharp_arp_input PROC
;;;687    static void
;;;688    etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;689    {
000004  e1a05000          MOV      r5,r0
000008  e1a09001          MOV      r9,r1
00000c  e1a06002          MOV      r6,r2
;;;690      struct etharp_hdr *hdr;
;;;691      struct eth_hdr *ethhdr;
;;;692      /* these are aligned properly, whereas the ARP header fields might not be */
;;;693      ip_addr_t sipaddr, dipaddr;
;;;694      u8_t for_us;
;;;695    #if LWIP_AUTOIP
;;;696      const u8_t * ethdst_hwaddr;
;;;697    #endif /* LWIP_AUTOIP */
;;;698    
;;;699      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
000010  e1a00000          MOV      r0,r0
000014  e3550000          CMP      r5,#0
000018  1a000007          BNE      |L1.60|
00001c  e1a00000          MOV      r0,r0
000020  e28f3f8a          ADR      r3,|L1.592|
000024  e59f2244          LDR      r2,|L1.624|
000028  e28f1f91          ADR      r1,|L1.628|
00002c  e28f0e25          ADR      r0,|L1.644|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L1.56|
;;;700    
;;;701      /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
;;;702         since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
;;;703      if (p->len < SIZEOF_ETHARP_PACKET) {
;;;704        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;705          ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
;;;706          (s16_t)SIZEOF_ETHARP_PACKET));
;;;707        ETHARP_STATS_INC(etharp.lenerr);
;;;708        ETHARP_STATS_INC(etharp.drop);
;;;709        pbuf_free(p);
;;;710        return;
;;;711      }
;;;712    
;;;713      ethhdr = (struct eth_hdr *)p->payload;
;;;714      hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;715    #if ETHARP_SUPPORT_VLAN
;;;716      if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
;;;717        hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
;;;718      }
;;;719    #endif /* ETHARP_SUPPORT_VLAN */
;;;720    
;;;721      /* RFC 826 "Packet Reception": */
;;;722      if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
;;;723          (hdr->hwlen != ETHARP_HWADDR_LEN) ||
;;;724          (hdr->protolen != sizeof(ip_addr_t)) ||
;;;725          (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
;;;726        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;727          ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
;;;728          hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
;;;729        ETHARP_STATS_INC(etharp.proterr);
;;;730        ETHARP_STATS_INC(etharp.drop);
;;;731        pbuf_free(p);
;;;732        return;
;;;733      }
;;;734      ETHARP_STATS_INC(etharp.recv);
;;;735    
;;;736    #if LWIP_AUTOIP
;;;737      /* We have to check if a host already has configured our random
;;;738       * created link local address and continously check if there is
;;;739       * a host with this IP-address so we can detect collisions */
;;;740      autoip_arp_reply(netif, hdr);
;;;741    #endif /* LWIP_AUTOIP */
;;;742    
;;;743      /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;744       * structure packing (not using structure copy which breaks strict-aliasing rules). */
;;;745      IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
;;;746      IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
;;;747    
;;;748      /* this interface is not configured? */
;;;749      if (ip_addr_isany(&netif->ip_addr)) {
;;;750        for_us = 0;
;;;751      } else {
;;;752        /* ARP packet directed to us? */
;;;753        for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
;;;754      }
;;;755    
;;;756      /* ARP message directed to us?
;;;757          -> add IP address in ARP cache; assume requester wants to talk to us,
;;;758             can result in directly sending the queued packets for this host.
;;;759         ARP message not directed to us?
;;;760          ->  update the source IP address in the cache, if present */
;;;761      etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
;;;762                       for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
;;;763    
;;;764      /* now act on the message itself */
;;;765      switch (hdr->opcode) {
;;;766      /* ARP request? */
;;;767      case PP_HTONS(ARP_REQUEST):
;;;768        /* ARP request. If it asked for our address, we send out a
;;;769         * reply. In any case, we time-stamp any existing ARP entry,
;;;770         * and possiby send out an IP packet that was queued on it. */
;;;771    
;;;772        LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
;;;773        /* ARP request for our address? */
;;;774        if (for_us) {
;;;775    
;;;776          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
;;;777          /* Re-use pbuf to send ARP reply.
;;;778             Since we are re-using an existing pbuf, we can't call etharp_raw since
;;;779             that would allocate a new pbuf. */
;;;780          hdr->opcode = htons(ARP_REPLY);
;;;781    
;;;782          IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
;;;783          IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
;;;784    
;;;785          LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;786                      (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;787    #if LWIP_AUTOIP
;;;788          /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;789           * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;790           * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;791          ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
;;;792    #endif /* LWIP_AUTOIP */
;;;793    
;;;794          ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
;;;795    #if LWIP_AUTOIP
;;;796          ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;797    #else  /* LWIP_AUTOIP */
;;;798          ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
;;;799    #endif /* LWIP_AUTOIP */
;;;800          ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
;;;801          ETHADDR16_COPY(&ethhdr->src, ethaddr);
;;;802    
;;;803          /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
;;;804             are already correct, we tested that before */
;;;805    
;;;806          /* return ARP reply */
;;;807          netif->linkoutput(netif, p);
;;;808        /* we are not configured? */
;;;809        } else if (ip_addr_isany(&netif->ip_addr)) {
;;;810          /* { for_us == 0 and netif->ip_addr.addr == 0 } */
;;;811          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
;;;812        /* request was not directed to us */
;;;813        } else {
;;;814          /* { for_us == 0 and netif->ip_addr.addr != 0 } */
;;;815          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
;;;816        }
;;;817        break;
;;;818      case PP_HTONS(ARP_REPLY):
;;;819        /* ARP reply. We already updated the ARP cache earlier. */
;;;820        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
;;;821    #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
;;;822        /* DHCP wants to know about ARP replies from any host with an
;;;823         * IP address also offered to us by the DHCP server. We do not
;;;824         * want to take a duplicate IP address on a single network.
;;;825         * @todo How should we handle redundant (fail-over) interfaces? */
;;;826        dhcp_arp_reply(netif, &sipaddr);
;;;827    #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
;;;828        break;
;;;829      default:
;;;830        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
;;;831        ETHARP_STATS_INC(etharp.err);
;;;832        break;
;;;833      }
;;;834      /* free ARP packet */
;;;835      pbuf_free(p);
;;;836    }
000038  e8bd87fc          POP      {r2-r10,pc}
                  |L1.60|
00003c  e1a00000          MOV      r0,r0                 ;699
000040  e1d600ba          LDRH     r0,[r6,#0xa]          ;703
000044  e350002a          CMP      r0,#0x2a              ;703
000048  aa000002          BGE      |L1.88|
00004c  e1a00006          MOV      r0,r6                 ;709
000050  ebfffffe          BL       pbuf_free
000054  eafffff7          B        |L1.56|
                  |L1.88|
000058  e5967004          LDR      r7,[r6,#4]            ;713
00005c  e287400e          ADD      r4,r7,#0xe            ;714
000060  e5d40001          LDRB     r0,[r4,#1]            ;722
000064  e5d41000          LDRB     r1,[r4,#0]            ;722
000068  e1810400          ORR      r0,r1,r0,LSL #8       ;722
00006c  e3500c01          CMP      r0,#0x100             ;722
000070  1a00000a          BNE      |L1.160|
000074  e5d40004          LDRB     r0,[r4,#4]            ;723
000078  e3500006          CMP      r0,#6                 ;723
00007c  1a000007          BNE      |L1.160|
000080  e5d40005          LDRB     r0,[r4,#5]            ;724
000084  e3500004          CMP      r0,#4                 ;724
000088  1a000004          BNE      |L1.160|
00008c  e5d40003          LDRB     r0,[r4,#3]            ;725
000090  e5d41002          LDRB     r1,[r4,#2]            ;725
000094  e1810400          ORR      r0,r1,r0,LSL #8       ;725
000098  e3500008          CMP      r0,#8                 ;725
00009c  0a000002          BEQ      |L1.172|
                  |L1.160|
0000a0  e1a00006          MOV      r0,r6                 ;731
0000a4  ebfffffe          BL       pbuf_free
0000a8  eaffffe2          B        |L1.56|
                  |L1.172|
0000ac  e3a02004          MOV      r2,#4                 ;745
0000b0  e284100e          ADD      r1,r4,#0xe            ;745
0000b4  e28d0004          ADD      r0,sp,#4              ;745
0000b8  ebfffffe          BL       __aeabi_memcpy
0000bc  e3a02004          MOV      r2,#4                 ;746
0000c0  e2841018          ADD      r1,r4,#0x18           ;746
0000c4  e1a0000d          MOV      r0,sp                 ;746
0000c8  ebfffffe          BL       __aeabi_memcpy
0000cc  e2850004          ADD      r0,r5,#4              ;749
0000d0  e3500000          CMP      r0,#0                 ;749
0000d4  0a000002          BEQ      |L1.228|
0000d8  e5950004          LDR      r0,[r5,#4]            ;749
0000dc  e3500000          CMP      r0,#0                 ;749
0000e0  1a000001          BNE      |L1.236|
                  |L1.228|
0000e4  e3a08000          MOV      r8,#0                 ;750
0000e8  ea000007          B        |L1.268|
                  |L1.236|
0000ec  e59d0000          LDR      r0,[sp,#0]            ;753
0000f0  e5951004          LDR      r1,[r5,#4]            ;753
0000f4  e1500001          CMP      r0,r1                 ;753
0000f8  1a000001          BNE      |L1.260|
0000fc  e3a00001          MOV      r0,#1                 ;753
000100  ea000000          B        |L1.264|
                  |L1.260|
000104  e3a00000          MOV      r0,#0                 ;753
                  |L1.264|
000108  e1a08000          MOV      r8,r0                 ;753
                  |L1.268|
00010c  e3580000          CMP      r8,#0                 ;761
000110  0a000001          BEQ      |L1.284|
000114  e3a00001          MOV      r0,#1                 ;762
000118  ea000000          B        |L1.288|
                  |L1.284|
00011c  e3a00002          MOV      r0,#2                 ;762
                  |L1.288|
000120  e1a03000          MOV      r3,r0                 ;762
000124  e2842008          ADD      r2,r4,#8              ;762
000128  e28d1004          ADD      r1,sp,#4              ;762
00012c  e1a00005          MOV      r0,r5                 ;762
000130  ebfffffe          BL       etharp_update_arp_entry
000134  e5d40007          LDRB     r0,[r4,#7]            ;765
000138  e5d41006          LDRB     r1,[r4,#6]            ;765
00013c  e1810400          ORR      r0,r1,r0,LSL #8       ;765
000140  e3500c01          CMP      r0,#0x100             ;765
000144  0a000002          BEQ      |L1.340|
000148  e3500c02          CMP      r0,#0x200             ;765
00014c  1a000038          BNE      |L1.564|
000150  ea000032          B        |L1.544|
                  |L1.340|
000154  e1a00000          MOV      r0,r0                 ;767
000158  e3580000          CMP      r8,#0                 ;774
00015c  0a00002d          BEQ      |L1.536|
000160  e3a00002          MOV      r0,#2                 ;780
000164  ebfffffe          BL       lwip_htons
000168  e5c40006          STRB     r0,[r4,#6]            ;780
00016c  e1a00420          LSR      r0,r0,#8              ;780
000170  e5c40007          STRB     r0,[r4,#7]            ;780
000174  e3a02004          MOV      r2,#4                 ;782
000178  e284100e          ADD      r1,r4,#0xe            ;782
00017c  e2840018          ADD      r0,r4,#0x18           ;782
000180  ebfffffe          BL       __aeabi_memcpy
000184  e3a02004          MOV      r2,#4                 ;783
000188  e2851004          ADD      r1,r5,#4              ;783
00018c  e284000e          ADD      r0,r4,#0xe            ;783
000190  ebfffffe          BL       __aeabi_memcpy
000194  e1a00000          MOV      r0,r0                 ;785
000198  e5d50026          LDRB     r0,[r5,#0x26]         ;785
00019c  e3500006          CMP      r0,#6                 ;785
0001a0  0a000006          BEQ      |L1.448|
0001a4  e1a00000          MOV      r0,r0                 ;785
0001a8  e28f30a0          ADR      r3,|L1.592|
0001ac  e59f20f8          LDR      r2,|L1.684|
0001b0  e59f10f8          LDR      r1,|L1.688|
0001b4  e28f00c8          ADR      r0,|L1.644|
0001b8  ebfffffe          BL       sysprintf
0001bc  e1a00000          MOV      r0,r0                 ;785
                  |L1.448|
0001c0  e1a00000          MOV      r0,r0                 ;785
0001c4  e3a02006          MOV      r2,#6                 ;794
0001c8  e2841008          ADD      r1,r4,#8              ;794
0001cc  e2840012          ADD      r0,r4,#0x12           ;794
0001d0  ebfffffe          BL       __aeabi_memcpy
0001d4  e3a02006          MOV      r2,#6                 ;798
0001d8  e2841008          ADD      r1,r4,#8              ;798
0001dc  e1a00007          MOV      r0,r7                 ;798
0001e0  ebfffffe          BL       __aeabi_memcpy
0001e4  e3a02006          MOV      r2,#6                 ;800
0001e8  e1a01009          MOV      r1,r9                 ;800
0001ec  e2840008          ADD      r0,r4,#8              ;800
0001f0  ebfffffe          BL       __aeabi_memcpy
0001f4  e3a02006          MOV      r2,#6                 ;801
0001f8  e1a01009          MOV      r1,r9                 ;801
0001fc  e2870006          ADD      r0,r7,#6              ;801
000200  ebfffffe          BL       __aeabi_memcpy
000204  e1a01006          MOV      r1,r6                 ;807
000208  e5952018          LDR      r2,[r5,#0x18]         ;807
00020c  e1a00005          MOV      r0,r5                 ;807
000210  e12fff32          BLX      r2                    ;807
000214  ea000000          B        |L1.540|
                  |L1.536|
000218  e1a00000          MOV      r0,r0                 ;809
                  |L1.540|
00021c  ea000006          B        |L1.572|
                  |L1.544|
000220  e1a00000          MOV      r0,r0                 ;818
000224  e28d1004          ADD      r1,sp,#4              ;826
000228  e1a00005          MOV      r0,r5                 ;826
00022c  ebfffffe          BL       dhcp_arp_reply
000230  ea000001          B        |L1.572|
                  |L1.564|
000234  e1a00000          MOV      r0,r0                 ;829
000238  e1a00000          MOV      r0,r0                 ;832
                  |L1.572|
00023c  e1a00000          MOV      r0,r0                 ;817
000240  e1a00006          MOV      r0,r6                 ;835
000244  ebfffffe          BL       pbuf_free
000248  e1a00000          MOV      r0,r0
00024c  eaffff79          B        |L1.56|
                  |L1.592|
000250  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
000254  2d312e34
000258  2e315c73
00025c  72635c6e
000260  65746966
000264  5c657468
000268  6172702e
00026c  6300    
00026e  00                DCB      0
00026f  00                DCB      0
                  |L1.624|
                          DCD      0x000002bb
                  |L1.628|
000274  6e657469          DCB      "netif != NULL",0
000278  6620213d
00027c  204e554c
000280  4c00    
000282  00                DCB      0
000283  00                DCB      0
                  |L1.644|
000284  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000288  7274696f
00028c  6e202225
000290  73222066
000294  61696c65
000298  64206174
00029c  206c696e
0002a0  65202564
0002a4  20696e20
0002a8  25730a00
                  |L1.684|
                          DCD      0x00000311
                  |L1.688|
                          DCD      ||.conststring||
                          ENDP


                          AREA ||i.etharp_cleanup_netif||, CODE, READONLY, ALIGN=2

                  etharp_cleanup_netif PROC
;;;578     */
;;;579    void etharp_cleanup_netif(struct netif *netif)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;580    {
000004  e1a05000          MOV      r5,r0
;;;581      u8_t i;
;;;582    
;;;583      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
000008  e3a04000          MOV      r4,#0
00000c  ea00000e          B        |L2.76|
                  |L2.16|
;;;584        u8_t state = arp_table[i].state;
000010  e0840104          ADD      r0,r4,r4,LSL #2
000014  e59f103c          LDR      r1,|L2.88|
000018  e0810100          ADD      r0,r1,r0,LSL #2
00001c  e5d06012          LDRB     r6,[r0,#0x12]
;;;585        if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
000020  e3560000          CMP      r6,#0
000024  0a000006          BEQ      |L2.68|
000028  e0840104          ADD      r0,r4,r4,LSL #2
00002c  e0810100          ADD      r0,r1,r0,LSL #2
000030  e5900008          LDR      r0,[r0,#8]
000034  e1500005          CMP      r0,r5
000038  1a000001          BNE      |L2.68|
;;;586          etharp_free_entry(i);
00003c  e1a00004          MOV      r0,r4
000040  ebfffffe          BL       etharp_free_entry
                  |L2.68|
000044  e2840001          ADD      r0,r4,#1              ;583
000048  e20040ff          AND      r4,r0,#0xff           ;583
                  |L2.76|
00004c  e354000a          CMP      r4,#0xa               ;583
000050  baffffee          BLT      |L2.16|
;;;587        }
;;;588      }
;;;589    }
000054  e8bd8070          POP      {r4-r6,pc}
;;;590    
                          ENDP

                  |L2.88|
                          DCD      arp_table

                          AREA ||i.etharp_find_addr||, CODE, READONLY, ALIGN=2

                  etharp_find_addr PROC
;;;602    s8_t
;;;603    etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;604             struct eth_addr **eth_ret, ip_addr_t **ip_ret)
;;;605    {
000004  e1a08000          MOV      r8,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a05002          MOV      r5,r2
000010  e1a06003          MOV      r6,r3
;;;606      s8_t i;
;;;607    
;;;608      LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
000014  e1a00000          MOV      r0,r0
000018  e3550000          CMP      r5,#0
00001c  0a000001          BEQ      |L3.40|
000020  e3560000          CMP      r6,#0
000024  1a000006          BNE      |L3.68|
                  |L3.40|
000028  e1a00000          MOV      r0,r0
00002c  e28f3074          ADR      r3,|L3.168|
000030  e3a02e26          MOV      r2,#0x260
000034  e28f108c          ADR      r1,|L3.200|
000038  e28f00ac          ADR      r0,|L3.236|
00003c  ebfffffe          BL       sysprintf
000040  e1a00000          MOV      r0,r0
                  |L3.68|
000044  e1a00000          MOV      r0,r0
;;;609        eth_ret != NULL && ip_ret != NULL);
;;;610    
;;;611      LWIP_UNUSED_ARG(netif);
;;;612    
;;;613      i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
000048  e3a01002          MOV      r1,#2
00004c  e1a00007          MOV      r0,r7
000050  ebfffffe          BL       etharp_find_entry
000054  e1a04000          MOV      r4,r0
;;;614      if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
000058  e3540000          CMP      r4,#0
00005c  ba00000f          BLT      |L3.160|
000060  e0840104          ADD      r0,r4,r4,LSL #2
000064  e59f10a8          LDR      r1,|L3.276|
000068  e0810100          ADD      r0,r1,r0,LSL #2
00006c  e5d00012          LDRB     r0,[r0,#0x12]
000070  e3500002          CMP      r0,#2
000074  ba000009          BLT      |L3.160|
;;;615          *eth_ret = &arp_table[i].ethaddr;
000078  e0840104          ADD      r0,r4,r4,LSL #2
00007c  e0810100          ADD      r0,r1,r0,LSL #2
000080  e280000c          ADD      r0,r0,#0xc
000084  e5850000          STR      r0,[r5,#0]
;;;616          *ip_ret = &arp_table[i].ipaddr;
000088  e0840104          ADD      r0,r4,r4,LSL #2
00008c  e0810100          ADD      r0,r1,r0,LSL #2
000090  e2800004          ADD      r0,r0,#4
000094  e5860000          STR      r0,[r6,#0]
;;;617          return i;
000098  e1a00004          MOV      r0,r4
                  |L3.156|
;;;618      }
;;;619      return -1;
;;;620    }
00009c  e8bd81f0          POP      {r4-r8,pc}
                  |L3.160|
0000a0  e3e00000          MVN      r0,#0                 ;619
0000a4  eafffffc          B        |L3.156|
;;;621    
                          ENDP

                  |L3.168|
0000a8  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
0000ac  2d312e34
0000b0  2e315c73
0000b4  72635c6e
0000b8  65746966
0000bc  5c657468
0000c0  6172702e
0000c4  6300    
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L3.200|
0000c8  6574685f          DCB      "eth_ret != NULL && ip_ret != NULL",0
0000cc  72657420
0000d0  213d204e
0000d4  554c4c20
0000d8  26262069
0000dc  705f7265
0000e0  7420213d
0000e4  204e554c
0000e8  4c00    
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L3.236|
0000ec  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f0  7274696f
0000f4  6e202225
0000f8  73222066
0000fc  61696c65
000100  64206174
000104  206c696e
000108  65202564
00010c  20696e20
000110  25730a00
                  |L3.276|
                          DCD      arp_table

                          AREA ||i.etharp_find_entry||, CODE, READONLY, ALIGN=2

                  etharp_find_entry PROC
;;;265    static s8_t
;;;266    etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;267    {
000004  e1a06000          MOV      r6,r0
000008  e1a08001          MOV      r8,r1
;;;268      s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
00000c  e3a0900a          MOV      r9,#0xa
000010  e3a0a00a          MOV      r10,#0xa
;;;269      s8_t empty = ARP_TABLE_SIZE;
000014  e3a0700a          MOV      r7,#0xa
;;;270      u8_t i = 0, age_pending = 0, age_stable = 0;
000018  e3a04000          MOV      r4,#0
00001c  e3a00000          MOV      r0,#0
000020  e58d0008          STR      r0,[sp,#8]
000024  e58d0004          STR      r0,[sp,#4]
;;;271      /* oldest entry with packets on queue */
;;;272      s8_t old_queue = ARP_TABLE_SIZE;
000028  e3a0b00a          MOV      r11,#0xa
;;;273      /* its age */
;;;274      u8_t age_queue = 0;
00002c  e58d0000          STR      r0,[sp,#0]
;;;275    
;;;276      /**
;;;277       * a) do a search through the cache, remember candidates
;;;278       * b) select candidate entry
;;;279       * c) create new entry
;;;280       */
;;;281    
;;;282      /* a) in a single search sweep, do all of this
;;;283       * 1) remember the first empty entry (if any)
;;;284       * 2) remember the oldest stable entry (if any)
;;;285       * 3) remember the oldest pending entry without queued packets (if any)
;;;286       * 4) remember the oldest pending entry with queued packets (if any)
;;;287       * 5) search for a matching IP entry, either pending or stable
;;;288       *    until 5 matches, or all entries are searched for.
;;;289       */
;;;290    
;;;291      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
000030  e1a00000          MOV      r0,r0
000034  ea00005b          B        |L4.424|
                  |L4.56|
;;;292        u8_t state = arp_table[i].state;
000038  e0840104          ADD      r0,r4,r4,LSL #2
00003c  e59f12e8          LDR      r1,|L4.812|
000040  e0810100          ADD      r0,r1,r0,LSL #2
000044  e5d05012          LDRB     r5,[r0,#0x12]
;;;293        /* no empty entry found yet and now we do find one? */
;;;294        if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
000048  e357000a          CMP      r7,#0xa
00004c  1a000004          BNE      |L4.100|
000050  e3550000          CMP      r5,#0
000054  1a000002          BNE      |L4.100|
;;;295          LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
;;;296          /* remember first empty entry */
;;;297          empty = i;
000058  e1a00c04          LSL      r0,r4,#24
00005c  e1a07c40          ASR      r7,r0,#24
000060  ea00004e          B        |L4.416|
                  |L4.100|
;;;298        } else if (state != ETHARP_STATE_EMPTY) {
000064  e3550000          CMP      r5,#0
000068  0a00004c          BEQ      |L4.416|
;;;299          LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
00006c  e1a00000          MOV      r0,r0
000070  e3550001          CMP      r5,#1
000074  0a000008          BEQ      |L4.156|
000078  e3550002          CMP      r5,#2
00007c  aa000006          BGE      |L4.156|
000080  e1a00000          MOV      r0,r0
000084  e28f3fa9          ADR      r3,|L4.816|
000088  e59f22c0          LDR      r2,|L4.848|
00008c  e28f1d0b          ADR      r1,|L4.852|
000090  e28f0fbf          ADR      r0,|L4.916|
000094  ebfffffe          BL       sysprintf
000098  e1a00000          MOV      r0,r0
                  |L4.156|
00009c  e1a00000          MOV      r0,r0
;;;300            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
;;;301          /* if given, does IP address match IP address in ARP entry? */
;;;302          if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
0000a0  e3560000          CMP      r6,#0
0000a4  0a000009          BEQ      |L4.208|
0000a8  e0841104          ADD      r1,r4,r4,LSL #2
0000ac  e59f2278          LDR      r2,|L4.812|
0000b0  e0821101          ADD      r1,r2,r1,LSL #2
0000b4  e5960000          LDR      r0,[r6,#0]
0000b8  e5911004          LDR      r1,[r1,#4]
0000bc  e1500001          CMP      r0,r1
0000c0  1a000002          BNE      |L4.208|
;;;303            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
;;;304            /* found exact IP address match, simply bail out */
;;;305            return i;
0000c4  e1a00c04          LSL      r0,r4,#24
0000c8  e1a00c40          ASR      r0,r0,#24
                  |L4.204|
;;;306          }
;;;307          /* pending entry? */
;;;308          if (state == ETHARP_STATE_PENDING) {
;;;309            /* pending with queued packets? */
;;;310            if (arp_table[i].q != NULL) {
;;;311              if (arp_table[i].ctime >= age_queue) {
;;;312                old_queue = i;
;;;313                age_queue = arp_table[i].ctime;
;;;314              }
;;;315            } else
;;;316            /* pending without queued packets? */
;;;317            {
;;;318              if (arp_table[i].ctime >= age_pending) {
;;;319                old_pending = i;
;;;320                age_pending = arp_table[i].ctime;
;;;321              }
;;;322            }
;;;323          /* stable entry? */
;;;324          } else if (state >= ETHARP_STATE_STABLE) {
;;;325    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;326            /* don't record old_stable for static entries since they never expire */
;;;327            if (state < ETHARP_STATE_STATIC)
;;;328    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;329            {
;;;330              /* remember entry with oldest stable entry in oldest, its age in maxtime */
;;;331              if (arp_table[i].ctime >= age_stable) {
;;;332                old_stable = i;
;;;333                age_stable = arp_table[i].ctime;
;;;334              }
;;;335            }
;;;336          }
;;;337        }
;;;338      }
;;;339      /* { we have no match } => try to create a new entry */
;;;340       
;;;341      /* don't create new entry, only search? */
;;;342      if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
;;;343          /* or no empty entry found and not allowed to recycle? */
;;;344          ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
;;;345        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
;;;346        return (s8_t)ERR_MEM;
;;;347      }
;;;348      
;;;349      /* b) choose the least destructive entry to recycle:
;;;350       * 1) empty entry
;;;351       * 2) oldest stable entry
;;;352       * 3) oldest pending entry without queued packets
;;;353       * 4) oldest pending entry with queued packets
;;;354       * 
;;;355       * { ETHARP_FLAG_TRY_HARD is set at this point }
;;;356       */ 
;;;357    
;;;358      /* 1) empty entry available? */
;;;359      if (empty < ARP_TABLE_SIZE) {
;;;360        i = empty;
;;;361        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
;;;362      } else {
;;;363        /* 2) found recyclable stable entry? */
;;;364        if (old_stable < ARP_TABLE_SIZE) {
;;;365          /* recycle oldest stable*/
;;;366          i = old_stable;
;;;367          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
;;;368          /* no queued packets should exist on stable entries */
;;;369          LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
;;;370        /* 3) found recyclable pending entry without queued packets? */
;;;371        } else if (old_pending < ARP_TABLE_SIZE) {
;;;372          /* recycle oldest pending */
;;;373          i = old_pending;
;;;374          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
;;;375        /* 4) found recyclable pending entry with queued packets? */
;;;376        } else if (old_queue < ARP_TABLE_SIZE) {
;;;377          /* recycle oldest pending (queued packets are free in etharp_free_entry) */
;;;378          i = old_queue;
;;;379          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;380          /* no empty or recyclable entries found */
;;;381        } else {
;;;382          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
;;;383          return (s8_t)ERR_MEM;
;;;384        }
;;;385    
;;;386        /* { empty or recyclable entry found } */
;;;387        LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;388        etharp_free_entry(i);
;;;389      }
;;;390    
;;;391      LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;392      LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
;;;393        arp_table[i].state == ETHARP_STATE_EMPTY);
;;;394    
;;;395      /* IP address given? */
;;;396      if (ipaddr != NULL) {
;;;397        /* set IP address */
;;;398        ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
;;;399      }
;;;400      arp_table[i].ctime = 0;
;;;401      return (err_t)i;
;;;402    }
0000cc  e8bd8ffe          POP      {r1-r11,pc}
                  |L4.208|
0000d0  e3550001          CMP      r5,#1                 ;308
0000d4  1a000021          BNE      |L4.352|
0000d8  e0840104          ADD      r0,r4,r4,LSL #2       ;310
0000dc  e59f1248          LDR      r1,|L4.812|
0000e0  e7910100          LDR      r0,[r1,r0,LSL #2]     ;310
0000e4  e3500000          CMP      r0,#0                 ;310
0000e8  0a00000d          BEQ      |L4.292|
0000ec  e0840104          ADD      r0,r4,r4,LSL #2       ;311
0000f0  e0810100          ADD      r0,r1,r0,LSL #2       ;311
0000f4  e5d01013          LDRB     r1,[r0,#0x13]         ;311
0000f8  e59d0000          LDR      r0,[sp,#0]            ;311
0000fc  e1510000          CMP      r1,r0                 ;311
000100  ba000026          BLT      |L4.416|
000104  e1a00c04          LSL      r0,r4,#24             ;312
000108  e1a0bc40          ASR      r11,r0,#24            ;312
00010c  e0840104          ADD      r0,r4,r4,LSL #2       ;313
000110  e59f1214          LDR      r1,|L4.812|
000114  e0810100          ADD      r0,r1,r0,LSL #2       ;313
000118  e5d00013          LDRB     r0,[r0,#0x13]         ;313
00011c  e58d0000          STR      r0,[sp,#0]            ;313
000120  ea00001e          B        |L4.416|
                  |L4.292|
000124  e0840104          ADD      r0,r4,r4,LSL #2       ;318
000128  e59f11fc          LDR      r1,|L4.812|
00012c  e0810100          ADD      r0,r1,r0,LSL #2       ;318
000130  e5d01013          LDRB     r1,[r0,#0x13]         ;318
000134  e59d0008          LDR      r0,[sp,#8]            ;318
000138  e1510000          CMP      r1,r0                 ;318
00013c  ba000017          BLT      |L4.416|
000140  e1a00c04          LSL      r0,r4,#24             ;319
000144  e1a09c40          ASR      r9,r0,#24             ;319
000148  e0840104          ADD      r0,r4,r4,LSL #2       ;320
00014c  e59f11d8          LDR      r1,|L4.812|
000150  e0810100          ADD      r0,r1,r0,LSL #2       ;320
000154  e5d00013          LDRB     r0,[r0,#0x13]         ;320
000158  e58d0008          STR      r0,[sp,#8]            ;320
00015c  ea00000f          B        |L4.416|
                  |L4.352|
000160  e3550002          CMP      r5,#2                 ;324
000164  ba00000d          BLT      |L4.416|
000168  e0840104          ADD      r0,r4,r4,LSL #2       ;331
00016c  e59f11b8          LDR      r1,|L4.812|
000170  e0810100          ADD      r0,r1,r0,LSL #2       ;331
000174  e5d01013          LDRB     r1,[r0,#0x13]         ;331
000178  e59d0004          LDR      r0,[sp,#4]            ;331
00017c  e1510000          CMP      r1,r0                 ;331
000180  ba000006          BLT      |L4.416|
000184  e1a00c04          LSL      r0,r4,#24             ;332
000188  e1a0ac40          ASR      r10,r0,#24            ;332
00018c  e0840104          ADD      r0,r4,r4,LSL #2       ;333
000190  e59f1194          LDR      r1,|L4.812|
000194  e0810100          ADD      r0,r1,r0,LSL #2       ;333
000198  e5d00013          LDRB     r0,[r0,#0x13]         ;333
00019c  e58d0004          STR      r0,[sp,#4]            ;333
                  |L4.416|
0001a0  e2840001          ADD      r0,r4,#1              ;291
0001a4  e20040ff          AND      r4,r0,#0xff           ;291
                  |L4.424|
0001a8  e354000a          CMP      r4,#0xa               ;291
0001ac  baffffa1          BLT      |L4.56|
0001b0  e2080002          AND      r0,r8,#2              ;342
0001b4  e3500000          CMP      r0,#0                 ;342
0001b8  1a000004          BNE      |L4.464|
0001bc  e357000a          CMP      r7,#0xa               ;344
0001c0  1a000004          BNE      |L4.472|
0001c4  e2080001          AND      r0,r8,#1              ;344
0001c8  e3500000          CMP      r0,#0                 ;344
0001cc  1a000001          BNE      |L4.472|
                  |L4.464|
0001d0  e3e00000          MVN      r0,#0                 ;346
0001d4  eaffffbc          B        |L4.204|
                  |L4.472|
0001d8  e357000a          CMP      r7,#0xa               ;359
0001dc  aa000001          BGE      |L4.488|
0001e0  e20740ff          AND      r4,r7,#0xff           ;360
0001e4  ea000027          B        |L4.648|
                  |L4.488|
0001e8  e35a000a          CMP      r10,#0xa              ;364
0001ec  aa00000e          BGE      |L4.556|
0001f0  e20a40ff          AND      r4,r10,#0xff          ;366
0001f4  e1a00000          MOV      r0,r0                 ;369
0001f8  e0840104          ADD      r0,r4,r4,LSL #2       ;369
0001fc  e59f1128          LDR      r1,|L4.812|
000200  e7910100          LDR      r0,[r1,r0,LSL #2]     ;369
000204  e3500000          CMP      r0,#0                 ;369
000208  0a000006          BEQ      |L4.552|
00020c  e1a00000          MOV      r0,r0                 ;369
000210  e28f3f46          ADR      r3,|L4.816|
000214  e59f21a0          LDR      r2,|L4.956|
000218  e28f1e1a          ADR      r1,|L4.960|
00021c  e28f0e17          ADR      r0,|L4.916|
000220  ebfffffe          BL       sysprintf
000224  e1a00000          MOV      r0,r0                 ;369
                  |L4.552|
000228  ea000009          B        |L4.596|
                  |L4.556|
00022c  e359000a          CMP      r9,#0xa               ;371
000230  aa000001          BGE      |L4.572|
000234  e20940ff          AND      r4,r9,#0xff           ;373
000238  ea000005          B        |L4.596|
                  |L4.572|
00023c  e35b000a          CMP      r11,#0xa              ;376
000240  aa000001          BGE      |L4.588|
000244  e20b40ff          AND      r4,r11,#0xff          ;378
000248  ea000001          B        |L4.596|
                  |L4.588|
00024c  e3e00000          MVN      r0,#0                 ;383
000250  eaffff9d          B        |L4.204|
                  |L4.596|
000254  e1a00000          MOV      r0,r0                 ;387
000258  e354000a          CMP      r4,#0xa               ;387
00025c  ba000006          BLT      |L4.636|
000260  e1a00000          MOV      r0,r0                 ;387
000264  e28f30c4          ADR      r3,|L4.816|
000268  e59f2168          LDR      r2,|L4.984|
00026c  e28f1f5a          ADR      r1,|L4.988|
000270  e28f0f47          ADR      r0,|L4.916|
000274  ebfffffe          BL       sysprintf
000278  e1a00000          MOV      r0,r0                 ;387
                  |L4.636|
00027c  e1a00000          MOV      r0,r0                 ;387
000280  e1a00004          MOV      r0,r4                 ;388
000284  ebfffffe          BL       etharp_free_entry
                  |L4.648|
000288  e1a00000          MOV      r0,r0                 ;391
00028c  e354000a          CMP      r4,#0xa               ;391
000290  ba000006          BLT      |L4.688|
000294  e1a00000          MOV      r0,r0                 ;391
000298  e28f3090          ADR      r3,|L4.816|
00029c  e59f214c          LDR      r2,|L4.1008|
0002a0  e28f1f4d          ADR      r1,|L4.988|
0002a4  e28f00e8          ADR      r0,|L4.916|
0002a8  ebfffffe          BL       sysprintf
0002ac  e1a00000          MOV      r0,r0                 ;391
                  |L4.688|
0002b0  e1a00000          MOV      r0,r0                 ;391
0002b4  e1a00000          MOV      r0,r0                 ;392
0002b8  e0840104          ADD      r0,r4,r4,LSL #2       ;392
0002bc  e59f1068          LDR      r1,|L4.812|
0002c0  e0810100          ADD      r0,r1,r0,LSL #2       ;392
0002c4  e5d00012          LDRB     r0,[r0,#0x12]         ;392
0002c8  e3500000          CMP      r0,#0                 ;392
0002cc  0a000006          BEQ      |L4.748|
0002d0  e1a00000          MOV      r0,r0                 ;392
0002d4  e28f3054          ADR      r3,|L4.816|
0002d8  e3a02f62          MOV      r2,#0x188             ;392
0002dc  e28f1e11          ADR      r1,|L4.1012|
0002e0  e28f00ac          ADR      r0,|L4.916|
0002e4  ebfffffe          BL       sysprintf
0002e8  e1a00000          MOV      r0,r0                 ;392
                  |L4.748|
0002ec  e1a00000          MOV      r0,r0                 ;392
0002f0  e3560000          CMP      r6,#0                 ;396
0002f4  0a000004          BEQ      |L4.780|
0002f8  e0841104          ADD      r1,r4,r4,LSL #2       ;398
0002fc  e59f2028          LDR      r2,|L4.812|
000300  e0821101          ADD      r1,r2,r1,LSL #2       ;398
000304  e5960000          LDR      r0,[r6,#0]            ;398
000308  e5810004          STR      r0,[r1,#4]            ;398
                  |L4.780|
00030c  e3a00000          MOV      r0,#0                 ;400
000310  e0841104          ADD      r1,r4,r4,LSL #2       ;400
000314  e59f2010          LDR      r2,|L4.812|
000318  e0821101          ADD      r1,r2,r1,LSL #2       ;400
00031c  e5c10013          STRB     r0,[r1,#0x13]         ;400
000320  e1a00c04          LSL      r0,r4,#24             ;401
000324  e1a00c40          ASR      r0,r0,#24             ;401
000328  eaffff67          B        |L4.204|
                  |L4.812|
                          DCD      arp_table
                  |L4.816|
000330  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
000334  2d312e34
000338  2e315c73
00033c  72635c6e
000340  65746966
000344  5c657468
000348  6172702e
00034c  6300    
00034e  00                DCB      0
00034f  00                DCB      0
                  |L4.848|
                          DCD      0x0000012b
                  |L4.852|
000354  73746174          DCB      "state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_"
000358  65203d3d
00035c  20455448
000360  4152505f
000364  53544154
000368  455f5045
00036c  4e44494e
000370  47207c7c
000374  20737461
000378  7465203e
00037c  3d204554
000380  48415250
000384  5f535441
000388  54455f  
00038b  53544142          DCB      "STABLE",0
00038f  4c4500  
000392  00                DCB      0
000393  00                DCB      0
                  |L4.916|
000394  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000398  7274696f
00039c  6e202225
0003a0  73222066
0003a4  61696c65
0003a8  64206174
0003ac  206c696e
0003b0  65202564
0003b4  20696e20
0003b8  25730a00
                  |L4.956|
                          DCD      0x00000171
                  |L4.960|
0003c0  6172705f          DCB      "arp_table[i].q == NULL",0
0003c4  7461626c
0003c8  655b695d
0003cc  2e71203d
0003d0  3d204e55
0003d4  4c4c00  
0003d7  00                DCB      0
                  |L4.984|
                          DCD      0x00000183
                  |L4.988|
0003dc  69203c20          DCB      "i < ARP_TABLE_SIZE",0
0003e0  4152505f
0003e4  5441424c
0003e8  455f5349
0003ec  5a4500  
0003ef  00                DCB      0
                  |L4.1008|
                          DCD      0x00000187
                  |L4.1012|
0003f4  6172705f          DCB      "arp_table[i].state == ETHARP_STATE_EMPTY",0
0003f8  7461626c
0003fc  655b695d
000400  2e737461
000404  7465203d
000408  3d204554
00040c  48415250
000410  5f535441
000414  54455f45
000418  4d505459
00041c  00      
00041d  00                DCB      0
00041e  00                DCB      0
00041f  00                DCB      0
                          ENDP


                          AREA ||i.etharp_free_entry||, CODE, READONLY, ALIGN=2

                  etharp_free_entry PROC
;;;176    static void
;;;177    etharp_free_entry(int i)
000000  e92d4010          PUSH     {r4,lr}
;;;178    {
000004  e1a04000          MOV      r4,r0
;;;179      /* remove from SNMP ARP index tree */
;;;180      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
;;;181      /* and empty packet queue */
;;;182      if (arp_table[i].q != NULL) {
000008  e0840104          ADD      r0,r4,r4,LSL #2
00000c  e59f107c          LDR      r1,|L5.144|
000010  e7910100          LDR      r0,[r1,r0,LSL #2]
000014  e3500000          CMP      r0,#0
000018  0a000007          BEQ      |L5.60|
;;;183        /* remove all queued packets */
;;;184        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;185        free_etharp_q(arp_table[i].q);
00001c  e0841104          ADD      r1,r4,r4,LSL #2
000020  e59f2068          LDR      r2,|L5.144|
000024  e7920101          LDR      r0,[r2,r1,LSL #2]
000028  ebfffffe          BL       pbuf_free
;;;186        arp_table[i].q = NULL;
00002c  e3a00000          MOV      r0,#0
000030  e0841104          ADD      r1,r4,r4,LSL #2
000034  e59f2054          LDR      r2,|L5.144|
000038  e7820101          STR      r0,[r2,r1,LSL #2]
                  |L5.60|
;;;187      }
;;;188      /* recycle entry for re-use */
;;;189      arp_table[i].state = ETHARP_STATE_EMPTY;
00003c  e3a00000          MOV      r0,#0
000040  e0841104          ADD      r1,r4,r4,LSL #2
000044  e59f2044          LDR      r2,|L5.144|
000048  e0821101          ADD      r1,r2,r1,LSL #2
00004c  e5c10012          STRB     r0,[r1,#0x12]
;;;190    #ifdef LWIP_DEBUG
;;;191      /* for debugging, clean out the complete entry */
;;;192      arp_table[i].ctime = 0;
000050  e0841104          ADD      r1,r4,r4,LSL #2
000054  e0821101          ADD      r1,r2,r1,LSL #2
000058  e5c10013          STRB     r0,[r1,#0x13]
;;;193      arp_table[i].netif = NULL;
00005c  e0841104          ADD      r1,r4,r4,LSL #2
000060  e0821101          ADD      r1,r2,r1,LSL #2
000064  e5810008          STR      r0,[r1,#8]
;;;194      ip_addr_set_zero(&arp_table[i].ipaddr);
000068  e0841104          ADD      r1,r4,r4,LSL #2
00006c  e0821101          ADD      r1,r2,r1,LSL #2
000070  e5810004          STR      r0,[r1,#4]
;;;195      arp_table[i].ethaddr = ethzero;
000074  e0841104          ADD      r1,r4,r4,LSL #2
000078  e0821101          ADD      r1,r2,r1,LSL #2
00007c  e281000c          ADD      r0,r1,#0xc
000080  e3a02006          MOV      r2,#6
000084  e59f1008          LDR      r1,|L5.148|
000088  ebfffffe          BL       __aeabi_memcpy
;;;196    #endif /* LWIP_DEBUG */
;;;197    }
00008c  e8bd8010          POP      {r4,pc}
;;;198    
                          ENDP

                  |L5.144|
                          DCD      arp_table
                  |L5.148|
                          DCD      ethzero

                          AREA ||i.etharp_output||, CODE, READONLY, ALIGN=2

                  etharp_output PROC
;;;878    err_t
;;;879    etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;880    {
000004  e1a04000          MOV      r4,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a05002          MOV      r5,r2
;;;881      struct eth_addr *dest;
;;;882      struct eth_addr mcastaddr;
;;;883      ip_addr_t *dst_addr = ipaddr;
000010  e1a09005          MOV      r9,r5
;;;884    
;;;885      LWIP_ASSERT("netif != NULL", netif != NULL);
000014  e1a00000          MOV      r0,r0
000018  e3540000          CMP      r4,#0
00001c  1a000006          BNE      |L6.60|
000020  e1a00000          MOV      r0,r0
000024  e28f3f92          ADR      r3,|L6.628|
000028  e59f2264          LDR      r2,|L6.660|
00002c  e28f1f99          ADR      r1,|L6.664|
000030  e28f0e27          ADR      r0,|L6.680|
000034  ebfffffe          BL       sysprintf
000038  e1a00000          MOV      r0,r0
                  |L6.60|
00003c  e1a00000          MOV      r0,r0
;;;886      LWIP_ASSERT("q != NULL", q != NULL);
000040  e1a00000          MOV      r0,r0
000044  e3570000          CMP      r7,#0
000048  1a000006          BNE      |L6.104|
00004c  e1a00000          MOV      r0,r0
000050  e28f3f87          ADR      r3,|L6.628|
000054  e59f2274          LDR      r2,|L6.720|
000058  e28f1f9d          ADR      r1,|L6.724|
00005c  e28f0f91          ADR      r0,|L6.680|
000060  ebfffffe          BL       sysprintf
000064  e1a00000          MOV      r0,r0
                  |L6.104|
000068  e1a00000          MOV      r0,r0
;;;887      LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
00006c  e1a00000          MOV      r0,r0
000070  e3550000          CMP      r5,#0
000074  1a000006          BNE      |L6.148|
000078  e1a00000          MOV      r0,r0
00007c  e28f3e1f          ADR      r3,|L6.628|
000080  e59f2258          LDR      r2,|L6.736|
000084  e28f1f96          ADR      r1,|L6.740|
000088  e28f0f86          ADR      r0,|L6.680|
00008c  ebfffffe          BL       sysprintf
000090  e1a00000          MOV      r0,r0
                  |L6.148|
000094  e1a00000          MOV      r0,r0
;;;888    
;;;889      /* make room for Ethernet header - should not fail */
;;;890      if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
000098  e3a0100e          MOV      r1,#0xe
00009c  e1a00007          MOV      r0,r7
0000a0  ebfffffe          BL       pbuf_header
0000a4  e3500000          CMP      r0,#0
0000a8  0a000001          BEQ      |L6.180|
;;;891        /* bail out */
;;;892        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;893          ("etharp_output: could not allocate room for header.\n"));
;;;894        LINK_STATS_INC(link.lenerr);
;;;895        return ERR_BUF;
0000ac  e3e00001          MVN      r0,#1
                  |L6.176|
;;;896      }
;;;897    
;;;898      /* Determine on destination hardware address. Broadcasts and multicasts
;;;899       * are special, other IP addresses are looked up in the ARP table. */
;;;900    
;;;901      /* broadcast destination IP address? */
;;;902      if (ip_addr_isbroadcast(ipaddr, netif)) {
;;;903        /* broadcast on Ethernet also */
;;;904        dest = (struct eth_addr *)&ethbroadcast;
;;;905      /* multicast destination IP address? */
;;;906      } else if (ip_addr_ismulticast(ipaddr)) {
;;;907        /* Hash IP multicast address to MAC address.*/
;;;908        mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
;;;909        mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
;;;910        mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
;;;911        mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
;;;912        mcastaddr.addr[4] = ip4_addr3(ipaddr);
;;;913        mcastaddr.addr[5] = ip4_addr4(ipaddr);
;;;914        /* destination Ethernet address is multicast */
;;;915        dest = &mcastaddr;
;;;916      /* unicast destination IP address? */
;;;917      } else {
;;;918        s8_t i;
;;;919        /* outside local network? if so, this can neither be a global broadcast nor
;;;920           a subnet broadcast. */
;;;921        if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
;;;922            !ip_addr_islinklocal(ipaddr)) {
;;;923    #if LWIP_AUTOIP
;;;924          struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
;;;925            sizeof(struct eth_hdr));
;;;926          /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
;;;927             a link-local source address must always be "directly to its destination
;;;928             on the same physical link. The host MUST NOT send the packet to any
;;;929             router for forwarding". */
;;;930          if (!ip_addr_islinklocal(&iphdr->src))
;;;931    #endif /* LWIP_AUTOIP */
;;;932          {
;;;933            /* interface has default gateway? */
;;;934            if (!ip_addr_isany(&netif->gw)) {
;;;935              /* send to hardware address of default gateway IP address */
;;;936              dst_addr = &(netif->gw);
;;;937            /* no default gateway available */
;;;938            } else {
;;;939              /* no route to destination error (default gateway missing) */
;;;940              return ERR_RTE;
;;;941            }
;;;942          }
;;;943        }
;;;944    #if LWIP_NETIF_HWADDRHINT
;;;945        if (netif->addr_hint != NULL) {
;;;946          /* per-pcb cached entry was given */
;;;947          u8_t etharp_cached_entry = *(netif->addr_hint);
;;;948          if (etharp_cached_entry < ARP_TABLE_SIZE) {
;;;949    #endif /* LWIP_NETIF_HWADDRHINT */
;;;950            if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
;;;951                (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
;;;952              /* the per-pcb-cached entry is stable and the right one! */
;;;953              ETHARP_STATS_INC(etharp.cachehit);
;;;954              return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
;;;955            }
;;;956    #if LWIP_NETIF_HWADDRHINT
;;;957          }
;;;958        }
;;;959    #endif /* LWIP_NETIF_HWADDRHINT */
;;;960    
;;;961        /* find stable entry: do this here since this is a critical path for
;;;962           throughput and etharp_find_entry() is kind of slow */
;;;963        for (i = 0; i < ARP_TABLE_SIZE; i++) {
;;;964          if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
;;;965              (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
;;;966            /* found an existing, stable entry */
;;;967            ETHARP_SET_HINT(netif, i);
;;;968            return etharp_output_to_arp_index(netif, q, i);
;;;969          }
;;;970        }
;;;971        /* no stable entry found, use the (slower) query function:
;;;972           queue on destination Ethernet address belonging to ipaddr */
;;;973        return etharp_query(netif, dst_addr, q);
;;;974      }
;;;975    
;;;976      /* continuation for multicast/broadcast destinations */
;;;977      /* obtain source Ethernet address of the given interface */
;;;978      /* send packet directly on the link */
;;;979      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
;;;980    }
0000b0  e8bd87fc          POP      {r2-r10,pc}
                  |L6.180|
0000b4  e1a01004          MOV      r1,r4                 ;902
0000b8  e5950000          LDR      r0,[r5,#0]            ;902
0000bc  ebfffffe          BL       ip4_addr_isbroadcast
0000c0  e3500000          CMP      r0,#0                 ;902
0000c4  0a000001          BEQ      |L6.208|
0000c8  e59f8224          LDR      r8,|L6.756|
0000cc  ea000062          B        |L6.604|
                  |L6.208|
0000d0  e5d50000          LDRB     r0,[r5,#0]            ;906
0000d4  e20000f0          AND      r0,r0,#0xf0           ;906
0000d8  e35000e0          CMP      r0,#0xe0              ;906
0000dc  1a00000e          BNE      |L6.284|
0000e0  e3a00001          MOV      r0,#1                 ;908
0000e4  e5cd0000          STRB     r0,[sp,#0]            ;908
0000e8  e3a00000          MOV      r0,#0                 ;909
0000ec  e5cd0001          STRB     r0,[sp,#1]            ;909
0000f0  e3a0005e          MOV      r0,#0x5e              ;910
0000f4  e5cd0002          STRB     r0,[sp,#2]            ;910
0000f8  e5d50001          LDRB     r0,[r5,#1]            ;911
0000fc  e200007f          AND      r0,r0,#0x7f           ;911
000100  e5cd0003          STRB     r0,[sp,#3]            ;911
000104  e5d50002          LDRB     r0,[r5,#2]            ;912
000108  e5cd0004          STRB     r0,[sp,#4]            ;912
00010c  e5d50003          LDRB     r0,[r5,#3]            ;913
000110  e5cd0005          STRB     r0,[sp,#5]            ;913
000114  e1a0800d          MOV      r8,sp                 ;915
000118  ea00004d          B        |L6.596|
                  |L6.284|
00011c  e5950000          LDR      r0,[r5,#0]            ;921
000120  e5941008          LDR      r1,[r4,#8]            ;921
000124  e0000001          AND      r0,r0,r1              ;921
000128  e9940006          LDMIB    r4,{r1,r2}            ;921
00012c  e0011002          AND      r1,r1,r2              ;921
000130  e1500001          CMP      r0,r1                 ;921
000134  0a00000f          BEQ      |L6.376|
000138  e1d500b0          LDRH     r0,[r5,#0]            ;922
00013c  e1a00800          LSL      r0,r0,#16             ;922
000140  e1a00820          LSR      r0,r0,#16             ;922
000144  e59f11ac          LDR      r1,|L6.760|
000148  e1500001          CMP      r0,r1                 ;922
00014c  0a000009          BEQ      |L6.376|
000150  e284000c          ADD      r0,r4,#0xc            ;934
000154  e3500000          CMP      r0,#0                 ;934
000158  0a000004          BEQ      |L6.368|
00015c  e594000c          LDR      r0,[r4,#0xc]          ;934
000160  e3500000          CMP      r0,#0                 ;934
000164  0a000001          BEQ      |L6.368|
000168  e284900c          ADD      r9,r4,#0xc            ;936
00016c  ea000001          B        |L6.376|
                  |L6.368|
000170  e3e00003          MVN      r0,#3                 ;940
000174  eaffffcd          B        |L6.176|
                  |L6.376|
000178  e59f017c          LDR      r0,|L6.764|
00017c  e5d00000          LDRB     r0,[r0,#0]            ;950  ; etharp_cached_entry
000180  e0800100          ADD      r0,r0,r0,LSL #2       ;950
000184  e59f1174          LDR      r1,|L6.768|
000188  e0810100          ADD      r0,r1,r0,LSL #2       ;950
00018c  e5d00012          LDRB     r0,[r0,#0x12]         ;950
000190  e3500002          CMP      r0,#2                 ;950
000194  ba00000e          BLT      |L6.468|
000198  e59f115c          LDR      r1,|L6.764|
00019c  e5990000          LDR      r0,[r9,#0]            ;951
0001a0  e5d11000          LDRB     r1,[r1,#0]            ;951  ; etharp_cached_entry
0001a4  e0811101          ADD      r1,r1,r1,LSL #2       ;951
0001a8  e59f2150          LDR      r2,|L6.768|
0001ac  e0821101          ADD      r1,r2,r1,LSL #2       ;951
0001b0  e5911004          LDR      r1,[r1,#4]            ;951
0001b4  e1500001          CMP      r0,r1                 ;951
0001b8  1a000005          BNE      |L6.468|
0001bc  e59f0138          LDR      r0,|L6.764|
0001c0  e5d02000          LDRB     r2,[r0,#0]            ;954  ; etharp_cached_entry
0001c4  e1a01007          MOV      r1,r7                 ;954
0001c8  e1a00004          MOV      r0,r4                 ;954
0001cc  ebfffffe          BL       etharp_output_to_arp_index
0001d0  eaffffb6          B        |L6.176|
                  |L6.468|
0001d4  e3a06000          MOV      r6,#0                 ;963
0001d8  ea000016          B        |L6.568|
                  |L6.476|
0001dc  e0860106          ADD      r0,r6,r6,LSL #2       ;964
0001e0  e59f1118          LDR      r1,|L6.768|
0001e4  e0810100          ADD      r0,r1,r0,LSL #2       ;964
0001e8  e5d00012          LDRB     r0,[r0,#0x12]         ;964
0001ec  e3500002          CMP      r0,#2                 ;964
0001f0  ba00000d          BLT      |L6.556|
0001f4  e0861106          ADD      r1,r6,r6,LSL #2       ;965
0001f8  e59f2100          LDR      r2,|L6.768|
0001fc  e0821101          ADD      r1,r2,r1,LSL #2       ;965
000200  e5990000          LDR      r0,[r9,#0]            ;965
000204  e5911004          LDR      r1,[r1,#4]            ;965
000208  e1500001          CMP      r0,r1                 ;965
00020c  1a000006          BNE      |L6.556|
000210  e59f10e4          LDR      r1,|L6.764|
000214  e5c16000          STRB     r6,[r1,#0]            ;967  ; etharp_cached_entry
000218  e20620ff          AND      r2,r6,#0xff           ;968
00021c  e1a01007          MOV      r1,r7                 ;968
000220  e1a00004          MOV      r0,r4                 ;968
000224  ebfffffe          BL       etharp_output_to_arp_index
000228  eaffffa0          B        |L6.176|
                  |L6.556|
00022c  e2860001          ADD      r0,r6,#1              ;963
000230  e1a00c00          LSL      r0,r0,#24             ;963
000234  e1a06c40          ASR      r6,r0,#24             ;963
                  |L6.568|
000238  e356000a          CMP      r6,#0xa               ;963
00023c  baffffe6          BLT      |L6.476|
000240  e1a02007          MOV      r2,r7                 ;973
000244  e1a01009          MOV      r1,r9                 ;973
000248  e1a00004          MOV      r0,r4                 ;973
00024c  ebfffffe          BL       etharp_query
000250  eaffff96          B        |L6.176|
                  |L6.596|
000254  e1a00000          MOV      r0,r0                 ;974
000258  e1a00000          MOV      r0,r0                 ;974
                  |L6.604|
00025c  e1a03008          MOV      r3,r8                 ;979
000260  e2842027          ADD      r2,r4,#0x27           ;979
000264  e1a01007          MOV      r1,r7                 ;979
000268  e1a00004          MOV      r0,r4                 ;979
00026c  ebfffffe          BL       etharp_send_ip
000270  eaffff8e          B        |L6.176|
                  |L6.628|
000274  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
000278  2d312e34
00027c  2e315c73
000280  72635c6e
000284  65746966
000288  5c657468
00028c  6172702e
000290  6300    
000292  00                DCB      0
000293  00                DCB      0
                  |L6.660|
                          DCD      0x00000375
                  |L6.664|
000298  6e657469          DCB      "netif != NULL",0
00029c  6620213d
0002a0  204e554c
0002a4  4c00    
0002a6  00                DCB      0
0002a7  00                DCB      0
                  |L6.680|
0002a8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0002ac  7274696f
0002b0  6e202225
0002b4  73222066
0002b8  61696c65
0002bc  64206174
0002c0  206c696e
0002c4  65202564
0002c8  20696e20
0002cc  25730a00
                  |L6.720|
                          DCD      0x00000376
                  |L6.724|
0002d4  7120213d          DCB      "q != NULL",0
0002d8  204e554c
0002dc  4c00    
0002de  00                DCB      0
0002df  00                DCB      0
                  |L6.736|
                          DCD      0x00000377
                  |L6.740|
0002e4  69706164          DCB      "ipaddr != NULL",0
0002e8  64722021
0002ec  3d204e55
0002f0  4c4c00  
0002f3  00                DCB      0
                  |L6.756|
                          DCD      ethbroadcast
                  |L6.760|
                          DCD      0x0000fea9
                  |L6.764|
                          DCD      etharp_cached_entry
                  |L6.768|
                          DCD      arp_table
                          ENDP


                          AREA ||i.etharp_output_to_arp_index||, CODE, READONLY, ALIGN=2

                  etharp_output_to_arp_index PROC
;;;841    static err_t
;;;842    etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;843    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a04002          MOV      r4,r2
;;;844      LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
000010  e1a00000          MOV      r0,r0
000014  e0840104          ADD      r0,r4,r4,LSL #2
000018  e59f10b0          LDR      r1,|L7.208|
00001c  e0810100          ADD      r0,r1,r0,LSL #2
000020  e5d00012          LDRB     r0,[r0,#0x12]
000024  e3500002          CMP      r0,#2
000028  aa000006          BGE      |L7.72|
00002c  e1a00000          MOV      r0,r0
000030  e28f309c          ADR      r3,|L7.212|
000034  e3a02fd3          MOV      r2,#0x34c
000038  e28f10b4          ADR      r1,|L7.244|
00003c  e28f00e0          ADR      r0,|L7.292|
000040  ebfffffe          BL       sysprintf
000044  e1a00000          MOV      r0,r0
                  |L7.72|
000048  e1a00000          MOV      r0,r0
;;;845                  arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
;;;846      /* if arp table entry is about to expire: re-request it,
;;;847         but only if its state is ETHARP_STATE_STABLE to prevent flooding the
;;;848         network with ARP requests if this address is used frequently. */
;;;849      if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
00004c  e0840104          ADD      r0,r4,r4,LSL #2
000050  e59f1078          LDR      r1,|L7.208|
000054  e0810100          ADD      r0,r1,r0,LSL #2
000058  e5d00012          LDRB     r0,[r0,#0x12]
00005c  e3500002          CMP      r0,#2
000060  1a000011          BNE      |L7.172|
;;;850          (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
000064  e0840104          ADD      r0,r4,r4,LSL #2
000068  e0810100          ADD      r0,r1,r0,LSL #2
00006c  e5d00013          LDRB     r0,[r0,#0x13]
000070  e35000e4          CMP      r0,#0xe4
000074  ba00000c          BLT      |L7.172|
;;;851        if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
000078  e0840104          ADD      r0,r4,r4,LSL #2
00007c  e2812000          ADD      r2,r1,#0
000080  e0820100          ADD      r0,r2,r0,LSL #2
000084  e2801004          ADD      r1,r0,#4
000088  e1a00005          MOV      r0,r5
00008c  ebfffffe          BL       etharp_request
000090  e3500000          CMP      r0,#0
000094  1a000004          BNE      |L7.172|
;;;852          arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
000098  e3a00003          MOV      r0,#3
00009c  e0841104          ADD      r1,r4,r4,LSL #2
0000a0  e59f2028          LDR      r2,|L7.208|
0000a4  e0821101          ADD      r1,r2,r1,LSL #2
0000a8  e5c10012          STRB     r0,[r1,#0x12]
                  |L7.172|
;;;853        }
;;;854      }
;;;855      
;;;856      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
0000ac  e0840104          ADD      r0,r4,r4,LSL #2
0000b0  e59f1018          LDR      r1,|L7.208|
0000b4  e0810100          ADD      r0,r1,r0,LSL #2
0000b8  e280300c          ADD      r3,r0,#0xc
0000bc  e2852027          ADD      r2,r5,#0x27
0000c0  e1a01006          MOV      r1,r6
0000c4  e1a00005          MOV      r0,r5
0000c8  ebfffffe          BL       etharp_send_ip
;;;857        &arp_table[arp_idx].ethaddr);
;;;858    }
0000cc  e8bd8070          POP      {r4-r6,pc}
;;;859    
                          ENDP

                  |L7.208|
                          DCD      arp_table
                  |L7.212|
0000d4  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
0000d8  2d312e34
0000dc  2e315c73
0000e0  72635c6e
0000e4  65746966
0000e8  5c657468
0000ec  6172702e
0000f0  6300    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L7.244|
0000f4  6172705f          DCB      "arp_table[arp_idx].state >= ETHARP_STATE_STABLE",0
0000f8  7461626c
0000fc  655b6172
000100  705f6964
000104  785d2e73
000108  74617465
00010c  203e3d20
000110  45544841
000114  52505f53
000118  54415445
00011c  5f535441
000120  424c4500
                  |L7.292|
000124  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000128  7274696f
00012c  6e202225
000130  73222066
000134  61696c65
000138  64206174
00013c  206c696e
000140  65202564
000144  20696e20
000148  25730a00

                          AREA ||i.etharp_query||, CODE, READONLY, ALIGN=2

                  etharp_query PROC
;;;1015   err_t
;;;1016   etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1017   {
000004  e1a08000          MOV      r8,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a06002          MOV      r6,r2
;;;1018     struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
000010  e2889027          ADD      r9,r8,#0x27
;;;1019     err_t result = ERR_MEM;
000014  e3e0a000          MVN      r10,#0
;;;1020     s8_t i; /* ARP entry index */
;;;1021   
;;;1022     /* non-unicast address? */
;;;1023     if (ip_addr_isbroadcast(ipaddr, netif) ||
000018  e1a01008          MOV      r1,r8
00001c  e5970000          LDR      r0,[r7,#0]
000020  ebfffffe          BL       ip4_addr_isbroadcast
000024  e3500000          CMP      r0,#0
000028  1a000008          BNE      |L8.80|
;;;1024         ip_addr_ismulticast(ipaddr) ||
00002c  e5d70000          LDRB     r0,[r7,#0]
000030  e20000f0          AND      r0,r0,#0xf0
000034  e35000e0          CMP      r0,#0xe0
000038  0a000004          BEQ      |L8.80|
;;;1025         ip_addr_isany(ipaddr)) {
00003c  e3570000          CMP      r7,#0
000040  0a000002          BEQ      |L8.80|
000044  e5970000          LDR      r0,[r7,#0]
000048  e3500000          CMP      r0,#0
00004c  1a000001          BNE      |L8.88|
                  |L8.80|
;;;1026       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
;;;1027       return ERR_ARG;
000050  e3e0000d          MVN      r0,#0xd
                  |L8.84|
;;;1028     }
;;;1029   
;;;1030     /* find entry in ARP cache, ask to create entry if queueing packet */
;;;1031     i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
;;;1032   
;;;1033     /* could not find or create entry? */
;;;1034     if (i < 0) {
;;;1035       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
;;;1036       if (q) {
;;;1037         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
;;;1038         ETHARP_STATS_INC(etharp.memerr);
;;;1039       }
;;;1040       return (err_t)i;
;;;1041     }
;;;1042   
;;;1043     /* mark a fresh entry as pending (we just sent a request) */
;;;1044     if (arp_table[i].state == ETHARP_STATE_EMPTY) {
;;;1045       arp_table[i].state = ETHARP_STATE_PENDING;
;;;1046     }
;;;1047   
;;;1048     /* { i is either a STABLE or (new or existing) PENDING entry } */
;;;1049     LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
;;;1050     ((arp_table[i].state == ETHARP_STATE_PENDING) ||
;;;1051      (arp_table[i].state >= ETHARP_STATE_STABLE)));
;;;1052   
;;;1053     /* do we have a pending entry? or an implicit query request? */
;;;1054     if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
;;;1055       /* try to resolve it; send out ARP request */
;;;1056       result = etharp_request(netif, ipaddr);
;;;1057       if (result != ERR_OK) {
;;;1058         /* ARP request couldn't be sent */
;;;1059         /* We don't re-send arp request in etharp_tmr, but we still queue packets,
;;;1060            since this failure could be temporary, and the next packet calling
;;;1061            etharp_query again could lead to sending the queued packets. */
;;;1062       }
;;;1063       if (q == NULL) {
;;;1064         return result;
;;;1065       }
;;;1066     }
;;;1067   
;;;1068     /* packet given? */
;;;1069     LWIP_ASSERT("q != NULL", q != NULL);
;;;1070     /* stable entry? */
;;;1071     if (arp_table[i].state >= ETHARP_STATE_STABLE) {
;;;1072       /* we have a valid IP->Ethernet address mapping */
;;;1073       ETHARP_SET_HINT(netif, i);
;;;1074       /* send the packet */
;;;1075       result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
;;;1076     /* pending entry? (either just created or already pending */
;;;1077     } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;1078       /* entry is still pending, queue the given packet 'q' */
;;;1079       struct pbuf *p;
;;;1080       int copy_needed = 0;
;;;1081       /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
;;;1082        * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
;;;1083        * PBUF_ROMs can be left as they are, since ROM must not get changed. */
;;;1084       p = q;
;;;1085       while (p) {
;;;1086         LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
;;;1087         if(p->type != PBUF_ROM) {
;;;1088           copy_needed = 1;
;;;1089           break;
;;;1090         }
;;;1091         p = p->next;
;;;1092       }
;;;1093       if(copy_needed) {
;;;1094         /* copy the whole packet into new pbufs */
;;;1095         p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;1096         if(p != NULL) {
;;;1097           if (pbuf_copy(p, q) != ERR_OK) {
;;;1098             pbuf_free(p);
;;;1099             p = NULL;
;;;1100           }
;;;1101         }
;;;1102       } else {
;;;1103         /* referencing the old pbuf is enough */
;;;1104         p = q;
;;;1105         pbuf_ref(p);
;;;1106       }
;;;1107       /* packet could be taken over? */
;;;1108       if (p != NULL) {
;;;1109         /* queue packet ... */
;;;1110   #if ARP_QUEUEING
;;;1111         struct etharp_q_entry *new_entry;
;;;1112         /* allocate a new arp queue entry */
;;;1113         new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
;;;1114         if (new_entry != NULL) {
;;;1115           new_entry->next = 0;
;;;1116           new_entry->p = p;
;;;1117           if(arp_table[i].q != NULL) {
;;;1118             /* queue was already existent, append the new entry to the end */
;;;1119             struct etharp_q_entry *r;
;;;1120             r = arp_table[i].q;
;;;1121             while (r->next != NULL) {
;;;1122               r = r->next;
;;;1123             }
;;;1124             r->next = new_entry;
;;;1125           } else {
;;;1126             /* queue did not exist, first item in queue */
;;;1127             arp_table[i].q = new_entry;
;;;1128           }
;;;1129           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1130           result = ERR_OK;
;;;1131         } else {
;;;1132           /* the pool MEMP_ARP_QUEUE is empty */
;;;1133           pbuf_free(p);
;;;1134           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1135           result = ERR_MEM;
;;;1136         }
;;;1137   #else /* ARP_QUEUEING */
;;;1138         /* always queue one packet per ARP request only, freeing a previously queued packet */
;;;1139         if (arp_table[i].q != NULL) {
;;;1140           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1141           pbuf_free(arp_table[i].q);
;;;1142         }
;;;1143         arp_table[i].q = p;
;;;1144         result = ERR_OK;
;;;1145         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1146   #endif /* ARP_QUEUEING */
;;;1147       } else {
;;;1148         ETHARP_STATS_INC(etharp.memerr);
;;;1149         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1150         result = ERR_MEM;
;;;1151       }
;;;1152     }
;;;1153     return result;
;;;1154   }
000054  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.88|
000058  e3a01001          MOV      r1,#1                 ;1031
00005c  e1a00007          MOV      r0,r7                 ;1031
000060  ebfffffe          BL       etharp_find_entry
000064  e1a04000          MOV      r4,r0                 ;1031
000068  e3540000          CMP      r4,#0                 ;1034
00006c  aa000001          BGE      |L8.120|
000070  e1a00004          MOV      r0,r4                 ;1040
000074  eafffff6          B        |L8.84|
                  |L8.120|
000078  e0840104          ADD      r0,r4,r4,LSL #2       ;1044
00007c  e59f1250          LDR      r1,|L8.724|
000080  e0810100          ADD      r0,r1,r0,LSL #2       ;1044
000084  e5d00012          LDRB     r0,[r0,#0x12]         ;1044
000088  e3500000          CMP      r0,#0                 ;1044
00008c  1a000004          BNE      |L8.164|
000090  e3a00001          MOV      r0,#1                 ;1045
000094  e0841104          ADD      r1,r4,r4,LSL #2       ;1045
000098  e59f2234          LDR      r2,|L8.724|
00009c  e0821101          ADD      r1,r2,r1,LSL #2       ;1045
0000a0  e5c10012          STRB     r0,[r1,#0x12]         ;1045
                  |L8.164|
0000a4  e1a00000          MOV      r0,r0                 ;1049
0000a8  e0840104          ADD      r0,r4,r4,LSL #2       ;1049
0000ac  e59f1220          LDR      r1,|L8.724|
0000b0  e0810100          ADD      r0,r1,r0,LSL #2       ;1049
0000b4  e5d00012          LDRB     r0,[r0,#0x12]         ;1049
0000b8  e3500001          CMP      r0,#1                 ;1049
0000bc  0a00000b          BEQ      |L8.240|
0000c0  e0840104          ADD      r0,r4,r4,LSL #2       ;1049
0000c4  e0810100          ADD      r0,r1,r0,LSL #2       ;1049
0000c8  e5d00012          LDRB     r0,[r0,#0x12]         ;1049
0000cc  e3500002          CMP      r0,#2                 ;1049
0000d0  aa000006          BGE      |L8.240|
0000d4  e1a00000          MOV      r0,r0                 ;1049
0000d8  e28f3f7e          ADR      r3,|L8.728|
0000dc  e59f2214          LDR      r2,|L8.760|
0000e0  e28f1f85          ADR      r1,|L8.764|
0000e4  e28f0f8e          ADR      r0,|L8.804|
0000e8  ebfffffe          BL       sysprintf
0000ec  e1a00000          MOV      r0,r0                 ;1049
                  |L8.240|
0000f0  e1a00000          MOV      r0,r0                 ;1049
0000f4  e0840104          ADD      r0,r4,r4,LSL #2       ;1054
0000f8  e59f11d4          LDR      r1,|L8.724|
0000fc  e0810100          ADD      r0,r1,r0,LSL #2       ;1054
000100  e5d00012          LDRB     r0,[r0,#0x12]         ;1054
000104  e3500001          CMP      r0,#1                 ;1054
000108  0a000001          BEQ      |L8.276|
00010c  e3560000          CMP      r6,#0                 ;1054
000110  1a000007          BNE      |L8.308|
                  |L8.276|
000114  e1a01007          MOV      r1,r7                 ;1056
000118  e1a00008          MOV      r0,r8                 ;1056
00011c  ebfffffe          BL       etharp_request
000120  e1a0a000          MOV      r10,r0                ;1056
000124  e3560000          CMP      r6,#0                 ;1063
000128  1a000001          BNE      |L8.308|
00012c  e1a0000a          MOV      r0,r10                ;1064
000130  eaffffc7          B        |L8.84|
                  |L8.308|
000134  e1a00000          MOV      r0,r0                 ;1069
000138  e3560000          CMP      r6,#0                 ;1069
00013c  1a000006          BNE      |L8.348|
000140  e1a00000          MOV      r0,r0                 ;1069
000144  e28f3f63          ADR      r3,|L8.728|
000148  e59f21fc          LDR      r2,|L8.844|
00014c  e28f1f7f          ADR      r1,|L8.848|
000150  e28f0f73          ADR      r0,|L8.804|
000154  ebfffffe          BL       sysprintf
000158  e1a00000          MOV      r0,r0                 ;1069
                  |L8.348|
00015c  e1a00000          MOV      r0,r0                 ;1069
000160  e0840104          ADD      r0,r4,r4,LSL #2       ;1071
000164  e59f1168          LDR      r1,|L8.724|
000168  e0810100          ADD      r0,r1,r0,LSL #2       ;1071
00016c  e5d00012          LDRB     r0,[r0,#0x12]         ;1071
000170  e3500002          CMP      r0,#2                 ;1071
000174  ba00000b          BLT      |L8.424|
000178  e59f11dc          LDR      r1,|L8.860|
00017c  e5c14000          STRB     r4,[r1,#0]            ;1073  ; etharp_cached_entry
000180  e0840104          ADD      r0,r4,r4,LSL #2       ;1075
000184  e59f1148          LDR      r1,|L8.724|
000188  e0810100          ADD      r0,r1,r0,LSL #2       ;1075
00018c  e280300c          ADD      r3,r0,#0xc            ;1075
000190  e1a02009          MOV      r2,r9                 ;1075
000194  e1a01006          MOV      r1,r6                 ;1075
000198  e1a00008          MOV      r0,r8                 ;1075
00019c  ebfffffe          BL       etharp_send_ip
0001a0  e1a0a000          MOV      r10,r0                ;1075
0001a4  ea000048          B        |L8.716|
                  |L8.424|
0001a8  e0840104          ADD      r0,r4,r4,LSL #2       ;1077
0001ac  e59f1120          LDR      r1,|L8.724|
0001b0  e0810100          ADD      r0,r1,r0,LSL #2       ;1077
0001b4  e5d00012          LDRB     r0,[r0,#0x12]         ;1077
0001b8  e3500001          CMP      r0,#1                 ;1077
0001bc  1a000042          BNE      |L8.716|
0001c0  e3a0b000          MOV      r11,#0                ;1080
0001c4  e1a05006          MOV      r5,r6                 ;1084
0001c8  ea000015          B        |L8.548|
                  |L8.460|
0001cc  e1a00000          MOV      r0,r0                 ;1086
0001d0  e1d500ba          LDRH     r0,[r5,#0xa]          ;1086
0001d4  e1d510b8          LDRH     r1,[r5,#8]            ;1086
0001d8  e1500001          CMP      r0,r1                 ;1086
0001dc  1a000009          BNE      |L8.520|
0001e0  e5950000          LDR      r0,[r5,#0]            ;1086
0001e4  e3500000          CMP      r0,#0                 ;1086
0001e8  0a000006          BEQ      |L8.520|
0001ec  e1a00000          MOV      r0,r0                 ;1086
0001f0  e28f30e0          ADR      r3,|L8.728|
0001f4  e59f2164          LDR      r2,|L8.864|
0001f8  e28f1f59          ADR      r1,|L8.868|
0001fc  e28f0e12          ADR      r0,|L8.804|
000200  ebfffffe          BL       sysprintf
000204  e1a00000          MOV      r0,r0                 ;1086
                  |L8.520|
000208  e1a00000          MOV      r0,r0                 ;1086
00020c  e5d5000c          LDRB     r0,[r5,#0xc]          ;1087
000210  e3500001          CMP      r0,#1                 ;1087
000214  0a000001          BEQ      |L8.544|
000218  e3a0b001          MOV      r11,#1                ;1088
00021c  ea000002          B        |L8.556|
                  |L8.544|
000220  e5955000          LDR      r5,[r5,#0]            ;1091
                  |L8.548|
000224  e3550000          CMP      r5,#0                 ;1085
000228  1affffe7          BNE      |L8.460|
                  |L8.556|
00022c  e1a00000          MOV      r0,r0                 ;1089
000230  e35b0000          CMP      r11,#0                ;1093
000234  0a00000f          BEQ      |L8.632|
000238  e1d510b8          LDRH     r1,[r5,#8]            ;1095
00023c  e3a02000          MOV      r2,#0                 ;1095
000240  e3a00003          MOV      r0,#3                 ;1095
000244  ebfffffe          BL       pbuf_alloc
000248  e1a05000          MOV      r5,r0                 ;1095
00024c  e3550000          CMP      r5,#0                 ;1096
000250  0a00000b          BEQ      |L8.644|
000254  e1a01006          MOV      r1,r6                 ;1097
000258  e1a00005          MOV      r0,r5                 ;1097
00025c  ebfffffe          BL       pbuf_copy
000260  e3500000          CMP      r0,#0                 ;1097
000264  0a000006          BEQ      |L8.644|
000268  e1a00005          MOV      r0,r5                 ;1098
00026c  ebfffffe          BL       pbuf_free
000270  e3a05000          MOV      r5,#0                 ;1099
000274  ea000002          B        |L8.644|
                  |L8.632|
000278  e1a05006          MOV      r5,r6                 ;1104
00027c  e1a00005          MOV      r0,r5                 ;1105
000280  ebfffffe          BL       pbuf_ref
                  |L8.644|
000284  e3550000          CMP      r5,#0                 ;1108
000288  0a00000d          BEQ      |L8.708|
00028c  e0840104          ADD      r0,r4,r4,LSL #2       ;1139
000290  e59f103c          LDR      r1,|L8.724|
000294  e7910100          LDR      r0,[r1,r0,LSL #2]     ;1139
000298  e3500000          CMP      r0,#0                 ;1139
00029c  0a000003          BEQ      |L8.688|
0002a0  e0841104          ADD      r1,r4,r4,LSL #2       ;1141
0002a4  e59f2028          LDR      r2,|L8.724|
0002a8  e7920101          LDR      r0,[r2,r1,LSL #2]     ;1141
0002ac  ebfffffe          BL       pbuf_free
                  |L8.688|
0002b0  e0840104          ADD      r0,r4,r4,LSL #2       ;1143
0002b4  e59f1018          LDR      r1,|L8.724|
0002b8  e7815100          STR      r5,[r1,r0,LSL #2]     ;1143
0002bc  e3a0a000          MOV      r10,#0                ;1144
0002c0  ea000000          B        |L8.712|
                  |L8.708|
0002c4  e3e0a000          MVN      r10,#0                ;1150
                  |L8.712|
0002c8  e1a00000          MOV      r0,r0                 ;1152
                  |L8.716|
0002cc  e1a0000a          MOV      r0,r10                ;1153
0002d0  eaffff5f          B        |L8.84|
                  |L8.724|
                          DCD      arp_table
                  |L8.728|
0002d8  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
0002dc  2d312e34
0002e0  2e315c73
0002e4  72635c6e
0002e8  65746966
0002ec  5c657468
0002f0  6172702e
0002f4  6300    
0002f6  00                DCB      0
0002f7  00                DCB      0
                  |L8.760|
                          DCD      0x00000419
                  |L8.764|
0002fc  6172705f          DCB      "arp_table[i].state == PENDING or STABLE",0
000300  7461626c
000304  655b695d
000308  2e737461
00030c  7465203d
000310  3d205045
000314  4e44494e
000318  47206f72
00031c  20535441
000320  424c4500
                  |L8.804|
000324  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000328  7274696f
00032c  6e202225
000330  73222066
000334  61696c65
000338  64206174
00033c  206c696e
000340  65202564
000344  20696e20
000348  25730a00
                  |L8.844|
                          DCD      0x0000042d
                  |L8.848|
000350  7120213d          DCB      "q != NULL",0
000354  204e554c
000358  4c00    
00035a  00                DCB      0
00035b  00                DCB      0
                  |L8.860|
                          DCD      etharp_cached_entry
                  |L8.864|
                          DCD      0x0000043e
                  |L8.868|
000364  6e6f2070          DCB      "no packet queues allowed!",0
000368  61636b65
00036c  74207175
000370  65756573
000374  20616c6c
000378  6f776564
00037c  2100    
00037e  00                DCB      0
00037f  00                DCB      0
                          ENDP


                          AREA ||i.etharp_raw||, CODE, READONLY, ALIGN=2

                  etharp_raw PROC
;;;1174   err_t
;;;1175   etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1176              const struct eth_addr *ethdst_addr,
;;;1177              const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
;;;1178              const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
;;;1179              const u16_t opcode)
;;;1180   {
000004  e1a07000          MOV      r7,r0
000008  e1a0b001          MOV      r11,r1
00000c  e1a08002          MOV      r8,r2
000010  e1a09003          MOV      r9,r3
;;;1181     struct pbuf *p;
;;;1182     err_t result = ERR_OK;
000014  e3a0a000          MOV      r10,#0
;;;1183     struct eth_hdr *ethhdr;
;;;1184     struct etharp_hdr *hdr;
;;;1185   #if LWIP_AUTOIP
;;;1186     const u8_t * ethdst_hwaddr;
;;;1187   #endif /* LWIP_AUTOIP */
;;;1188   
;;;1189     LWIP_ASSERT("netif != NULL", netif != NULL);
000018  e1a00000          MOV      r0,r0
00001c  e3570000          CMP      r7,#0
000020  1a000006          BNE      |L9.64|
000024  e1a00000          MOV      r0,r0
000028  e28f3f5f          ADR      r3,|L9.428|
00002c  e59f2198          LDR      r2,|L9.460|
000030  e28f1f66          ADR      r1,|L9.464|
000034  e28f0f69          ADR      r0,|L9.480|
000038  ebfffffe          BL       sysprintf
00003c  e1a00000          MOV      r0,r0
                  |L9.64|
000040  e1a00000          MOV      r0,r0
;;;1190   
;;;1191     /* allocate a pbuf for the outgoing ARP request packet */
;;;1192     p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
000044  e3a02000          MOV      r2,#0
000048  e3a0102a          MOV      r1,#0x2a
00004c  e3a00003          MOV      r0,#3
000050  ebfffffe          BL       pbuf_alloc
000054  e1a05000          MOV      r5,r0
;;;1193     /* could allocate a pbuf for an ARP request? */
;;;1194     if (p == NULL) {
000058  e3550000          CMP      r5,#0
00005c  1a000001          BNE      |L9.104|
;;;1195       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;1196         ("etharp_raw: could not allocate pbuf for ARP request.\n"));
;;;1197       ETHARP_STATS_INC(etharp.memerr);
;;;1198       return ERR_MEM;
000060  e3e00000          MVN      r0,#0
                  |L9.100|
;;;1199     }
;;;1200     LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
;;;1201                 (p->len >= SIZEOF_ETHARP_PACKET));
;;;1202   
;;;1203     ethhdr = (struct eth_hdr *)p->payload;
;;;1204     hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;1205     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
;;;1206     hdr->opcode = htons(opcode);
;;;1207   
;;;1208     LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;1209                 (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;1210   #if LWIP_AUTOIP
;;;1211     /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;1212      * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;1213      * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;1214     ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
;;;1215   #endif /* LWIP_AUTOIP */
;;;1216     /* Write the ARP MAC-Addresses */
;;;1217     ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
;;;1218     ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
;;;1219     /* Write the Ethernet MAC-Addresses */
;;;1220   #if LWIP_AUTOIP
;;;1221     ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;1222   #else  /* LWIP_AUTOIP */
;;;1223     ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
;;;1224   #endif /* LWIP_AUTOIP */
;;;1225     ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
;;;1226     /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;1227      * structure packing. */ 
;;;1228     IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
;;;1229     IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
;;;1230   
;;;1231     hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
;;;1232     hdr->proto = PP_HTONS(ETHTYPE_IP);
;;;1233     /* set hwlen and protolen */
;;;1234     hdr->hwlen = ETHARP_HWADDR_LEN;
;;;1235     hdr->protolen = sizeof(ip_addr_t);
;;;1236   
;;;1237     ethhdr->type = PP_HTONS(ETHTYPE_ARP);
;;;1238     /* send ARP query */
;;;1239     result = netif->linkoutput(netif, p);
;;;1240     ETHARP_STATS_INC(etharp.xmit);
;;;1241     /* free ARP query packet */
;;;1242     pbuf_free(p);
;;;1243     p = NULL;
;;;1244     /* could not allocate pbuf for ARP request */
;;;1245   
;;;1246     return result;
;;;1247   }
000064  e8bd9ff0          POP      {r4-r12,pc}
                  |L9.104|
000068  e1a00000          MOV      r0,r0                 ;1200
00006c  e1d500ba          LDRH     r0,[r5,#0xa]          ;1200
000070  e350002a          CMP      r0,#0x2a              ;1200
000074  aa000006          BGE      |L9.148|
000078  e1a00000          MOV      r0,r0                 ;1200
00007c  e28f3f4a          ADR      r3,|L9.428|
000080  e3a02e4b          MOV      r2,#0x4b0             ;1200
000084  e28f1f5f          ADR      r1,|L9.520|
000088  e28f0e15          ADR      r0,|L9.480|
00008c  ebfffffe          BL       sysprintf
000090  e1a00000          MOV      r0,r0                 ;1200
                  |L9.148|
000094  e1a00000          MOV      r0,r0                 ;1200
000098  e5956004          LDR      r6,[r5,#4]            ;1203
00009c  e286400e          ADD      r4,r6,#0xe            ;1204
0000a0  e59d0034          LDR      r0,[sp,#0x34]         ;1206
0000a4  ebfffffe          BL       lwip_htons
0000a8  e5c40006          STRB     r0,[r4,#6]            ;1206
0000ac  e1a00420          LSR      r0,r0,#8              ;1206
0000b0  e5c40007          STRB     r0,[r4,#7]            ;1206
0000b4  e1a00000          MOV      r0,r0                 ;1208
0000b8  e5d70026          LDRB     r0,[r7,#0x26]         ;1208
0000bc  e3500006          CMP      r0,#6                 ;1208
0000c0  0a000006          BEQ      |L9.224|
0000c4  e1a00000          MOV      r0,r0                 ;1208
0000c8  e28f30dc          ADR      r3,|L9.428|
0000cc  e59f2168          LDR      r2,|L9.572|
0000d0  e59f1168          LDR      r1,|L9.576|
0000d4  e28f0f41          ADR      r0,|L9.480|
0000d8  ebfffffe          BL       sysprintf
0000dc  e1a00000          MOV      r0,r0                 ;1208
                  |L9.224|
0000e0  e1a00000          MOV      r0,r0                 ;1208
0000e4  e3a02006          MOV      r2,#6                 ;1217
0000e8  e1a01009          MOV      r1,r9                 ;1217
0000ec  e2840008          ADD      r0,r4,#8              ;1217
0000f0  ebfffffe          BL       __aeabi_memcpy
0000f4  e3a02006          MOV      r2,#6                 ;1218
0000f8  e2840012          ADD      r0,r4,#0x12           ;1218
0000fc  e59d102c          LDR      r1,[sp,#0x2c]         ;1218
000100  ebfffffe          BL       __aeabi_memcpy
000104  e3a02006          MOV      r2,#6                 ;1223
000108  e1a01008          MOV      r1,r8                 ;1223
00010c  e1a00006          MOV      r0,r6                 ;1223
000110  ebfffffe          BL       __aeabi_memcpy
000114  e3a02006          MOV      r2,#6                 ;1225
000118  e1a0100b          MOV      r1,r11                ;1225
00011c  e2860006          ADD      r0,r6,#6              ;1225
000120  ebfffffe          BL       __aeabi_memcpy
000124  e3a02004          MOV      r2,#4                 ;1228
000128  e284000e          ADD      r0,r4,#0xe            ;1228
00012c  e59d1028          LDR      r1,[sp,#0x28]         ;1228
000130  ebfffffe          BL       __aeabi_memcpy
000134  e3a02004          MOV      r2,#4                 ;1229
000138  e2840018          ADD      r0,r4,#0x18           ;1229
00013c  e59d1030          LDR      r1,[sp,#0x30]         ;1229
000140  ebfffffe          BL       __aeabi_memcpy
000144  e3a00c01          MOV      r0,#0x100             ;1231
000148  e5c40000          STRB     r0,[r4,#0]            ;1231
00014c  e1a00420          LSR      r0,r0,#8              ;1231
000150  e5c40001          STRB     r0,[r4,#1]            ;1231
000154  e3a00008          MOV      r0,#8                 ;1232
000158  e5c40002          STRB     r0,[r4,#2]            ;1232
00015c  e3a00000          MOV      r0,#0                 ;1232
000160  e5c40003          STRB     r0,[r4,#3]            ;1232
000164  e3a00006          MOV      r0,#6                 ;1234
000168  e5c40004          STRB     r0,[r4,#4]            ;1234
00016c  e3a00004          MOV      r0,#4                 ;1235
000170  e5c40005          STRB     r0,[r4,#5]            ;1235
000174  e59f00c8          LDR      r0,|L9.580|
000178  e5c6000c          STRB     r0,[r6,#0xc]          ;1237
00017c  e1a00420          LSR      r0,r0,#8              ;1237
000180  e5c6000d          STRB     r0,[r6,#0xd]          ;1237
000184  e1a01005          MOV      r1,r5                 ;1239
000188  e5972018          LDR      r2,[r7,#0x18]         ;1239
00018c  e1a00007          MOV      r0,r7                 ;1239
000190  e12fff32          BLX      r2                    ;1239
000194  e1a0a000          MOV      r10,r0                ;1239
000198  e1a00005          MOV      r0,r5                 ;1242
00019c  ebfffffe          BL       pbuf_free
0001a0  e1a00000          MOV      r0,r0                 ;1243
0001a4  e1a0000a          MOV      r0,r10                ;1246
0001a8  eaffffad          B        |L9.100|
;;;1248   
                          ENDP

                  |L9.428|
0001ac  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
0001b0  2d312e34
0001b4  2e315c73
0001b8  72635c6e
0001bc  65746966
0001c0  5c657468
0001c4  6172702e
0001c8  6300    
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L9.460|
                          DCD      0x000004a5
                  |L9.464|
0001d0  6e657469          DCB      "netif != NULL",0
0001d4  6620213d
0001d8  204e554c
0001dc  4c00    
0001de  00                DCB      0
0001df  00                DCB      0
                  |L9.480|
0001e0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001e4  7274696f
0001e8  6e202225
0001ec  73222066
0001f0  61696c65
0001f4  64206174
0001f8  206c696e
0001fc  65202564
000200  20696e20
000204  25730a00
                  |L9.520|
000208  63686563          DCB      "check that first pbuf can hold struct etharp_hdr",0
00020c  6b207468
000210  61742066
000214  69727374
000218  20706275
00021c  66206361
000220  6e20686f
000224  6c642073
000228  74727563
00022c  74206574
000230  68617270
000234  5f686472
000238  00      
000239  00                DCB      0
00023a  00                DCB      0
00023b  00                DCB      0
                  |L9.572|
                          DCD      0x000004b8
                  |L9.576|
                          DCD      ||.conststring||
                  |L9.580|
                          DCD      0x00000608

                          AREA ||i.etharp_request||, CODE, READONLY, ALIGN=2

                  etharp_request PROC
;;;1258   err_t
;;;1259   etharp_request(struct netif *netif, ip_addr_t *ipaddr)
000000  e92d407f          PUSH     {r0-r6,lr}
;;;1260   {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;1261     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
;;;1262     return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
00000c  e3a00001          MOV      r0,#1
000010  e59f1028          LDR      r1,|L10.64|
000014  e2842004          ADD      r2,r4,#4
000018  e2843027          ADD      r3,r4,#0x27
00001c  e58d2000          STR      r2,[sp,#0]
000020  e59f201c          LDR      r2,|L10.68|
000024  e98d0022          STMIB    sp,{r1,r5}
000028  e2841027          ADD      r1,r4,#0x27
00002c  e58d000c          STR      r0,[sp,#0xc]
000030  e1a00004          MOV      r0,r4
000034  ebfffffe          BL       etharp_raw
000038  e28dd010          ADD      sp,sp,#0x10
;;;1263                       (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
;;;1264                       ipaddr, ARP_REQUEST);
;;;1265   }
00003c  e8bd8070          POP      {r4-r6,pc}
;;;1266   #endif /* LWIP_ARP */
                          ENDP

                  |L10.64|
                          DCD      ethzero
                  |L10.68|
                          DCD      ethbroadcast

                          AREA ||i.etharp_send_ip||, CODE, READONLY, ALIGN=2

                  etharp_send_ip PROC
;;;414    static err_t
;;;415    etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;416    {
000004  e1a04000          MOV      r4,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a07002          MOV      r7,r2
000010  e1a08003          MOV      r8,r3
;;;417      struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
000014  e5965004          LDR      r5,[r6,#4]
;;;418    
;;;419      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
000018  e1a00000          MOV      r0,r0
00001c  e5d40026          LDRB     r0,[r4,#0x26]
000020  e3500006          CMP      r0,#6
000024  0a000006          BEQ      |L11.68|
000028  e1a00000          MOV      r0,r0
00002c  e28f3058          ADR      r3,|L11.140|
000030  e59f2074          LDR      r2,|L11.172|
000034  e59f1074          LDR      r1,|L11.176|
000038  e28f0074          ADR      r0,|L11.180|
00003c  ebfffffe          BL       sysprintf
000040  e1a00000          MOV      r0,r0
                  |L11.68|
000044  e1a00000          MOV      r0,r0
;;;420                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;421      ETHADDR32_COPY(&ethhdr->dest, dst);
000048  e3a02006          MOV      r2,#6
00004c  e1a01008          MOV      r1,r8
000050  e1a00005          MOV      r0,r5
000054  ebfffffe          BL       __aeabi_memcpy
;;;422      ETHADDR16_COPY(&ethhdr->src, src);
000058  e3a02006          MOV      r2,#6
00005c  e1a01007          MOV      r1,r7
000060  e2850006          ADD      r0,r5,#6
000064  ebfffffe          BL       __aeabi_memcpy
;;;423      ethhdr->type = PP_HTONS(ETHTYPE_IP);
000068  e3a00008          MOV      r0,#8
00006c  e5c5000c          STRB     r0,[r5,#0xc]
000070  e3a00000          MOV      r0,#0
000074  e5c5000d          STRB     r0,[r5,#0xd]
;;;424      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
;;;425      /* send the packet */
;;;426      return netif->linkoutput(netif, p);
000078  e1a01006          MOV      r1,r6
00007c  e5942018          LDR      r2,[r4,#0x18]
000080  e1a00004          MOV      r0,r4
000084  e12fff32          BLX      r2
;;;427    }
000088  e8bd81f0          POP      {r4-r8,pc}
;;;428    
                          ENDP

                  |L11.140|
00008c  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
000090  2d312e34
000094  2e315c73
000098  72635c6e
00009c  65746966
0000a0  5c657468
0000a4  6172702e
0000a8  6300    
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L11.172|
                          DCD      0x000001a3
                  |L11.176|
                          DCD      ||.conststring||
                  |L11.180|
0000b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000b8  7274696f
0000bc  6e202225
0000c0  73222066
0000c4  61696c65
0000c8  64206174
0000cc  206c696e
0000d0  65202564
0000d4  20696e20
0000d8  25730a00

                          AREA ||i.etharp_tmr||, CODE, READONLY, ALIGN=2

                  etharp_tmr PROC
;;;205    void
;;;206    etharp_tmr(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;207    {
;;;208      u8_t i;
;;;209    
;;;210      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
;;;211      /* remove expired entries from the ARP table */
;;;212      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
000004  e3a04000          MOV      r4,#0
000008  ea00002d          B        |L12.196|
                  |L12.12|
;;;213        u8_t state = arp_table[i].state;
00000c  e0840104          ADD      r0,r4,r4,LSL #2
000010  e59f10b8          LDR      r1,|L12.208|
000014  e0810100          ADD      r0,r1,r0,LSL #2
000018  e5d05012          LDRB     r5,[r0,#0x12]
;;;214        if (state != ETHARP_STATE_EMPTY
00001c  e3550000          CMP      r5,#0
000020  0a000025          BEQ      |L12.188|
;;;215    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;216          && (state != ETHARP_STATE_STATIC)
;;;217    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;218          ) {
;;;219          arp_table[i].ctime++;
000024  e0840104          ADD      r0,r4,r4,LSL #2
000028  e0810100          ADD      r0,r1,r0,LSL #2
00002c  e5d00013          LDRB     r0,[r0,#0x13]
000030  e2800001          ADD      r0,r0,#1
000034  e0841104          ADD      r1,r4,r4,LSL #2
000038  e59f2090          LDR      r2,|L12.208|
00003c  e0821101          ADD      r1,r2,r1,LSL #2
000040  e5c10013          STRB     r0,[r1,#0x13]
;;;220          if ((arp_table[i].ctime >= ARP_MAXAGE) ||
000044  e0840104          ADD      r0,r4,r4,LSL #2
000048  e2821000          ADD      r1,r2,#0
00004c  e0810100          ADD      r0,r1,r0,LSL #2
000050  e5d00013          LDRB     r0,[r0,#0x13]
000054  e35000f0          CMP      r0,#0xf0
000058  aa000009          BGE      |L12.132|
;;;221              ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
00005c  e0840104          ADD      r0,r4,r4,LSL #2
000060  e0810100          ADD      r0,r1,r0,LSL #2
000064  e5d00012          LDRB     r0,[r0,#0x12]
000068  e3500001          CMP      r0,#1
00006c  1a000007          BNE      |L12.144|
;;;222               (arp_table[i].ctime >= ARP_MAXPENDING))) {
000070  e0840104          ADD      r0,r4,r4,LSL #2
000074  e0810100          ADD      r0,r1,r0,LSL #2
000078  e5d00013          LDRB     r0,[r0,#0x13]
00007c  e3500002          CMP      r0,#2
000080  ba000002          BLT      |L12.144|
                  |L12.132|
;;;223            /* pending or stable entry has become old! */
;;;224            LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
;;;225                 arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
;;;226            /* clean up entries that have just been expired */
;;;227            etharp_free_entry(i);
000084  e1a00004          MOV      r0,r4
000088  ebfffffe          BL       etharp_free_entry
00008c  ea00000a          B        |L12.188|
                  |L12.144|
;;;228          }
;;;229          else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
000090  e0840104          ADD      r0,r4,r4,LSL #2
000094  e59f1034          LDR      r1,|L12.208|
000098  e0810100          ADD      r0,r1,r0,LSL #2
00009c  e5d00012          LDRB     r0,[r0,#0x12]
0000a0  e3500003          CMP      r0,#3
0000a4  1a000004          BNE      |L12.188|
;;;230            /* Reset state to stable, so that the next transmitted packet will
;;;231               re-send an ARP request. */
;;;232            arp_table[i].state = ETHARP_STATE_STABLE;
0000a8  e3a00002          MOV      r0,#2
0000ac  e0841104          ADD      r1,r4,r4,LSL #2
0000b0  e59f2018          LDR      r2,|L12.208|
0000b4  e0821101          ADD      r1,r2,r1,LSL #2
0000b8  e5c10012          STRB     r0,[r1,#0x12]
                  |L12.188|
0000bc  e2840001          ADD      r0,r4,#1              ;212
0000c0  e20040ff          AND      r4,r0,#0xff           ;212
                  |L12.196|
0000c4  e354000a          CMP      r4,#0xa               ;212
0000c8  baffffcf          BLT      |L12.12|
;;;233          }
;;;234    #if ARP_QUEUEING
;;;235          /* still pending entry? (not expired) */
;;;236          if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;237            /* resend an ARP query here? */
;;;238          }
;;;239    #endif /* ARP_QUEUEING */
;;;240        }
;;;241      }
;;;242    }
0000cc  e8bd8070          POP      {r4-r6,pc}
;;;243    
                          ENDP

                  |L12.208|
                          DCD      arp_table

                          AREA ||i.etharp_update_arp_entry||, CODE, READONLY, ALIGN=2

                  etharp_update_arp_entry PROC
;;;447    static err_t
;;;448    etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;449    {
000004  e1a06000          MOV      r6,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a07002          MOV      r7,r2
000010  e1a08003          MOV      r8,r3
;;;450      s8_t i;
;;;451      LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
000014  e1a00000          MOV      r0,r0
000018  e5d60026          LDRB     r0,[r6,#0x26]
00001c  e3500006          CMP      r0,#6
000020  0a000006          BEQ      |L13.64|
000024  e1a00000          MOV      r0,r0
000028  e28f3f45          ADR      r3,|L13.324|
00002c  e59f2130          LDR      r2,|L13.356|
000030  e28f1e13          ADR      r1,|L13.360|
000034  e28f0f55          ADR      r0,|L13.400|
000038  ebfffffe          BL       sysprintf
00003c  e1a00000          MOV      r0,r0
                  |L13.64|
000040  e1a00000          MOV      r0,r0
;;;452      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
;;;453        ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
;;;454        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
;;;455        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
;;;456      /* non-unicast address? */
;;;457      if (ip_addr_isany(ipaddr) ||
000044  e3550000          CMP      r5,#0
000048  0a00000b          BEQ      |L13.124|
00004c  e5950000          LDR      r0,[r5,#0]
000050  e3500000          CMP      r0,#0
000054  0a000008          BEQ      |L13.124|
;;;458          ip_addr_isbroadcast(ipaddr, netif) ||
000058  e1a01006          MOV      r1,r6
00005c  e5950000          LDR      r0,[r5,#0]
000060  ebfffffe          BL       ip4_addr_isbroadcast
000064  e3500000          CMP      r0,#0
000068  1a000003          BNE      |L13.124|
;;;459          ip_addr_ismulticast(ipaddr)) {
00006c  e5d50000          LDRB     r0,[r5,#0]
000070  e20000f0          AND      r0,r0,#0xf0
000074  e35000e0          CMP      r0,#0xe0
000078  1a000001          BNE      |L13.132|
                  |L13.124|
;;;460        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
;;;461        return ERR_ARG;
00007c  e3e0000d          MVN      r0,#0xd
                  |L13.128|
;;;462      }
;;;463      /* find or create ARP entry */
;;;464      i = etharp_find_entry(ipaddr, flags);
;;;465      /* bail out if no entry could be found */
;;;466      if (i < 0) {
;;;467        return (err_t)i;
;;;468      }
;;;469    
;;;470    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;471      if (flags & ETHARP_FLAG_STATIC_ENTRY) {
;;;472        /* record static type */
;;;473        arp_table[i].state = ETHARP_STATE_STATIC;
;;;474      } else
;;;475    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;476      {
;;;477        /* mark it stable */
;;;478        arp_table[i].state = ETHARP_STATE_STABLE;
;;;479      }
;;;480    
;;;481      /* record network interface */
;;;482      arp_table[i].netif = netif;
;;;483      /* insert in SNMP ARP index tree */
;;;484      snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
;;;485    
;;;486      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
;;;487      /* update address */
;;;488      ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
;;;489      /* reset time stamp */
;;;490      arp_table[i].ctime = 0;
;;;491      /* this is where we will send out queued packets! */
;;;492    #if ARP_QUEUEING
;;;493      while (arp_table[i].q != NULL) {
;;;494        struct pbuf *p;
;;;495        /* remember remainder of queue */
;;;496        struct etharp_q_entry *q = arp_table[i].q;
;;;497        /* pop first item off the queue */
;;;498        arp_table[i].q = q->next;
;;;499        /* get the packet pointer */
;;;500        p = q->p;
;;;501        /* now queue entry can be freed */
;;;502        memp_free(MEMP_ARP_QUEUE, q);
;;;503    #else /* ARP_QUEUEING */
;;;504      if (arp_table[i].q != NULL) {
;;;505        struct pbuf *p = arp_table[i].q;
;;;506        arp_table[i].q = NULL;
;;;507    #endif /* ARP_QUEUEING */
;;;508        /* send the queued IP packet */
;;;509        etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
;;;510        /* free the queued IP packet */
;;;511        pbuf_free(p);
;;;512      }
;;;513      return ERR_OK;
;;;514    }
000080  e8bd87f0          POP      {r4-r10,pc}
                  |L13.132|
000084  e1a01008          MOV      r1,r8                 ;464
000088  e1a00005          MOV      r0,r5                 ;464
00008c  ebfffffe          BL       etharp_find_entry
000090  e1a04000          MOV      r4,r0                 ;464
000094  e3540000          CMP      r4,#0                 ;466
000098  aa000001          BGE      |L13.164|
00009c  e1a00004          MOV      r0,r4                 ;467
0000a0  eafffff6          B        |L13.128|
                  |L13.164|
0000a4  e3a00002          MOV      r0,#2                 ;478
0000a8  e0841104          ADD      r1,r4,r4,LSL #2       ;478
0000ac  e59f2104          LDR      r2,|L13.440|
0000b0  e0821101          ADD      r1,r2,r1,LSL #2       ;478
0000b4  e5c10012          STRB     r0,[r1,#0x12]         ;478
0000b8  e0840104          ADD      r0,r4,r4,LSL #2       ;482
0000bc  e2821000          ADD      r1,r2,#0              ;482
0000c0  e0810100          ADD      r0,r1,r0,LSL #2       ;482
0000c4  e5806008          STR      r6,[r0,#8]            ;482
0000c8  e0841104          ADD      r1,r4,r4,LSL #2       ;488
0000cc  e0821101          ADD      r1,r2,r1,LSL #2       ;488
0000d0  e281000c          ADD      r0,r1,#0xc            ;488
0000d4  e3a02006          MOV      r2,#6                 ;488
0000d8  e1a01007          MOV      r1,r7                 ;488
0000dc  ebfffffe          BL       __aeabi_memcpy
0000e0  e3a00000          MOV      r0,#0                 ;490
0000e4  e0841104          ADD      r1,r4,r4,LSL #2       ;490
0000e8  e59f20c8          LDR      r2,|L13.440|
0000ec  e0821101          ADD      r1,r2,r1,LSL #2       ;490
0000f0  e5c10013          STRB     r0,[r1,#0x13]         ;490
0000f4  e0840104          ADD      r0,r4,r4,LSL #2       ;504
0000f8  e2821000          ADD      r1,r2,#0              ;504
0000fc  e7910100          LDR      r0,[r1,r0,LSL #2]     ;504
000100  e3500000          CMP      r0,#0                 ;504
000104  0a00000c          BEQ      |L13.316|
000108  e0840104          ADD      r0,r4,r4,LSL #2       ;505
00010c  e7919100          LDR      r9,[r1,r0,LSL #2]     ;505
000110  e3a00000          MOV      r0,#0                 ;506
000114  e0841104          ADD      r1,r4,r4,LSL #2       ;506
000118  e7820101          STR      r0,[r2,r1,LSL #2]     ;506
00011c  e1a03007          MOV      r3,r7                 ;509
000120  e2862027          ADD      r2,r6,#0x27           ;509
000124  e1a01009          MOV      r1,r9                 ;509
000128  e1a00006          MOV      r0,r6                 ;509
00012c  ebfffffe          BL       etharp_send_ip
000130  e1a00009          MOV      r0,r9                 ;511
000134  ebfffffe          BL       pbuf_free
000138  e1a00000          MOV      r0,r0                 ;512
                  |L13.316|
00013c  e3a00000          MOV      r0,#0                 ;513
000140  eaffffce          B        |L13.128|
;;;515    
                          ENDP

                  |L13.324|
000144  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
000148  2d312e34
00014c  2e315c73
000150  72635c6e
000154  65746966
000158  5c657468
00015c  6172702e
000160  6300    
000162  00                DCB      0
000163  00                DCB      0
                  |L13.356|
                          DCD      0x000001c3
                  |L13.360|
000168  6e657469          DCB      "netif->hwaddr_len == ETHARP_HWADDR_LEN",0
00016c  662d3e68
000170  77616464
000174  725f6c65
000178  6e203d3d
00017c  20455448
000180  4152505f
000184  48574144
000188  44525f4c
00018c  454e00  
00018f  00                DCB      0
                  |L13.400|
000190  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000194  7274696f
000198  6e202225
00019c  73222066
0001a0  61696c65
0001a4  64206174
0001a8  206c696e
0001ac  65202564
0001b0  20696e20
0001b4  25730a00
                  |L13.440|
                          DCD      arp_table

                          AREA ||i.ethernet_input||, CODE, READONLY, ALIGN=2

                  ethernet_input PROC
;;;1276   err_t
;;;1277   ethernet_input(struct pbuf *p, struct netif *netif)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1278   {
000004  e1a04000          MOV      r4,r0
000008  e1a06001          MOV      r6,r1
;;;1279     struct eth_hdr* ethhdr;
;;;1280     u16_t type;
;;;1281   #if LWIP_ARP || ETHARP_SUPPORT_VLAN
;;;1282     s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
00000c  e3a0800e          MOV      r8,#0xe
;;;1283   #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
;;;1284   
;;;1285     if (p->len <= SIZEOF_ETH_HDR) {
000010  e1d400ba          LDRH     r0,[r4,#0xa]
000014  e350000e          CMP      r0,#0xe
000018  ca000000          BGT      |L14.32|
;;;1286       /* a packet with only an ethernet header (or less) is not valid for us */
;;;1287       ETHARP_STATS_INC(etharp.proterr);
;;;1288       ETHARP_STATS_INC(etharp.drop);
;;;1289       goto free_and_return;
00001c  ea00004f          B        |L14.352|
                  |L14.32|
;;;1290     }
;;;1291   
;;;1292     /* points to packet payload, which starts with an Ethernet header */
;;;1293     ethhdr = (struct eth_hdr *)p->payload;
000020  e5945004          LDR      r5,[r4,#4]
;;;1294     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
;;;1295       ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", type:%"X16_F"\n",
;;;1296        (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
;;;1297        (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
;;;1298        (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
;;;1299        (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
;;;1300        (unsigned)htons(ethhdr->type)));
;;;1301   
;;;1302     type = ethhdr->type;
000024  e5d5000d          LDRB     r0,[r5,#0xd]
000028  e5d5100c          LDRB     r1,[r5,#0xc]
00002c  e1817400          ORR      r7,r1,r0,LSL #8
;;;1303   #if ETHARP_SUPPORT_VLAN
;;;1304     if (type == PP_HTONS(ETHTYPE_VLAN)) {
;;;1305       struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
;;;1306       if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
;;;1307         /* a packet with only an ethernet/vlan header (or less) is not valid for us */
;;;1308         ETHARP_STATS_INC(etharp.proterr);
;;;1309         ETHARP_STATS_INC(etharp.drop);
;;;1310         goto free_and_return;
;;;1311       }
;;;1312   #if defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
;;;1313   #ifdef ETHARP_VLAN_CHECK_FN
;;;1314       if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
;;;1315   #elif defined(ETHARP_VLAN_CHECK)
;;;1316       if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
;;;1317   #endif
;;;1318         /* silently ignore this packet: not for our VLAN */
;;;1319         pbuf_free(p);
;;;1320         return ERR_OK;
;;;1321       }
;;;1322   #endif /* defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
;;;1323       type = vlan->tpid;
;;;1324       ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
;;;1325     }
;;;1326   #endif /* ETHARP_SUPPORT_VLAN */
;;;1327   
;;;1328   #if LWIP_ARP_FILTER_NETIF
;;;1329     netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
;;;1330   #endif /* LWIP_ARP_FILTER_NETIF*/
;;;1331   
;;;1332     if (ethhdr->dest.addr[0] & 1) {
000030  e5d50000          LDRB     r0,[r5,#0]
000034  e2000001          AND      r0,r0,#1
000038  e3500000          CMP      r0,#0
00003c  0a000015          BEQ      |L14.152|
;;;1333       /* this might be a multicast or broadcast packet */
;;;1334       if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
000040  e5d50000          LDRB     r0,[r5,#0]
000044  e3500001          CMP      r0,#1
000048  1a000009          BNE      |L14.116|
;;;1335         if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
00004c  e5d50001          LDRB     r0,[r5,#1]
000050  e3500000          CMP      r0,#0
000054  1a00000f          BNE      |L14.152|
;;;1336             (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
000058  e5d50002          LDRB     r0,[r5,#2]
00005c  e350005e          CMP      r0,#0x5e
000060  1a00000c          BNE      |L14.152|
;;;1337           /* mark the pbuf as link-layer multicast */
;;;1338           p->flags |= PBUF_FLAG_LLMCAST;
000064  e5d4000d          LDRB     r0,[r4,#0xd]
000068  e3800010          ORR      r0,r0,#0x10
00006c  e5c4000d          STRB     r0,[r4,#0xd]
000070  ea000008          B        |L14.152|
                  |L14.116|
;;;1339         }
;;;1340       } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
000074  e3a02006          MOV      r2,#6
000078  e59f10f4          LDR      r1,|L14.372|
00007c  e1a00005          MOV      r0,r5
000080  ebfffffe          BL       memcmp
000084  e3500000          CMP      r0,#0
000088  1a000002          BNE      |L14.152|
;;;1341         /* mark the pbuf as link-layer broadcast */
;;;1342         p->flags |= PBUF_FLAG_LLBCAST;
00008c  e5d4000d          LDRB     r0,[r4,#0xd]
000090  e3800008          ORR      r0,r0,#8
000094  e5c4000d          STRB     r0,[r4,#0xd]
                  |L14.152|
;;;1343       }
;;;1344     }
;;;1345   
;;;1346     switch (type) {
000098  e3570008          CMP      r7,#8
00009c  0a000004          BEQ      |L14.180|
0000a0  e2470b01          SUB      r0,r7,#0x400
0000a4  e2400f82          SUB      r0,r0,#0x208
0000a8  e3500000          CMP      r0,#0
0000ac  1a000026          BNE      |L14.332|
0000b0  ea00001a          B        |L14.288|
                  |L14.180|
;;;1347   #if LWIP_ARP
;;;1348       /* IP packet? */
;;;1349       case PP_HTONS(ETHTYPE_IP):
0000b4  e1a00000          MOV      r0,r0
;;;1350         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
0000b8  e5d6002d          LDRB     r0,[r6,#0x2d]
0000bc  e2000020          AND      r0,r0,#0x20
0000c0  e3500000          CMP      r0,#0
0000c4  1a000000          BNE      |L14.204|
;;;1351           goto free_and_return;
0000c8  ea000024          B        |L14.352|
                  |L14.204|
;;;1352         }
;;;1353   #if ETHARP_TRUST_IP_MAC
;;;1354         /* update ARP table */
;;;1355         etharp_ip_input(netif, p);
;;;1356   #endif /* ETHARP_TRUST_IP_MAC */
;;;1357         /* skip Ethernet header */
;;;1358         if(pbuf_header(p, -ip_hdr_offset)) {
0000cc  e2680000          RSB      r0,r8,#0
0000d0  e1a01800          LSL      r1,r0,#16
0000d4  e1a01841          ASR      r1,r1,#16
0000d8  e1a00004          MOV      r0,r4
0000dc  ebfffffe          BL       pbuf_header
0000e0  e3500000          CMP      r0,#0
0000e4  0a000009          BEQ      |L14.272|
;;;1359           LWIP_ASSERT("Can't move over header in packet", 0);
0000e8  e1a00000          MOV      r0,r0
0000ec  e1a00000          MOV      r0,r0
0000f0  e28f3080          ADR      r3,|L14.376|
0000f4  e59f209c          LDR      r2,|L14.408|
0000f8  e28f109c          ADR      r1,|L14.412|
0000fc  e28f00bc          ADR      r0,|L14.448|
000100  ebfffffe          BL       sysprintf
000104  e1a00000          MOV      r0,r0
000108  e1a00000          MOV      r0,r0
;;;1360           goto free_and_return;
00010c  ea000013          B        |L14.352|
                  |L14.272|
;;;1361         } else {
;;;1362           /* pass to IP layer */
;;;1363           ip_input(p, netif);
000110  e1a01006          MOV      r1,r6
000114  e1a00004          MOV      r0,r4
000118  ebfffffe          BL       ip_input
;;;1364         }
;;;1365         break;
00011c  ea00000c          B        |L14.340|
                  |L14.288|
;;;1366         
;;;1367       case PP_HTONS(ETHTYPE_ARP):
000120  e1a00000          MOV      r0,r0
;;;1368         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
000124  e5d6002d          LDRB     r0,[r6,#0x2d]
000128  e2000020          AND      r0,r0,#0x20
00012c  e3500000          CMP      r0,#0
000130  1a000000          BNE      |L14.312|
;;;1369           goto free_and_return;
000134  ea000009          B        |L14.352|
                  |L14.312|
;;;1370         }
;;;1371         /* pass p to ARP module */
;;;1372         etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
000138  e1a02004          MOV      r2,r4
00013c  e2861027          ADD      r1,r6,#0x27
000140  e1a00006          MOV      r0,r6
000144  ebfffffe          BL       etharp_arp_input
;;;1373         break;
000148  ea000001          B        |L14.340|
                  |L14.332|
;;;1374   #endif /* LWIP_ARP */
;;;1375   #if PPPOE_SUPPORT
;;;1376       case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
;;;1377         pppoe_disc_input(netif, p);
;;;1378         break;
;;;1379   
;;;1380       case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
;;;1381         pppoe_data_input(netif, p);
;;;1382         break;
;;;1383   #endif /* PPPOE_SUPPORT */
;;;1384   
;;;1385       default:
00014c  e1a00000          MOV      r0,r0
;;;1386         ETHARP_STATS_INC(etharp.proterr);
;;;1387         ETHARP_STATS_INC(etharp.drop);
;;;1388         goto free_and_return;
000150  ea000002          B        |L14.352|
                  |L14.340|
000154  e1a00000          MOV      r0,r0                 ;1365
;;;1389     }
;;;1390   
;;;1391     /* This means the pbuf is freed or consumed,
;;;1392        so the caller doesn't have to free it again */
;;;1393     return ERR_OK;
000158  e3a00000          MOV      r0,#0
                  |L14.348|
;;;1394   
;;;1395   free_and_return:
;;;1396     pbuf_free(p);
;;;1397     return ERR_OK;
;;;1398   }
00015c  e8bd81f0          POP      {r4-r8,pc}
                  |L14.352|
000160  e1a00000          MOV      r0,r0                 ;1395
000164  e1a00004          MOV      r0,r4                 ;1396
000168  ebfffffe          BL       pbuf_free
00016c  e3a00000          MOV      r0,#0                 ;1397
000170  eafffff9          B        |L14.348|
;;;1399   #endif /* LWIP_ARP || LWIP_ETHERNET */
                          ENDP

                  |L14.372|
                          DCD      ethbroadcast
                  |L14.376|
000178  6c776970          DCB      "lwip-1.4.1\\src\\netif\\etharp.c",0
00017c  2d312e34
000180  2e315c73
000184  72635c6e
000188  65746966
00018c  5c657468
000190  6172702e
000194  6300    
000196  00                DCB      0
000197  00                DCB      0
                  |L14.408|
                          DCD      0x0000054f
                  |L14.412|
00019c  43616e27          DCB      "Can't move over header in packet",0
0001a0  74206d6f
0001a4  7665206f
0001a8  76657220
0001ac  68656164
0001b0  65722069
0001b4  6e207061
0001b8  636b6574
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L14.448|
0001c0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001c4  7274696f
0001c8  6e202225
0001cc  73222066
0001d0  61696c65
0001d4  64206174
0001d8  206c696e
0001dc  65202564
0001e0  20696e20
0001e4  25730a00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  arp_table
                          %        200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ethbroadcast
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff
                  ethzero
000006  0000              DCB      0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  6e657469          DCB      "netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN"
000004  662d3e68
000008  77616464
00000c  725f6c65
000010  6e206d75
000014  73742062
000018  65207468
00001c  65207361
000020  6d652061
000024  73204554
000028  48415250
00002c  5f485741
000030  4444525f
000034  4c454e  
000037  20666f72          DCB      " for etharp!",0
00003b  20657468
00003f  61727021
000043  00      

                          AREA ||.data||, DATA, ALIGN=0

                  etharp_cached_entry
000000  00                DCB      0x00
