; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\list.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\list.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -D__UVISION_VERSION=524 --omf_browse=.\obj\list.crf FreeRTOS\Source\list.c]
                          ARM

                          AREA ||i.uxListRemove||, CODE, READONLY, ALIGN=2

                  uxListRemove PROC
;;;211    
;;;212    UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
000000  e1a01000          MOV      r1,r0
;;;213    {
;;;214    /* The list item knows which list it is in.  Obtain the list from the list
;;;215    item. */
;;;216    List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
000004  e5912010          LDR      r2,[r1,#0x10]
;;;217    
;;;218    	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
000008  e5910008          LDR      r0,[r1,#8]
00000c  e5913004          LDR      r3,[r1,#4]
000010  e5830008          STR      r0,[r3,#8]
;;;219    	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
000014  e9910009          LDMIB    r1,{r0,r3}
000018  e5830004          STR      r0,[r3,#4]
;;;220    
;;;221    	/* Only used during decision coverage testing. */
;;;222    	mtCOVERAGE_TEST_DELAY();
;;;223    
;;;224    	/* Make sure the index is left pointing to a valid item. */
;;;225    	if( pxList->pxIndex == pxItemToRemove )
00001c  e5920004          LDR      r0,[r2,#4]
000020  e1500001          CMP      r0,r1
000024  1a000001          BNE      |L1.48|
;;;226    	{
;;;227    		pxList->pxIndex = pxItemToRemove->pxPrevious;
000028  e5910008          LDR      r0,[r1,#8]
00002c  e5820004          STR      r0,[r2,#4]
                  |L1.48|
;;;228    	}
;;;229    	else
;;;230    	{
;;;231    		mtCOVERAGE_TEST_MARKER();
;;;232    	}
;;;233    
;;;234    	pxItemToRemove->pvContainer = NULL;
000030  e3a00000          MOV      r0,#0
000034  e5810010          STR      r0,[r1,#0x10]
;;;235    	( pxList->uxNumberOfItems )--;
000038  e5920000          LDR      r0,[r2,#0]
00003c  e2400001          SUB      r0,r0,#1
000040  e5820000          STR      r0,[r2,#0]
;;;236    
;;;237    	return pxList->uxNumberOfItems;
000044  e5920000          LDR      r0,[r2,#0]
;;;238    }
000048  e12fff1e          BX       lr
;;;239    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInitialise||, CODE, READONLY, ALIGN=2

                  vListInitialise PROC
;;;78     
;;;79     void vListInitialise( List_t * const pxList )
000000  e2801008          ADD      r1,r0,#8
;;;80     {
;;;81     	/* The list structure contains a list item which is used to mark the
;;;82     	end of the list.  To initialise the list the list end is inserted
;;;83     	as the only list entry. */
;;;84     	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
000004  e5801004          STR      r1,[r0,#4]
;;;85     
;;;86     	/* The list end value is the highest possible value in the list to
;;;87     	ensure it remains at the end of the list. */
;;;88     	pxList->xListEnd.xItemValue = portMAX_DELAY;
000008  e3e01000          MVN      r1,#0
00000c  e5801008          STR      r1,[r0,#8]
;;;89     
;;;90     	/* The list end next and previous pointers point to itself so we know
;;;91     	when the list is empty. */
;;;92     	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
000010  e2801008          ADD      r1,r0,#8
000014  e580100c          STR      r1,[r0,#0xc]
;;;93     	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
000018  e2801008          ADD      r1,r0,#8
00001c  e5801010          STR      r1,[r0,#0x10]
;;;94     
;;;95     	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
000020  e3a01000          MOV      r1,#0
000024  e5801000          STR      r1,[r0,#0]
;;;96     
;;;97     	/* Write known values into the list if
;;;98     	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
;;;99     	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
;;;100    	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
;;;101    }
000028  e12fff1e          BX       lr
;;;102    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInitialiseItem||, CODE, READONLY, ALIGN=2

                  vListInitialiseItem PROC
;;;103    
;;;104    void vListInitialiseItem( ListItem_t * const pxItem )
000000  e3a01000          MOV      r1,#0
;;;105    {
;;;106    	/* Make sure the list item is not recorded as being on a list. */
;;;107    	pxItem->pvContainer = NULL;
000004  e5801010          STR      r1,[r0,#0x10]
;;;108    
;;;109    	/* Write known values into the list item if
;;;110    	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
;;;111    	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
;;;112    	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
;;;113    }
000008  e12fff1e          BX       lr
;;;114    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInsert||, CODE, READONLY, ALIGN=2

                  vListInsert PROC
;;;144    
;;;145    void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
000000  e1a02000          MOV      r2,r0
;;;146    {
;;;147    ListItem_t *pxIterator;
;;;148    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
000004  e5913000          LDR      r3,[r1,#0]
;;;149    
;;;150    	/* Only effective when configASSERT() is also defined, these tests may catch
;;;151    	the list data structures being overwritten in memory.  They will not catch
;;;152    	data errors caused by incorrect configuration or use of FreeRTOS. */
;;;153    	listTEST_LIST_INTEGRITY( pxList );
;;;154    	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
;;;155    
;;;156    	/* Insert the new list item into the list, sorted in xItemValue order.
;;;157    
;;;158    	If the list already contains a list item with the same item value then the
;;;159    	new list item should be placed after it.  This ensures that TCB's which are
;;;160    	stored in ready lists (all of which have the same xItemValue value) get a
;;;161    	share of the CPU.  However, if the xItemValue is the same as the back marker
;;;162    	the iteration loop below will not end.  Therefore the value is checked
;;;163    	first, and the algorithm slightly modified if necessary. */
;;;164    	if( xValueOfInsertion == portMAX_DELAY )
000008  e3730001          CMN      r3,#1
00000c  1a000001          BNE      |L4.24|
;;;165    	{
;;;166    		pxIterator = pxList->xListEnd.pxPrevious;
000010  e5920010          LDR      r0,[r2,#0x10]
000014  ea000006          B        |L4.52|
                  |L4.24|
;;;167    	}
;;;168    	else
;;;169    	{
;;;170    		/* *** NOTE ***********************************************************
;;;171    		If you find your application is crashing here then likely causes are
;;;172    		listed below.  In addition see http://www.freertos.org/FAQHelp.html for
;;;173    		more tips, and ensure configASSERT() is defined!
;;;174    		http://www.freertos.org/a00110.html#configASSERT
;;;175    
;;;176    			1) Stack overflow -
;;;177    			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
;;;178    			2) Incorrect interrupt priority assignment, especially on Cortex-M
;;;179    			   parts where numerically high priority values denote low actual
;;;180    			   interrupt priorities, which can seem counter intuitive.  See
;;;181    			   http://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
;;;182    			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
;;;183    			   http://www.freertos.org/a00110.html
;;;184    			3) Calling an API function from within a critical section or when
;;;185    			   the scheduler is suspended, or calling an API function that does
;;;186    			   not end in "FromISR" from an interrupt.
;;;187    			4) Using a queue or semaphore before it has been initialised or
;;;188    			   before the scheduler has been started (are interrupts firing
;;;189    			   before vTaskStartScheduler() has been called?).
;;;190    		**********************************************************************/
;;;191    
;;;192    		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
000018  e2820008          ADD      r0,r2,#8
00001c  ea000000          B        |L4.36|
                  |L4.32|
000020  e5900004          LDR      r0,[r0,#4]
                  |L4.36|
000024  e590c004          LDR      r12,[r0,#4]
000028  e59cc000          LDR      r12,[r12,#0]
00002c  e15c0003          CMP      r12,r3
000030  9afffffa          BLS      |L4.32|
                  |L4.52|
;;;193    		{
;;;194    			/* There is nothing to do here, just iterating to the wanted
;;;195    			insertion position. */
;;;196    		}
;;;197    	}
;;;198    
;;;199    	pxNewListItem->pxNext = pxIterator->pxNext;
000034  e590c004          LDR      r12,[r0,#4]
000038  e581c004          STR      r12,[r1,#4]
;;;200    	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
00003c  e591c004          LDR      r12,[r1,#4]
000040  e58c1008          STR      r1,[r12,#8]
;;;201    	pxNewListItem->pxPrevious = pxIterator;
000044  e5810008          STR      r0,[r1,#8]
;;;202    	pxIterator->pxNext = pxNewListItem;
000048  e5801004          STR      r1,[r0,#4]
;;;203    
;;;204    	/* Remember which list the item is in.  This allows fast removal of the
;;;205    	item later. */
;;;206    	pxNewListItem->pvContainer = ( void * ) pxList;
00004c  e5812010          STR      r2,[r1,#0x10]
;;;207    
;;;208    	( pxList->uxNumberOfItems )++;
000050  e592c000          LDR      r12,[r2,#0]
000054  e28cc001          ADD      r12,r12,#1
000058  e582c000          STR      r12,[r2,#0]
;;;209    }
00005c  e12fff1e          BX       lr
;;;210    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInsertEnd||, CODE, READONLY, ALIGN=2

                  vListInsertEnd PROC
;;;115    
;;;116    void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
000000  e5902004          LDR      r2,[r0,#4]
;;;117    {
;;;118    ListItem_t * const pxIndex = pxList->pxIndex;
;;;119    
;;;120    	/* Only effective when configASSERT() is also defined, these tests may catch
;;;121    	the list data structures being overwritten in memory.  They will not catch
;;;122    	data errors caused by incorrect configuration or use of FreeRTOS. */
;;;123    	listTEST_LIST_INTEGRITY( pxList );
;;;124    	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
;;;125    
;;;126    	/* Insert a new list item into pxList, but rather than sort the list,
;;;127    	makes the new list item the last item to be removed by a call to
;;;128    	listGET_OWNER_OF_NEXT_ENTRY(). */
;;;129    	pxNewListItem->pxNext = pxIndex;
000004  e5812004          STR      r2,[r1,#4]
;;;130    	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
000008  e5923008          LDR      r3,[r2,#8]
00000c  e5813008          STR      r3,[r1,#8]
;;;131    
;;;132    	/* Only used during decision coverage testing. */
;;;133    	mtCOVERAGE_TEST_DELAY();
;;;134    
;;;135    	pxIndex->pxPrevious->pxNext = pxNewListItem;
000010  e5923008          LDR      r3,[r2,#8]
000014  e5831004          STR      r1,[r3,#4]
;;;136    	pxIndex->pxPrevious = pxNewListItem;
000018  e5821008          STR      r1,[r2,#8]
;;;137    
;;;138    	/* Remember which list the item is in. */
;;;139    	pxNewListItem->pvContainer = ( void * ) pxList;
00001c  e5810010          STR      r0,[r1,#0x10]
;;;140    
;;;141    	( pxList->uxNumberOfItems )++;
000020  e5903000          LDR      r3,[r0,#0]
000024  e2833001          ADD      r3,r3,#1
000028  e5803000          STR      r3,[r0,#0]
;;;142    }
00002c  e12fff1e          BX       lr
;;;143    /*-----------------------------------------------------------*/
                          ENDP

