; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\tcp.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tcp.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I.\lwip-1.4.1 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\tcp.crf lwip-1.4.1\src\core\tcp.c]
                          ARM

                          AREA ||i.tcp_abandon||, CODE, READONLY, ALIGN=2

                  tcp_abandon PROC
;;;355    void
;;;356    tcp_abandon(struct tcp_pcb *pcb, int reset)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;357    {
000004  e1a04000          MOV      r4,r0
000008  e1a06001          MOV      r6,r1
;;;358      u32_t seqno, ackno;
;;;359    #if LWIP_CALLBACK_API  
;;;360      tcp_err_fn errf;
;;;361    #endif /* LWIP_CALLBACK_API */
;;;362      void *errf_arg;
;;;363    
;;;364      /* pcb->state LISTEN not allowed here */
;;;365      LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
00000c  e1a00000          MOV      r0,r0
000010  e5d40018          LDRB     r0,[r4,#0x18]
000014  e3500001          CMP      r0,#1
000018  1a000006          BNE      |L1.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f3c01          ADR      r3,|L1.296|
000024  e59f2118          LDR      r2,|L1.324|
000028  e28f1f46          ADR      r1,|L1.328|
00002c  e28f0f52          ADR      r0,|L1.380|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L1.56|
000038  e1a00000          MOV      r0,r0
;;;366        pcb->state != LISTEN);
;;;367      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;368         are in an active state, call the receive function associated with
;;;369         the PCB with a NULL argument, and send an RST to the remote end. */
;;;370      if (pcb->state == TIME_WAIT) {
00003c  e5d40018          LDRB     r0,[r4,#0x18]
000040  e350000a          CMP      r0,#0xa
000044  1a000006          BNE      |L1.100|
;;;371        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
000048  e1a01004          MOV      r1,r4
00004c  e59f0150          LDR      r0,|L1.420|
000050  ebfffffe          BL       tcp_pcb_remove
;;;372        memp_free(MEMP_TCP_PCB, pcb);
000054  e1a01004          MOV      r1,r4
000058  e3a00001          MOV      r0,#1
00005c  ebfffffe          BL       memp_free
000060  ea00002f          B        |L1.292|
                  |L1.100|
;;;373      } else {
;;;374        seqno = pcb->snd_nxt;
000064  e5947050          LDR      r7,[r4,#0x50]
;;;375        ackno = pcb->rcv_nxt;
000068  e5948028          LDR      r8,[r4,#0x28]
;;;376    #if LWIP_CALLBACK_API
;;;377        errf = pcb->errf;
00006c  e594508c          LDR      r5,[r4,#0x8c]
;;;378    #endif /* LWIP_CALLBACK_API */
;;;379        errf_arg = pcb->callback_arg;
000070  e5949010          LDR      r9,[r4,#0x10]
;;;380        TCP_PCB_REMOVE_ACTIVE(pcb);
000074  e1a00000          MOV      r0,r0
000078  e1a01004          MOV      r1,r4
00007c  e59f0124          LDR      r0,|L1.424|
000080  ebfffffe          BL       tcp_pcb_remove
000084  e3a00001          MOV      r0,#1
000088  e59f111c          LDR      r1,|L1.428|
00008c  e5c10000          STRB     r0,[r1,#0]  ; tcp_active_pcbs_changed
000090  e1a00000          MOV      r0,r0
;;;381        if (pcb->unacked != NULL) {
000094  e5940070          LDR      r0,[r4,#0x70]
000098  e3500000          CMP      r0,#0
00009c  0a000001          BEQ      |L1.168|
;;;382          tcp_segs_free(pcb->unacked);
0000a0  e5940070          LDR      r0,[r4,#0x70]
0000a4  ebfffffe          BL       tcp_segs_free
                  |L1.168|
;;;383        }
;;;384        if (pcb->unsent != NULL) {
0000a8  e594006c          LDR      r0,[r4,#0x6c]
0000ac  e3500000          CMP      r0,#0
0000b0  0a000001          BEQ      |L1.188|
;;;385          tcp_segs_free(pcb->unsent);
0000b4  e594006c          LDR      r0,[r4,#0x6c]
0000b8  ebfffffe          BL       tcp_segs_free
                  |L1.188|
;;;386        }
;;;387    #if TCP_QUEUE_OOSEQ    
;;;388        if (pcb->ooseq != NULL) {
0000bc  e5940074          LDR      r0,[r4,#0x74]
0000c0  e3500000          CMP      r0,#0
0000c4  0a000001          BEQ      |L1.208|
;;;389          tcp_segs_free(pcb->ooseq);
0000c8  e5940074          LDR      r0,[r4,#0x74]
0000cc  ebfffffe          BL       tcp_segs_free
                  |L1.208|
;;;390        }
;;;391    #endif /* TCP_QUEUE_OOSEQ */
;;;392        if (reset) {
0000d0  e3560000          CMP      r6,#0
0000d4  0a000008          BEQ      |L1.252|
;;;393          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
;;;394          tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
0000d8  e1d401bc          LDRH     r0,[r4,#0x1c]
0000dc  e1d411ba          LDRH     r1,[r4,#0x1a]
0000e0  e2843004          ADD      r3,r4,#4
0000e4  e1a02004          MOV      r2,r4
0000e8  e58d1000          STR      r1,[sp,#0]
0000ec  e1a01008          MOV      r1,r8
0000f0  e58d0004          STR      r0,[sp,#4]
0000f4  e1a00007          MOV      r0,r7
0000f8  ebfffffe          BL       tcp_rst
                  |L1.252|
;;;395        }
;;;396        memp_free(MEMP_TCP_PCB, pcb);
0000fc  e1a01004          MOV      r1,r4
000100  e3a00001          MOV      r0,#1
000104  ebfffffe          BL       memp_free
;;;397        TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
000108  e1a00000          MOV      r0,r0
00010c  e3550000          CMP      r5,#0
000110  0a000002          BEQ      |L1.288|
000114  e3e01009          MVN      r1,#9
000118  e1a00009          MOV      r0,r9
00011c  e12fff35          BLX      r5
                  |L1.288|
000120  e1a00000          MOV      r0,r0
                  |L1.292|
;;;398      }
;;;399    }
000124  e8bd87fc          POP      {r2-r10,pc}
;;;400    
                          ENDP

                  |L1.296|
000128  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
00012c  2d312e34
000130  2e315c73
000134  72635c63
000138  6f72655c
00013c  7463702e
000140  6300    
000142  00                DCB      0
000143  00                DCB      0
                  |L1.324|
                          DCD      0x0000016d
                  |L1.328|
000148  646f6e27          DCB      "don't call tcp_abort/tcp_abandon for listen-pcbs",0
00014c  74206361
000150  6c6c2074
000154  63705f61
000158  626f7274
00015c  2f746370
000160  5f616261
000164  6e646f6e
000168  20666f72
00016c  206c6973
000170  74656e2d
000174  70636273
000178  00      
000179  00                DCB      0
00017a  00                DCB      0
00017b  00                DCB      0
                  |L1.380|
00017c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000180  7274696f
000184  6e202225
000188  73222066
00018c  61696c65
000190  64206174
000194  206c696e
000198  65202564
00019c  20696e20
0001a0  25730a00
                  |L1.420|
                          DCD      tcp_tw_pcbs
                  |L1.424|
                          DCD      tcp_active_pcbs
                  |L1.428|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_abort||, CODE, READONLY, ALIGN=2

                  tcp_abort PROC
;;;411    void
;;;412    tcp_abort(struct tcp_pcb *pcb)
000000  e92d4010          PUSH     {r4,lr}
;;;413    {
000004  e1a04000          MOV      r4,r0
;;;414      tcp_abandon(pcb, 1);
000008  e3a01001          MOV      r1,#1
00000c  e1a00004          MOV      r0,r4
000010  ebfffffe          BL       tcp_abandon
;;;415    }
000014  e8bd8010          POP      {r4,pc}
;;;416    
                          ENDP


                          AREA ||i.tcp_accept||, CODE, READONLY, ALIGN=2

                  tcp_accept PROC
;;;1434   void
;;;1435   tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
000000  e5801014          STR      r1,[r0,#0x14]
;;;1436   {
;;;1437     /* This function is allowed to be called for both listen pcbs and
;;;1438        connection pcbs. */
;;;1439     pcb->accept = accept;
;;;1440   }
000004  e12fff1e          BX       lr
;;;1441   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_accept_null||, CODE, READONLY, ALIGN=2

                  tcp_accept_null PROC
;;;492    static err_t
;;;493    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
000000  e1a03000          MOV      r3,r0
;;;494    {
;;;495      LWIP_UNUSED_ARG(arg);
;;;496      LWIP_UNUSED_ARG(pcb);
;;;497      LWIP_UNUSED_ARG(err);
;;;498    
;;;499      return ERR_ABRT;
000004  e3e00009          MVN      r0,#9
;;;500    }
000008  e12fff1e          BX       lr
;;;501    #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_alloc||, CODE, READONLY, ALIGN=2

                  tcp_alloc PROC
;;;1276   struct tcp_pcb *
;;;1277   tcp_alloc(u8_t prio)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1278   {
000004  e1a06000          MOV      r6,r0
;;;1279     struct tcp_pcb *pcb;
;;;1280     u32_t iss;
;;;1281     
;;;1282     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000008  e3a00001          MOV      r0,#1
00000c  ebfffffe          BL       memp_malloc
000010  e1a04000          MOV      r4,r0
;;;1283     if (pcb == NULL) {
000014  e3540000          CMP      r4,#0
000018  1a00000c          BNE      |L5.80|
;;;1284       /* Try killing oldest connection in TIME-WAIT. */
;;;1285       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
;;;1286       tcp_kill_timewait();
00001c  ebfffffe          BL       tcp_kill_timewait
;;;1287       /* Try to allocate a tcp_pcb again. */
;;;1288       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000020  e3a00001          MOV      r0,#1
000024  ebfffffe          BL       memp_malloc
000028  e1a04000          MOV      r4,r0
;;;1289       if (pcb == NULL) {
00002c  e3540000          CMP      r4,#0
000030  1a000005          BNE      |L5.76|
;;;1290         /* Try killing active connections with lower priority than the new one. */
;;;1291         LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
;;;1292         tcp_kill_prio(prio);
000034  e1a00006          MOV      r0,r6
000038  ebfffffe          BL       tcp_kill_prio
;;;1293         /* Try to allocate a tcp_pcb again. */
;;;1294         pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
00003c  e3a00001          MOV      r0,#1
000040  ebfffffe          BL       memp_malloc
000044  e1a04000          MOV      r4,r0
;;;1295         if (pcb != NULL) {
000048  e1a00000          MOV      r0,r0
                  |L5.76|
;;;1296           /* adjust err stats: memp_malloc failed twice before */
;;;1297           MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1298         }
;;;1299       }
;;;1300       if (pcb != NULL) {
00004c  e1a00000          MOV      r0,r0
                  |L5.80|
;;;1301         /* adjust err stats: timewait PCB was freed above */
;;;1302         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1303       }
;;;1304     }
;;;1305     if (pcb != NULL) {
000050  e3540000          CMP      r4,#0
000054  0a00002e          BEQ      |L5.276|
;;;1306       memset(pcb, 0, sizeof(struct tcp_pcb));
000058  e3a01098          MOV      r1,#0x98
00005c  e1a00004          MOV      r0,r4
000060  ebfffffe          BL       __aeabi_memclr4
;;;1307       pcb->prio = prio;
000064  e5c46019          STRB     r6,[r4,#0x19]
;;;1308       pcb->snd_buf = TCP_SND_BUF;
000068  e3a00e43          MOV      r0,#0x430
00006c  e1c406b6          STRH     r0,[r4,#0x66]
;;;1309       pcb->snd_queuelen = 0;
000070  e3a00000          MOV      r0,#0
000074  e1c406b8          STRH     r0,[r4,#0x68]
;;;1310       pcb->rcv_wnd = TCP_WND;
000078  e3a00e86          MOV      r0,#0x860
00007c  e1c402bc          STRH     r0,[r4,#0x2c]
;;;1311       pcb->rcv_ann_wnd = TCP_WND;
000080  e1c402be          STRH     r0,[r4,#0x2e]
;;;1312       pcb->tos = 0;
000084  e3a00000          MOV      r0,#0
000088  e5c40009          STRB     r0,[r4,#9]
;;;1313       pcb->ttl = TCP_TTL;
00008c  e3a000ff          MOV      r0,#0xff
000090  e5c4000a          STRB     r0,[r4,#0xa]
;;;1314       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1315          The send MSS is updated when an MSS option is received. */
;;;1316       pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
000094  e3a00f86          MOV      r0,#0x218
000098  e1c403b6          STRH     r0,[r4,#0x36]
;;;1317       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
00009c  e3a00006          MOV      r0,#6
0000a0  e1c404b4          STRH     r0,[r4,#0x44]
;;;1318       pcb->sa = 0;
0000a4  e3a00000          MOV      r0,#0
0000a8  e1c404b0          STRH     r0,[r4,#0x40]
;;;1319       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
0000ac  e3a00006          MOV      r0,#6
0000b0  e1c404b2          STRH     r0,[r4,#0x42]
;;;1320       pcb->rtime = -1;
0000b4  e3e00000          MVN      r0,#0
0000b8  e1c403b4          STRH     r0,[r4,#0x34]
;;;1321       pcb->cwnd = 1;
0000bc  e3a00001          MOV      r0,#1
0000c0  e1c404bc          STRH     r0,[r4,#0x4c]
;;;1322       iss = tcp_next_iss();
0000c4  ebfffffe          BL       tcp_next_iss
0000c8  e1a05000          MOV      r5,r0
;;;1323       pcb->snd_wl2 = iss;
0000cc  e5845058          STR      r5,[r4,#0x58]
;;;1324       pcb->snd_nxt = iss;
0000d0  e5845050          STR      r5,[r4,#0x50]
;;;1325       pcb->lastack = iss;
0000d4  e5845048          STR      r5,[r4,#0x48]
;;;1326       pcb->snd_lbb = iss;   
0000d8  e584505c          STR      r5,[r4,#0x5c]
;;;1327       pcb->tmr = tcp_ticks;
0000dc  e59f0038          LDR      r0,|L5.284|
0000e0  e5900000          LDR      r0,[r0,#0]  ; tcp_ticks
0000e4  e5840024          STR      r0,[r4,#0x24]
;;;1328       pcb->last_timer = tcp_timer_ctr;
0000e8  e59f0030          LDR      r0,|L5.288|
0000ec  e5d00000          LDRB     r0,[r0,#0]  ; tcp_timer_ctr
0000f0  e5c40021          STRB     r0,[r4,#0x21]
;;;1329   
;;;1330       pcb->polltmr = 0;
0000f4  e3a00000          MOV      r0,#0
0000f8  e5c4001f          STRB     r0,[r4,#0x1f]
;;;1331   
;;;1332   #if LWIP_CALLBACK_API
;;;1333       pcb->recv = tcp_recv_null;
0000fc  e59f0020          LDR      r0,|L5.292|
000100  e5840080          STR      r0,[r4,#0x80]
;;;1334   #endif /* LWIP_CALLBACK_API */  
;;;1335       
;;;1336       /* Init KEEPALIVE timer */
;;;1337       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
000104  e59f001c          LDR      r0,|L5.296|
000108  e5840090          STR      r0,[r4,#0x90]
;;;1338       
;;;1339   #if LWIP_TCP_KEEPALIVE
;;;1340       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1341       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1342   #endif /* LWIP_TCP_KEEPALIVE */
;;;1343   
;;;1344       pcb->keep_cnt_sent = 0;
00010c  e3a00000          MOV      r0,#0
000110  e5c40096          STRB     r0,[r4,#0x96]
                  |L5.276|
;;;1345     }
;;;1346     return pcb;
000114  e1a00004          MOV      r0,r4
;;;1347   }
000118  e8bd8070          POP      {r4-r6,pc}
;;;1348   
                          ENDP

                  |L5.284|
                          DCD      tcp_ticks
                  |L5.288|
                          DCD      tcp_timer_ctr
                  |L5.292|
                          DCD      tcp_recv_null
                  |L5.296|
                          DCD      0x006ddd00

                          AREA ||i.tcp_arg||, CODE, READONLY, ALIGN=2

                  tcp_arg PROC
;;;1374   void
;;;1375   tcp_arg(struct tcp_pcb *pcb, void *arg)
000000  e5801010          STR      r1,[r0,#0x10]
;;;1376   {
;;;1377     /* This function is allowed to be called for both listen pcbs and
;;;1378        connection pcbs. */
;;;1379     pcb->callback_arg = arg;
;;;1380   }
000004  e12fff1e          BX       lr
;;;1381   #if LWIP_CALLBACK_API
                          ENDP


                          AREA ||i.tcp_bind||, CODE, READONLY, ALIGN=2

                  tcp_bind PROC
;;;431    err_t
;;;432    tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;433    {
000004  e1a05000          MOV      r5,r0
000008  e1a04001          MOV      r4,r1
00000c  e1a07002          MOV      r7,r2
;;;434      int i;
;;;435      int max_pcb_list = NUM_TCP_PCB_LISTS;
000010  e3a09004          MOV      r9,#4
;;;436      struct tcp_pcb *cpcb;
;;;437    
;;;438      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
000014  e1a00000          MOV      r0,r0
000018  e5d50018          LDRB     r0,[r5,#0x18]
00001c  e3500000          CMP      r0,#0
000020  0a000008          BEQ      |L7.72|
000024  e1a00000          MOV      r0,r0
000028  e28f3c01          ADR      r3,|L7.304|
00002c  e59f2118          LDR      r2,|L7.332|
000030  e28f1f46          ADR      r1,|L7.336|
000034  e28f0f4f          ADR      r0,|L7.376|
000038  ebfffffe          BL       sysprintf
00003c  e1a00000          MOV      r0,r0
000040  e3e00005          MVN      r0,#5
                  |L7.68|
;;;439    
;;;440    #if SO_REUSE
;;;441      /* Unless the REUSEADDR flag is set,
;;;442         we have to check the pcbs in TIME-WAIT state, also.
;;;443         We do not dump TIME_WAIT pcb's; they can still be matched by incoming
;;;444         packets using both local and remote IP addresses and ports to distinguish.
;;;445       */
;;;446      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;447        max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
;;;448      }
;;;449    #endif /* SO_REUSE */
;;;450    
;;;451      if (port == 0) {
;;;452        port = tcp_new_port();
;;;453        if (port == 0) {
;;;454          return ERR_BUF;
;;;455        }
;;;456      }
;;;457    
;;;458      /* Check if the address already is in use (on all lists) */
;;;459      for (i = 0; i < max_pcb_list; i++) {
;;;460        for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;461          if (cpcb->local_port == port) {
;;;462    #if SO_REUSE
;;;463            /* Omit checking for the same port if both pcbs have REUSEADDR set.
;;;464               For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
;;;465               tcp_connect. */
;;;466            if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;467                !ip_get_option(cpcb, SOF_REUSEADDR))
;;;468    #endif /* SO_REUSE */
;;;469            {
;;;470              if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;471                  ip_addr_isany(ipaddr) ||
;;;472                  ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;473                return ERR_USE;
;;;474              }
;;;475            }
;;;476          }
;;;477        }
;;;478      }
;;;479    
;;;480      if (!ip_addr_isany(ipaddr)) {
;;;481        pcb->local_ip = *ipaddr;
;;;482      }
;;;483      pcb->local_port = port;
;;;484      TCP_REG(&tcp_bound_pcbs, pcb);
;;;485      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;486      return ERR_OK;
;;;487    }
000044  e8bd87f0          POP      {r4-r10,pc}
                  |L7.72|
000048  e1a00000          MOV      r0,r0                 ;438
00004c  e3570000          CMP      r7,#0                 ;451
000050  1a000005          BNE      |L7.108|
000054  ebfffffe          BL       tcp_new_port
000058  e1a07000          MOV      r7,r0                 ;452
00005c  e3570000          CMP      r7,#0                 ;453
000060  1a000001          BNE      |L7.108|
000064  e3e00001          MVN      r0,#1                 ;454
000068  eafffff5          B        |L7.68|
                  |L7.108|
00006c  e3a08000          MOV      r8,#0                 ;459
000070  ea00001a          B        |L7.224|
                  |L7.116|
000074  e59f0124          LDR      r0,|L7.416|
000078  e7900108          LDR      r0,[r0,r8,LSL #2]     ;460
00007c  e5906000          LDR      r6,[r0,#0]            ;460
000080  ea000013          B        |L7.212|
                  |L7.132|
000084  e1d601ba          LDRH     r0,[r6,#0x1a]         ;461
000088  e1500007          CMP      r0,r7                 ;461
00008c  1a00000f          BNE      |L7.208|
000090  e3560000          CMP      r6,#0                 ;470
000094  0a00000b          BEQ      |L7.200|
000098  e5960000          LDR      r0,[r6,#0]            ;470
00009c  e3500000          CMP      r0,#0                 ;470
0000a0  0a000008          BEQ      |L7.200|
0000a4  e3540000          CMP      r4,#0                 ;471
0000a8  0a000006          BEQ      |L7.200|
0000ac  e5940000          LDR      r0,[r4,#0]            ;471
0000b0  e3500000          CMP      r0,#0                 ;471
0000b4  0a000003          BEQ      |L7.200|
0000b8  e5960000          LDR      r0,[r6,#0]            ;472
0000bc  e5941000          LDR      r1,[r4,#0]            ;472
0000c0  e1500001          CMP      r0,r1                 ;472
0000c4  1a000001          BNE      |L7.208|
                  |L7.200|
0000c8  e3e00007          MVN      r0,#7                 ;473
0000cc  eaffffdc          B        |L7.68|
                  |L7.208|
0000d0  e596600c          LDR      r6,[r6,#0xc]          ;460
                  |L7.212|
0000d4  e3560000          CMP      r6,#0                 ;460
0000d8  1affffe9          BNE      |L7.132|
0000dc  e2888001          ADD      r8,r8,#1              ;459
                  |L7.224|
0000e0  e1580009          CMP      r8,r9                 ;459
0000e4  baffffe2          BLT      |L7.116|
0000e8  e3540000          CMP      r4,#0                 ;480
0000ec  0a000004          BEQ      |L7.260|
0000f0  e5940000          LDR      r0,[r4,#0]            ;480
0000f4  e3500000          CMP      r0,#0                 ;480
0000f8  0a000001          BEQ      |L7.260|
0000fc  e5940000          LDR      r0,[r4,#0]            ;481
000100  e5850000          STR      r0,[r5,#0]            ;481
                  |L7.260|
000104  e1c571ba          STRH     r7,[r5,#0x1a]         ;483
000108  e1a00000          MOV      r0,r0                 ;484
00010c  e59f0090          LDR      r0,|L7.420|
000110  e5900000          LDR      r0,[r0,#0]            ;484  ; tcp_bound_pcbs
000114  e585000c          STR      r0,[r5,#0xc]          ;484
000118  e59f0084          LDR      r0,|L7.420|
00011c  e5805000          STR      r5,[r0,#0]            ;484  ; tcp_bound_pcbs
000120  ebfffffe          BL       tcp_timer_needed
000124  e1a00000          MOV      r0,r0                 ;484
000128  e3a00000          MOV      r0,#0                 ;486
00012c  eaffffc4          B        |L7.68|
;;;488    #if LWIP_CALLBACK_API
                          ENDP

                  |L7.304|
000130  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
000134  2d312e34
000138  2e315c73
00013c  72635c63
000140  6f72655c
000144  7463702e
000148  6300    
00014a  00                DCB      0
00014b  00                DCB      0
                  |L7.332|
                          DCD      0x000001b6
                  |L7.336|
000150  7463705f          DCB      "tcp_bind: can only bind in state CLOSED",0
000154  62696e64
000158  3a206361
00015c  6e206f6e
000160  6c792062
000164  696e6420
000168  696e2073
00016c  74617465
000170  20434c4f
000174  53454400
                  |L7.376|
000178  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00017c  7274696f
000180  6e202225
000184  73222066
000188  61696c65
00018c  64206174
000190  206c696e
000194  65202564
000198  20696e20
00019c  25730a00
                  |L7.416|
                          DCD      tcp_pcb_lists
                  |L7.420|
                          DCD      tcp_bound_pcbs

                          AREA ||i.tcp_close||, CODE, READONLY, ALIGN=2

                  tcp_close PROC
;;;283    err_t
;;;284    tcp_close(struct tcp_pcb *pcb)
000000  e92d4010          PUSH     {r4,lr}
;;;285    {
000004  e1a04000          MOV      r4,r0
;;;286    #if TCP_DEBUG
;;;287      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
;;;288      tcp_debug_print_state(pcb->state);
;;;289    #endif /* TCP_DEBUG */
;;;290    
;;;291      if (pcb->state != LISTEN) {
000008  e5d40018          LDRB     r0,[r4,#0x18]
00000c  e3500001          CMP      r0,#1
000010  0a000002          BEQ      |L8.32|
;;;292        /* Set a flag not to receive any more data... */
;;;293        pcb->flags |= TF_RXCLOSED;
000014  e5d4001e          LDRB     r0,[r4,#0x1e]
000018  e3800010          ORR      r0,r0,#0x10
00001c  e5c4001e          STRB     r0,[r4,#0x1e]
                  |L8.32|
;;;294      }
;;;295      /* ... and close */
;;;296      return tcp_close_shutdown(pcb, 1);
000020  e3a01001          MOV      r1,#1
000024  e1a00004          MOV      r0,r4
000028  ebfffffe          BL       tcp_close_shutdown
;;;297    }
00002c  e8bd8010          POP      {r4,pc}
;;;298    
                          ENDP


                          AREA ||i.tcp_close_shutdown||, CODE, READONLY, ALIGN=2

                  tcp_close_shutdown PROC
;;;169    static err_t
;;;170    tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
000000  e92d407c          PUSH     {r2-r6,lr}
;;;171    {
000004  e1a04000          MOV      r4,r0
000008  e1a06001          MOV      r6,r1
;;;172      err_t err;
;;;173    
;;;174      if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
00000c  e3560000          CMP      r6,#0
000010  0a000061          BEQ      |L9.412|
000014  e5d40018          LDRB     r0,[r4,#0x18]
000018  e3500004          CMP      r0,#4
00001c  0a000002          BEQ      |L9.44|
000020  e5d40018          LDRB     r0,[r4,#0x18]
000024  e3500007          CMP      r0,#7
000028  1a00005b          BNE      |L9.412|
                  |L9.44|
;;;175        if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
00002c  e5940078          LDR      r0,[r4,#0x78]
000030  e3500000          CMP      r0,#0
000034  1a000002          BNE      |L9.68|
000038  e1d402bc          LDRH     r0,[r4,#0x2c]
00003c  e3500e86          CMP      r0,#0x860
000040  0a000055          BEQ      |L9.412|
                  |L9.68|
;;;176          /* Not all data received by application, send RST to tell the remote
;;;177             side about this. */
;;;178          LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
000044  e1a00000          MOV      r0,r0
000048  e5d4001e          LDRB     r0,[r4,#0x1e]
00004c  e2000010          AND      r0,r0,#0x10
000050  e3500000          CMP      r0,#0
000054  1a000006          BNE      |L9.116|
000058  e1a00000          MOV      r0,r0
00005c  e28f3e2b          ADR      r3,|L9.788|
000060  e3a020b2          MOV      r2,#0xb2
000064  e28f1fb1          ADR      r1,|L9.816|
000068  e28f0fb7          ADR      r0,|L9.844|
00006c  ebfffffe          BL       sysprintf
000070  e1a00000          MOV      r0,r0
                  |L9.116|
000074  e1a00000          MOV      r0,r0
;;;179          /* don't call tcp_abort here: we must not deallocate the pcb since
;;;180             that might not be expected when calling tcp_close */
;;;181          tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
000078  e1d401bc          LDRH     r0,[r4,#0x1c]
00007c  e1d411ba          LDRH     r1,[r4,#0x1a]
000080  e58d0004          STR      r0,[sp,#4]
000084  e58d1000          STR      r1,[sp,#0]
000088  e5940050          LDR      r0,[r4,#0x50]
00008c  e5941028          LDR      r1,[r4,#0x28]
000090  e2843004          ADD      r3,r4,#4
000094  e1a02004          MOV      r2,r4
000098  ebfffffe          BL       tcp_rst
;;;182            pcb->local_port, pcb->remote_port);
;;;183    
;;;184          tcp_pcb_purge(pcb);
00009c  e1a00004          MOV      r0,r4
0000a0  ebfffffe          BL       tcp_pcb_purge
;;;185          TCP_RMV_ACTIVE(pcb);
0000a4  e1a00000          MOV      r0,r0
0000a8  e1a00000          MOV      r0,r0
0000ac  e59f02c0          LDR      r0,|L9.884|
0000b0  e5900000          LDR      r0,[r0,#0]  ; tcp_active_pcbs
0000b4  e1500004          CMP      r0,r4
0000b8  1a000005          BNE      |L9.212|
0000bc  e59f02b0          LDR      r0,|L9.884|
0000c0  e5900000          LDR      r0,[r0,#0]  ; tcp_active_pcbs
0000c4  e590000c          LDR      r0,[r0,#0xc]
0000c8  e59f12a4          LDR      r1,|L9.884|
0000cc  e5810000          STR      r0,[r1,#0]  ; tcp_active_pcbs
0000d0  ea000018          B        |L9.312|
                  |L9.212|
0000d4  e59f0298          LDR      r0,|L9.884|
0000d8  e5900000          LDR      r0,[r0,#0]  ; tcp_active_pcbs
0000dc  e59f1294          LDR      r1,|L9.888|
0000e0  e5810000          STR      r0,[r1,#0]  ; tcp_tmp_pcb
0000e4  ea00000e          B        |L9.292|
                  |L9.232|
0000e8  e59f0288          LDR      r0,|L9.888|
0000ec  e5900000          LDR      r0,[r0,#0]  ; tcp_tmp_pcb
0000f0  e590000c          LDR      r0,[r0,#0xc]
0000f4  e1500004          CMP      r0,r4
0000f8  1a000004          BNE      |L9.272|
0000fc  e59f1274          LDR      r1,|L9.888|
000100  e594000c          LDR      r0,[r4,#0xc]
000104  e5911000          LDR      r1,[r1,#0]  ; tcp_tmp_pcb
000108  e581000c          STR      r0,[r1,#0xc]
00010c  ea000008          B        |L9.308|
                  |L9.272|
000110  e59f0260          LDR      r0,|L9.888|
000114  e5900000          LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000118  e590000c          LDR      r0,[r0,#0xc]
00011c  e59f1254          LDR      r1,|L9.888|
000120  e5810000          STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L9.292|
000124  e59f024c          LDR      r0,|L9.888|
000128  e5900000          LDR      r0,[r0,#0]  ; tcp_tmp_pcb
00012c  e3500000          CMP      r0,#0
000130  1affffec          BNE      |L9.232|
                  |L9.308|
000134  e1a00000          MOV      r0,r0
                  |L9.312|
000138  e3a00000          MOV      r0,#0
00013c  e584000c          STR      r0,[r4,#0xc]
000140  e1a00000          MOV      r0,r0
000144  e3a00001          MOV      r0,#1
000148  e59f122c          LDR      r1,|L9.892|
00014c  e5c10000          STRB     r0,[r1,#0]  ; tcp_active_pcbs_changed
000150  e1a00000          MOV      r0,r0
;;;186          if (pcb->state == ESTABLISHED) {
000154  e5d40018          LDRB     r0,[r4,#0x18]
000158  e3500004          CMP      r0,#4
00015c  1a000009          BNE      |L9.392|
;;;187            /* move to TIME_WAIT since we close actively */
;;;188            pcb->state = TIME_WAIT;
000160  e3a0000a          MOV      r0,#0xa
000164  e5c40018          STRB     r0,[r4,#0x18]
;;;189            TCP_REG(&tcp_tw_pcbs, pcb);
000168  e1a00000          MOV      r0,r0
00016c  e59f020c          LDR      r0,|L9.896|
000170  e5900000          LDR      r0,[r0,#0]  ; tcp_tw_pcbs
000174  e584000c          STR      r0,[r4,#0xc]
000178  e59f0200          LDR      r0,|L9.896|
00017c  e5804000          STR      r4,[r0,#0]  ; tcp_tw_pcbs
000180  ebfffffe          BL       tcp_timer_needed
000184  ea000002          B        |L9.404|
                  |L9.392|
;;;190          } else {
;;;191            /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
;;;192            memp_free(MEMP_TCP_PCB, pcb);
000188  e1a01004          MOV      r1,r4
00018c  e3a00001          MOV      r0,#1
000190  ebfffffe          BL       memp_free
                  |L9.404|
;;;193          }
;;;194          return ERR_OK;
000194  e3a00000          MOV      r0,#0
                  |L9.408|
;;;195        }
;;;196      }
;;;197    
;;;198      switch (pcb->state) {
;;;199      case CLOSED:
;;;200        /* Closing a pcb in the CLOSED state might seem erroneous,
;;;201         * however, it is in this state once allocated and as yet unused
;;;202         * and the user needs some way to free it should the need arise.
;;;203         * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;204         * or for a pcb that has been used and then entered the CLOSED state 
;;;205         * is erroneous, but this should never happen as the pcb has in those cases
;;;206         * been freed, and so any remaining handles are bogus. */
;;;207        err = ERR_OK;
;;;208        if (pcb->local_port != 0) {
;;;209          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;210        }
;;;211        memp_free(MEMP_TCP_PCB, pcb);
;;;212        pcb = NULL;
;;;213        break;
;;;214      case LISTEN:
;;;215        err = ERR_OK;
;;;216        tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
;;;217        memp_free(MEMP_TCP_PCB_LISTEN, pcb);
;;;218        pcb = NULL;
;;;219        break;
;;;220      case SYN_SENT:
;;;221        err = ERR_OK;
;;;222        TCP_PCB_REMOVE_ACTIVE(pcb);
;;;223        memp_free(MEMP_TCP_PCB, pcb);
;;;224        pcb = NULL;
;;;225        snmp_inc_tcpattemptfails();
;;;226        break;
;;;227      case SYN_RCVD:
;;;228        err = tcp_send_fin(pcb);
;;;229        if (err == ERR_OK) {
;;;230          snmp_inc_tcpattemptfails();
;;;231          pcb->state = FIN_WAIT_1;
;;;232        }
;;;233        break;
;;;234      case ESTABLISHED:
;;;235        err = tcp_send_fin(pcb);
;;;236        if (err == ERR_OK) {
;;;237          snmp_inc_tcpestabresets();
;;;238          pcb->state = FIN_WAIT_1;
;;;239        }
;;;240        break;
;;;241      case CLOSE_WAIT:
;;;242        err = tcp_send_fin(pcb);
;;;243        if (err == ERR_OK) {
;;;244          snmp_inc_tcpestabresets();
;;;245          pcb->state = LAST_ACK;
;;;246        }
;;;247        break;
;;;248      default:
;;;249        /* Has already been closed, do nothing. */
;;;250        err = ERR_OK;
;;;251        pcb = NULL;
;;;252        break;
;;;253      }
;;;254    
;;;255      if (pcb != NULL && err == ERR_OK) {
;;;256        /* To ensure all data has been sent when tcp_close returns, we have
;;;257           to make sure tcp_output doesn't fail.
;;;258           Since we don't really have to ensure all data has been sent when tcp_close
;;;259           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;260           for the return value of tcp_output for now. */
;;;261        /* @todo: When implementing SO_LINGER, this must be changed somehow:
;;;262           If SOF_LINGER is set, the data should be sent and acked before close returns.
;;;263           This can only be valid for sequential APIs, not for the raw API. */
;;;264        tcp_output(pcb);
;;;265      }
;;;266      return err;
;;;267    }
000198  e8bd807c          POP      {r2-r6,pc}
                  |L9.412|
00019c  e5d40018          LDRB     r0,[r4,#0x18]         ;198
0001a0  e3500008          CMP      r0,#8                 ;198
0001a4  308ff100          ADDCC    pc,pc,r0,LSL #2       ;198
0001a8  ea000089          B        |L9.980|
0001ac  ea000006          B        |L9.460|
0001b0  ea000036          B        |L9.656|
0001b4  ea00003f          B        |L9.696|
0001b8  ea00004c          B        |L9.752|
0001bc  ea000072          B        |L9.908|
0001c0  ea000083          B        |L9.980|
0001c4  ea000082          B        |L9.980|
0001c8  ea000078          B        |L9.944|
                  |L9.460|
0001cc  e1a00000          MOV      r0,r0                 ;199
0001d0  e3a05000          MOV      r5,#0                 ;207
0001d4  e1d401ba          LDRH     r0,[r4,#0x1a]         ;208
0001d8  e3500000          CMP      r0,#0                 ;208
0001dc  0a000026          BEQ      |L9.636|
0001e0  e1a00000          MOV      r0,r0                 ;209
0001e4  e59f0198          LDR      r0,|L9.900|
0001e8  e5900000          LDR      r0,[r0,#0]            ;209  ; tcp_bound_pcbs
0001ec  e1500004          CMP      r0,r4                 ;209
0001f0  1a000005          BNE      |L9.524|
0001f4  e59f0188          LDR      r0,|L9.900|
0001f8  e5900000          LDR      r0,[r0,#0]            ;209  ; tcp_bound_pcbs
0001fc  e590000c          LDR      r0,[r0,#0xc]          ;209
000200  e59f117c          LDR      r1,|L9.900|
000204  e5810000          STR      r0,[r1,#0]            ;209  ; tcp_bound_pcbs
000208  ea000018          B        |L9.624|
                  |L9.524|
00020c  e59f0170          LDR      r0,|L9.900|
000210  e5900000          LDR      r0,[r0,#0]            ;209  ; tcp_bound_pcbs
000214  e59f115c          LDR      r1,|L9.888|
000218  e5810000          STR      r0,[r1,#0]            ;209  ; tcp_tmp_pcb
00021c  ea00000e          B        |L9.604|
                  |L9.544|
000220  e59f0150          LDR      r0,|L9.888|
000224  e5900000          LDR      r0,[r0,#0]            ;209  ; tcp_tmp_pcb
000228  e590000c          LDR      r0,[r0,#0xc]          ;209
00022c  e1500004          CMP      r0,r4                 ;209
000230  1a000004          BNE      |L9.584|
000234  e59f113c          LDR      r1,|L9.888|
000238  e594000c          LDR      r0,[r4,#0xc]          ;209
00023c  e5911000          LDR      r1,[r1,#0]            ;209  ; tcp_tmp_pcb
000240  e581000c          STR      r0,[r1,#0xc]          ;209
000244  ea000008          B        |L9.620|
                  |L9.584|
000248  e59f0128          LDR      r0,|L9.888|
00024c  e5900000          LDR      r0,[r0,#0]            ;209  ; tcp_tmp_pcb
000250  e590000c          LDR      r0,[r0,#0xc]          ;209
000254  e59f111c          LDR      r1,|L9.888|
000258  e5810000          STR      r0,[r1,#0]            ;209  ; tcp_tmp_pcb
                  |L9.604|
00025c  e59f0114          LDR      r0,|L9.888|
000260  e5900000          LDR      r0,[r0,#0]            ;209  ; tcp_tmp_pcb
000264  e3500000          CMP      r0,#0                 ;209
000268  1affffec          BNE      |L9.544|
                  |L9.620|
00026c  e1a00000          MOV      r0,r0                 ;209
                  |L9.624|
000270  e3a00000          MOV      r0,#0                 ;209
000274  e584000c          STR      r0,[r4,#0xc]          ;209
000278  e1a00000          MOV      r0,r0                 ;209
                  |L9.636|
00027c  e1a01004          MOV      r1,r4                 ;211
000280  e3a00001          MOV      r0,#1                 ;211
000284  ebfffffe          BL       memp_free
000288  e3a04000          MOV      r4,#0                 ;212
00028c  ea000054          B        |L9.996|
                  |L9.656|
000290  e1a00000          MOV      r0,r0                 ;214
000294  e3a05000          MOV      r5,#0                 ;215
000298  e1a01004          MOV      r1,r4                 ;216
00029c  e59f00e4          LDR      r0,|L9.904|
0002a0  ebfffffe          BL       tcp_pcb_remove
0002a4  e1a01004          MOV      r1,r4                 ;217
0002a8  e3a00002          MOV      r0,#2                 ;217
0002ac  ebfffffe          BL       memp_free
0002b0  e3a04000          MOV      r4,#0                 ;218
0002b4  ea00004a          B        |L9.996|
                  |L9.696|
0002b8  e1a00000          MOV      r0,r0                 ;220
0002bc  e3a05000          MOV      r5,#0                 ;221
0002c0  e1a00000          MOV      r0,r0                 ;222
0002c4  e1a01004          MOV      r1,r4                 ;222
0002c8  e59f00a4          LDR      r0,|L9.884|
0002cc  ebfffffe          BL       tcp_pcb_remove
0002d0  e3a00001          MOV      r0,#1                 ;222
0002d4  e59f10a0          LDR      r1,|L9.892|
0002d8  e5c10000          STRB     r0,[r1,#0]            ;222  ; tcp_active_pcbs_changed
0002dc  e1a00000          MOV      r0,r0                 ;222
0002e0  e1a01004          MOV      r1,r4                 ;223
0002e4  ebfffffe          BL       memp_free
0002e8  e3a04000          MOV      r4,#0                 ;224
0002ec  ea00003c          B        |L9.996|
                  |L9.752|
0002f0  e1a00000          MOV      r0,r0                 ;227
0002f4  e1a00004          MOV      r0,r4                 ;228
0002f8  ebfffffe          BL       tcp_send_fin
0002fc  e1a05000          MOV      r5,r0                 ;228
000300  e3550000          CMP      r5,#0                 ;229
000304  1a000001          BNE      |L9.784|
000308  e3a00005          MOV      r0,#5                 ;231
00030c  e5c40018          STRB     r0,[r4,#0x18]         ;231
                  |L9.784|
000310  ea000033          B        |L9.996|
                  |L9.788|
000314  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
000318  2d312e34
00031c  2e315c73
000320  72635c63
000324  6f72655c
000328  7463702e
00032c  6300    
00032e  00                DCB      0
00032f  00                DCB      0
                  |L9.816|
000330  7063622d          DCB      "pcb->flags & TF_RXCLOSED",0
000334  3e666c61
000338  67732026
00033c  2054465f
000340  5258434c
000344  4f534544
000348  00      
000349  00                DCB      0
00034a  00                DCB      0
00034b  00                DCB      0
                  |L9.844|
00034c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000350  7274696f
000354  6e202225
000358  73222066
00035c  61696c65
000360  64206174
000364  206c696e
000368  65202564
00036c  20696e20
000370  25730a00
                  |L9.884|
                          DCD      tcp_active_pcbs
                  |L9.888|
                          DCD      tcp_tmp_pcb
                  |L9.892|
                          DCD      tcp_active_pcbs_changed
                  |L9.896|
                          DCD      tcp_tw_pcbs
                  |L9.900|
                          DCD      tcp_bound_pcbs
                  |L9.904|
                          DCD      tcp_listen_pcbs
                  |L9.908|
00038c  e1a00000          MOV      r0,r0                 ;234
000390  e1a00004          MOV      r0,r4                 ;235
000394  ebfffffe          BL       tcp_send_fin
000398  e1a05000          MOV      r5,r0                 ;235
00039c  e3550000          CMP      r5,#0                 ;236
0003a0  1a000001          BNE      |L9.940|
0003a4  e3a00005          MOV      r0,#5                 ;238
0003a8  e5c40018          STRB     r0,[r4,#0x18]         ;238
                  |L9.940|
0003ac  ea00000c          B        |L9.996|
                  |L9.944|
0003b0  e1a00000          MOV      r0,r0                 ;241
0003b4  e1a00004          MOV      r0,r4                 ;242
0003b8  ebfffffe          BL       tcp_send_fin
0003bc  e1a05000          MOV      r5,r0                 ;242
0003c0  e3550000          CMP      r5,#0                 ;243
0003c4  1a000001          BNE      |L9.976|
0003c8  e3a00009          MOV      r0,#9                 ;245
0003cc  e5c40018          STRB     r0,[r4,#0x18]         ;245
                  |L9.976|
0003d0  ea000003          B        |L9.996|
                  |L9.980|
0003d4  e1a00000          MOV      r0,r0                 ;248
0003d8  e3a05000          MOV      r5,#0                 ;250
0003dc  e3a04000          MOV      r4,#0                 ;251
0003e0  e1a00000          MOV      r0,r0                 ;252
                  |L9.996|
0003e4  e1a00000          MOV      r0,r0                 ;213
0003e8  e3540000          CMP      r4,#0                 ;255
0003ec  0a000003          BEQ      |L9.1024|
0003f0  e3550000          CMP      r5,#0                 ;255
0003f4  1a000001          BNE      |L9.1024|
0003f8  e1a00004          MOV      r0,r4                 ;264
0003fc  ebfffffe          BL       tcp_output
                  |L9.1024|
000400  e1a00005          MOV      r0,r5                 ;266
000404  eaffff63          B        |L9.408|
;;;268    
                          ENDP


                          AREA ||i.tcp_connect||, CODE, READONLY, ALIGN=2

                  tcp_connect PROC
;;;682    err_t
;;;683    tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;684          tcp_connected_fn connected)
;;;685    {
000004  e1a04000          MOV      r4,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a08002          MOV      r8,r2
000010  e1a09003          MOV      r9,r3
;;;686      err_t ret;
;;;687      u32_t iss;
;;;688      u16_t old_local_port;
;;;689    
;;;690      LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
000014  e1a00000          MOV      r0,r0
000018  e5d40018          LDRB     r0,[r4,#0x18]
00001c  e3500000          CMP      r0,#0
000020  0a000008          BEQ      |L10.72|
000024  e1a00000          MOV      r0,r0
000028  e28f3f89          ADR      r3,|L10.596|
00002c  e59f223c          LDR      r2,|L10.624|
000030  e28f1f8f          ADR      r1,|L10.628|
000034  e28f0f9a          ADR      r0,|L10.676|
000038  ebfffffe          BL       sysprintf
00003c  e1a00000          MOV      r0,r0
000040  e3e00008          MVN      r0,#8
                  |L10.68|
;;;691    
;;;692      LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;693      if (ipaddr != NULL) {
;;;694        pcb->remote_ip = *ipaddr;
;;;695      } else {
;;;696        return ERR_VAL;
;;;697      }
;;;698      pcb->remote_port = port;
;;;699    
;;;700      /* check if we have a route to the remote host */
;;;701      if (ip_addr_isany(&(pcb->local_ip))) {
;;;702        /* no local IP address set, yet. */
;;;703        struct netif *netif = ip_route(&(pcb->remote_ip));
;;;704        if (netif == NULL) {
;;;705          /* Don't even try to send a SYN packet if we have no route
;;;706             since that will fail. */
;;;707          return ERR_RTE;
;;;708        }
;;;709        /* Use the netif's IP address as local address. */
;;;710        ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;711      }
;;;712    
;;;713      old_local_port = pcb->local_port;
;;;714      if (pcb->local_port == 0) {
;;;715        pcb->local_port = tcp_new_port();
;;;716        if (pcb->local_port == 0) {
;;;717          return ERR_BUF;
;;;718        }
;;;719      }
;;;720    #if SO_REUSE
;;;721      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;722        /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
;;;723           now that the 5-tuple is unique. */
;;;724        struct tcp_pcb *cpcb;
;;;725        int i;
;;;726        /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
;;;727        for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
;;;728          for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;729            if ((cpcb->local_port == pcb->local_port) &&
;;;730                (cpcb->remote_port == port) &&
;;;731                ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
;;;732                ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
;;;733              /* linux returns EISCONN here, but ERR_USE should be OK for us */
;;;734              return ERR_USE;
;;;735            }
;;;736          }
;;;737        }
;;;738      }
;;;739    #endif /* SO_REUSE */
;;;740      iss = tcp_next_iss();
;;;741      pcb->rcv_nxt = 0;
;;;742      pcb->snd_nxt = iss;
;;;743      pcb->lastack = iss - 1;
;;;744      pcb->snd_lbb = iss - 1;
;;;745      pcb->rcv_wnd = TCP_WND;
;;;746      pcb->rcv_ann_wnd = TCP_WND;
;;;747      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;748      pcb->snd_wnd = TCP_WND;
;;;749      /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;750         The send MSS is updated when an MSS option is received. */
;;;751      pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
;;;752    #if TCP_CALCULATE_EFF_SEND_MSS
;;;753      pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
;;;754    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;755      pcb->cwnd = 1;
;;;756      pcb->ssthresh = pcb->mss * 10;
;;;757    #if LWIP_CALLBACK_API
;;;758      pcb->connected = connected;
;;;759    #else /* LWIP_CALLBACK_API */  
;;;760      LWIP_UNUSED_ARG(connected);
;;;761    #endif /* LWIP_CALLBACK_API */
;;;762    
;;;763      /* Send a SYN together with the MSS option. */
;;;764      ret = tcp_enqueue_flags(pcb, TCP_SYN);
;;;765      if (ret == ERR_OK) {
;;;766        /* SYN segment was enqueued, changed the pcbs state now */
;;;767        pcb->state = SYN_SENT;
;;;768        if (old_local_port != 0) {
;;;769          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;770        }
;;;771        TCP_REG_ACTIVE(pcb);
;;;772        snmp_inc_tcpactiveopens();
;;;773    
;;;774        tcp_output(pcb);
;;;775      }
;;;776      return ret;
;;;777    }
000044  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.72|
000048  e1a00000          MOV      r0,r0                 ;690
00004c  e3560000          CMP      r6,#0                 ;693
000050  0a000002          BEQ      |L10.96|
000054  e5960000          LDR      r0,[r6,#0]            ;694
000058  e5840004          STR      r0,[r4,#4]            ;694
00005c  ea000001          B        |L10.104|
                  |L10.96|
000060  e3e00005          MVN      r0,#5                 ;696
000064  eafffff6          B        |L10.68|
                  |L10.104|
000068  e1c481bc          STRH     r8,[r4,#0x1c]         ;698
00006c  e3540000          CMP      r4,#0                 ;701
000070  0a000002          BEQ      |L10.128|
000074  e5940000          LDR      r0,[r4,#0]            ;701
000078  e3500000          CMP      r0,#0                 ;701
00007c  1a000009          BNE      |L10.168|
                  |L10.128|
000080  e2840004          ADD      r0,r4,#4              ;703
000084  ebfffffe          BL       ip_route
000088  e1a0b000          MOV      r11,r0                ;703
00008c  e35b0000          CMP      r11,#0                ;704
000090  1a000001          BNE      |L10.156|
000094  e3e00003          MVN      r0,#3                 ;707
000098  eaffffe9          B        |L10.68|
                  |L10.156|
00009c  e59b0004          LDR      r0,[r11,#4]           ;710
0000a0  e5840000          STR      r0,[r4,#0]            ;710
0000a4  e1a00000          MOV      r0,r0                 ;711
                  |L10.168|
0000a8  e1d4a1ba          LDRH     r10,[r4,#0x1a]        ;713
0000ac  e1d401ba          LDRH     r0,[r4,#0x1a]         ;714
0000b0  e3500000          CMP      r0,#0                 ;714
0000b4  1a000006          BNE      |L10.212|
0000b8  ebfffffe          BL       tcp_new_port
0000bc  e1c401ba          STRH     r0,[r4,#0x1a]         ;715
0000c0  e1d401ba          LDRH     r0,[r4,#0x1a]         ;716
0000c4  e3500000          CMP      r0,#0                 ;716
0000c8  1a000001          BNE      |L10.212|
0000cc  e3e00001          MVN      r0,#1                 ;717
0000d0  eaffffdb          B        |L10.68|
                  |L10.212|
0000d4  ebfffffe          BL       tcp_next_iss
0000d8  e1a05000          MOV      r5,r0                 ;740
0000dc  e3a00000          MOV      r0,#0                 ;741
0000e0  e5840028          STR      r0,[r4,#0x28]         ;741
0000e4  e5845050          STR      r5,[r4,#0x50]         ;742
0000e8  e2450001          SUB      r0,r5,#1              ;743
0000ec  e5840048          STR      r0,[r4,#0x48]         ;743
0000f0  e2450001          SUB      r0,r5,#1              ;744
0000f4  e584005c          STR      r0,[r4,#0x5c]         ;744
0000f8  e3a00e86          MOV      r0,#0x860             ;745
0000fc  e1c402bc          STRH     r0,[r4,#0x2c]         ;745
000100  e1c402be          STRH     r0,[r4,#0x2e]         ;746
000104  e5940028          LDR      r0,[r4,#0x28]         ;747
000108  e5840030          STR      r0,[r4,#0x30]         ;747
00010c  e3a00e86          MOV      r0,#0x860             ;748
000110  e1c406b0          STRH     r0,[r4,#0x60]         ;748
000114  e3a00f86          MOV      r0,#0x218             ;751
000118  e1c403b6          STRH     r0,[r4,#0x36]         ;751
00011c  e1d403b6          LDRH     r0,[r4,#0x36]         ;753
000120  e1a01006          MOV      r1,r6                 ;753
000124  ebfffffe          BL       tcp_eff_send_mss
000128  e1c403b6          STRH     r0,[r4,#0x36]         ;753
00012c  e3a00001          MOV      r0,#1                 ;755
000130  e1c404bc          STRH     r0,[r4,#0x4c]         ;755
000134  e1d403b6          LDRH     r0,[r4,#0x36]         ;756
000138  e0800100          ADD      r0,r0,r0,LSL #2       ;756
00013c  e59f1188          LDR      r1,|L10.716|
000140  e0010080          AND      r0,r1,r0,LSL #1       ;756
000144  e1c404be          STRH     r0,[r4,#0x4e]         ;756
000148  e5849084          STR      r9,[r4,#0x84]         ;758
00014c  e3a01002          MOV      r1,#2                 ;764
000150  e1a00004          MOV      r0,r4                 ;764
000154  ebfffffe          BL       tcp_enqueue_flags
000158  e1a07000          MOV      r7,r0                 ;764
00015c  e3570000          CMP      r7,#0                 ;765
000160  1a000039          BNE      |L10.588|
000164  e3a00002          MOV      r0,#2                 ;767
000168  e5c40018          STRB     r0,[r4,#0x18]         ;767
00016c  e35a0000          CMP      r10,#0                ;768
000170  0a000026          BEQ      |L10.528|
000174  e1a00000          MOV      r0,r0                 ;769
000178  e59f0150          LDR      r0,|L10.720|
00017c  e5900000          LDR      r0,[r0,#0]            ;769  ; tcp_bound_pcbs
000180  e1500004          CMP      r0,r4                 ;769
000184  1a000005          BNE      |L10.416|
000188  e59f0140          LDR      r0,|L10.720|
00018c  e5900000          LDR      r0,[r0,#0]            ;769  ; tcp_bound_pcbs
000190  e590000c          LDR      r0,[r0,#0xc]          ;769
000194  e59f1134          LDR      r1,|L10.720|
000198  e5810000          STR      r0,[r1,#0]            ;769  ; tcp_bound_pcbs
00019c  ea000018          B        |L10.516|
                  |L10.416|
0001a0  e59f0128          LDR      r0,|L10.720|
0001a4  e5900000          LDR      r0,[r0,#0]            ;769  ; tcp_bound_pcbs
0001a8  e59f1124          LDR      r1,|L10.724|
0001ac  e5810000          STR      r0,[r1,#0]            ;769  ; tcp_tmp_pcb
0001b0  ea00000e          B        |L10.496|
                  |L10.436|
0001b4  e59f0118          LDR      r0,|L10.724|
0001b8  e5900000          LDR      r0,[r0,#0]            ;769  ; tcp_tmp_pcb
0001bc  e590000c          LDR      r0,[r0,#0xc]          ;769
0001c0  e1500004          CMP      r0,r4                 ;769
0001c4  1a000004          BNE      |L10.476|
0001c8  e59f1104          LDR      r1,|L10.724|
0001cc  e594000c          LDR      r0,[r4,#0xc]          ;769
0001d0  e5911000          LDR      r1,[r1,#0]            ;769  ; tcp_tmp_pcb
0001d4  e581000c          STR      r0,[r1,#0xc]          ;769
0001d8  ea000008          B        |L10.512|
                  |L10.476|
0001dc  e59f00f0          LDR      r0,|L10.724|
0001e0  e5900000          LDR      r0,[r0,#0]            ;769  ; tcp_tmp_pcb
0001e4  e590000c          LDR      r0,[r0,#0xc]          ;769
0001e8  e59f10e4          LDR      r1,|L10.724|
0001ec  e5810000          STR      r0,[r1,#0]            ;769  ; tcp_tmp_pcb
                  |L10.496|
0001f0  e59f00dc          LDR      r0,|L10.724|
0001f4  e5900000          LDR      r0,[r0,#0]            ;769  ; tcp_tmp_pcb
0001f8  e3500000          CMP      r0,#0                 ;769
0001fc  1affffec          BNE      |L10.436|
                  |L10.512|
000200  e1a00000          MOV      r0,r0                 ;769
                  |L10.516|
000204  e3a00000          MOV      r0,#0                 ;769
000208  e584000c          STR      r0,[r4,#0xc]          ;769
00020c  e1a00000          MOV      r0,r0                 ;769
                  |L10.528|
000210  e1a00000          MOV      r0,r0                 ;771
000214  e1a00000          MOV      r0,r0                 ;771
000218  e59f00b8          LDR      r0,|L10.728|
00021c  e5900000          LDR      r0,[r0,#0]            ;771  ; tcp_active_pcbs
000220  e584000c          STR      r0,[r4,#0xc]          ;771
000224  e59f00ac          LDR      r0,|L10.728|
000228  e5804000          STR      r4,[r0,#0]            ;771  ; tcp_active_pcbs
00022c  ebfffffe          BL       tcp_timer_needed
000230  e1a00000          MOV      r0,r0                 ;771
000234  e3a00001          MOV      r0,#1                 ;771
000238  e59f109c          LDR      r1,|L10.732|
00023c  e5c10000          STRB     r0,[r1,#0]            ;771  ; tcp_active_pcbs_changed
000240  e1a00000          MOV      r0,r0                 ;771
000244  e1a00004          MOV      r0,r4                 ;774
000248  ebfffffe          BL       tcp_output
                  |L10.588|
00024c  e1a00007          MOV      r0,r7                 ;776
000250  eaffff7b          B        |L10.68|
                  |L10.596|
000254  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
000258  2d312e34
00025c  2e315c73
000260  72635c63
000264  6f72655c
000268  7463702e
00026c  6300    
00026e  00                DCB      0
00026f  00                DCB      0
                  |L10.624|
                          DCD      0x000002b2
                  |L10.628|
000274  7463705f          DCB      "tcp_connect: can only connect from state CLOSED",0
000278  636f6e6e
00027c  6563743a
000280  2063616e
000284  206f6e6c
000288  7920636f
00028c  6e6e6563
000290  74206672
000294  6f6d2073
000298  74617465
00029c  20434c4f
0002a0  53454400
                  |L10.676|
0002a4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0002a8  7274696f
0002ac  6e202225
0002b0  73222066
0002b4  61696c65
0002b8  64206174
0002bc  206c696e
0002c0  65202564
0002c4  20696e20
0002c8  25730a00
                  |L10.716|
                          DCD      0x0000ffff
                  |L10.720|
                          DCD      tcp_bound_pcbs
                  |L10.724|
                          DCD      tcp_tmp_pcb
                  |L10.728|
                          DCD      tcp_active_pcbs
                  |L10.732|
                          DCD      tcp_active_pcbs_changed
                          ENDP


                          AREA ||i.tcp_debug_state_str||, CODE, READONLY, ALIGN=2

                  tcp_debug_state_str PROC
;;;1603   const char*
;;;1604   tcp_debug_state_str(enum tcp_state s)
000000  e1a01000          MOV      r1,r0
;;;1605   {
;;;1606     return tcp_state_str[s];
000004  e59f0004          LDR      r0,|L11.16|
000008  e7900101          LDR      r0,[r0,r1,LSL #2]
;;;1607   }
00000c  e12fff1e          BX       lr
;;;1608   
                          ENDP

                  |L11.16|
                          DCD      tcp_state_str

                          AREA ||i.tcp_eff_send_mss||, CODE, READONLY, ALIGN=2

                  tcp_eff_send_mss PROC
;;;1584   u16_t
;;;1585   tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1586   {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;1587     u16_t mss_s;
;;;1588     struct netif *outif;
;;;1589   
;;;1590     outif = ip_route(addr);
00000c  e1a00006          MOV      r0,r6
000010  ebfffffe          BL       ip_route
000014  e1a04000          MOV      r4,r0
;;;1591     if ((outif != NULL) && (outif->mtu != 0)) {
000018  e3540000          CMP      r4,#0
00001c  0a00000c          BEQ      |L12.84|
000020  e1d402b4          LDRH     r0,[r4,#0x24]
000024  e3500000          CMP      r0,#0
000028  0a000009          BEQ      |L12.84|
;;;1592       mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
00002c  e1d402b4          LDRH     r0,[r4,#0x24]
000030  e2400028          SUB      r0,r0,#0x28
000034  e1a07800          LSL      r7,r0,#16
000038  e1a07827          LSR      r7,r7,#16
;;;1593       /* RFC 1122, chap 4.2.2.6:
;;;1594        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;1595        * We correct for TCP options in tcp_write(), and don't support IP options.
;;;1596        */
;;;1597       sendmss = LWIP_MIN(sendmss, mss_s);
00003c  e1550007          CMP      r5,r7
000040  aa000001          BGE      |L12.76|
000044  e1a00005          MOV      r0,r5
000048  ea000000          B        |L12.80|
                  |L12.76|
00004c  e1a00007          MOV      r0,r7
                  |L12.80|
000050  e1a05000          MOV      r5,r0
                  |L12.84|
;;;1598     }
;;;1599     return sendmss;
000054  e1a00005          MOV      r0,r5
;;;1600   }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;1601   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP


                          AREA ||i.tcp_err||, CODE, READONLY, ALIGN=2

                  tcp_err PROC
;;;1419   void
;;;1420   tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1421   {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;1422     LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
00000c  e1a00000          MOV      r0,r0
000010  e5d40018          LDRB     r0,[r4,#0x18]
000014  e3500001          CMP      r0,#1
000018  1a000006          BNE      |L13.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f301c          ADR      r3,|L13.68|
000024  e59f2034          LDR      r2,|L13.96|
000028  e28f1034          ADR      r1,|L13.100|
00002c  e28f0058          ADR      r0,|L13.140|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L13.56|
000038  e1a00000          MOV      r0,r0
;;;1423     pcb->errf = err;
00003c  e584508c          STR      r5,[r4,#0x8c]
;;;1424   }
000040  e8bd8070          POP      {r4-r6,pc}
;;;1425   
                          ENDP

                  |L13.68|
000044  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
000048  2d312e34
00004c  2e315c73
000050  72635c63
000054  6f72655c
000058  7463702e
00005c  6300    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L13.96|
                          DCD      0x0000058e
                  |L13.100|
000064  696e7661          DCB      "invalid socket state for err callback",0
000068  6c696420
00006c  736f636b
000070  65742073
000074  74617465
000078  20666f72
00007c  20657272
000080  2063616c
000084  6c626163
000088  6b00    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L13.140|
00008c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000090  7274696f
000094  6e202225
000098  73222066
00009c  61696c65
0000a0  64206174
0000a4  206c696e
0000a8  65202564
0000ac  20696e20
0000b0  25730a00

                          AREA ||i.tcp_fasttmr||, CODE, READONLY, ALIGN=2

                  tcp_fasttmr PROC
;;;1044   void
;;;1045   tcp_fasttmr(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1046   {
;;;1047     struct tcp_pcb *pcb;
;;;1048   
;;;1049     ++tcp_timer_ctr;
000004  e59f00c0          LDR      r0,|L14.204|
000008  e5d00000          LDRB     r0,[r0,#0]  ; tcp_timer_ctr
00000c  e2800001          ADD      r0,r0,#1
000010  e59f10b4          LDR      r1,|L14.204|
000014  e5c10000          STRB     r0,[r1,#0]  ; tcp_timer_ctr
;;;1050   
;;;1051   tcp_fasttmr_start:
000018  e1a00000          MOV      r0,r0
                  |L14.28|
;;;1052     pcb = tcp_active_pcbs;
00001c  e59f00ac          LDR      r0,|L14.208|
000020  e5904000          LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;1053   
;;;1054     while(pcb != NULL) {
000024  ea000025          B        |L14.192|
                  |L14.40|
;;;1055       if (pcb->last_timer != tcp_timer_ctr) {
000028  e5d40021          LDRB     r0,[r4,#0x21]
00002c  e59f1098          LDR      r1,|L14.204|
000030  e5d11000          LDRB     r1,[r1,#0]  ; tcp_timer_ctr
000034  e1500001          CMP      r0,r1
000038  0a000020          BEQ      |L14.192|
;;;1056         struct tcp_pcb *next;
;;;1057         pcb->last_timer = tcp_timer_ctr;
00003c  e59f0088          LDR      r0,|L14.204|
000040  e5d00000          LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000044  e5c40021          STRB     r0,[r4,#0x21]
;;;1058         /* send delayed ACKs */
;;;1059         if (pcb->flags & TF_ACK_DELAY) {
000048  e5d4001e          LDRB     r0,[r4,#0x1e]
00004c  e2000001          AND      r0,r0,#1
000050  e3500000          CMP      r0,#0
000054  0a000009          BEQ      |L14.128|
;;;1060           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
;;;1061           tcp_ack_now(pcb);
000058  e1a00000          MOV      r0,r0
00005c  e5d4001e          LDRB     r0,[r4,#0x1e]
000060  e3800002          ORR      r0,r0,#2
000064  e5c4001e          STRB     r0,[r4,#0x1e]
000068  e1a00000          MOV      r0,r0
;;;1062           tcp_output(pcb);
00006c  e1a00004          MOV      r0,r4
000070  ebfffffe          BL       tcp_output
;;;1063           pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
000074  e5d4001e          LDRB     r0,[r4,#0x1e]
000078  e3c00003          BIC      r0,r0,#3
00007c  e5c4001e          STRB     r0,[r4,#0x1e]
                  |L14.128|
;;;1064         }
;;;1065   
;;;1066         next = pcb->next;
000080  e594500c          LDR      r5,[r4,#0xc]
;;;1067   
;;;1068         /* If there is data which was previously "refused" by upper layer */
;;;1069         if (pcb->refused_data != NULL) {
000084  e5940078          LDR      r0,[r4,#0x78]
000088  e3500000          CMP      r0,#0
00008c  0a000009          BEQ      |L14.184|
;;;1070           tcp_active_pcbs_changed = 0;
000090  e3a00000          MOV      r0,#0
000094  e59f1038          LDR      r1,|L14.212|
000098  e5c10000          STRB     r0,[r1,#0]  ; tcp_active_pcbs_changed
;;;1071           tcp_process_refused_data(pcb);
00009c  e1a00004          MOV      r0,r4
0000a0  ebfffffe          BL       tcp_process_refused_data
;;;1072           if (tcp_active_pcbs_changed) {
0000a4  e59f0028          LDR      r0,|L14.212|
0000a8  e5d00000          LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
0000ac  e3500000          CMP      r0,#0
0000b0  0a000000          BEQ      |L14.184|
;;;1073             /* application callback has changed the pcb list: restart the loop */
;;;1074             goto tcp_fasttmr_start;
0000b4  eaffffd8          B        |L14.28|
                  |L14.184|
;;;1075           }
;;;1076         }
;;;1077         pcb = next;
0000b8  e1a04005          MOV      r4,r5
;;;1078       }
0000bc  e1a00000          MOV      r0,r0
                  |L14.192|
0000c0  e3540000          CMP      r4,#0                 ;1054
0000c4  1affffd7          BNE      |L14.40|
;;;1079     }
;;;1080   }
0000c8  e8bd8070          POP      {r4-r6,pc}
;;;1081   
                          ENDP

                  |L14.204|
                          DCD      tcp_timer_ctr
                  |L14.208|
                          DCD      tcp_active_pcbs
                  |L14.212|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_init||, CODE, READONLY, ALIGN=2

                  tcp_init PROC
;;;129    void
;;;130    tcp_init(void)
000000  e12fff1e          BX       lr
;;;131    {
;;;132    #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;133      tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;134    #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;135    }
;;;136    
                          ENDP


                          AREA ||i.tcp_kill_prio||, CODE, READONLY, ALIGN=2

                  tcp_kill_prio PROC
;;;1215   static void
;;;1216   tcp_kill_prio(u8_t prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1217   {
000004  e1a06000          MOV      r6,r0
;;;1218     struct tcp_pcb *pcb, *inactive;
;;;1219     u32_t inactivity;
;;;1220     u8_t mprio;
;;;1221   
;;;1222   
;;;1223     mprio = TCP_PRIO_MAX;
000008  e3a0807f          MOV      r8,#0x7f
;;;1224     
;;;1225     /* We kill the oldest active connection that has lower priority than prio. */
;;;1226     inactivity = 0;
00000c  e3a07000          MOV      r7,#0
;;;1227     inactive = NULL;
000010  e3a05000          MOV      r5,#0
;;;1228     for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000014  e59f006c          LDR      r0,|L16.136|
000018  e5904000          LDR      r4,[r0,#0]  ; tcp_active_pcbs
00001c  ea000012          B        |L16.108|
                  |L16.32|
;;;1229       if (pcb->prio <= prio &&
000020  e5d40019          LDRB     r0,[r4,#0x19]
000024  e1500006          CMP      r0,r6
000028  ca00000e          BGT      |L16.104|
;;;1230          pcb->prio <= mprio &&
00002c  e5d40019          LDRB     r0,[r4,#0x19]
000030  e1500008          CMP      r0,r8
000034  ca00000b          BGT      |L16.104|
;;;1231          (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
000038  e59f104c          LDR      r1,|L16.140|
00003c  e5940024          LDR      r0,[r4,#0x24]
000040  e5911000          LDR      r1,[r1,#0]  ; tcp_ticks
000044  e0410000          SUB      r0,r1,r0
000048  e1500007          CMP      r0,r7
00004c  3a000005          BCC      |L16.104|
;;;1232         inactivity = tcp_ticks - pcb->tmr;
000050  e59f1034          LDR      r1,|L16.140|
000054  e5940024          LDR      r0,[r4,#0x24]
000058  e5911000          LDR      r1,[r1,#0]  ; tcp_ticks
00005c  e0417000          SUB      r7,r1,r0
;;;1233         inactive = pcb;
000060  e1a05004          MOV      r5,r4
;;;1234         mprio = pcb->prio;
000064  e5d48019          LDRB     r8,[r4,#0x19]
                  |L16.104|
000068  e594400c          LDR      r4,[r4,#0xc]          ;1228
                  |L16.108|
00006c  e3540000          CMP      r4,#0                 ;1228
000070  1affffea          BNE      |L16.32|
;;;1235       }
;;;1236     }
;;;1237     if (inactive != NULL) {
000074  e3550000          CMP      r5,#0
000078  0a000001          BEQ      |L16.132|
;;;1238       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
;;;1239              (void *)inactive, inactivity));
;;;1240       tcp_abort(inactive);
00007c  e1a00005          MOV      r0,r5
000080  ebfffffe          BL       tcp_abort
                  |L16.132|
;;;1241     }
;;;1242   }
000084  e8bd81f0          POP      {r4-r8,pc}
;;;1243   
                          ENDP

                  |L16.136|
                          DCD      tcp_active_pcbs
                  |L16.140|
                          DCD      tcp_ticks

                          AREA ||i.tcp_kill_timewait||, CODE, READONLY, ALIGN=2

                  tcp_kill_timewait PROC
;;;1248   static void
;;;1249   tcp_kill_timewait(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1250   {
;;;1251     struct tcp_pcb *pcb, *inactive;
;;;1252     u32_t inactivity;
;;;1253   
;;;1254     inactivity = 0;
000004  e3a06000          MOV      r6,#0
;;;1255     inactive = NULL;
000008  e3a05000          MOV      r5,#0
;;;1256     /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
;;;1257     for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
00000c  e59f0050          LDR      r0,|L17.100|
000010  e5904000          LDR      r4,[r0,#0]  ; tcp_tw_pcbs
000014  ea00000b          B        |L17.72|
                  |L17.24|
;;;1258       if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
000018  e59f1048          LDR      r1,|L17.104|
00001c  e5940024          LDR      r0,[r4,#0x24]
000020  e5911000          LDR      r1,[r1,#0]  ; tcp_ticks
000024  e0410000          SUB      r0,r1,r0
000028  e1500006          CMP      r0,r6
00002c  3a000004          BCC      |L17.68|
;;;1259         inactivity = tcp_ticks - pcb->tmr;
000030  e59f1030          LDR      r1,|L17.104|
000034  e5940024          LDR      r0,[r4,#0x24]
000038  e5911000          LDR      r1,[r1,#0]  ; tcp_ticks
00003c  e0416000          SUB      r6,r1,r0
;;;1260         inactive = pcb;
000040  e1a05004          MOV      r5,r4
                  |L17.68|
000044  e594400c          LDR      r4,[r4,#0xc]          ;1257
                  |L17.72|
000048  e3540000          CMP      r4,#0                 ;1257
00004c  1afffff1          BNE      |L17.24|
;;;1261       }
;;;1262     }
;;;1263     if (inactive != NULL) {
000050  e3550000          CMP      r5,#0
000054  0a000001          BEQ      |L17.96|
;;;1264       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
;;;1265              (void *)inactive, inactivity));
;;;1266       tcp_abort(inactive);
000058  e1a00005          MOV      r0,r5
00005c  ebfffffe          BL       tcp_abort
                  |L17.96|
;;;1267     }
;;;1268   }
000060  e8bd8070          POP      {r4-r6,pc}
;;;1269   
                          ENDP

                  |L17.100|
                          DCD      tcp_tw_pcbs
                  |L17.104|
                          DCD      tcp_ticks

                          AREA ||i.tcp_listen_with_backlog||, CODE, READONLY, ALIGN=2

                  tcp_listen_with_backlog PROC
;;;517    struct tcp_pcb *
;;;518    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;519    {
000004  e1a04000          MOV      r4,r0
000008  e1a06001          MOV      r6,r1
;;;520      struct tcp_pcb_listen *lpcb;
;;;521    
;;;522      LWIP_UNUSED_ARG(backlog);
;;;523      LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
00000c  e1a00000          MOV      r0,r0
000010  e5d40018          LDRB     r0,[r4,#0x18]
000014  e3500000          CMP      r0,#0
000018  0a000008          BEQ      |L18.64|
00001c  e1a00000          MOV      r0,r0
000020  e28f3f5f          ADR      r3,|L18.420|
000024  e59f2194          LDR      r2,|L18.448|
000028  e28f1f65          ADR      r1,|L18.452|
00002c  e28f0f6d          ADR      r0,|L18.488|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
000038  e3a00000          MOV      r0,#0
                  |L18.60|
;;;524    
;;;525      /* already listening? */
;;;526      if (pcb->state == LISTEN) {
;;;527        return pcb;
;;;528      }
;;;529    #if SO_REUSE
;;;530      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;531        /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
;;;532           is declared (listen-/connection-pcb), we have to make sure now that
;;;533           this port is only used once for every local IP. */
;;;534        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;535          if (lpcb->local_port == pcb->local_port) {
;;;536            if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
;;;537              /* this address/port is already used */
;;;538              return NULL;
;;;539            }
;;;540          }
;;;541        }
;;;542      }
;;;543    #endif /* SO_REUSE */
;;;544      lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
;;;545      if (lpcb == NULL) {
;;;546        return NULL;
;;;547      }
;;;548      lpcb->callback_arg = pcb->callback_arg;
;;;549      lpcb->local_port = pcb->local_port;
;;;550      lpcb->state = LISTEN;
;;;551      lpcb->prio = pcb->prio;
;;;552      lpcb->so_options = pcb->so_options;
;;;553      ip_set_option(lpcb, SOF_ACCEPTCONN);
;;;554      lpcb->ttl = pcb->ttl;
;;;555      lpcb->tos = pcb->tos;
;;;556      ip_addr_copy(lpcb->local_ip, pcb->local_ip);
;;;557      if (pcb->local_port != 0) {
;;;558        TCP_RMV(&tcp_bound_pcbs, pcb);
;;;559      }
;;;560      memp_free(MEMP_TCP_PCB, pcb);
;;;561    #if LWIP_CALLBACK_API
;;;562      lpcb->accept = tcp_accept_null;
;;;563    #endif /* LWIP_CALLBACK_API */
;;;564    #if TCP_LISTEN_BACKLOG
;;;565      lpcb->accepts_pending = 0;
;;;566      lpcb->backlog = (backlog ? backlog : 1);
;;;567    #endif /* TCP_LISTEN_BACKLOG */
;;;568      TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
;;;569      return (struct tcp_pcb *)lpcb;
;;;570    }
00003c  e8bd8070          POP      {r4-r6,pc}
                  |L18.64|
000040  e1a00000          MOV      r0,r0                 ;523
000044  e5d40018          LDRB     r0,[r4,#0x18]         ;526
000048  e3500001          CMP      r0,#1                 ;526
00004c  1a000001          BNE      |L18.88|
000050  e1a00004          MOV      r0,r4                 ;527
000054  eafffff8          B        |L18.60|
                  |L18.88|
000058  e3a00002          MOV      r0,#2                 ;544
00005c  ebfffffe          BL       memp_malloc
000060  e1a05000          MOV      r5,r0                 ;544
000064  e3550000          CMP      r5,#0                 ;545
000068  1a000001          BNE      |L18.116|
00006c  e3a00000          MOV      r0,#0                 ;546
000070  eafffff1          B        |L18.60|
                  |L18.116|
000074  e5940010          LDR      r0,[r4,#0x10]         ;548
000078  e5850010          STR      r0,[r5,#0x10]         ;548
00007c  e1d401ba          LDRH     r0,[r4,#0x1a]         ;549
000080  e1c501ba          STRH     r0,[r5,#0x1a]         ;549
000084  e3a00001          MOV      r0,#1                 ;550
000088  e5c50018          STRB     r0,[r5,#0x18]         ;550
00008c  e5d40019          LDRB     r0,[r4,#0x19]         ;551
000090  e5c50019          STRB     r0,[r5,#0x19]         ;551
000094  e5d40008          LDRB     r0,[r4,#8]            ;552
000098  e5c50008          STRB     r0,[r5,#8]            ;552
00009c  e5d50008          LDRB     r0,[r5,#8]            ;553
0000a0  e3800002          ORR      r0,r0,#2              ;553
0000a4  e5c50008          STRB     r0,[r5,#8]            ;553
0000a8  e5d4000a          LDRB     r0,[r4,#0xa]          ;554
0000ac  e5c5000a          STRB     r0,[r5,#0xa]          ;554
0000b0  e5d40009          LDRB     r0,[r4,#9]            ;555
0000b4  e5c50009          STRB     r0,[r5,#9]            ;555
0000b8  e5940000          LDR      r0,[r4,#0]            ;556
0000bc  e5850000          STR      r0,[r5,#0]            ;556
0000c0  e1d401ba          LDRH     r0,[r4,#0x1a]         ;557
0000c4  e3500000          CMP      r0,#0                 ;557
0000c8  0a000026          BEQ      |L18.360|
0000cc  e1a00000          MOV      r0,r0                 ;558
0000d0  e59f0138          LDR      r0,|L18.528|
0000d4  e5900000          LDR      r0,[r0,#0]            ;558  ; tcp_bound_pcbs
0000d8  e1500004          CMP      r0,r4                 ;558
0000dc  1a000005          BNE      |L18.248|
0000e0  e59f0128          LDR      r0,|L18.528|
0000e4  e5900000          LDR      r0,[r0,#0]            ;558  ; tcp_bound_pcbs
0000e8  e590000c          LDR      r0,[r0,#0xc]          ;558
0000ec  e59f111c          LDR      r1,|L18.528|
0000f0  e5810000          STR      r0,[r1,#0]            ;558  ; tcp_bound_pcbs
0000f4  ea000018          B        |L18.348|
                  |L18.248|
0000f8  e59f0110          LDR      r0,|L18.528|
0000fc  e5900000          LDR      r0,[r0,#0]            ;558  ; tcp_bound_pcbs
000100  e59f110c          LDR      r1,|L18.532|
000104  e5810000          STR      r0,[r1,#0]            ;558  ; tcp_tmp_pcb
000108  ea00000e          B        |L18.328|
                  |L18.268|
00010c  e59f0100          LDR      r0,|L18.532|
000110  e5900000          LDR      r0,[r0,#0]            ;558  ; tcp_tmp_pcb
000114  e590000c          LDR      r0,[r0,#0xc]          ;558
000118  e1500004          CMP      r0,r4                 ;558
00011c  1a000004          BNE      |L18.308|
000120  e59f10ec          LDR      r1,|L18.532|
000124  e594000c          LDR      r0,[r4,#0xc]          ;558
000128  e5911000          LDR      r1,[r1,#0]            ;558  ; tcp_tmp_pcb
00012c  e581000c          STR      r0,[r1,#0xc]          ;558
000130  ea000008          B        |L18.344|
                  |L18.308|
000134  e59f00d8          LDR      r0,|L18.532|
000138  e5900000          LDR      r0,[r0,#0]            ;558  ; tcp_tmp_pcb
00013c  e590000c          LDR      r0,[r0,#0xc]          ;558
000140  e59f10cc          LDR      r1,|L18.532|
000144  e5810000          STR      r0,[r1,#0]            ;558  ; tcp_tmp_pcb
                  |L18.328|
000148  e59f00c4          LDR      r0,|L18.532|
00014c  e5900000          LDR      r0,[r0,#0]            ;558  ; tcp_tmp_pcb
000150  e3500000          CMP      r0,#0                 ;558
000154  1affffec          BNE      |L18.268|
                  |L18.344|
000158  e1a00000          MOV      r0,r0                 ;558
                  |L18.348|
00015c  e3a00000          MOV      r0,#0                 ;558
000160  e584000c          STR      r0,[r4,#0xc]          ;558
000164  e1a00000          MOV      r0,r0                 ;558
                  |L18.360|
000168  e1a01004          MOV      r1,r4                 ;560
00016c  e3a00001          MOV      r0,#1                 ;560
000170  ebfffffe          BL       memp_free
000174  e59f009c          LDR      r0,|L18.536|
000178  e5850014          STR      r0,[r5,#0x14]         ;562
00017c  e1a00000          MOV      r0,r0                 ;568
000180  e59f0094          LDR      r0,|L18.540|
000184  e5900000          LDR      r0,[r0,#0]            ;568  ; tcp_listen_pcbs
000188  e585000c          STR      r0,[r5,#0xc]          ;568
00018c  e59f0088          LDR      r0,|L18.540|
000190  e5805000          STR      r5,[r0,#0]            ;568  ; tcp_listen_pcbs
000194  ebfffffe          BL       tcp_timer_needed
000198  e1a00000          MOV      r0,r0                 ;568
00019c  e1a00005          MOV      r0,r5                 ;569
0001a0  eaffffa5          B        |L18.60|
;;;571    
                          ENDP

                  |L18.420|
0001a4  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
0001a8  2d312e34
0001ac  2e315c73
0001b0  72635c63
0001b4  6f72655c
0001b8  7463702e
0001bc  6300    
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L18.448|
                          DCD      0x0000020b
                  |L18.452|
0001c4  7463705f          DCB      "tcp_listen: pcb already connected",0
0001c8  6c697374
0001cc  656e3a20
0001d0  70636220
0001d4  616c7265
0001d8  61647920
0001dc  636f6e6e
0001e0  65637465
0001e4  6400    
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L18.488|
0001e8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001ec  7274696f
0001f0  6e202225
0001f4  73222066
0001f8  61696c65
0001fc  64206174
000200  206c696e
000204  65202564
000208  20696e20
00020c  25730a00
                  |L18.528|
                          DCD      tcp_bound_pcbs
                  |L18.532|
                          DCD      tcp_tmp_pcb
                  |L18.536|
                          DCD      tcp_accept_null
                  |L18.540|
                          DCD      tcp_listen_pcbs

                          AREA ||i.tcp_new||, CODE, READONLY, ALIGN=2

                  tcp_new PROC
;;;1361   struct tcp_pcb *
;;;1362   tcp_new(void)
000000  e92d4010          PUSH     {r4,lr}
;;;1363   {
;;;1364     return tcp_alloc(TCP_PRIO_NORMAL);
000004  e3a00040          MOV      r0,#0x40
000008  ebfffffe          BL       tcp_alloc
;;;1365   }
00000c  e8bd8010          POP      {r4,pc}
;;;1366   
                          ENDP


                          AREA ||i.tcp_new_port||, CODE, READONLY, ALIGN=2

                  tcp_new_port PROC
;;;645    static u16_t
;;;646    tcp_new_port(void)
000000  e92d4010          PUSH     {r4,lr}
;;;647    {
;;;648      u8_t i;
;;;649      u16_t n = 0;
000004  e3a03000          MOV      r3,#0
;;;650      struct tcp_pcb *pcb;
;;;651      
;;;652    again:
000008  e1a00000          MOV      r0,r0
                  |L20.12|
;;;653      if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
00000c  e59f00a8          LDR      r0,|L20.188|
000010  e1d000b0          LDRH     r0,[r0,#0]  ; tcp_port
000014  e59fc0a0          LDR      r12,|L20.188|
000018  e1dcc0b0          LDRH     r12,[r12,#0]  ; tcp_port
00001c  e28cc001          ADD      r12,r12,#1
000020  e3ccc801          BIC      r12,r12,#0x10000
000024  e59f4090          LDR      r4,|L20.188|
000028  e1c4c0b0          STRH     r12,[r4,#0]  ; tcp_port
00002c  e59fc08c          LDR      r12,|L20.192|
000030  e150000c          CMP      r0,r12
000034  1a000002          BNE      |L20.68|
;;;654        tcp_port = TCP_LOCAL_PORT_RANGE_START;
000038  e3a00903          MOV      r0,#0xc000
00003c  e284c000          ADD      r12,r4,#0
000040  e1cc00b0          STRH     r0,[r12,#0]  ; tcp_port
                  |L20.68|
;;;655      }
;;;656      /* Check all PCB lists. */
;;;657      for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
000044  e3a01000          MOV      r1,#0
000048  ea000016          B        |L20.168|
                  |L20.76|
;;;658        for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
00004c  e59f0070          LDR      r0,|L20.196|
000050  e7900101          LDR      r0,[r0,r1,LSL #2]
000054  e5902000          LDR      r2,[r0,#0]
000058  ea00000e          B        |L20.152|
                  |L20.92|
;;;659          if (pcb->local_port == tcp_port) {
00005c  e1d201ba          LDRH     r0,[r2,#0x1a]
000060  e59fc054          LDR      r12,|L20.188|
000064  e1dcc0b0          LDRH     r12,[r12,#0]  ; tcp_port
000068  e150000c          CMP      r0,r12
00006c  1a000008          BNE      |L20.148|
;;;660            if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
000070  e2830001          ADD      r0,r3,#1
000074  e1a00800          LSL      r0,r0,#16
000078  e1a00820          LSR      r0,r0,#16
00007c  e1a03000          MOV      r3,r0
000080  e3500901          CMP      r0,#0x4000
000084  ba000001          BLT      |L20.144|
;;;661              return 0;
000088  e3a00000          MOV      r0,#0
                  |L20.140|
;;;662            }
;;;663            goto again;
;;;664          }
;;;665        }
;;;666      }
;;;667      return tcp_port;
;;;668    }
00008c  e8bd8010          POP      {r4,pc}
                  |L20.144|
000090  eaffffdd          B        |L20.12|
                  |L20.148|
000094  e592200c          LDR      r2,[r2,#0xc]          ;658
                  |L20.152|
000098  e3520000          CMP      r2,#0                 ;658
00009c  1affffee          BNE      |L20.92|
0000a0  e2810001          ADD      r0,r1,#1              ;657
0000a4  e20010ff          AND      r1,r0,#0xff           ;657
                  |L20.168|
0000a8  e3510004          CMP      r1,#4                 ;657
0000ac  baffffe6          BLT      |L20.76|
0000b0  e59f0004          LDR      r0,|L20.188|
0000b4  e1d000b0          LDRH     r0,[r0,#0]            ;667  ; tcp_port
0000b8  eafffff3          B        |L20.140|
;;;669    
                          ENDP

                  |L20.188|
                          DCD      tcp_port
                  |L20.192|
                          DCD      0x0000ffff
                  |L20.196|
                          DCD      tcp_pcb_lists

                          AREA ||i.tcp_next_iss||, CODE, READONLY, ALIGN=2

                  tcp_next_iss PROC
;;;1569   u32_t
;;;1570   tcp_next_iss(void)
000000  e59f0020          LDR      r0,|L21.40|
;;;1571   {
;;;1572     static u32_t iss = 6510;
;;;1573     
;;;1574     iss += tcp_ticks;       /* XXX */
000004  e5900000          LDR      r0,[r0,#0]  ; iss
000008  e59f101c          LDR      r1,|L21.44|
00000c  e5911000          LDR      r1,[r1,#0]  ; tcp_ticks
000010  e0800001          ADD      r0,r0,r1
000014  e59f100c          LDR      r1,|L21.40|
000018  e5810000          STR      r0,[r1,#0]  ; iss
;;;1575     return iss;
00001c  e2810000          ADD      r0,r1,#0
000020  e5900000          LDR      r0,[r0,#0]  ; iss
;;;1576   }
000024  e12fff1e          BX       lr
;;;1577   
                          ENDP

                  |L21.40|
                          DCD      iss
                  |L21.44|
                          DCD      tcp_ticks

                          AREA ||i.tcp_pcb_purge||, CODE, READONLY, ALIGN=2

                  tcp_pcb_purge PROC
;;;1468   void
;;;1469   tcp_pcb_purge(struct tcp_pcb *pcb)
000000  e92d4010          PUSH     {r4,lr}
;;;1470   {
000004  e1a04000          MOV      r4,r0
;;;1471     if (pcb->state != CLOSED &&
000008  e5d40018          LDRB     r0,[r4,#0x18]
00000c  e3500000          CMP      r0,#0
000010  0a00001a          BEQ      |L22.128|
;;;1472        pcb->state != TIME_WAIT &&
000014  e5d40018          LDRB     r0,[r4,#0x18]
000018  e350000a          CMP      r0,#0xa
00001c  0a000017          BEQ      |L22.128|
;;;1473        pcb->state != LISTEN) {
000020  e5d40018          LDRB     r0,[r4,#0x18]
000024  e3500001          CMP      r0,#1
000028  0a000014          BEQ      |L22.128|
;;;1474   
;;;1475       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
;;;1476   
;;;1477   #if TCP_LISTEN_BACKLOG
;;;1478       if (pcb->state == SYN_RCVD) {
;;;1479         /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
;;;1480         struct tcp_pcb_listen *lpcb;
;;;1481         LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
;;;1482           tcp_listen_pcbs.listen_pcbs != NULL);
;;;1483         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;1484           if ((lpcb->local_port == pcb->local_port) &&
;;;1485               (ip_addr_isany(&lpcb->local_ip) ||
;;;1486                ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
;;;1487               /* port and address of the listen pcb match the timed-out pcb */
;;;1488               LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
;;;1489                 lpcb->accepts_pending > 0);
;;;1490               lpcb->accepts_pending--;
;;;1491               break;
;;;1492             }
;;;1493         }
;;;1494       }
;;;1495   #endif /* TCP_LISTEN_BACKLOG */
;;;1496   
;;;1497   
;;;1498       if (pcb->refused_data != NULL) {
00002c  e5940078          LDR      r0,[r4,#0x78]
000030  e3500000          CMP      r0,#0
000034  0a000003          BEQ      |L22.72|
;;;1499         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
;;;1500         pbuf_free(pcb->refused_data);
000038  e5940078          LDR      r0,[r4,#0x78]
00003c  ebfffffe          BL       pbuf_free
;;;1501         pcb->refused_data = NULL;
000040  e3a00000          MOV      r0,#0
000044  e5840078          STR      r0,[r4,#0x78]
                  |L22.72|
;;;1502       }
;;;1503       if (pcb->unsent != NULL) {
;;;1504         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
;;;1505       }
;;;1506       if (pcb->unacked != NULL) {
;;;1507         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
;;;1508       }
;;;1509   #if TCP_QUEUE_OOSEQ
;;;1510       if (pcb->ooseq != NULL) {
;;;1511         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
;;;1512       }
;;;1513       tcp_segs_free(pcb->ooseq);
000048  e5940074          LDR      r0,[r4,#0x74]
00004c  ebfffffe          BL       tcp_segs_free
;;;1514       pcb->ooseq = NULL;
000050  e3a00000          MOV      r0,#0
000054  e5840074          STR      r0,[r4,#0x74]
;;;1515   #endif /* TCP_QUEUE_OOSEQ */
;;;1516   
;;;1517       /* Stop the retransmission timer as it will expect data on unacked
;;;1518          queue if it fires */
;;;1519       pcb->rtime = -1;
000058  e3e00000          MVN      r0,#0
00005c  e1c403b4          STRH     r0,[r4,#0x34]
;;;1520   
;;;1521       tcp_segs_free(pcb->unsent);
000060  e594006c          LDR      r0,[r4,#0x6c]
000064  ebfffffe          BL       tcp_segs_free
;;;1522       tcp_segs_free(pcb->unacked);
000068  e5940070          LDR      r0,[r4,#0x70]
00006c  ebfffffe          BL       tcp_segs_free
;;;1523       pcb->unacked = pcb->unsent = NULL;
000070  e3a00000          MOV      r0,#0
000074  e584006c          STR      r0,[r4,#0x6c]
000078  e5840070          STR      r0,[r4,#0x70]
;;;1524   #if TCP_OVERSIZE
;;;1525       pcb->unsent_oversize = 0;
00007c  e1c406ba          STRH     r0,[r4,#0x6a]
                  |L22.128|
;;;1526   #endif /* TCP_OVERSIZE */
;;;1527     }
;;;1528   }
000080  e8bd8010          POP      {r4,pc}
;;;1529   
                          ENDP


                          AREA ||i.tcp_pcb_remove||, CODE, READONLY, ALIGN=2

                  tcp_pcb_remove PROC
;;;1536   void
;;;1537   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1538   {
000004  e1a05000          MOV      r5,r0
000008  e1a04001          MOV      r4,r1
;;;1539     TCP_RMV(pcblist, pcb);
00000c  e1a00000          MOV      r0,r0
000010  e5950000          LDR      r0,[r5,#0]
000014  e1500004          CMP      r0,r4
000018  1a000003          BNE      |L23.44|
00001c  e5950000          LDR      r0,[r5,#0]
000020  e590000c          LDR      r0,[r0,#0xc]
000024  e5850000          STR      r0,[r5,#0]
000028  ea000017          B        |L23.140|
                  |L23.44|
00002c  e59f1158          LDR      r1,|L23.396|
000030  e5950000          LDR      r0,[r5,#0]
000034  e5810000          STR      r0,[r1,#0]  ; tcp_tmp_pcb
000038  ea00000e          B        |L23.120|
                  |L23.60|
00003c  e59f0148          LDR      r0,|L23.396|
000040  e5900000          LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000044  e590000c          LDR      r0,[r0,#0xc]
000048  e1500004          CMP      r0,r4
00004c  1a000004          BNE      |L23.100|
000050  e59f1134          LDR      r1,|L23.396|
000054  e594000c          LDR      r0,[r4,#0xc]
000058  e5911000          LDR      r1,[r1,#0]  ; tcp_tmp_pcb
00005c  e581000c          STR      r0,[r1,#0xc]
000060  ea000008          B        |L23.136|
                  |L23.100|
000064  e59f0120          LDR      r0,|L23.396|
000068  e5900000          LDR      r0,[r0,#0]  ; tcp_tmp_pcb
00006c  e590000c          LDR      r0,[r0,#0xc]
000070  e59f1114          LDR      r1,|L23.396|
000074  e5810000          STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L23.120|
000078  e59f010c          LDR      r0,|L23.396|
00007c  e5900000          LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000080  e3500000          CMP      r0,#0
000084  1affffec          BNE      |L23.60|
                  |L23.136|
000088  e1a00000          MOV      r0,r0
                  |L23.140|
00008c  e3a00000          MOV      r0,#0
000090  e584000c          STR      r0,[r4,#0xc]
000094  e1a00000          MOV      r0,r0
;;;1540   
;;;1541     tcp_pcb_purge(pcb);
000098  e1a00004          MOV      r0,r4
00009c  ebfffffe          BL       tcp_pcb_purge
;;;1542     
;;;1543     /* if there is an outstanding delayed ACKs, send it */
;;;1544     if (pcb->state != TIME_WAIT &&
0000a0  e5d40018          LDRB     r0,[r4,#0x18]
0000a4  e350000a          CMP      r0,#0xa
0000a8  0a00000b          BEQ      |L23.220|
;;;1545        pcb->state != LISTEN &&
0000ac  e5d40018          LDRB     r0,[r4,#0x18]
0000b0  e3500001          CMP      r0,#1
0000b4  0a000008          BEQ      |L23.220|
;;;1546        pcb->flags & TF_ACK_DELAY) {
0000b8  e5d4001e          LDRB     r0,[r4,#0x1e]
0000bc  e2000001          AND      r0,r0,#1
0000c0  e3500000          CMP      r0,#0
0000c4  0a000004          BEQ      |L23.220|
;;;1547       pcb->flags |= TF_ACK_NOW;
0000c8  e5d4001e          LDRB     r0,[r4,#0x1e]
0000cc  e3800002          ORR      r0,r0,#2
0000d0  e5c4001e          STRB     r0,[r4,#0x1e]
;;;1548       tcp_output(pcb);
0000d4  e1a00004          MOV      r0,r4
0000d8  ebfffffe          BL       tcp_output
                  |L23.220|
;;;1549     }
;;;1550   
;;;1551     if (pcb->state != LISTEN) {
0000dc  e5d40018          LDRB     r0,[r4,#0x18]
0000e0  e3500001          CMP      r0,#1
0000e4  0a000023          BEQ      |L23.376|
;;;1552       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
0000e8  e1a00000          MOV      r0,r0
0000ec  e594006c          LDR      r0,[r4,#0x6c]
0000f0  e3500000          CMP      r0,#0
0000f4  0a000006          BEQ      |L23.276|
0000f8  e1a00000          MOV      r0,r0
0000fc  e28f308c          ADR      r3,|L23.400|
000100  e3a02e61          MOV      r2,#0x610
000104  e28f10a0          ADR      r1,|L23.428|
000108  e28f00b4          ADR      r0,|L23.452|
00010c  ebfffffe          BL       sysprintf
000110  e1a00000          MOV      r0,r0
                  |L23.276|
000114  e1a00000          MOV      r0,r0
;;;1553       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
000118  e1a00000          MOV      r0,r0
00011c  e5940070          LDR      r0,[r4,#0x70]
000120  e3500000          CMP      r0,#0
000124  0a000006          BEQ      |L23.324|
000128  e1a00000          MOV      r0,r0
00012c  e28f305c          ADR      r3,|L23.400|
000130  e59f20b4          LDR      r2,|L23.492|
000134  e28f10b4          ADR      r1,|L23.496|
000138  e28f0084          ADR      r0,|L23.452|
00013c  ebfffffe          BL       sysprintf
000140  e1a00000          MOV      r0,r0
                  |L23.324|
000144  e1a00000          MOV      r0,r0
;;;1554   #if TCP_QUEUE_OOSEQ
;;;1555       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
000148  e1a00000          MOV      r0,r0
00014c  e5940074          LDR      r0,[r4,#0x74]
000150  e3500000          CMP      r0,#0
000154  0a000006          BEQ      |L23.372|
000158  e1a00000          MOV      r0,r0
00015c  e28f302c          ADR      r3,|L23.400|
000160  e59f20a4          LDR      r2,|L23.524|
000164  e28f10a4          ADR      r1,|L23.528|
000168  e28f0054          ADR      r0,|L23.452|
00016c  ebfffffe          BL       sysprintf
000170  e1a00000          MOV      r0,r0
                  |L23.372|
000174  e1a00000          MOV      r0,r0
                  |L23.376|
;;;1556   #endif /* TCP_QUEUE_OOSEQ */
;;;1557     }
;;;1558   
;;;1559     pcb->state = CLOSED;
000178  e3a00000          MOV      r0,#0
00017c  e5c40018          STRB     r0,[r4,#0x18]
;;;1560   
;;;1561     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
000180  e1a00000          MOV      r0,r0
000184  e1a00000          MOV      r0,r0
;;;1562   }
000188  e8bd8070          POP      {r4-r6,pc}
;;;1563   
                          ENDP

                  |L23.396|
                          DCD      tcp_tmp_pcb
                  |L23.400|
000190  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
000194  2d312e34
000198  2e315c73
00019c  72635c63
0001a0  6f72655c
0001a4  7463702e
0001a8  6300    
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L23.428|
0001ac  756e7365          DCB      "unsent segments leaking",0
0001b0  6e742073
0001b4  65676d65
0001b8  6e747320
0001bc  6c65616b
0001c0  696e6700
                  |L23.452|
0001c4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001c8  7274696f
0001cc  6e202225
0001d0  73222066
0001d4  61696c65
0001d8  64206174
0001dc  206c696e
0001e0  65202564
0001e4  20696e20
0001e8  25730a00
                  |L23.492|
                          DCD      0x00000611
                  |L23.496|
0001f0  756e6163          DCB      "unacked segments leaking",0
0001f4  6b656420
0001f8  7365676d
0001fc  656e7473
000200  206c6561
000204  6b696e67
000208  00      
000209  00                DCB      0
00020a  00                DCB      0
00020b  00                DCB      0
                  |L23.524|
                          DCD      0x00000613
                  |L23.528|
000210  6f6f7365          DCB      "ooseq segments leaking",0
000214  71207365
000218  676d656e
00021c  7473206c
000220  65616b69
000224  6e6700  
000227  00                DCB      0

                          AREA ||i.tcp_poll||, CODE, READONLY, ALIGN=2

                  tcp_poll PROC
;;;1450   void
;;;1451   tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1452   {
000004  e1a04000          MOV      r4,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a05002          MOV      r5,r2
;;;1453     LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
000010  e1a00000          MOV      r0,r0
000014  e5d40018          LDRB     r0,[r4,#0x18]
000018  e3500001          CMP      r0,#1
00001c  1a000006          BNE      |L24.60|
000020  e1a00000          MOV      r0,r0
000024  e28f3020          ADR      r3,|L24.76|
000028  e59f2038          LDR      r2,|L24.104|
00002c  e28f1038          ADR      r1,|L24.108|
000030  e28f0054          ADR      r0,|L24.140|
000034  ebfffffe          BL       sysprintf
000038  e1a00000          MOV      r0,r0
                  |L24.60|
00003c  e1a00000          MOV      r0,r0
;;;1454   #if LWIP_CALLBACK_API
;;;1455     pcb->poll = poll;
000040  e5846088          STR      r6,[r4,#0x88]
;;;1456   #else /* LWIP_CALLBACK_API */  
;;;1457     LWIP_UNUSED_ARG(poll);
;;;1458   #endif /* LWIP_CALLBACK_API */  
;;;1459     pcb->pollinterval = interval;
000044  e5c45020          STRB     r5,[r4,#0x20]
;;;1460   }
000048  e8bd8070          POP      {r4-r6,pc}
;;;1461   
                          ENDP

                  |L24.76|
00004c  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
000050  2d312e34
000054  2e315c73
000058  72635c63
00005c  6f72655c
000060  7463702e
000064  6300    
000066  00                DCB      0
000067  00                DCB      0
                  |L24.104|
                          DCD      0x000005ad
                  |L24.108|
00006c  696e7661          DCB      "invalid socket state for poll",0
000070  6c696420
000074  736f636b
000078  65742073
00007c  74617465
000080  20666f72
000084  20706f6c
000088  6c00    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L24.140|
00008c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000090  7274696f
000094  6e202225
000098  73222066
00009c  61696c65
0000a0  64206174
0000a4  206c696e
0000a8  65202564
0000ac  20696e20
0000b0  25730a00

                          AREA ||i.tcp_process_refused_data||, CODE, READONLY, ALIGN=2

                  tcp_process_refused_data PROC
;;;1083   err_t
;;;1084   tcp_process_refused_data(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1085   {
000004  e1a04000          MOV      r4,r0
;;;1086     err_t err;
;;;1087     u8_t refused_flags = pcb->refused_data->flags;
000008  e5940078          LDR      r0,[r4,#0x78]
00000c  e5d0700d          LDRB     r7,[r0,#0xd]
;;;1088     /* set pcb->refused_data to NULL in case the callback frees it and then
;;;1089        closes the pcb */
;;;1090     struct pbuf *refused_data = pcb->refused_data;
000010  e5946078          LDR      r6,[r4,#0x78]
;;;1091     pcb->refused_data = NULL;
000014  e3a00000          MOV      r0,#0
000018  e5840078          STR      r0,[r4,#0x78]
;;;1092     /* Notify again application with data previously received. */
;;;1093     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
;;;1094     TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
00001c  e1a00000          MOV      r0,r0
000020  e5940080          LDR      r0,[r4,#0x80]
000024  e3500000          CMP      r0,#0
000028  0a000007          BEQ      |L25.76|
00002c  e3a03000          MOV      r3,#0
000030  e1a02006          MOV      r2,r6
000034  e5940010          LDR      r0,[r4,#0x10]
000038  e594c080          LDR      r12,[r4,#0x80]
00003c  e1a01004          MOV      r1,r4
000040  e12fff3c          BLX      r12
000044  e1a05000          MOV      r5,r0
000048  ea000005          B        |L25.100|
                  |L25.76|
00004c  e3a03000          MOV      r3,#0
000050  e1a02006          MOV      r2,r6
000054  e1a01004          MOV      r1,r4
000058  e1a00003          MOV      r0,r3
00005c  ebfffffe          BL       tcp_recv_null
000060  e1a05000          MOV      r5,r0
                  |L25.100|
000064  e1a00000          MOV      r0,r0
;;;1095     if (err == ERR_OK) {
000068  e3550000          CMP      r5,#0
00006c  1a00001b          BNE      |L25.224|
;;;1096       /* did refused_data include a FIN? */
;;;1097       if (refused_flags & PBUF_FLAG_TCP_FIN) {
000070  e2070020          AND      r0,r7,#0x20
000074  e3500000          CMP      r0,#0
000078  0a00001d          BEQ      |L25.244|
;;;1098         /* correct rcv_wnd as the application won't call tcp_recved()
;;;1099            for the FIN's seqno */
;;;1100         if (pcb->rcv_wnd != TCP_WND) {
00007c  e1d402bc          LDRH     r0,[r4,#0x2c]
000080  e3500e86          CMP      r0,#0x860
000084  0a000003          BEQ      |L25.152|
;;;1101           pcb->rcv_wnd++;
000088  e1d402bc          LDRH     r0,[r4,#0x2c]
00008c  e2800001          ADD      r0,r0,#1
000090  e3c00801          BIC      r0,r0,#0x10000
000094  e1c402bc          STRH     r0,[r4,#0x2c]
                  |L25.152|
;;;1102         }
;;;1103         TCP_EVENT_CLOSED(pcb, err);
000098  e1a00000          MOV      r0,r0
00009c  e5940080          LDR      r0,[r4,#0x80]
0000a0  e3500000          CMP      r0,#0
0000a4  0a000007          BEQ      |L25.200|
0000a8  e3a03000          MOV      r3,#0
0000ac  e1a02003          MOV      r2,r3
0000b0  e5940010          LDR      r0,[r4,#0x10]
0000b4  e594c080          LDR      r12,[r4,#0x80]
0000b8  e1a01004          MOV      r1,r4
0000bc  e12fff3c          BLX      r12
0000c0  e1a05000          MOV      r5,r0
0000c4  ea000000          B        |L25.204|
                  |L25.200|
0000c8  e3a05000          MOV      r5,#0
                  |L25.204|
0000cc  e1a00000          MOV      r0,r0
;;;1104         if (err == ERR_ABRT) {
0000d0  e375000a          CMN      r5,#0xa
0000d4  1a000006          BNE      |L25.244|
;;;1105           return ERR_ABRT;
0000d8  e3e00009          MVN      r0,#9
                  |L25.220|
;;;1106         }
;;;1107       }
;;;1108     } else if (err == ERR_ABRT) {
;;;1109       /* if err == ERR_ABRT, 'pcb' is already deallocated */
;;;1110       /* Drop incoming packets because pcb is "full" (only if the incoming
;;;1111          segment contains data). */
;;;1112       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
;;;1113       return ERR_ABRT;
;;;1114     } else {
;;;1115       /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
;;;1116       pcb->refused_data = refused_data;
;;;1117     }
;;;1118     return ERR_OK;
;;;1119   }
0000dc  e8bd81f0          POP      {r4-r8,pc}
                  |L25.224|
0000e0  e375000a          CMN      r5,#0xa               ;1108
0000e4  1a000001          BNE      |L25.240|
0000e8  e3e00009          MVN      r0,#9                 ;1113
0000ec  eafffffa          B        |L25.220|
                  |L25.240|
0000f0  e5846078          STR      r6,[r4,#0x78]         ;1116
                  |L25.244|
0000f4  e3a00000          MOV      r0,#0                 ;1118
0000f8  eafffff7          B        |L25.220|
;;;1120   
                          ENDP


                          AREA ||i.tcp_recv||, CODE, READONLY, ALIGN=2

                  tcp_recv PROC
;;;1390   void
;;;1391   tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1392   {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;1393     LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
00000c  e1a00000          MOV      r0,r0
000010  e5d40018          LDRB     r0,[r4,#0x18]
000014  e3500001          CMP      r0,#1
000018  1a000006          BNE      |L26.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f301c          ADR      r3,|L26.68|
000024  e59f2034          LDR      r2,|L26.96|
000028  e28f1034          ADR      r1,|L26.100|
00002c  e28f0058          ADR      r0,|L26.140|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L26.56|
000038  e1a00000          MOV      r0,r0
;;;1394     pcb->recv = recv;
00003c  e5845080          STR      r5,[r4,#0x80]
;;;1395   }
000040  e8bd8070          POP      {r4-r6,pc}
;;;1396   
                          ENDP

                  |L26.68|
000044  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
000048  2d312e34
00004c  2e315c73
000050  72635c63
000054  6f72655c
000058  7463702e
00005c  6300    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L26.96|
                          DCD      0x00000571
                  |L26.100|
000064  696e7661          DCB      "invalid socket state for recv callback",0
000068  6c696420
00006c  736f636b
000070  65742073
000074  74617465
000078  20666f72
00007c  20726563
000080  76206361
000084  6c6c6261
000088  636b00  
00008b  00                DCB      0
                  |L26.140|
00008c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000090  7274696f
000094  6e202225
000098  73222066
00009c  61696c65
0000a0  64206174
0000a4  206c696e
0000a8  65202564
0000ac  20696e20
0000b0  25730a00

                          AREA ||i.tcp_recv_null||, CODE, READONLY, ALIGN=2

                  tcp_recv_null PROC
;;;1195   err_t
;;;1196   tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1197   {
000004  e1a07000          MOV      r7,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a04002          MOV      r4,r2
000010  e1a06003          MOV      r6,r3
;;;1198     LWIP_UNUSED_ARG(arg);
;;;1199     if (p != NULL) {
000014  e3540000          CMP      r4,#0
000018  0a000005          BEQ      |L27.52|
;;;1200       tcp_recved(pcb, p->tot_len);
00001c  e1d410b8          LDRH     r1,[r4,#8]
000020  e1a00005          MOV      r0,r5
000024  ebfffffe          BL       tcp_recved
;;;1201       pbuf_free(p);
000028  e1a00004          MOV      r0,r4
00002c  ebfffffe          BL       pbuf_free
000030  ea000004          B        |L27.72|
                  |L27.52|
;;;1202     } else if (err == ERR_OK) {
000034  e3560000          CMP      r6,#0
000038  1a000002          BNE      |L27.72|
;;;1203       return tcp_close(pcb);
00003c  e1a00005          MOV      r0,r5
000040  ebfffffe          BL       tcp_close
                  |L27.68|
;;;1204     }
;;;1205     return ERR_OK;
;;;1206   }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L27.72|
000048  e3a00000          MOV      r0,#0                 ;1205
00004c  eafffffc          B        |L27.68|
;;;1207   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_recved||, CODE, READONLY, ALIGN=2

                  tcp_recved PROC
;;;609    void
;;;610    tcp_recved(struct tcp_pcb *pcb, u16_t len)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;611    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;612      int wnd_inflation;
;;;613    
;;;614      /* pcb->state LISTEN not allowed here */
;;;615      LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
00000c  e1a00000          MOV      r0,r0
000010  e5d40018          LDRB     r0,[r4,#0x18]
000014  e3500001          CMP      r0,#1
000018  1a000006          BNE      |L28.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f30a0          ADR      r3,|L28.200|
000024  e59f20b8          LDR      r2,|L28.228|
000028  e28f10b8          ADR      r1,|L28.232|
00002c  e28f00dc          ADR      r0,|L28.272|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L28.56|
000038  e1a00000          MOV      r0,r0
;;;616        pcb->state != LISTEN);
;;;617      LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
00003c  e1a00000          MOV      r0,r0
000040  e1d402bc          LDRH     r0,[r4,#0x2c]
000044  e59f10ec          LDR      r1,|L28.312|
000048  e0410000          SUB      r0,r1,r0
00004c  e1500005          CMP      r0,r5
000050  aa000006          BGE      |L28.112|
000054  e1a00000          MOV      r0,r0
000058  e28f3068          ADR      r3,|L28.200|
00005c  e59f20d8          LDR      r2,|L28.316|
000060  e28f10d8          ADR      r1,|L28.320|
000064  e28f00a4          ADR      r0,|L28.272|
000068  ebfffffe          BL       sysprintf
00006c  e1a00000          MOV      r0,r0
                  |L28.112|
000070  e1a00000          MOV      r0,r0
;;;618                  len <= 0xffff - pcb->rcv_wnd );
;;;619    
;;;620      pcb->rcv_wnd += len;
000074  e1d402bc          LDRH     r0,[r4,#0x2c]
000078  e0800005          ADD      r0,r0,r5
00007c  e1c402bc          STRH     r0,[r4,#0x2c]
;;;621      if (pcb->rcv_wnd > TCP_WND) {
000080  e1d402bc          LDRH     r0,[r4,#0x2c]
000084  e3500e86          CMP      r0,#0x860
000088  da000001          BLE      |L28.148|
;;;622        pcb->rcv_wnd = TCP_WND;
00008c  e3a00e86          MOV      r0,#0x860
000090  e1c402bc          STRH     r0,[r4,#0x2c]
                  |L28.148|
;;;623      }
;;;624    
;;;625      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
000094  e1a00004          MOV      r0,r4
000098  ebfffffe          BL       tcp_update_rcv_ann_wnd
00009c  e1a06000          MOV      r6,r0
;;;626    
;;;627      /* If the change in the right edge of window is significant (default
;;;628       * watermark is TCP_WND/4), then send an explicit update now.
;;;629       * Otherwise wait for a packet to be sent in the normal course of
;;;630       * events (or more window to be available later) */
;;;631      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
0000a0  e3560f86          CMP      r6,#0x218
0000a4  ba000006          BLT      |L28.196|
;;;632        tcp_ack_now(pcb);
0000a8  e1a00000          MOV      r0,r0
0000ac  e5d4001e          LDRB     r0,[r4,#0x1e]
0000b0  e3800002          ORR      r0,r0,#2
0000b4  e5c4001e          STRB     r0,[r4,#0x1e]
0000b8  e1a00000          MOV      r0,r0
;;;633        tcp_output(pcb);
0000bc  e1a00004          MOV      r0,r4
0000c0  ebfffffe          BL       tcp_output
                  |L28.196|
;;;634      }
;;;635    
;;;636      LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
;;;637             len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
;;;638    }
0000c4  e8bd8070          POP      {r4-r6,pc}
;;;639    
                          ENDP

                  |L28.200|
0000c8  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
0000cc  2d312e34
0000d0  2e315c73
0000d4  72635c63
0000d8  6f72655c
0000dc  7463702e
0000e0  6300    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L28.228|
                          DCD      0x00000267
                  |L28.232|
0000e8  646f6e27          DCB      "don't call tcp_recved for listen-pcbs",0
0000ec  74206361
0000f0  6c6c2074
0000f4  63705f72
0000f8  65637665
0000fc  6420666f
000100  72206c69
000104  7374656e
000108  2d706362
00010c  7300    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L28.272|
000110  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000114  7274696f
000118  6e202225
00011c  73222066
000120  61696c65
000124  64206174
000128  206c696e
00012c  65202564
000130  20696e20
000134  25730a00
                  |L28.312|
                          DCD      0x0000ffff
                  |L28.316|
                          DCD      0x00000269
                  |L28.320|
000140  7463705f          DCB      "tcp_recved: len would wrap rcv_wnd\n",0
000144  72656376
000148  65643a20
00014c  6c656e20
000150  776f756c
000154  64207772
000158  61702072
00015c  63765f77
000160  6e640a00

                          AREA ||i.tcp_seg_copy||, CODE, READONLY, ALIGN=2

                  tcp_seg_copy PROC
;;;1175   struct tcp_seg *
;;;1176   tcp_seg_copy(struct tcp_seg *seg)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1177   {
000004  e1a05000          MOV      r5,r0
;;;1178     struct tcp_seg *cseg;
;;;1179   
;;;1180     cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
000008  e3a00003          MOV      r0,#3
00000c  ebfffffe          BL       memp_malloc
000010  e1a04000          MOV      r4,r0
;;;1181     if (cseg == NULL) {
000014  e3540000          CMP      r4,#0
000018  1a000001          BNE      |L29.36|
;;;1182       return NULL;
00001c  e3a00000          MOV      r0,#0
                  |L29.32|
;;;1183     }
;;;1184     SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
;;;1185     pbuf_ref(cseg->p);
;;;1186     return cseg;
;;;1187   }
000020  e8bd8070          POP      {r4-r6,pc}
                  |L29.36|
000024  e3a02014          MOV      r2,#0x14              ;1184
000028  e1a01005          MOV      r1,r5                 ;1184
00002c  e1a00004          MOV      r0,r4                 ;1184
000030  ebfffffe          BL       __aeabi_memcpy4
000034  e5940004          LDR      r0,[r4,#4]            ;1185
000038  ebfffffe          BL       pbuf_ref
00003c  e1a00004          MOV      r0,r4                 ;1186
000040  eafffff6          B        |L29.32|
;;;1188   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP


                          AREA ||i.tcp_seg_free||, CODE, READONLY, ALIGN=2

                  tcp_seg_free PROC
;;;1141   void
;;;1142   tcp_seg_free(struct tcp_seg *seg)
000000  e92d4010          PUSH     {r4,lr}
;;;1143   {
000004  e1a04000          MOV      r4,r0
;;;1144     if (seg != NULL) {
000008  e3540000          CMP      r4,#0
00000c  0a000007          BEQ      |L30.48|
;;;1145       if (seg->p != NULL) {
000010  e5940004          LDR      r0,[r4,#4]
000014  e3500000          CMP      r0,#0
000018  0a000001          BEQ      |L30.36|
;;;1146         pbuf_free(seg->p);
00001c  e5940004          LDR      r0,[r4,#4]
000020  ebfffffe          BL       pbuf_free
                  |L30.36|
;;;1147   #if TCP_DEBUG
;;;1148         seg->p = NULL;
;;;1149   #endif /* TCP_DEBUG */
;;;1150       }
;;;1151       memp_free(MEMP_TCP_SEG, seg);
000024  e1a01004          MOV      r1,r4
000028  e3a00003          MOV      r0,#3
00002c  ebfffffe          BL       memp_free
                  |L30.48|
;;;1152     }
;;;1153   }
000030  e8bd8010          POP      {r4,pc}
;;;1154   
                          ENDP


                          AREA ||i.tcp_segs_free||, CODE, READONLY, ALIGN=2

                  tcp_segs_free PROC
;;;1126   void
;;;1127   tcp_segs_free(struct tcp_seg *seg)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1128   {
000004  e1a04000          MOV      r4,r0
;;;1129     while (seg != NULL) {
000008  ea000004          B        |L31.32|
                  |L31.12|
;;;1130       struct tcp_seg *next = seg->next;
00000c  e5945000          LDR      r5,[r4,#0]
;;;1131       tcp_seg_free(seg);
000010  e1a00004          MOV      r0,r4
000014  ebfffffe          BL       tcp_seg_free
;;;1132       seg = next;
000018  e1a04005          MOV      r4,r5
;;;1133     }
00001c  e1a00000          MOV      r0,r0
                  |L31.32|
000020  e3540000          CMP      r4,#0                 ;1129
000024  1afffff8          BNE      |L31.12|
;;;1134   }
000028  e8bd8070          POP      {r4-r6,pc}
;;;1135   
                          ENDP


                          AREA ||i.tcp_sent||, CODE, READONLY, ALIGN=2

                  tcp_sent PROC
;;;1404   void
;;;1405   tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1406   {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;1407     LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
00000c  e1a00000          MOV      r0,r0
000010  e5d40018          LDRB     r0,[r4,#0x18]
000014  e3500001          CMP      r0,#1
000018  1a000006          BNE      |L32.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f301c          ADR      r3,|L32.68|
000024  e59f2034          LDR      r2,|L32.96|
000028  e28f1034          ADR      r1,|L32.100|
00002c  e28f0058          ADR      r0,|L32.140|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L32.56|
000038  e1a00000          MOV      r0,r0
;;;1408     pcb->sent = sent;
00003c  e584507c          STR      r5,[r4,#0x7c]
;;;1409   }
000040  e8bd8070          POP      {r4-r6,pc}
;;;1410   
                          ENDP

                  |L32.68|
000044  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
000048  2d312e34
00004c  2e315c73
000050  72635c63
000054  6f72655c
000058  7463702e
00005c  6300    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L32.96|
                          DCD      0x0000057f
                  |L32.100|
000064  696e7661          DCB      "invalid socket state for sent callback",0
000068  6c696420
00006c  736f636b
000070  65742073
000074  74617465
000078  20666f72
00007c  2073656e
000080  74206361
000084  6c6c6261
000088  636b00  
00008b  00                DCB      0
                  |L32.140|
00008c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000090  7274696f
000094  6e202225
000098  73222066
00009c  61696c65
0000a0  64206174
0000a4  206c696e
0000a8  65202564
0000ac  20696e20
0000b0  25730a00

                          AREA ||i.tcp_setprio||, CODE, READONLY, ALIGN=2

                  tcp_setprio PROC
;;;1161   void
;;;1162   tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
000000  e5c01019          STRB     r1,[r0,#0x19]
;;;1163   {
;;;1164     pcb->prio = prio;
;;;1165   }
000004  e12fff1e          BX       lr
;;;1166   
                          ENDP


                          AREA ||i.tcp_shutdown||, CODE, READONLY, ALIGN=2

                  tcp_shutdown PROC
;;;311    err_t
;;;312    tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;313    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a06002          MOV      r6,r2
;;;314      if (pcb->state == LISTEN) {
000010  e5d40018          LDRB     r0,[r4,#0x18]
000014  e3500001          CMP      r0,#1
000018  1a000001          BNE      |L34.36|
;;;315        return ERR_CONN;
00001c  e3e0000c          MVN      r0,#0xc
                  |L34.32|
;;;316      }
;;;317      if (shut_rx) {
;;;318        /* shut down the receive side: set a flag not to receive any more data... */
;;;319        pcb->flags |= TF_RXCLOSED;
;;;320        if (shut_tx) {
;;;321          /* shutting down the tx AND rx side is the same as closing for the raw API */
;;;322          return tcp_close_shutdown(pcb, 1);
;;;323        }
;;;324        /* ... and free buffered data */
;;;325        if (pcb->refused_data != NULL) {
;;;326          pbuf_free(pcb->refused_data);
;;;327          pcb->refused_data = NULL;
;;;328        }
;;;329      }
;;;330      if (shut_tx) {
;;;331        /* This can't happen twice since if it succeeds, the pcb's state is changed.
;;;332           Only close in these states as the others directly deallocate the PCB */
;;;333        switch (pcb->state) {
;;;334        case SYN_RCVD:
;;;335        case ESTABLISHED:
;;;336        case CLOSE_WAIT:
;;;337          return tcp_close_shutdown(pcb, shut_rx);
;;;338        default:
;;;339          /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
;;;340            into CLOSED state, where the PCB is deallocated. */
;;;341          return ERR_CONN;
;;;342        }
;;;343      }
;;;344      return ERR_OK;
;;;345    }
000020  e8bd8070          POP      {r4-r6,pc}
                  |L34.36|
000024  e3550000          CMP      r5,#0                 ;317
000028  0a00000f          BEQ      |L34.108|
00002c  e5d4001e          LDRB     r0,[r4,#0x1e]         ;319
000030  e3800010          ORR      r0,r0,#0x10           ;319
000034  e5c4001e          STRB     r0,[r4,#0x1e]         ;319
000038  e3560000          CMP      r6,#0                 ;320
00003c  0a000003          BEQ      |L34.80|
000040  e3a01001          MOV      r1,#1                 ;322
000044  e1a00004          MOV      r0,r4                 ;322
000048  ebfffffe          BL       tcp_close_shutdown
00004c  eafffff3          B        |L34.32|
                  |L34.80|
000050  e5940078          LDR      r0,[r4,#0x78]         ;325
000054  e3500000          CMP      r0,#0                 ;325
000058  0a000003          BEQ      |L34.108|
00005c  e5940078          LDR      r0,[r4,#0x78]         ;326
000060  ebfffffe          BL       pbuf_free
000064  e3a00000          MOV      r0,#0                 ;327
000068  e5840078          STR      r0,[r4,#0x78]         ;327
                  |L34.108|
00006c  e3560000          CMP      r6,#0                 ;330
000070  0a000011          BEQ      |L34.188|
000074  e5d40018          LDRB     r0,[r4,#0x18]         ;333
000078  e3500003          CMP      r0,#3                 ;333
00007c  0a000004          BEQ      |L34.148|
000080  e3500004          CMP      r0,#4                 ;333
000084  0a000004          BEQ      |L34.156|
000088  e3500007          CMP      r0,#7                 ;333
00008c  1a000007          BNE      |L34.176|
000090  ea000002          B        |L34.160|
                  |L34.148|
000094  e1a00000          MOV      r0,r0                 ;334
000098  e1a00000          MOV      r0,r0                 ;335
                  |L34.156|
00009c  e1a00000          MOV      r0,r0                 ;336
                  |L34.160|
0000a0  e20510ff          AND      r1,r5,#0xff           ;337
0000a4  e1a00004          MOV      r0,r4                 ;337
0000a8  ebfffffe          BL       tcp_close_shutdown
0000ac  eaffffdb          B        |L34.32|
                  |L34.176|
0000b0  e1a00000          MOV      r0,r0                 ;338
0000b4  e3e0000c          MVN      r0,#0xc               ;341
0000b8  eaffffd8          B        |L34.32|
                  |L34.188|
0000bc  e3a00000          MOV      r0,#0                 ;344
0000c0  eaffffd6          B        |L34.32|
;;;346    
                          ENDP


                          AREA ||i.tcp_slowtmr||, CODE, READONLY, ALIGN=2

                  tcp_slowtmr PROC
;;;786    void
;;;787    tcp_slowtmr(void)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;788    {
;;;789      struct tcp_pcb *pcb, *prev;
;;;790      u16_t eff_wnd;
;;;791      u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;792      u8_t pcb_reset;       /* flag if a RST should be sent when removing */
;;;793      err_t err;
;;;794    
;;;795      err = ERR_OK;
000004  e3a00000          MOV      r0,#0
000008  e58d0008          STR      r0,[sp,#8]
;;;796    
;;;797      ++tcp_ticks;
00000c  e59f0304          LDR      r0,|L35.792|
000010  e5900000          LDR      r0,[r0,#0]  ; tcp_ticks
000014  e2800001          ADD      r0,r0,#1
000018  e59f12f8          LDR      r1,|L35.792|
00001c  e5810000          STR      r0,[r1,#0]  ; tcp_ticks
;;;798      ++tcp_timer_ctr;
000020  e59f02f4          LDR      r0,|L35.796|
000024  e5d00000          LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000028  e2800001          ADD      r0,r0,#1
00002c  e59f12e8          LDR      r1,|L35.796|
000030  e5c10000          STRB     r0,[r1,#0]  ; tcp_timer_ctr
;;;799    
;;;800    tcp_slowtmr_start:
000034  e1a00000          MOV      r0,r0
                  |L35.56|
;;;801      /* Steps through all of the active PCBs. */
;;;802      prev = NULL;
000038  e3a05000          MOV      r5,#0
;;;803      pcb = tcp_active_pcbs;
00003c  e59f02dc          LDR      r0,|L35.800|
000040  e5904000          LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;804      if (pcb == NULL) {
;;;805        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
;;;806      }
;;;807      while (pcb != NULL) {
000044  ea000194          B        |L35.1692|
                  |L35.72|
;;;808        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
;;;809        LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
000048  e1a00000          MOV      r0,r0
00004c  e5d40018          LDRB     r0,[r4,#0x18]
000050  e3500000          CMP      r0,#0
000054  1a000006          BNE      |L35.116|
000058  e1a00000          MOV      r0,r0
00005c  e28f3d0b          ADR      r3,|L35.804|
000060  e59f22d8          LDR      r2,|L35.832|
000064  e28f1fb6          ADR      r1,|L35.836|
000068  e28f0c03          ADR      r0,|L35.880|
00006c  ebfffffe          BL       sysprintf
000070  e1a00000          MOV      r0,r0
                  |L35.116|
000074  e1a00000          MOV      r0,r0
;;;810        LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
000078  e1a00000          MOV      r0,r0
00007c  e5d40018          LDRB     r0,[r4,#0x18]
000080  e3500001          CMP      r0,#1
000084  1a000006          BNE      |L35.164|
000088  e1a00000          MOV      r0,r0
00008c  e28f3e29          ADR      r3,|L35.804|
000090  e59f2300          LDR      r2,|L35.920|
000094  e28f1c03          ADR      r1,|L35.924|
000098  e28f0e2d          ADR      r0,|L35.880|
00009c  ebfffffe          BL       sysprintf
0000a0  e1a00000          MOV      r0,r0
                  |L35.164|
0000a4  e1a00000          MOV      r0,r0
;;;811        LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
0000a8  e1a00000          MOV      r0,r0
0000ac  e5d40018          LDRB     r0,[r4,#0x18]
0000b0  e350000a          CMP      r0,#0xa
0000b4  1a000006          BNE      |L35.212|
0000b8  e1a00000          MOV      r0,r0
0000bc  e28f3e26          ADR      r3,|L35.804|
0000c0  e59f2300          LDR      r2,|L35.968|
0000c4  e28f1c03          ADR      r1,|L35.972|
0000c8  e28f0e2a          ADR      r0,|L35.880|
0000cc  ebfffffe          BL       sysprintf
0000d0  e1a00000          MOV      r0,r0
                  |L35.212|
0000d4  e1a00000          MOV      r0,r0
;;;812        if (pcb->last_timer == tcp_timer_ctr) {
0000d8  e5d40021          LDRB     r0,[r4,#0x21]
0000dc  e59f1238          LDR      r1,|L35.796|
0000e0  e5d11000          LDRB     r1,[r1,#0]  ; tcp_timer_ctr
0000e4  e1500001          CMP      r0,r1
0000e8  1a000001          BNE      |L35.244|
;;;813          /* skip this pcb, we have already processed it */
;;;814          pcb = pcb->next;
0000ec  e594400c          LDR      r4,[r4,#0xc]
;;;815          continue;
0000f0  ea000169          B        |L35.1692|
                  |L35.244|
;;;816        }
;;;817        pcb->last_timer = tcp_timer_ctr;
0000f4  e59f0220          LDR      r0,|L35.796|
0000f8  e5d00000          LDRB     r0,[r0,#0]  ; tcp_timer_ctr
0000fc  e5c40021          STRB     r0,[r4,#0x21]
;;;818    
;;;819        pcb_remove = 0;
000100  e3a06000          MOV      r6,#0
;;;820        pcb_reset = 0;
000104  e3a09000          MOV      r9,#0
;;;821    
;;;822        if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
000108  e5d40018          LDRB     r0,[r4,#0x18]
00010c  e3500002          CMP      r0,#2
000110  1a000005          BNE      |L35.300|
000114  e5d40046          LDRB     r0,[r4,#0x46]
000118  e3500006          CMP      r0,#6
00011c  1a000002          BNE      |L35.300|
;;;823          ++pcb_remove;
000120  e2860001          ADD      r0,r6,#1
000124  e20060ff          AND      r6,r0,#0xff
000128  ea000051          B        |L35.628|
                  |L35.300|
;;;824          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
;;;825        }
;;;826        else if (pcb->nrtx == TCP_MAXRTX) {
00012c  e5d40046          LDRB     r0,[r4,#0x46]
000130  e350000c          CMP      r0,#0xc
000134  1a000002          BNE      |L35.324|
;;;827          ++pcb_remove;
000138  e2860001          ADD      r0,r6,#1
00013c  e20060ff          AND      r6,r0,#0xff
000140  ea00004b          B        |L35.628|
                  |L35.324|
;;;828          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
;;;829        } else {
;;;830          if (pcb->persist_backoff > 0) {
000144  e5d40095          LDRB     r0,[r4,#0x95]
000148  e3500000          CMP      r0,#0
00014c  da000014          BLE      |L35.420|
;;;831            /* If snd_wnd is zero, use persist timer to send 1 byte probes
;;;832             * instead of using the standard retransmission mechanism. */
;;;833            pcb->persist_cnt++;
000150  e5d40094          LDRB     r0,[r4,#0x94]
000154  e2800001          ADD      r0,r0,#1
000158  e5c40094          STRB     r0,[r4,#0x94]
;;;834            if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
00015c  e5d40094          LDRB     r0,[r4,#0x94]
000160  e5d41095          LDRB     r1,[r4,#0x95]
000164  e2411001          SUB      r1,r1,#1
000168  e59f228c          LDR      r2,|L35.1020|
00016c  e7d21001          LDRB     r1,[r2,r1]
000170  e1500001          CMP      r0,r1
000174  ba00003e          BLT      |L35.628|
;;;835              pcb->persist_cnt = 0;
000178  e3a00000          MOV      r0,#0
00017c  e5c40094          STRB     r0,[r4,#0x94]
;;;836              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
000180  e5d40095          LDRB     r0,[r4,#0x95]
000184  e3500007          CMP      r0,#7
000188  2a000002          BCS      |L35.408|
;;;837                pcb->persist_backoff++;
00018c  e5d40095          LDRB     r0,[r4,#0x95]
000190  e2800001          ADD      r0,r0,#1
000194  e5c40095          STRB     r0,[r4,#0x95]
                  |L35.408|
;;;838              }
;;;839              tcp_zero_window_probe(pcb);
000198  e1a00004          MOV      r0,r4
00019c  ebfffffe          BL       tcp_zero_window_probe
0001a0  ea000033          B        |L35.628|
                  |L35.420|
;;;840            }
;;;841          } else {
;;;842            /* Increase the retransmission timer if it is running */
;;;843            if(pcb->rtime >= 0) {
0001a4  e1d403f4          LDRSH    r0,[r4,#0x34]
0001a8  e3500000          CMP      r0,#0
0001ac  ba000004          BLT      |L35.452|
;;;844              ++pcb->rtime;
0001b0  e1d403b4          LDRH     r0,[r4,#0x34]
0001b4  e2800001          ADD      r0,r0,#1
0001b8  e1a00800          LSL      r0,r0,#16
0001bc  e1a00840          ASR      r0,r0,#16
0001c0  e1c403b4          STRH     r0,[r4,#0x34]
                  |L35.452|
;;;845            }
;;;846    
;;;847            if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
0001c4  e5940070          LDR      r0,[r4,#0x70]
0001c8  e3500000          CMP      r0,#0
0001cc  0a000028          BEQ      |L35.628|
0001d0  e1d403f4          LDRSH    r0,[r4,#0x34]
0001d4  e1d414f4          LDRSH    r1,[r4,#0x44]
0001d8  e1500001          CMP      r0,r1
0001dc  ba000024          BLT      |L35.628|
;;;848              /* Time for a retransmission. */
;;;849              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
;;;850                                          " pcb->rto %"S16_F"\n",
;;;851                                          pcb->rtime, pcb->rto));
;;;852    
;;;853              /* Double retransmission time-out unless we are trying to
;;;854               * connect to somebody (i.e., we are in SYN_SENT). */
;;;855              if (pcb->state != SYN_SENT) {
0001e0  e5d40018          LDRB     r0,[r4,#0x18]
0001e4  e3500002          CMP      r0,#2
0001e8  0a000009          BEQ      |L35.532|
;;;856                pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
0001ec  e1d404b2          LDRH     r0,[r4,#0x42]
0001f0  e1d414f0          LDRSH    r1,[r4,#0x40]
0001f4  e08001c1          ADD      r0,r0,r1,ASR #3
0001f8  e5d41046          LDRB     r1,[r4,#0x46]
0001fc  e59f21fc          LDR      r2,|L35.1024|
000200  e7d21001          LDRB     r1,[r2,r1]
000204  e1a00110          LSL      r0,r0,r1
000208  e1a00800          LSL      r0,r0,#16
00020c  e1a00840          ASR      r0,r0,#16
000210  e1c404b4          STRH     r0,[r4,#0x44]
                  |L35.532|
;;;857              }
;;;858    
;;;859              /* Reset the retransmission timer. */
;;;860              pcb->rtime = 0;
000214  e3a00000          MOV      r0,#0
000218  e1c403b4          STRH     r0,[r4,#0x34]
;;;861    
;;;862              /* Reduce congestion window and ssthresh. */
;;;863              eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
00021c  e1d404bc          LDRH     r0,[r4,#0x4c]
000220  e1d416b0          LDRH     r1,[r4,#0x60]
000224  e1500001          CMP      r0,r1
000228  aa000001          BGE      |L35.564|
00022c  e1d404bc          LDRH     r0,[r4,#0x4c]
000230  ea000000          B        |L35.568|
                  |L35.564|
000234  e1d406b0          LDRH     r0,[r4,#0x60]
                  |L35.568|
000238  e1a0a000          MOV      r10,r0
;;;864              pcb->ssthresh = eff_wnd >> 1;
00023c  e1a000ca          ASR      r0,r10,#1
000240  e1c404be          STRH     r0,[r4,#0x4e]
;;;865              if (pcb->ssthresh < (pcb->mss << 1)) {
000244  e1d404be          LDRH     r0,[r4,#0x4e]
000248  e1d413b6          LDRH     r1,[r4,#0x36]
00024c  e1500081          CMP      r0,r1,LSL #1
000250  aa000003          BGE      |L35.612|
;;;866                pcb->ssthresh = (pcb->mss << 1);
000254  e1d403b6          LDRH     r0,[r4,#0x36]
000258  e59f11a4          LDR      r1,|L35.1028|
00025c  e0010080          AND      r0,r1,r0,LSL #1
000260  e1c404be          STRH     r0,[r4,#0x4e]
                  |L35.612|
;;;867              }
;;;868              pcb->cwnd = pcb->mss;
000264  e1d403b6          LDRH     r0,[r4,#0x36]
000268  e1c404bc          STRH     r0,[r4,#0x4c]
;;;869              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
;;;870                                           " ssthresh %"U16_F"\n",
;;;871                                           pcb->cwnd, pcb->ssthresh));
;;;872     
;;;873              /* The following needs to be called AFTER cwnd is set to one
;;;874                 mss - STJ */
;;;875              tcp_rexmit_rto(pcb);
00026c  e1a00004          MOV      r0,r4
000270  ebfffffe          BL       tcp_rexmit_rto
                  |L35.628|
;;;876            }
;;;877          }
;;;878        }
;;;879        /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;880        if (pcb->state == FIN_WAIT_2) {
000274  e5d40018          LDRB     r0,[r4,#0x18]
000278  e3500006          CMP      r0,#6
00027c  1a00000b          BNE      |L35.688|
;;;881          /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
;;;882          if (pcb->flags & TF_RXCLOSED) {
000280  e5d4001e          LDRB     r0,[r4,#0x1e]
000284  e2000010          AND      r0,r0,#0x10
000288  e3500000          CMP      r0,#0
00028c  0a000007          BEQ      |L35.688|
;;;883            /* PCB was fully closed (either through close() or SHUT_RDWR):
;;;884               normal FIN-WAIT timeout handling. */
;;;885            if ((u32_t)(tcp_ticks - pcb->tmr) >
000290  e59f1080          LDR      r1,|L35.792|
000294  e5940024          LDR      r0,[r4,#0x24]
000298  e5911000          LDR      r1,[r1,#0]  ; tcp_ticks
00029c  e0410000          SUB      r0,r1,r0
0002a0  e3500028          CMP      r0,#0x28
0002a4  9a000001          BLS      |L35.688|
;;;886                TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;887              ++pcb_remove;
0002a8  e2860001          ADD      r0,r6,#1
0002ac  e20060ff          AND      r6,r0,#0xff
                  |L35.688|
;;;888              LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
;;;889            }
;;;890          }
;;;891        }
;;;892    
;;;893        /* Check if KEEPALIVE should be sent */
;;;894        if(ip_get_option(pcb, SOF_KEEPALIVE) &&
0002b0  e5d40008          LDRB     r0,[r4,#8]
0002b4  e2000008          AND      r0,r0,#8
0002b8  e3500000          CMP      r0,#0
0002bc  0a000064          BEQ      |L35.1108|
;;;895           ((pcb->state == ESTABLISHED) ||
0002c0  e5d40018          LDRB     r0,[r4,#0x18]
0002c4  e3500004          CMP      r0,#4
0002c8  0a000002          BEQ      |L35.728|
;;;896            (pcb->state == CLOSE_WAIT))) {
0002cc  e5d40018          LDRB     r0,[r4,#0x18]
0002d0  e3500007          CMP      r0,#7
0002d4  1a00005e          BNE      |L35.1108|
                  |L35.728|
;;;897          if((u32_t)(tcp_ticks - pcb->tmr) >
0002d8  e5941090          LDR      r1,[r4,#0x90]
0002dc  e59f2124          LDR      r2,|L35.1032|
0002e0  e0810002          ADD      r0,r1,r2
0002e4  e3a01f7d          MOV      r1,#0x1f4
0002e8  ebfffffe          BL       __aeabi_uidivmod
0002ec  e59f2024          LDR      r2,|L35.792|
0002f0  e5941024          LDR      r1,[r4,#0x24]
0002f4  e5922000          LDR      r2,[r2,#0]  ; tcp_ticks
0002f8  e0421001          SUB      r1,r2,r1
0002fc  e1500001          CMP      r0,r1
000300  2a000041          BCS      |L35.1036|
;;;898             (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
;;;899          {
;;;900            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
;;;901                                    ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;902                                    ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;903            
;;;904            ++pcb_remove;
000304  e2860001          ADD      r0,r6,#1
000308  e20060ff          AND      r6,r0,#0xff
;;;905            ++pcb_reset;
00030c  e2890001          ADD      r0,r9,#1
000310  e20090ff          AND      r9,r0,#0xff
000314  ea00004e          B        |L35.1108|
                  |L35.792|
                          DCD      tcp_ticks
                  |L35.796|
                          DCD      tcp_timer_ctr
                  |L35.800|
                          DCD      tcp_active_pcbs
                  |L35.804|
000324  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
000328  2d312e34
00032c  2e315c73
000330  72635c63
000334  6f72655c
000338  7463702e
00033c  6300    
00033e  00                DCB      0
00033f  00                DCB      0
                  |L35.832|
                          DCD      0x00000329
                  |L35.836|
000344  7463705f          DCB      "tcp_slowtmr: active pcb->state != CLOSED\n",0
000348  736c6f77
00034c  746d723a
000350  20616374
000354  69766520
000358  7063622d
00035c  3e737461
000360  74652021
000364  3d20434c
000368  4f534544
00036c  0a00    
00036e  00                DCB      0
00036f  00                DCB      0
                  |L35.880|
000370  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000374  7274696f
000378  6e202225
00037c  73222066
000380  61696c65
000384  64206174
000388  206c696e
00038c  65202564
000390  20696e20
000394  25730a00
                  |L35.920|
                          DCD      0x0000032a
                  |L35.924|
00039c  7463705f          DCB      "tcp_slowtmr: active pcb->state != LISTEN\n",0
0003a0  736c6f77
0003a4  746d723a
0003a8  20616374
0003ac  69766520
0003b0  7063622d
0003b4  3e737461
0003b8  74652021
0003bc  3d204c49
0003c0  5354454e
0003c4  0a00    
0003c6  00                DCB      0
0003c7  00                DCB      0
                  |L35.968|
                          DCD      0x0000032b
                  |L35.972|
0003cc  7463705f          DCB      "tcp_slowtmr: active pcb->state != TIME-WAIT\n",0
0003d0  736c6f77
0003d4  746d723a
0003d8  20616374
0003dc  69766520
0003e0  7063622d
0003e4  3e737461
0003e8  74652021
0003ec  3d205449
0003f0  4d452d57
0003f4  4149540a
0003f8  00      
0003f9  00                DCB      0
0003fa  00                DCB      0
0003fb  00                DCB      0
                  |L35.1020|
                          DCD      tcp_persist_backoff
                  |L35.1024|
                          DCD      tcp_backoff
                  |L35.1028|
                          DCD      0x0000ffff
                  |L35.1032|
                          DCD      0x000a4cb8
                  |L35.1036|
;;;906          }
;;;907          else if((u32_t)(tcp_ticks - pcb->tmr) > 
00040c  e5941090          LDR      r1,[r4,#0x90]
000410  e5d42096          LDRB     r2,[r4,#0x96]
000414  e59f339c          LDR      r3,|L35.1976|
000418  e1620382          SMULBB   r2,r2,r3
00041c  e0810182          ADD      r0,r1,r2,LSL #3
000420  e3a01f7d          MOV      r1,#0x1f4
000424  ebfffffe          BL       __aeabi_uidivmod
000428  e51f2118          LDR      r2,|L35.792|
00042c  e5941024          LDR      r1,[r4,#0x24]
000430  e5922000          LDR      r2,[r2,#0]  ; tcp_ticks
000434  e0421001          SUB      r1,r2,r1
000438  e1500001          CMP      r0,r1
00043c  2a000004          BCS      |L35.1108|
;;;908                  (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
;;;909                  / TCP_SLOW_INTERVAL)
;;;910          {
;;;911            tcp_keepalive(pcb);
000440  e1a00004          MOV      r0,r4
000444  ebfffffe          BL       tcp_keepalive
;;;912            pcb->keep_cnt_sent++;
000448  e5d40096          LDRB     r0,[r4,#0x96]
00044c  e2800001          ADD      r0,r0,#1
000450  e5c40096          STRB     r0,[r4,#0x96]
                  |L35.1108|
;;;913          }
;;;914        }
;;;915    
;;;916        /* If this PCB has queued out of sequence data, but has been
;;;917           inactive for too long, will drop the data (it will eventually
;;;918           be retransmitted). */
;;;919    #if TCP_QUEUE_OOSEQ
;;;920        if (pcb->ooseq != NULL &&
000454  e5940074          LDR      r0,[r4,#0x74]
000458  e3500000          CMP      r0,#0
00045c  0a00000b          BEQ      |L35.1168|
;;;921            (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
000460  e51f1150          LDR      r1,|L35.792|
000464  e5940024          LDR      r0,[r4,#0x24]
000468  e5911000          LDR      r1,[r1,#0]  ; tcp_ticks
00046c  e0410000          SUB      r0,r1,r0
000470  e1d414f4          LDRSH    r1,[r4,#0x44]
000474  e0811081          ADD      r1,r1,r1,LSL #1
000478  e1500081          CMP      r0,r1,LSL #1
00047c  3a000003          BCC      |L35.1168|
;;;922          tcp_segs_free(pcb->ooseq);
000480  e5940074          LDR      r0,[r4,#0x74]
000484  ebfffffe          BL       tcp_segs_free
;;;923          pcb->ooseq = NULL;
000488  e3a00000          MOV      r0,#0
00048c  e5840074          STR      r0,[r4,#0x74]
                  |L35.1168|
;;;924          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
;;;925        }
;;;926    #endif /* TCP_QUEUE_OOSEQ */
;;;927    
;;;928        /* Check if this PCB has stayed too long in SYN-RCVD */
;;;929        if (pcb->state == SYN_RCVD) {
000490  e5d40018          LDRB     r0,[r4,#0x18]
000494  e3500003          CMP      r0,#3
000498  1a000007          BNE      |L35.1212|
;;;930          if ((u32_t)(tcp_ticks - pcb->tmr) >
00049c  e51f118c          LDR      r1,|L35.792|
0004a0  e5940024          LDR      r0,[r4,#0x24]
0004a4  e5911000          LDR      r1,[r1,#0]  ; tcp_ticks
0004a8  e0410000          SUB      r0,r1,r0
0004ac  e3500028          CMP      r0,#0x28
0004b0  9a000001          BLS      |L35.1212|
;;;931              TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;932            ++pcb_remove;
0004b4  e2860001          ADD      r0,r6,#1
0004b8  e20060ff          AND      r6,r0,#0xff
                  |L35.1212|
;;;933            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
;;;934          }
;;;935        }
;;;936    
;;;937        /* Check if this PCB has stayed too long in LAST-ACK */
;;;938        if (pcb->state == LAST_ACK) {
0004bc  e5d40018          LDRB     r0,[r4,#0x18]
0004c0  e3500009          CMP      r0,#9
0004c4  1a000007          BNE      |L35.1256|
;;;939          if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
0004c8  e51f11b8          LDR      r1,|L35.792|
0004cc  e5940024          LDR      r0,[r4,#0x24]
0004d0  e5911000          LDR      r1,[r1,#0]  ; tcp_ticks
0004d4  e0410000          SUB      r0,r1,r0
0004d8  e35000f0          CMP      r0,#0xf0
0004dc  9a000001          BLS      |L35.1256|
;;;940            ++pcb_remove;
0004e0  e2860001          ADD      r0,r6,#1
0004e4  e20060ff          AND      r6,r0,#0xff
                  |L35.1256|
;;;941            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
;;;942          }
;;;943        }
;;;944    
;;;945        /* If the PCB should be removed, do it. */
;;;946        if (pcb_remove) {
0004e8  e3560000          CMP      r6,#0
0004ec  0a000045          BEQ      |L35.1544|
;;;947          struct tcp_pcb *pcb2;
;;;948          tcp_err_fn err_fn;
;;;949          void *err_arg;
;;;950          tcp_pcb_purge(pcb);
0004f0  e1a00004          MOV      r0,r4
0004f4  ebfffffe          BL       tcp_pcb_purge
;;;951          /* Remove PCB from tcp_active_pcbs list. */
;;;952          if (prev != NULL) {
0004f8  e3550000          CMP      r5,#0
0004fc  0a00000f          BEQ      |L35.1344|
;;;953            LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
000500  e1a00000          MOV      r0,r0
000504  e51f01ec          LDR      r0,|L35.800|
000508  e5900000          LDR      r0,[r0,#0]  ; tcp_active_pcbs
00050c  e1540000          CMP      r4,r0
000510  1a000006          BNE      |L35.1328|
000514  e1a00000          MOV      r0,r0
000518  e24f3f7f          ADR      r3,|L35.804|
00051c  e59f2298          LDR      r2,|L35.1980|
000520  e28f1fa6          ADR      r1,|L35.1984|
000524  e24f0f6f          ADR      r0,|L35.880|
000528  ebfffffe          BL       sysprintf
00052c  e1a00000          MOV      r0,r0
                  |L35.1328|
000530  e1a00000          MOV      r0,r0
;;;954            prev->next = pcb->next;
000534  e594000c          LDR      r0,[r4,#0xc]
000538  e585000c          STR      r0,[r5,#0xc]
00053c  ea00000f          B        |L35.1408|
                  |L35.1344|
;;;955          } else {
;;;956            /* This PCB was the first. */
;;;957            LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
000540  e1a00000          MOV      r0,r0
000544  e51f022c          LDR      r0,|L35.800|
000548  e5900000          LDR      r0,[r0,#0]  ; tcp_active_pcbs
00054c  e1500004          CMP      r0,r4
000550  0a000006          BEQ      |L35.1392|
000554  e1a00000          MOV      r0,r0
000558  e24f3f8f          ADR      r3,|L35.804|
00055c  e59f2288          LDR      r2,|L35.2028|
000560  e28f1fa2          ADR      r1,|L35.2032|
000564  e24f0f7f          ADR      r0,|L35.880|
000568  ebfffffe          BL       sysprintf
00056c  e1a00000          MOV      r0,r0
                  |L35.1392|
000570  e1a00000          MOV      r0,r0
;;;958            tcp_active_pcbs = pcb->next;
000574  e51f125c          LDR      r1,|L35.800|
000578  e594000c          LDR      r0,[r4,#0xc]
00057c  e5810000          STR      r0,[r1,#0]  ; tcp_active_pcbs
                  |L35.1408|
;;;959          }
;;;960    
;;;961          if (pcb_reset) {
000580  e3590000          CMP      r9,#0
000584  0a000008          BEQ      |L35.1452|
;;;962            tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
000588  e1d401bc          LDRH     r0,[r4,#0x1c]
00058c  e1d411ba          LDRH     r1,[r4,#0x1a]
000590  e58d0004          STR      r0,[sp,#4]
000594  e58d1000          STR      r1,[sp,#0]
000598  e5940050          LDR      r0,[r4,#0x50]
00059c  e5941028          LDR      r1,[r4,#0x28]
0005a0  e2843004          ADD      r3,r4,#4
0005a4  e1a02004          MOV      r2,r4
0005a8  ebfffffe          BL       tcp_rst
                  |L35.1452|
;;;963              pcb->local_port, pcb->remote_port);
;;;964          }
;;;965    
;;;966          err_fn = pcb->errf;
0005ac  e594808c          LDR      r8,[r4,#0x8c]
;;;967          err_arg = pcb->callback_arg;
0005b0  e594b010          LDR      r11,[r4,#0x10]
;;;968          pcb2 = pcb;
0005b4  e1a07004          MOV      r7,r4
;;;969          pcb = pcb->next;
0005b8  e594400c          LDR      r4,[r4,#0xc]
;;;970          memp_free(MEMP_TCP_PCB, pcb2);
0005bc  e1a01007          MOV      r1,r7
0005c0  e3a00001          MOV      r0,#1
0005c4  ebfffffe          BL       memp_free
;;;971    
;;;972          tcp_active_pcbs_changed = 0;
0005c8  e3a00000          MOV      r0,#0
0005cc  e59f1248          LDR      r1,|L35.2076|
0005d0  e5c10000          STRB     r0,[r1,#0]  ; tcp_active_pcbs_changed
;;;973          TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
0005d4  e1a00000          MOV      r0,r0
0005d8  e3580000          CMP      r8,#0
0005dc  0a000002          BEQ      |L35.1516|
0005e0  e3e01009          MVN      r1,#9
0005e4  e1a0000b          MOV      r0,r11
0005e8  e12fff38          BLX      r8
                  |L35.1516|
0005ec  e1a00000          MOV      r0,r0
;;;974          if (tcp_active_pcbs_changed) {
0005f0  e59f0224          LDR      r0,|L35.2076|
0005f4  e5d00000          LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
0005f8  e3500000          CMP      r0,#0
0005fc  0a000000          BEQ      |L35.1540|
;;;975            goto tcp_slowtmr_start;
000600  eafffe8c          B        |L35.56|
                  |L35.1540|
;;;976          }
;;;977        } else {
000604  ea000023          B        |L35.1688|
                  |L35.1544|
;;;978          /* get the 'next' element now and work with 'prev' below (in case of abort) */
;;;979          prev = pcb;
000608  e1a05004          MOV      r5,r4
;;;980          pcb = pcb->next;
00060c  e594400c          LDR      r4,[r4,#0xc]
;;;981    
;;;982          /* We check if we should poll the connection. */
;;;983          ++prev->polltmr;
000610  e5d5001f          LDRB     r0,[r5,#0x1f]
000614  e2800001          ADD      r0,r0,#1
000618  e5c5001f          STRB     r0,[r5,#0x1f]
;;;984          if (prev->polltmr >= prev->pollinterval) {
00061c  e5d5001f          LDRB     r0,[r5,#0x1f]
000620  e5d51020          LDRB     r1,[r5,#0x20]
000624  e1500001          CMP      r0,r1
000628  ba00001a          BLT      |L35.1688|
;;;985            prev->polltmr = 0;
00062c  e3a00000          MOV      r0,#0
000630  e5c5001f          STRB     r0,[r5,#0x1f]
;;;986            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
;;;987            tcp_active_pcbs_changed = 0;
000634  e59f11e0          LDR      r1,|L35.2076|
000638  e5c10000          STRB     r0,[r1,#0]  ; tcp_active_pcbs_changed
;;;988            TCP_EVENT_POLL(prev, err);
00063c  e1a00000          MOV      r0,r0
000640  e5950088          LDR      r0,[r5,#0x88]
000644  e3500000          CMP      r0,#0
000648  0a000005          BEQ      |L35.1636|
00064c  e5950010          LDR      r0,[r5,#0x10]
000650  e5952088          LDR      r2,[r5,#0x88]
000654  e1a01005          MOV      r1,r5
000658  e12fff32          BLX      r2
00065c  e58d0008          STR      r0,[sp,#8]
000660  ea000001          B        |L35.1644|
                  |L35.1636|
000664  e3a00000          MOV      r0,#0
000668  e58d0008          STR      r0,[sp,#8]
                  |L35.1644|
00066c  e1a00000          MOV      r0,r0
;;;989            if (tcp_active_pcbs_changed) {
000670  e59f01a4          LDR      r0,|L35.2076|
000674  e5d00000          LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
000678  e3500000          CMP      r0,#0
00067c  0a000000          BEQ      |L35.1668|
;;;990              goto tcp_slowtmr_start;
000680  eafffe6c          B        |L35.56|
                  |L35.1668|
;;;991            }
;;;992            /* if err == ERR_ABRT, 'prev' is already deallocated */
;;;993            if (err == ERR_OK) {
000684  e59d0008          LDR      r0,[sp,#8]
000688  e3500000          CMP      r0,#0
00068c  1a000001          BNE      |L35.1688|
;;;994              tcp_output(prev);
000690  e1a00005          MOV      r0,r5
000694  ebfffffe          BL       tcp_output
                  |L35.1688|
000698  e1a00000          MOV      r0,r0                 ;815
                  |L35.1692|
00069c  e3540000          CMP      r4,#0                 ;807
0006a0  1afffe68          BNE      |L35.72|
;;;995            }
;;;996          }
;;;997        }
;;;998      }
;;;999    
;;;1000     
;;;1001     /* Steps through all of the TIME-WAIT PCBs. */
;;;1002     prev = NULL;
0006a4  e3a05000          MOV      r5,#0
;;;1003     pcb = tcp_tw_pcbs;
0006a8  e59f0170          LDR      r0,|L35.2080|
0006ac  e5904000          LDR      r4,[r0,#0]  ; tcp_tw_pcbs
;;;1004     while (pcb != NULL) {
0006b0  ea000082          B        |L35.2240|
                  |L35.1716|
;;;1005       LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
0006b4  e1a00000          MOV      r0,r0
0006b8  e5d40018          LDRB     r0,[r4,#0x18]
0006bc  e350000a          CMP      r0,#0xa
0006c0  0a000006          BEQ      |L35.1760|
0006c4  e1a00000          MOV      r0,r0
0006c8  e24f3feb          ADR      r3,|L35.804|
0006cc  e59f2150          LDR      r2,|L35.2084|
0006d0  e28f1e15          ADR      r1,|L35.2088|
0006d4  e24f0fdb          ADR      r0,|L35.880|
0006d8  ebfffffe          BL       sysprintf
0006dc  e1a00000          MOV      r0,r0
                  |L35.1760|
0006e0  e1a00000          MOV      r0,r0
;;;1006       pcb_remove = 0;
0006e4  e3a06000          MOV      r6,#0
;;;1007   
;;;1008       /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;1009       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
0006e8  e51f13d8          LDR      r1,|L35.792|
0006ec  e5940024          LDR      r0,[r4,#0x24]
0006f0  e5911000          LDR      r1,[r1,#0]  ; tcp_ticks
0006f4  e0410000          SUB      r0,r1,r0
0006f8  e35000f0          CMP      r0,#0xf0
0006fc  9a000001          BLS      |L35.1800|
;;;1010         ++pcb_remove;
000700  e2860001          ADD      r0,r6,#1
000704  e20060ff          AND      r6,r0,#0xff
                  |L35.1800|
;;;1011       }
;;;1012       
;;;1013   
;;;1014   
;;;1015       /* If the PCB should be removed, do it. */
;;;1016       if (pcb_remove) {
000708  e3560000          CMP      r6,#0
00070c  0a000069          BEQ      |L35.2232|
;;;1017         struct tcp_pcb *pcb2;
;;;1018         tcp_pcb_purge(pcb);
000710  e1a00004          MOV      r0,r4
000714  ebfffffe          BL       tcp_pcb_purge
;;;1019         /* Remove PCB from tcp_tw_pcbs list. */
;;;1020         if (prev != NULL) {
000718  e3550000          CMP      r5,#0
00071c  0a00000f          BEQ      |L35.1888|
;;;1021           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
000720  e1a00000          MOV      r0,r0
000724  e59f00f4          LDR      r0,|L35.2080|
000728  e5900000          LDR      r0,[r0,#0]  ; tcp_tw_pcbs
00072c  e1540000          CMP      r4,r0
000730  1a000006          BNE      |L35.1872|
000734  e1a00000          MOV      r0,r0
000738  e59f3118          LDR      r3,|L35.2136|
00073c  e59f2118          LDR      r2,|L35.2140|
000740  e28f1f46          ADR      r1,|L35.2144|
000744  e24f0ff7          ADR      r0,|L35.880|
000748  ebfffffe          BL       sysprintf
00074c  e1a00000          MOV      r0,r0
                  |L35.1872|
000750  e1a00000          MOV      r0,r0
;;;1022           prev->next = pcb->next;
000754  e594000c          LDR      r0,[r4,#0xc]
000758  e585000c          STR      r0,[r5,#0xc]
00075c  ea00000f          B        |L35.1952|
                  |L35.1888|
;;;1023         } else {
;;;1024           /* This PCB was the first. */
;;;1025           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
000760  e1a00000          MOV      r0,r0
000764  e59f00b4          LDR      r0,|L35.2080|
000768  e5900000          LDR      r0,[r0,#0]  ; tcp_tw_pcbs
00076c  e1500004          CMP      r0,r4
000770  0a000006          BEQ      |L35.1936|
000774  e1a00000          MOV      r0,r0
000778  e59f30d8          LDR      r3,|L35.2136|
00077c  e59f2104          LDR      r2,|L35.2184|
000780  e28f1f41          ADR      r1,|L35.2188|
000784  e59f0128          LDR      r0,|L35.2228|
000788  ebfffffe          BL       sysprintf
00078c  e1a00000          MOV      r0,r0
                  |L35.1936|
000790  e1a00000          MOV      r0,r0
;;;1026           tcp_tw_pcbs = pcb->next;
000794  e59f1084          LDR      r1,|L35.2080|
000798  e594000c          LDR      r0,[r4,#0xc]
00079c  e5810000          STR      r0,[r1,#0]  ; tcp_tw_pcbs
                  |L35.1952|
;;;1027         }
;;;1028         pcb2 = pcb;
0007a0  e1a07004          MOV      r7,r4
;;;1029         pcb = pcb->next;
0007a4  e594400c          LDR      r4,[r4,#0xc]
;;;1030         memp_free(MEMP_TCP_PCB, pcb2);
0007a8  e1a01007          MOV      r1,r7
0007ac  e3a00001          MOV      r0,#1
0007b0  ebfffffe          BL       memp_free
;;;1031       } else {
0007b4  ea000041          B        |L35.2240|
                  |L35.1976|
                          DCD      0x0000249f
                  |L35.1980|
                          DCD      0x000003b9
                  |L35.1984|
0007c0  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_active_pcbs",0
0007c4  736c6f77
0007c8  746d723a
0007cc  206d6964
0007d0  646c6520
0007d4  74637020
0007d8  213d2074
0007dc  63705f61
0007e0  63746976
0007e4  655f7063
0007e8  627300  
0007eb  00                DCB      0
                  |L35.2028|
                          DCD      0x000003bd
                  |L35.2032|
0007f0  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_active_pcbs",0
0007f4  736c6f77
0007f8  746d723a
0007fc  20666972
000800  73742070
000804  6362203d
000808  3d207463
00080c  705f6163
000810  74697665
000814  5f706362
000818  7300    
00081a  00                DCB      0
00081b  00                DCB      0
                  |L35.2076|
                          DCD      tcp_active_pcbs_changed
                  |L35.2080|
                          DCD      tcp_tw_pcbs
                  |L35.2084|
                          DCD      0x000003ed
                  |L35.2088|
000828  7463705f          DCB      "tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT",0
00082c  736c6f77
000830  746d723a
000834  2054494d
000838  452d5741
00083c  49542070
000840  63622d3e
000844  73746174
000848  65203d3d
00084c  2054494d
000850  452d5741
000854  495400  
000857  00                DCB      0
                  |L35.2136|
                          DCD      ||i.tcp_slowtmr||+0x324
                  |L35.2140|
                          DCD      0x000003fd
                  |L35.2144|
000860  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_tw_pcbs",0
000864  736c6f77
000868  746d723a
00086c  206d6964
000870  646c6520
000874  74637020
000878  213d2074
00087c  63705f74
000880  775f7063
000884  627300  
000887  00                DCB      0
                  |L35.2184|
                          DCD      0x00000401
                  |L35.2188|
00088c  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_tw_pcbs",0
000890  736c6f77
000894  746d723a
000898  20666972
00089c  73742070
0008a0  6362203d
0008a4  3d207463
0008a8  705f7477
0008ac  5f706362
0008b0  7300    
0008b2  00                DCB      0
0008b3  00                DCB      0
                  |L35.2228|
                          DCD      ||i.tcp_slowtmr||+0x370
                  |L35.2232|
;;;1032         prev = pcb;
0008b8  e1a05004          MOV      r5,r4
;;;1033         pcb = pcb->next;
0008bc  e594400c          LDR      r4,[r4,#0xc]
                  |L35.2240|
0008c0  e3540000          CMP      r4,#0                 ;1004
0008c4  1affff7a          BNE      |L35.1716|
;;;1034       }
;;;1035     }
;;;1036   }
0008c8  e8bd8ffe          POP      {r1-r11,pc}
;;;1037   
                          ENDP


                          AREA ||i.tcp_tmr||, CODE, READONLY, ALIGN=2

                  tcp_tmr PROC
;;;140    void
;;;141    tcp_tmr(void)
000000  e92d4010          PUSH     {r4,lr}
;;;142    {
;;;143      /* Call tcp_fasttmr() every 250 ms */
;;;144      tcp_fasttmr();
000004  ebfffffe          BL       tcp_fasttmr
;;;145    
;;;146      if (++tcp_timer & 1) {
000008  e59f0024          LDR      r0,|L36.52|
00000c  e5d00000          LDRB     r0,[r0,#0]  ; tcp_timer
000010  e2800001          ADD      r0,r0,#1
000014  e20000ff          AND      r0,r0,#0xff
000018  e59f1014          LDR      r1,|L36.52|
00001c  e5c10000          STRB     r0,[r1,#0]  ; tcp_timer
000020  e2000001          AND      r0,r0,#1
000024  e3500000          CMP      r0,#0
000028  0a000000          BEQ      |L36.48|
;;;147        /* Call tcp_tmr() every 500 ms, i.e., every other timer
;;;148           tcp_tmr() is called. */
;;;149        tcp_slowtmr();
00002c  ebfffffe          BL       tcp_slowtmr
                  |L36.48|
;;;150      }
;;;151    }
000030  e8bd8010          POP      {r4,pc}
;;;152    
                          ENDP

                  |L36.52|
                          DCD      tcp_timer

                          AREA ||i.tcp_update_rcv_ann_wnd||, CODE, READONLY, ALIGN=2

                  tcp_update_rcv_ann_wnd PROC
;;;577     */
;;;578    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;579    {
000004  e1a04000          MOV      r4,r0
;;;580      u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
000008  e5940028          LDR      r0,[r4,#0x28]
00000c  e1d412bc          LDRH     r1,[r4,#0x2c]
000010  e0805001          ADD      r5,r0,r1
;;;581    
;;;582      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
000014  e5941030          LDR      r1,[r4,#0x30]
000018  e1d403b6          LDRH     r0,[r4,#0x36]
00001c  e3500e43          CMP      r0,#0x430
000020  da000001          BLE      |L37.44|
000024  e3a00e43          MOV      r0,#0x430
000028  ea000000          B        |L37.48|
                  |L37.44|
00002c  e1d403b6          LDRH     r0,[r4,#0x36]
                  |L37.48|
000030  e0800001          ADD      r0,r0,r1
000034  e0550000          SUBS     r0,r5,r0
000038  4a000004          BMI      |L37.80|
;;;583        /* we can advertise more window */
;;;584        pcb->rcv_ann_wnd = pcb->rcv_wnd;
00003c  e1d402bc          LDRH     r0,[r4,#0x2c]
000040  e1c402be          STRH     r0,[r4,#0x2e]
;;;585        return new_right_edge - pcb->rcv_ann_right_edge;
000044  e5940030          LDR      r0,[r4,#0x30]
000048  e0450000          SUB      r0,r5,r0
                  |L37.76|
;;;586      } else {
;;;587        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;588          /* Can happen due to other end sending out of advertised window,
;;;589           * but within actual available (but not yet advertised) window */
;;;590          pcb->rcv_ann_wnd = 0;
;;;591        } else {
;;;592          /* keep the right edge of window constant */
;;;593          u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;594          LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
;;;595          pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
;;;596        }
;;;597        return 0;
;;;598      }
;;;599    }
00004c  e8bd8070          POP      {r4-r6,pc}
                  |L37.80|
000050  e5940028          LDR      r0,[r4,#0x28]         ;587
000054  e5941030          LDR      r1,[r4,#0x30]         ;587
000058  e0400001          SUB      r0,r0,r1              ;587
00005c  e3500000          CMP      r0,#0                 ;587
000060  da000002          BLE      |L37.112|
000064  e3a00000          MOV      r0,#0                 ;590
000068  e1c402be          STRH     r0,[r4,#0x2e]         ;590
00006c  ea00000f          B        |L37.176|
                  |L37.112|
000070  e5940030          LDR      r0,[r4,#0x30]         ;593
000074  e5941028          LDR      r1,[r4,#0x28]         ;593
000078  e0406001          SUB      r6,r0,r1              ;593
00007c  e1a00000          MOV      r0,r0                 ;594
000080  e3560801          CMP      r6,#0x10000           ;594
000084  3a000006          BCC      |L37.164|
000088  e1a00000          MOV      r0,r0                 ;594
00008c  e28f3024          ADR      r3,|L37.184|
000090  e59f203c          LDR      r2,|L37.212|
000094  e28f103c          ADR      r1,|L37.216|
000098  e28f0054          ADR      r0,|L37.244|
00009c  ebfffffe          BL       sysprintf
0000a0  e1a00000          MOV      r0,r0                 ;594
                  |L37.164|
0000a4  e1a00000          MOV      r0,r0                 ;594
0000a8  e1c462be          STRH     r6,[r4,#0x2e]         ;595
0000ac  e1a00000          MOV      r0,r0                 ;596
                  |L37.176|
0000b0  e3a00000          MOV      r0,#0                 ;597
0000b4  eaffffe4          B        |L37.76|
;;;600    
                          ENDP

                  |L37.184|
0000b8  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
0000bc  2d312e34
0000c0  2e315c73
0000c4  72635c63
0000c8  6f72655c
0000cc  7463702e
0000d0  6300    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L37.212|
                          DCD      0x00000252
                  |L37.216|
0000d8  6e65775f          DCB      "new_rcv_ann_wnd <= 0xffff",0
0000dc  7263765f
0000e0  616e6e5f
0000e4  776e6420
0000e8  3c3d2030
0000ec  78666666
0000f0  6600    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L37.244|
0000f4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f8  7274696f
0000fc  6e202225
000100  73222066
000104  61696c65
000108  64206174
00010c  206c696e
000110  65202564
000114  20696e20
000118  25730a00

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  tcp_state_str
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x34
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x4c
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x6c
                  tcp_backoff
00002c  01020304          DCB      0x01,0x02,0x03,0x04
000030  05060707          DCB      0x05,0x06,0x07,0x07
000034  07070707          DCB      0x07,0x07,0x07,0x07
000038  07                DCB      0x07
                  tcp_persist_backoff
000039  03060c            DCB      0x03,0x06,0x0c
00003c  18306078          DCB      0x18,0x30,0x60,0x78
                  tcp_pcb_lists
                          DCD      tcp_listen_pcbs
                          DCD      tcp_bound_pcbs
                          DCD      tcp_active_pcbs
                          DCD      tcp_tw_pcbs

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  434c4f53          DCB      "CLOSED",0
000004  454400  
000007  00                DCB      0
000008  4c495354          DCB      "LISTEN",0
00000c  454e00  
00000f  00                DCB      0
000010  53594e5f          DCB      "SYN_SENT",0
000014  53454e54
000018  00      
000019  00                DCB      0
00001a  00                DCB      0
00001b  00                DCB      0
00001c  53594e5f          DCB      "SYN_RCVD",0
000020  52435644
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
000028  45535441          DCB      "ESTABLISHED",0
00002c  424c4953
000030  48454400
000034  46494e5f          DCB      "FIN_WAIT_1",0
000038  57414954
00003c  5f3100  
00003f  00                DCB      0
000040  46494e5f          DCB      "FIN_WAIT_2",0
000044  57414954
000048  5f3200  
00004b  00                DCB      0
00004c  434c4f53          DCB      "CLOSE_WAIT",0
000050  455f5741
000054  495400  
000057  00                DCB      0
000058  434c4f53          DCB      "CLOSING",0
00005c  494e4700
000060  4c415354          DCB      "LAST_ACK",0
000064  5f41434b
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  54494d45          DCB      "TIME_WAIT",0
000070  5f574149
000074  5400    

                          AREA ||.data||, DATA, ALIGN=2

                  tcp_port
000000  c000              DCW      0xc000
000002  0000              DCB      0x00,0x00
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000
                  tcp_tmp_pcb
                          DCD      0x00000000
                  tcp_active_pcbs_changed
00001c  00                DCB      0x00
                  tcp_timer
00001d  00                DCB      0x00
                  tcp_timer_ctr
00001e  0000              DCB      0x00,0x00
                  iss
                          DCD      0x0000196e
