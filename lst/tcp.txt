; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\tcp.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tcp.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\tcp.crf lwip-1.4.1\src\core\tcp.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tcp_init PROC
;;;129    void
;;;130    tcp_init(void)
000000  e12fff1e          BX       lr
;;;131    {
;;;132    #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;133      tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;134    #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;135    }
;;;136    
                          ENDP

                  tcp_seg_free PROC
;;;1141   void
;;;1142   tcp_seg_free(struct tcp_seg *seg)
000004  e92d4010          PUSH     {r4,lr}
;;;1143   {
000008  e1b04000          MOVS     r4,r0
;;;1144     if (seg != NULL) {
;;;1145       if (seg->p != NULL) {
;;;1146         pbuf_free(seg->p);
;;;1147   #if TCP_DEBUG
;;;1148         seg->p = NULL;
;;;1149   #endif /* TCP_DEBUG */
;;;1150       }
;;;1151       memp_free(MEMP_TCP_SEG, seg);
;;;1152     }
;;;1153   }
00000c  08bd8010          POPEQ    {r4,pc}
000010  e5940004          LDR      r0,[r4,#4]            ;1145
000014  e3500000          CMP      r0,#0                 ;1145
000018  1bfffffe          BLNE     pbuf_free
00001c  e1a01004          MOV      r1,r4                 ;1151
000020  e8bd4010          POP      {r4,lr}               ;1151
000024  e3a00003          MOV      r0,#3                 ;1151
000028  eafffffe          B        memp_free
;;;1154   
                          ENDP

                  tcp_segs_free PROC
;;;1126   void
;;;1127   tcp_segs_free(struct tcp_seg *seg)
00002c  e92d4010          PUSH     {r4,lr}
;;;1128   {
;;;1129     while (seg != NULL) {
;;;1130       struct tcp_seg *next = seg->next;
;;;1131       tcp_seg_free(seg);
;;;1132       seg = next;
;;;1133     }
000030  ea000002          B        |L1.64|
                  |L1.52|
000034  e5904000          LDR      r4,[r0,#0]            ;1130
000038  ebfffffe          BL       tcp_seg_free
00003c  e1a00004          MOV      r0,r4                 ;1132
                  |L1.64|
000040  e3500000          CMP      r0,#0                 ;1129
000044  1afffffa          BNE      |L1.52|
;;;1134   }
000048  e8bd8010          POP      {r4,pc}
;;;1135   
                          ENDP

                  tcp_pcb_purge PROC
;;;1468   void
;;;1469   tcp_pcb_purge(struct tcp_pcb *pcb)
00004c  e92d4070          PUSH     {r4-r6,lr}
;;;1470   {
000050  e1a04000          MOV      r4,r0
;;;1471     if (pcb->state != CLOSED &&
000054  e5d00018          LDRB     r0,[r0,#0x18]
000058  e3500000          CMP      r0,#0
;;;1472        pcb->state != TIME_WAIT &&
00005c  1350000a          CMPNE    r0,#0xa
;;;1473        pcb->state != LISTEN) {
000060  13500001          CMPNE    r0,#1
;;;1474   
;;;1475       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
;;;1476   
;;;1477   #if TCP_LISTEN_BACKLOG
;;;1478       if (pcb->state == SYN_RCVD) {
;;;1479         /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
;;;1480         struct tcp_pcb_listen *lpcb;
;;;1481         LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
;;;1482           tcp_listen_pcbs.listen_pcbs != NULL);
;;;1483         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;1484           if ((lpcb->local_port == pcb->local_port) &&
;;;1485               (ip_addr_isany(&lpcb->local_ip) ||
;;;1486                ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
;;;1487               /* port and address of the listen pcb match the timed-out pcb */
;;;1488               LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
;;;1489                 lpcb->accepts_pending > 0);
;;;1490               lpcb->accepts_pending--;
;;;1491               break;
;;;1492             }
;;;1493         }
;;;1494       }
;;;1495   #endif /* TCP_LISTEN_BACKLOG */
;;;1496   
;;;1497   
;;;1498       if (pcb->refused_data != NULL) {
;;;1499         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
;;;1500         pbuf_free(pcb->refused_data);
;;;1501         pcb->refused_data = NULL;
;;;1502       }
;;;1503       if (pcb->unsent != NULL) {
;;;1504         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
;;;1505       }
;;;1506       if (pcb->unacked != NULL) {
;;;1507         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
;;;1508       }
;;;1509   #if TCP_QUEUE_OOSEQ
;;;1510       if (pcb->ooseq != NULL) {
;;;1511         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
;;;1512       }
;;;1513       tcp_segs_free(pcb->ooseq);
;;;1514       pcb->ooseq = NULL;
;;;1515   #endif /* TCP_QUEUE_OOSEQ */
;;;1516   
;;;1517       /* Stop the retransmission timer as it will expect data on unacked
;;;1518          queue if it fires */
;;;1519       pcb->rtime = -1;
;;;1520   
;;;1521       tcp_segs_free(pcb->unsent);
;;;1522       tcp_segs_free(pcb->unacked);
;;;1523       pcb->unacked = pcb->unsent = NULL;
;;;1524   #if TCP_OVERSIZE
;;;1525       pcb->unsent_oversize = 0;
;;;1526   #endif /* TCP_OVERSIZE */
;;;1527     }
;;;1528   }
000064  08bd8070          POPEQ    {r4-r6,pc}
000068  e5940078          LDR      r0,[r4,#0x78]         ;1498
00006c  e3a05000          MOV      r5,#0                 ;1498
000070  e3500000          CMP      r0,#0                 ;1498
000074  0a000001          BEQ      |L1.128|
000078  ebfffffe          BL       pbuf_free
00007c  e5845078          STR      r5,[r4,#0x78]         ;1501
                  |L1.128|
000080  e5940074          LDR      r0,[r4,#0x74]         ;1513
000084  ebfffffe          BL       tcp_segs_free
000088  e3e00000          MVN      r0,#0                 ;1519
00008c  e5845074          STR      r5,[r4,#0x74]         ;1519
000090  e1c403b4          STRH     r0,[r4,#0x34]         ;1519
000094  e594006c          LDR      r0,[r4,#0x6c]         ;1521
000098  ebfffffe          BL       tcp_segs_free
00009c  e5940070          LDR      r0,[r4,#0x70]         ;1522
0000a0  ebfffffe          BL       tcp_segs_free
0000a4  e584506c          STR      r5,[r4,#0x6c]         ;1523
0000a8  e5845070          STR      r5,[r4,#0x70]         ;1523
0000ac  e1c456ba          STRH     r5,[r4,#0x6a]         ;1525
0000b0  e8bd8070          POP      {r4-r6,pc}
;;;1529   
                          ENDP

                  tcp_slowtmr PROC
;;;786    void
;;;787    tcp_slowtmr(void)
0000b4  e92d5ffc          PUSH     {r2-r12,lr}
;;;788    {
;;;789      struct tcp_pcb *pcb, *prev;
;;;790      u16_t eff_wnd;
;;;791      u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;792      u8_t pcb_reset;       /* flag if a RST should be sent when removing */
;;;793      err_t err;
;;;794    
;;;795      err = ERR_OK;
;;;796    
;;;797      ++tcp_ticks;
0000b8  e59fa2b4          LDR      r10,|L1.884|
;;;798      ++tcp_timer_ctr;
0000bc  e3a08000          MOV      r8,#0
0000c0  e59a000c          LDR      r0,[r10,#0xc]         ;797  ; tcp_ticks
0000c4  e2800001          ADD      r0,r0,#1              ;797
0000c8  e58a000c          STR      r0,[r10,#0xc]         ;797  ; tcp_ticks
0000cc  e5da0002          LDRB     r0,[r10,#2]  ; tcp_timer_ctr
0000d0  e2800001          ADD      r0,r0,#1
0000d4  e5ca0002          STRB     r0,[r10,#2]  ; tcp_timer_ctr
                  |L1.216|
;;;799    
;;;800    tcp_slowtmr_start:
;;;801      /* Steps through all of the active PCBs. */
;;;802      prev = NULL;
;;;803      pcb = tcp_active_pcbs;
0000d8  e59a4018          LDR      r4,[r10,#0x18]  ; tcp_active_pcbs
0000dc  e3a06000          MOV      r6,#0                 ;802
;;;804      if (pcb == NULL) {
;;;805        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
;;;806      }
;;;807      while (pcb != NULL) {
0000e0  ea00012f          B        |L1.1444|
                  |L1.228|
;;;808        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
;;;809        LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
0000e4  e5d40018          LDRB     r0,[r4,#0x18]
0000e8  e3500000          CMP      r0,#0
0000ec  1a000004          BNE      |L1.260|
0000f0  e59f229c          LDR      r2,|L1.916|
0000f4  e28f3f9f          ADR      r3,|L1.888|
0000f8  e28f1fa6          ADR      r1,|L1.920|
0000fc  e28f0d0b          ADR      r0,|L1.964|
000100  ebfffffe          BL       sysprintf
                  |L1.260|
;;;810        LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
000104  e5d40018          LDRB     r0,[r4,#0x18]
000108  e3500001          CMP      r0,#1
00010c  1a000004          BNE      |L1.292|
000110  e59f22d4          LDR      r2,|L1.1004|
000114  e28f3f97          ADR      r3,|L1.888|
000118  e28f1e2d          ADR      r1,|L1.1008|
00011c  e28f0e2a          ADR      r0,|L1.964|
000120  ebfffffe          BL       sysprintf
                  |L1.292|
;;;811        LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
000124  e5d40018          LDRB     r0,[r4,#0x18]
000128  e350000a          CMP      r0,#0xa
00012c  1a000004          BNE      |L1.324|
000130  e59f22e4          LDR      r2,|L1.1052|
000134  e28f3f8f          ADR      r3,|L1.888|
000138  e28f1e2e          ADR      r1,|L1.1056|
00013c  e28f0d0a          ADR      r0,|L1.964|
000140  ebfffffe          BL       sysprintf
                  |L1.324|
;;;812        if (pcb->last_timer == tcp_timer_ctr) {
000144  e5d41021          LDRB     r1,[r4,#0x21]
000148  e5da0002          LDRB     r0,[r10,#2]  ; tcp_timer_ctr
00014c  e1510000          CMP      r1,r0
;;;813          /* skip this pcb, we have already processed it */
;;;814          pcb = pcb->next;
000150  0594400c          LDREQ    r4,[r4,#0xc]
000154  0a000112          BEQ      |L1.1444|
;;;815          continue;
;;;816        }
;;;817        pcb->last_timer = tcp_timer_ctr;
000158  e5c40021          STRB     r0,[r4,#0x21]
;;;818    
;;;819        pcb_remove = 0;
;;;820        pcb_reset = 0;
;;;821    
;;;822        if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
00015c  e5d41018          LDRB     r1,[r4,#0x18]
000160  e3a05000          MOV      r5,#0                 ;819
000164  e1a07005          MOV      r7,r5                 ;820
000168  e3510002          CMP      r1,#2
00016c  05d40046          LDRBEQ   r0,[r4,#0x46]
000170  03500006          CMPEQ    r0,#6
;;;823          ++pcb_remove;
000174  03a05001          MOVEQ    r5,#1
000178  0a000044          BEQ      |L1.656|
;;;824          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
;;;825        }
;;;826        else if (pcb->nrtx == TCP_MAXRTX) {
00017c  e5d42046          LDRB     r2,[r4,#0x46]
000180  e352000c          CMP      r2,#0xc
;;;827          ++pcb_remove;
000184  03a05001          MOVEQ    r5,#1
000188  0a000035          BEQ      |L1.612|
;;;828          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
;;;829        } else {
;;;830          if (pcb->persist_backoff > 0) {
00018c  e5d40095          LDRB     r0,[r4,#0x95]
000190  e3500000          CMP      r0,#0
000194  0a00000f          BEQ      |L1.472|
;;;831            /* If snd_wnd is zero, use persist timer to send 1 byte probes
;;;832             * instead of using the standard retransmission mechanism. */
;;;833            pcb->persist_cnt++;
000198  e5d41094          LDRB     r1,[r4,#0x94]
;;;834            if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
00019c  e59f22ac          LDR      r2,|L1.1104|
0001a0  e2811001          ADD      r1,r1,#1              ;833
0001a4  e20110ff          AND      r1,r1,#0xff           ;833
0001a8  e0822000          ADD      r2,r2,r0
0001ac  e5c41094          STRB     r1,[r4,#0x94]         ;833
0001b0  e5522001          LDRB     r2,[r2,#-1]
0001b4  e1520001          CMP      r2,r1
0001b8  8a000029          BHI      |L1.612|
;;;835              pcb->persist_cnt = 0;
;;;836              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
0001bc  e3500007          CMP      r0,#7
0001c0  32800001          ADDCC    r0,r0,#1
0001c4  e5c48094          STRB     r8,[r4,#0x94]         ;835
;;;837                pcb->persist_backoff++;
0001c8  35c40095          STRBCC   r0,[r4,#0x95]
;;;838              }
;;;839              tcp_zero_window_probe(pcb);
0001cc  e1a00004          MOV      r0,r4
0001d0  ebfffffe          BL       tcp_zero_window_probe
0001d4  ea000022          B        |L1.612|
                  |L1.472|
;;;840            }
;;;841          } else {
;;;842            /* Increase the retransmission timer if it is running */
;;;843            if(pcb->rtime >= 0) {
0001d8  e1d403f4          LDRSH    r0,[r4,#0x34]
0001dc  e3500000          CMP      r0,#0
0001e0  a2800001          ADDGE    r0,r0,#1
;;;844              ++pcb->rtime;
0001e4  a1c403b4          STRHGE   r0,[r4,#0x34]
;;;845            }
;;;846    
;;;847            if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
0001e8  e5940070          LDR      r0,[r4,#0x70]
0001ec  e3500000          CMP      r0,#0
0001f0  0a00001b          BEQ      |L1.612|
0001f4  e1d403f4          LDRSH    r0,[r4,#0x34]
0001f8  e1d434f4          LDRSH    r3,[r4,#0x44]
0001fc  e1500003          CMP      r0,r3
000200  ba000017          BLT      |L1.612|
;;;848              /* Time for a retransmission. */
;;;849              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
;;;850                                          " pcb->rto %"S16_F"\n",
;;;851                                          pcb->rtime, pcb->rto));
;;;852    
;;;853              /* Double retransmission time-out unless we are trying to
;;;854               * connect to somebody (i.e., we are in SYN_SENT). */
;;;855              if (pcb->state != SYN_SENT) {
000204  e3510002          CMP      r1,#2
000208  0a000006          BEQ      |L1.552|
;;;856                pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
00020c  e1d404b2          LDRH     r0,[r4,#0x42]
000210  e1d414f0          LDRSH    r1,[r4,#0x40]
000214  e08001c1          ADD      r0,r0,r1,ASR #3
000218  e59f1234          LDR      r1,|L1.1108|
00021c  e7d11002          LDRB     r1,[r1,r2]
000220  e1a00110          LSL      r0,r0,r1
000224  e1c404b4          STRH     r0,[r4,#0x44]
                  |L1.552|
;;;857              }
;;;858    
;;;859              /* Reset the retransmission timer. */
;;;860              pcb->rtime = 0;
000228  e1c483b4          STRH     r8,[r4,#0x34]
;;;861    
;;;862              /* Reduce congestion window and ssthresh. */
;;;863              eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
00022c  e1d404bc          LDRH     r0,[r4,#0x4c]
000230  e1d416b0          LDRH     r1,[r4,#0x60]
000234  e1500001          CMP      r0,r1
000238  21a00001          MOVCS    r0,r1
;;;864              pcb->ssthresh = eff_wnd >> 1;
00023c  e1a010a0          LSR      r1,r0,#1
000240  e1c414be          STRH     r1,[r4,#0x4e]
;;;865              if (pcb->ssthresh < (pcb->mss << 1)) {
000244  e1d403b6          LDRH     r0,[r4,#0x36]
000248  e1510080          CMP      r1,r0,LSL #1
;;;866                pcb->ssthresh = (pcb->mss << 1);
00024c  33e01801          MVNCC    r1,#0x10000
000250  30011080          ANDCC    r1,r1,r0,LSL #1
000254  31c414be          STRHCC   r1,[r4,#0x4e]
;;;867              }
;;;868              pcb->cwnd = pcb->mss;
000258  e1c404bc          STRH     r0,[r4,#0x4c]
;;;869              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
;;;870                                           " ssthresh %"U16_F"\n",
;;;871                                           pcb->cwnd, pcb->ssthresh));
;;;872     
;;;873              /* The following needs to be called AFTER cwnd is set to one
;;;874                 mss - STJ */
;;;875              tcp_rexmit_rto(pcb);
00025c  e1a00004          MOV      r0,r4
000260  ebfffffe          BL       tcp_rexmit_rto
                  |L1.612|
;;;876            }
;;;877          }
;;;878        }
;;;879        /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;880        if (pcb->state == FIN_WAIT_2) {
000264  e5d40018          LDRB     r0,[r4,#0x18]
000268  e3500006          CMP      r0,#6
00026c  1a000007          BNE      |L1.656|
;;;881          /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
;;;882          if (pcb->flags & TF_RXCLOSED) {
000270  e5d4001e          LDRB     r0,[r4,#0x1e]
000274  e3100010          TST      r0,#0x10
000278  0a000004          BEQ      |L1.656|
;;;883            /* PCB was fully closed (either through close() or SHUT_RDWR):
;;;884               normal FIN-WAIT timeout handling. */
;;;885            if ((u32_t)(tcp_ticks - pcb->tmr) >
00027c  e5940024          LDR      r0,[r4,#0x24]
000280  e59a100c          LDR      r1,[r10,#0xc]  ; tcp_ticks
000284  e0410000          SUB      r0,r1,r0
000288  e3500028          CMP      r0,#0x28
00028c  82855001          ADDHI    r5,r5,#1
                  |L1.656|
;;;886                TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;887              ++pcb_remove;
;;;888              LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
;;;889            }
;;;890          }
;;;891        }
;;;892    
;;;893        /* Check if KEEPALIVE should be sent */
;;;894        if(ip_get_option(pcb, SOF_KEEPALIVE) &&
000290  e5d40008          LDRB     r0,[r4,#8]
000294  e3100008          TST      r0,#8
000298  0a00001c          BEQ      |L1.784|
;;;895           ((pcb->state == ESTABLISHED) ||
00029c  e5d40018          LDRB     r0,[r4,#0x18]
0002a0  e3500004          CMP      r0,#4
;;;896            (pcb->state == CLOSE_WAIT))) {
0002a4  13500007          CMPNE    r0,#7
0002a8  1a000018          BNE      |L1.784|
;;;897          if((u32_t)(tcp_ticks - pcb->tmr) >
0002ac  e594b090          LDR      r11,[r4,#0x90]
0002b0  e59f01a0          LDR      r0,|L1.1112|
0002b4  e3a01f7d          MOV      r1,#0x1f4
0002b8  e080000b          ADD      r0,r0,r11
0002bc  ebfffffe          BL       __aeabi_uidivmod
0002c0  e5941024          LDR      r1,[r4,#0x24]
0002c4  e59a200c          LDR      r2,[r10,#0xc]  ; tcp_ticks
0002c8  e0429001          SUB      r9,r2,r1
0002cc  e1500009          CMP      r0,r9
;;;898             (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
;;;899          {
;;;900            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
;;;901                                    ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;902                                    ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;903            
;;;904            ++pcb_remove;
;;;905            ++pcb_reset;
0002d0  33a07001          MOVCC    r7,#1
0002d4  32855001          ADDCC    r5,r5,#1
0002d8  3a00000c          BCC      |L1.784|
;;;906          }
;;;907          else if((u32_t)(tcp_ticks - pcb->tmr) > 
0002dc  e5d40096          LDRB     r0,[r4,#0x96]
0002e0  e59f1174          LDR      r1,|L1.1116|
0002e4  e1600180          SMULBB   r0,r0,r1
0002e8  e3a01f7d          MOV      r1,#0x1f4
0002ec  e08b0180          ADD      r0,r11,r0,LSL #3
0002f0  ebfffffe          BL       __aeabi_uidivmod
0002f4  e1590000          CMP      r9,r0
0002f8  9a000004          BLS      |L1.784|
;;;908                  (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
;;;909                  / TCP_SLOW_INTERVAL)
;;;910          {
;;;911            tcp_keepalive(pcb);
0002fc  e1a00004          MOV      r0,r4
000300  ebfffffe          BL       tcp_keepalive
;;;912            pcb->keep_cnt_sent++;
000304  e5d40096          LDRB     r0,[r4,#0x96]
000308  e2800001          ADD      r0,r0,#1
00030c  e5c40096          STRB     r0,[r4,#0x96]
                  |L1.784|
;;;913          }
;;;914        }
;;;915    
;;;916        /* If this PCB has queued out of sequence data, but has been
;;;917           inactive for too long, will drop the data (it will eventually
;;;918           be retransmitted). */
;;;919    #if TCP_QUEUE_OOSEQ
;;;920        if (pcb->ooseq != NULL &&
000310  e5940074          LDR      r0,[r4,#0x74]
000314  e3500000          CMP      r0,#0
000318  0a000008          BEQ      |L1.832|
;;;921            (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
00031c  e5941024          LDR      r1,[r4,#0x24]
000320  e59a200c          LDR      r2,[r10,#0xc]  ; tcp_ticks
000324  e0422001          SUB      r2,r2,r1
000328  e1d414f4          LDRSH    r1,[r4,#0x44]
00032c  e0811081          ADD      r1,r1,r1,LSL #1
000330  e1520081          CMP      r2,r1,LSL #1
000334  3a000001          BCC      |L1.832|
;;;922          tcp_segs_free(pcb->ooseq);
000338  ebfffffe          BL       tcp_segs_free
;;;923          pcb->ooseq = NULL;
00033c  e5848074          STR      r8,[r4,#0x74]
                  |L1.832|
;;;924          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
;;;925        }
;;;926    #endif /* TCP_QUEUE_OOSEQ */
;;;927    
;;;928        /* Check if this PCB has stayed too long in SYN-RCVD */
;;;929        if (pcb->state == SYN_RCVD) {
000340  e5d40018          LDRB     r0,[r4,#0x18]
000344  e3500003          CMP      r0,#3
000348  0a000002          BEQ      |L1.856|
;;;930          if ((u32_t)(tcp_ticks - pcb->tmr) >
;;;931              TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;932            ++pcb_remove;
;;;933            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
;;;934          }
;;;935        }
;;;936    
;;;937        /* Check if this PCB has stayed too long in LAST-ACK */
;;;938        if (pcb->state == LAST_ACK) {
00034c  e3500009          CMP      r0,#9
000350  0a000042          BEQ      |L1.1120|
000354  ea000046          B        |L1.1140|
                  |L1.856|
000358  e5940024          LDR      r0,[r4,#0x24]         ;930
00035c  e59a100c          LDR      r1,[r10,#0xc]         ;930  ; tcp_ticks
000360  e0410000          SUB      r0,r1,r0              ;930
000364  e3500028          CMP      r0,#0x28              ;930
000368  9a000041          BLS      |L1.1140|
                  |L1.876|
00036c  e2855001          ADD      r5,r5,#1              ;930
000370  ea00003f          B        |L1.1140|
                  |L1.884|
                          DCD      ||.data||
                  |L1.888|
000378  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp.c",0
00037c  2d312e34
000380  2e315c73
000384  72635c63
000388  6f72655c
00038c  7463702e
000390  6300    
000392  00                DCB      0
000393  00                DCB      0
                  |L1.916|
                          DCD      0x00000329
                  |L1.920|
000398  7463705f          DCB      "tcp_slowtmr: active pcb->state != CLOSED\n",0
00039c  736c6f77
0003a0  746d723a
0003a4  20616374
0003a8  69766520
0003ac  7063622d
0003b0  3e737461
0003b4  74652021
0003b8  3d20434c
0003bc  4f534544
0003c0  0a00    
0003c2  00                DCB      0
0003c3  00                DCB      0
                  |L1.964|
0003c4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0003c8  7274696f
0003cc  6e202225
0003d0  73222066
0003d4  61696c65
0003d8  64206174
0003dc  206c696e
0003e0  65202564
0003e4  20696e20
0003e8  25730a00
                  |L1.1004|
                          DCD      0x0000032a
                  |L1.1008|
0003f0  7463705f          DCB      "tcp_slowtmr: active pcb->state != LISTEN\n",0
0003f4  736c6f77
0003f8  746d723a
0003fc  20616374
000400  69766520
000404  7063622d
000408  3e737461
00040c  74652021
000410  3d204c49
000414  5354454e
000418  0a00    
00041a  00                DCB      0
00041b  00                DCB      0
                  |L1.1052|
                          DCD      0x0000032b
                  |L1.1056|
000420  7463705f          DCB      "tcp_slowtmr: active pcb->state != TIME-WAIT\n",0
000424  736c6f77
000428  746d723a
00042c  20616374
000430  69766520
000434  7063622d
000438  3e737461
00043c  74652021
000440  3d205449
000444  4d452d57
000448  4149540a
00044c  00      
00044d  00                DCB      0
00044e  00                DCB      0
00044f  00                DCB      0
                  |L1.1104|
                          DCD      ||.constdata||
                  |L1.1108|
                          DCD      ||.constdata||+0x34
                  |L1.1112|
                          DCD      0x000a4cb8
                  |L1.1116|
                          DCD      0x0000249f
                  |L1.1120|
;;;939          if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
000460  e5940024          LDR      r0,[r4,#0x24]
000464  e59a100c          LDR      r1,[r10,#0xc]  ; tcp_ticks
000468  e0410000          SUB      r0,r1,r0
00046c  e35000f0          CMP      r0,#0xf0
000470  8affffbd          BHI      |L1.876|
                  |L1.1140|
;;;940            ++pcb_remove;
;;;941            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
;;;942          }
;;;943        }
;;;944    
;;;945        /* If the PCB should be removed, do it. */
;;;946        if (pcb_remove) {
000474  e3550000          CMP      r5,#0
000478  0a000031          BEQ      |L1.1348|
;;;947          struct tcp_pcb *pcb2;
;;;948          tcp_err_fn err_fn;
;;;949          void *err_arg;
;;;950          tcp_pcb_purge(pcb);
00047c  e1a00004          MOV      r0,r4
000480  ebfffffe          BL       tcp_pcb_purge
;;;951          /* Remove PCB from tcp_active_pcbs list. */
;;;952          if (prev != NULL) {
;;;953            LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
;;;954            prev->next = pcb->next;
;;;955          } else {
;;;956            /* This PCB was the first. */
;;;957            LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
000484  e59a0018          LDR      r0,[r10,#0x18]  ; tcp_active_pcbs
000488  e3560000          CMP      r6,#0                 ;952
00048c  0a000009          BEQ      |L1.1208|
000490  e1540000          CMP      r4,r0                 ;953
000494  1a000004          BNE      |L1.1196|
000498  e59f21d0          LDR      r2,|L1.1648|
00049c  e24f3f4b          ADR      r3,|L1.888|
0004a0  e28f1f73          ADR      r1,|L1.1652|
0004a4  e24f00e8          ADR      r0,|L1.964|
0004a8  ebfffffe          BL       sysprintf
                  |L1.1196|
0004ac  e594000c          LDR      r0,[r4,#0xc]          ;954
0004b0  e586000c          STR      r0,[r6,#0xc]          ;954
0004b4  ea000008          B        |L1.1244|
                  |L1.1208|
0004b8  e1500004          CMP      r0,r4
0004bc  0a000004          BEQ      |L1.1236|
0004c0  e59f21d8          LDR      r2,|L1.1696|
0004c4  e24f3f55          ADR      r3,|L1.888|
0004c8  e28f1f75          ADR      r1,|L1.1700|
0004cc  e24f0e11          ADR      r0,|L1.964|
0004d0  ebfffffe          BL       sysprintf
                  |L1.1236|
;;;958            tcp_active_pcbs = pcb->next;
0004d4  e594000c          LDR      r0,[r4,#0xc]
0004d8  e58a0018          STR      r0,[r10,#0x18]  ; tcp_active_pcbs
                  |L1.1244|
;;;959          }
;;;960    
;;;961          if (pcb_reset) {
0004dc  e3570000          CMP      r7,#0
0004e0  0a000007          BEQ      |L1.1284|
;;;962            tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
0004e4  e1d401ba          LDRH     r0,[r4,#0x1a]
0004e8  e1d411bc          LDRH     r1,[r4,#0x1c]
0004ec  e2843004          ADD      r3,r4,#4
0004f0  e1cd00f0          STRD     r0,r1,[sp,#0]
0004f4  e5940050          LDR      r0,[r4,#0x50]
0004f8  e5941028          LDR      r1,[r4,#0x28]
0004fc  e1a02004          MOV      r2,r4
000500  ebfffffe          BL       tcp_rst
                  |L1.1284|
;;;963              pcb->local_port, pcb->remote_port);
;;;964          }
;;;965    
;;;966          err_fn = pcb->errf;
;;;967          err_arg = pcb->callback_arg;
000504  e594508c          LDR      r5,[r4,#0x8c]
000508  e5947010          LDR      r7,[r4,#0x10]
;;;968          pcb2 = pcb;
;;;969          pcb = pcb->next;
00050c  e1a01004          MOV      r1,r4
000510  e594400c          LDR      r4,[r4,#0xc]
;;;970          memp_free(MEMP_TCP_PCB, pcb2);
000514  e3a00001          MOV      r0,#1
000518  ebfffffe          BL       memp_free
;;;971    
;;;972          tcp_active_pcbs_changed = 0;
;;;973          TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
00051c  e3550000          CMP      r5,#0
000520  e5ca8000          STRB     r8,[r10,#0]           ;972  ; tcp_active_pcbs_changed
000524  0a00001e          BEQ      |L1.1444|
000528  e3e01009          MVN      r1,#9
00052c  e1a00007          MOV      r0,r7
000530  e12fff35          BLX      r5
;;;974          if (tcp_active_pcbs_changed) {
000534  e5da0000          LDRB     r0,[r10,#0]  ; tcp_active_pcbs_changed
000538  e3500000          CMP      r0,#0
00053c  0a000018          BEQ      |L1.1444|
000540  eafffee4          B        |L1.216|
                  |L1.1348|
;;;975            goto tcp_slowtmr_start;
;;;976          }
;;;977        } else {
;;;978          /* get the 'next' element now and work with 'prev' below (in case of abort) */
;;;979          prev = pcb;
000544  e1a06004          MOV      r6,r4
;;;980          pcb = pcb->next;
;;;981    
;;;982          /* We check if we should poll the connection. */
;;;983          ++prev->polltmr;
000548  e5d6001f          LDRB     r0,[r6,#0x1f]
00054c  e594400c          LDR      r4,[r4,#0xc]          ;980
000550  e2800001          ADD      r0,r0,#1
000554  e20000ff          AND      r0,r0,#0xff
000558  e5c6001f          STRB     r0,[r6,#0x1f]
;;;984          if (prev->polltmr >= prev->pollinterval) {
00055c  e5d61020          LDRB     r1,[r6,#0x20]
000560  e1500001          CMP      r0,r1
000564  3a00000e          BCC      |L1.1444|
;;;985            prev->polltmr = 0;
000568  e5c6801f          STRB     r8,[r6,#0x1f]
;;;986            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
;;;987            tcp_active_pcbs_changed = 0;
00056c  e5ca8000          STRB     r8,[r10,#0]  ; tcp_active_pcbs_changed
;;;988            TCP_EVENT_POLL(prev, err);
000570  e5962088          LDR      r2,[r6,#0x88]
000574  e3520000          CMP      r2,#0
000578  0a000007          BEQ      |L1.1436|
00057c  e5960010          LDR      r0,[r6,#0x10]
000580  e1a01006          MOV      r1,r6
000584  e12fff32          BLX      r2
;;;989            if (tcp_active_pcbs_changed) {
000588  e5da1000          LDRB     r1,[r10,#0]  ; tcp_active_pcbs_changed
00058c  e3510000          CMP      r1,#0
000590  1afffed0          BNE      |L1.216|
;;;990              goto tcp_slowtmr_start;
;;;991            }
;;;992            /* if err == ERR_ABRT, 'prev' is already deallocated */
;;;993            if (err == ERR_OK) {
000594  e3500000          CMP      r0,#0
000598  1a000001          BNE      |L1.1444|
                  |L1.1436|
;;;994              tcp_output(prev);
00059c  e1a00006          MOV      r0,r6
0005a0  ebfffffe          BL       tcp_output
                  |L1.1444|
0005a4  e3540000          CMP      r4,#0                 ;807
;;;995            }
;;;996          }
;;;997        }
;;;998      }
;;;999    
;;;1000     
;;;1001     /* Steps through all of the TIME-WAIT PCBs. */
;;;1002     prev = NULL;
;;;1003     pcb = tcp_tw_pcbs;
0005a8  059a401c          LDREQ    r4,[r10,#0x1c]  ; tcp_tw_pcbs
0005ac  03a05000          MOVEQ    r5,#0                 ;1002
0005b0  1afffecb          BNE      |L1.228|
0005b4  ea00002a          B        |L1.1636|
                  |L1.1464|
;;;1004     while (pcb != NULL) {
;;;1005       LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
0005b8  e5d40018          LDRB     r0,[r4,#0x18]
0005bc  e350000a          CMP      r0,#0xa
0005c0  0a000004          BEQ      |L1.1496|
0005c4  e59f2104          LDR      r2,|L1.1744|
0005c8  e24f3f96          ADR      r3,|L1.888|
0005cc  e28f1c01          ADR      r1,|L1.1748|
0005d0  e24f0f85          ADR      r0,|L1.964|
0005d4  ebfffffe          BL       sysprintf
                  |L1.1496|
;;;1006       pcb_remove = 0;
;;;1007   
;;;1008       /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;1009       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
0005d8  e5940024          LDR      r0,[r4,#0x24]
0005dc  e59a100c          LDR      r1,[r10,#0xc]  ; tcp_ticks
0005e0  e0410000          SUB      r0,r1,r0
0005e4  e35000f0          CMP      r0,#0xf0
;;;1010         ++pcb_remove;
;;;1011       }
;;;1012       
;;;1013   
;;;1014   
;;;1015       /* If the PCB should be removed, do it. */
;;;1016       if (pcb_remove) {
;;;1017         struct tcp_pcb *pcb2;
;;;1018         tcp_pcb_purge(pcb);
;;;1019         /* Remove PCB from tcp_tw_pcbs list. */
;;;1020         if (prev != NULL) {
;;;1021           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
;;;1022           prev->next = pcb->next;
;;;1023         } else {
;;;1024           /* This PCB was the first. */
;;;1025           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
;;;1026           tcp_tw_pcbs = pcb->next;
;;;1027         }
;;;1028         pcb2 = pcb;
;;;1029         pcb = pcb->next;
;;;1030         memp_free(MEMP_TCP_PCB, pcb2);
;;;1031       } else {
;;;1032         prev = pcb;
0005e8  91a05004          MOVLS    r5,r4
;;;1033         pcb = pcb->next;
0005ec  9594400c          LDRLS    r4,[r4,#0xc]
0005f0  9a00001b          BLS      |L1.1636|
0005f4  e1a00004          MOV      r0,r4                 ;1018
0005f8  ebfffffe          BL       tcp_pcb_purge
0005fc  e59a001c          LDR      r0,[r10,#0x1c]        ;1025  ; tcp_tw_pcbs
000600  e3550000          CMP      r5,#0                 ;1020
000604  0a000009          BEQ      |L1.1584|
000608  e1540000          CMP      r4,r0                 ;1021
00060c  1a000004          BNE      |L1.1572|
000610  e59f20ec          LDR      r2,|L1.1796|
000614  e24f3fa9          ADR      r3,|L1.888|
000618  e28f10e8          ADR      r1,|L1.1800|
00061c  e24f0e26          ADR      r0,|L1.964|
000620  ebfffffe          BL       sysprintf
                  |L1.1572|
000624  e594000c          LDR      r0,[r4,#0xc]          ;1022
000628  e585000c          STR      r0,[r5,#0xc]          ;1022
00062c  ea000008          B        |L1.1620|
                  |L1.1584|
000630  e1500004          CMP      r0,r4                 ;1025
000634  0a000004          BEQ      |L1.1612|
000638  e59f20f0          LDR      r2,|L1.1840|
00063c  e24f3fb3          ADR      r3,|L1.888|
000640  e28f10ec          ADR      r1,|L1.1844|
000644  e24f0fa2          ADR      r0,|L1.964|
000648  ebfffffe          BL       sysprintf
                  |L1.1612|
00064c  e594000c          LDR      r0,[r4,#0xc]          ;1026
000650  e58a001c          STR      r0,[r10,#0x1c]        ;1026  ; tcp_tw_pcbs
                  |L1.1620|
000654  e1a01004          MOV      r1,r4                 ;1028
000658  e594400c          LDR      r4,[r4,#0xc]          ;1029
00065c  e3a00001          MOV      r0,#1                 ;1030
000660  ebfffffe          BL       memp_free
                  |L1.1636|
000664  e3540000          CMP      r4,#0                 ;1004
000668  1affffd2          BNE      |L1.1464|
;;;1034       }
;;;1035     }
;;;1036   }
00066c  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.1648|
                          DCD      0x000003b9
                  |L1.1652|
000674  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_active_pcbs",0
000678  736c6f77
00067c  746d723a
000680  206d6964
000684  646c6520
000688  74637020
00068c  213d2074
000690  63705f61
000694  63746976
000698  655f7063
00069c  627300  
00069f  00                DCB      0
                  |L1.1696|
                          DCD      0x000003bd
                  |L1.1700|
0006a4  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_active_pcbs",0
0006a8  736c6f77
0006ac  746d723a
0006b0  20666972
0006b4  73742070
0006b8  6362203d
0006bc  3d207463
0006c0  705f6163
0006c4  74697665
0006c8  5f706362
0006cc  7300    
0006ce  00                DCB      0
0006cf  00                DCB      0
                  |L1.1744|
                          DCD      0x000003ed
                  |L1.1748|
0006d4  7463705f          DCB      "tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT",0
0006d8  736c6f77
0006dc  746d723a
0006e0  2054494d
0006e4  452d5741
0006e8  49542070
0006ec  63622d3e
0006f0  73746174
0006f4  65203d3d
0006f8  2054494d
0006fc  452d5741
000700  495400  
000703  00                DCB      0
                  |L1.1796|
                          DCD      0x000003fd
                  |L1.1800|
000708  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_tw_pcbs",0
00070c  736c6f77
000710  746d723a
000714  206d6964
000718  646c6520
00071c  74637020
000720  213d2074
000724  63705f74
000728  775f7063
00072c  627300  
00072f  00                DCB      0
                  |L1.1840|
                          DCD      0x00000401
                  |L1.1844|
000734  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_tw_pcbs",0
000738  736c6f77
00073c  746d723a
000740  20666972
000744  73742070
000748  6362203d
00074c  3d207463
000750  705f7477
000754  5f706362
000758  7300    
00075a  00                DCB      0
00075b  00                DCB      0
                          ENDP

                  tcp_pcb_remove PROC
;;;1536   void
;;;1537   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
00075c  e92d4070          PUSH     {r4-r6,lr}
;;;1538   {
000760  e1a04001          MOV      r4,r1
000764  e1a01000          MOV      r1,r0
;;;1539     TCP_RMV(pcblist, pcb);
000768  e5900000          LDR      r0,[r0,#0]
00076c  e1500004          CMP      r0,r4
000770  0590000c          LDREQ    r0,[r0,#0xc]
000774  05810000          STREQ    r0,[r1,#0]
000778  151f140c          LDRNE    r1,|L1.884|
00077c  0a000009          BEQ      |L1.1960|
000780  ea000005          B        |L1.1948|
                  |L1.1924|
000784  e590000c          LDR      r0,[r0,#0xc]
000788  e1500004          CMP      r0,r4
00078c  0594000c          LDREQ    r0,[r4,#0xc]
000790  05911020          LDREQ    r1,[r1,#0x20]  ; tcp_tmp_pcb
000794  0581000c          STREQ    r0,[r1,#0xc]
000798  0a000002          BEQ      |L1.1960|
                  |L1.1948|
00079c  e3500000          CMP      r0,#0
0007a0  e5810020          STR      r0,[r1,#0x20]  ; tcp_tmp_pcb
0007a4  1afffff6          BNE      |L1.1924|
                  |L1.1960|
0007a8  e3a05000          MOV      r5,#0
;;;1540   
;;;1541     tcp_pcb_purge(pcb);
0007ac  e1a00004          MOV      r0,r4
0007b0  e584500c          STR      r5,[r4,#0xc]          ;1539
0007b4  ebfffffe          BL       tcp_pcb_purge
;;;1542     
;;;1543     /* if there is an outstanding delayed ACKs, send it */
;;;1544     if (pcb->state != TIME_WAIT &&
0007b8  e5d40018          LDRB     r0,[r4,#0x18]
0007bc  e350000a          CMP      r0,#0xa
0007c0  0a00000b          BEQ      |L1.2036|
;;;1545        pcb->state != LISTEN &&
0007c4  e3500001          CMP      r0,#1
0007c8  0a000021          BEQ      |L1.2132|
;;;1546        pcb->flags & TF_ACK_DELAY) {
0007cc  e5d4001e          LDRB     r0,[r4,#0x1e]
0007d0  e3100001          TST      r0,#1
0007d4  0a000006          BEQ      |L1.2036|
;;;1547       pcb->flags |= TF_ACK_NOW;
0007d8  e3800002          ORR      r0,r0,#2
0007dc  e5c4001e          STRB     r0,[r4,#0x1e]
;;;1548       tcp_output(pcb);
0007e0  e1a00004          MOV      r0,r4
0007e4  ebfffffe          BL       tcp_output
;;;1549     }
;;;1550   
;;;1551     if (pcb->state != LISTEN) {
0007e8  e5d40018          LDRB     r0,[r4,#0x18]
0007ec  e3500001          CMP      r0,#1
0007f0  0a000017          BEQ      |L1.2132|
                  |L1.2036|
;;;1552       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
0007f4  e594006c          LDR      r0,[r4,#0x6c]
0007f8  e3500000          CMP      r0,#0
0007fc  0a000004          BEQ      |L1.2068|
000800  e59f3264          LDR      r3,|L1.2668|
000804  e59f027c          LDR      r0,|L1.2696|
000808  e3a02e61          MOV      r2,#0x610
00080c  e28f1f97          ADR      r1,|L1.2672|
000810  ebfffffe          BL       sysprintf
                  |L1.2068|
;;;1553       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
000814  e5940070          LDR      r0,[r4,#0x70]
000818  e3500000          CMP      r0,#0
00081c  0a000004          BEQ      |L1.2100|
000820  e59f3244          LDR      r3,|L1.2668|
000824  e59f2260          LDR      r2,|L1.2700|
000828  e59f0258          LDR      r0,|L1.2696|
00082c  e28f1f97          ADR      r1,|L1.2704|
000830  ebfffffe          BL       sysprintf
                  |L1.2100|
;;;1554   #if TCP_QUEUE_OOSEQ
;;;1555       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
000834  e5940074          LDR      r0,[r4,#0x74]
000838  e3500000          CMP      r0,#0
00083c  0a000004          BEQ      |L1.2132|
000840  e59f3224          LDR      r3,|L1.2668|
000844  e59f2260          LDR      r2,|L1.2732|
000848  e59f0238          LDR      r0,|L1.2696|
00084c  e28f1f97          ADR      r1,|L1.2736|
000850  ebfffffe          BL       sysprintf
                  |L1.2132|
;;;1556   #endif /* TCP_QUEUE_OOSEQ */
;;;1557     }
;;;1558   
;;;1559     pcb->state = CLOSED;
000854  e5c45018          STRB     r5,[r4,#0x18]
;;;1560   
;;;1561     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;1562   }
000858  e8bd8070          POP      {r4-r6,pc}
;;;1563   
                          ENDP

                  tcp_close_shutdown PROC
;;;169    static err_t
;;;170    tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
00085c  e92d47fc          PUSH     {r2-r10,lr}
;;;171    {
000860  e1a04000          MOV      r4,r0
;;;172      err_t err;
;;;173    
;;;174      if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
000864  e5d00018          LDRB     r0,[r0,#0x18]
;;;175        if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
;;;176          /* Not all data received by application, send RST to tell the remote
;;;177             side about this. */
;;;178          LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
;;;179          /* don't call tcp_abort here: we must not deallocate the pcb since
;;;180             that might not be expected when calling tcp_close */
;;;181          tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
;;;182            pcb->local_port, pcb->remote_port);
;;;183    
;;;184          tcp_pcb_purge(pcb);
;;;185          TCP_RMV_ACTIVE(pcb);
000868  e51f64fc          LDR      r6,|L1.884|
00086c  e3510000          CMP      r1,#0                 ;174
000870  e3a07000          MOV      r7,#0                 ;171
000874  e3a08001          MOV      r8,#1
000878  0a000002          BEQ      |L1.2184|
00087c  e3500004          CMP      r0,#4                 ;174
000880  13500007          CMPNE    r0,#7                 ;174
000884  0a00000b          BEQ      |L1.2232|
                  |L1.2184|
;;;186          if (pcb->state == ESTABLISHED) {
;;;187            /* move to TIME_WAIT since we close actively */
;;;188            pcb->state = TIME_WAIT;
;;;189            TCP_REG(&tcp_tw_pcbs, pcb);
;;;190          } else {
;;;191            /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
;;;192            memp_free(MEMP_TCP_PCB, pcb);
;;;193          }
;;;194          return ERR_OK;
;;;195        }
;;;196      }
;;;197    
;;;198      switch (pcb->state) {
000888  e3500008          CMP      r0,#8
;;;199      case CLOSED:
;;;200        /* Closing a pcb in the CLOSED state might seem erroneous,
;;;201         * however, it is in this state once allocated and as yet unused
;;;202         * and the user needs some way to free it should the need arise.
;;;203         * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;204         * or for a pcb that has been used and then entered the CLOSED state 
;;;205         * is erroneous, but this should never happen as the pcb has in those cases
;;;206         * been freed, and so any remaining handles are bogus. */
;;;207        err = ERR_OK;
;;;208        if (pcb->local_port != 0) {
;;;209          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;210        }
;;;211        memp_free(MEMP_TCP_PCB, pcb);
;;;212        pcb = NULL;
;;;213        break;
;;;214      case LISTEN:
;;;215        err = ERR_OK;
;;;216        tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
;;;217        memp_free(MEMP_TCP_PCB_LISTEN, pcb);
;;;218        pcb = NULL;
;;;219        break;
;;;220      case SYN_SENT:
;;;221        err = ERR_OK;
;;;222        TCP_PCB_REMOVE_ACTIVE(pcb);
;;;223        memp_free(MEMP_TCP_PCB, pcb);
;;;224        pcb = NULL;
;;;225        snmp_inc_tcpattemptfails();
;;;226        break;
;;;227      case SYN_RCVD:
;;;228        err = tcp_send_fin(pcb);
;;;229        if (err == ERR_OK) {
;;;230          snmp_inc_tcpattemptfails();
;;;231          pcb->state = FIN_WAIT_1;
00088c  e3a09005          MOV      r9,#5
000890  308ff100          ADDCC    pc,pc,r0,LSL #2       ;198
000894  ea000071          B        |L1.2656|
000898  ea00003c          B        |L1.2448|
00089c  ea000052          B        |L1.2540|
0008a0  ea000058          B        |L1.2568|
0008a4  ea00005d          B        |L1.2592|
0008a8  ea00005c          B        |L1.2592|
0008ac  ea00006b          B        |L1.2656|
0008b0  ea00006a          B        |L1.2656|
0008b4  ea00005e          B        |L1.2612|
                  |L1.2232|
0008b8  e5941078          LDR      r1,[r4,#0x78]         ;175
0008bc  e3510000          CMP      r1,#0                 ;175
0008c0  01d412bc          LDRHEQ   r1,[r4,#0x2c]         ;175
0008c4  03510efa          CMPEQ    r1,#0xfa0             ;175
0008c8  0affffee          BEQ      |L1.2184|
0008cc  e5d4001e          LDRB     r0,[r4,#0x1e]         ;178
0008d0  e3100010          TST      r0,#0x10              ;178
0008d4  1a000004          BNE      |L1.2284|
0008d8  e59f318c          LDR      r3,|L1.2668|
0008dc  e59f01a4          LDR      r0,|L1.2696|
0008e0  e3a020b2          MOV      r2,#0xb2              ;178
0008e4  e28f1f77          ADR      r1,|L1.2760|
0008e8  ebfffffe          BL       sysprintf
                  |L1.2284|
0008ec  e1d401ba          LDRH     r0,[r4,#0x1a]         ;181
0008f0  e1d411bc          LDRH     r1,[r4,#0x1c]         ;181
0008f4  e2843004          ADD      r3,r4,#4              ;181
0008f8  e1cd00f0          STRD     r0,r1,[sp,#0]         ;181
0008fc  e5940050          LDR      r0,[r4,#0x50]         ;181
000900  e5941028          LDR      r1,[r4,#0x28]         ;181
000904  e1a02004          MOV      r2,r4                 ;181
000908  ebfffffe          BL       tcp_rst
00090c  e1a00004          MOV      r0,r4                 ;184
000910  ebfffffe          BL       tcp_pcb_purge
000914  e5960018          LDR      r0,[r6,#0x18]         ;185  ; tcp_active_pcbs
000918  e1500004          CMP      r0,r4                 ;185
00091c  0590000c          LDREQ    r0,[r0,#0xc]          ;185
000920  05860018          STREQ    r0,[r6,#0x18]         ;185  ; tcp_active_pcbs
000924  0a000008          BEQ      |L1.2380|
                  |L1.2344|
000928  e3500000          CMP      r0,#0                 ;185
00092c  e5860020          STR      r0,[r6,#0x20]         ;185  ; tcp_tmp_pcb
000930  0a000005          BEQ      |L1.2380|
000934  e590000c          LDR      r0,[r0,#0xc]          ;185
000938  e1500004          CMP      r0,r4                 ;185
00093c  0594000c          LDREQ    r0,[r4,#0xc]          ;185
000940  05961020          LDREQ    r1,[r6,#0x20]         ;185  ; tcp_tmp_pcb
000944  0581000c          STREQ    r0,[r1,#0xc]          ;185
000948  1afffff6          BNE      |L1.2344|
                  |L1.2380|
00094c  e584700c          STR      r7,[r4,#0xc]          ;185
000950  e5c68000          STRB     r8,[r6,#0]            ;185  ; tcp_active_pcbs_changed
000954  e5d40018          LDRB     r0,[r4,#0x18]         ;186
000958  e3500004          CMP      r0,#4                 ;186
00095c  0a000004          BEQ      |L1.2420|
000960  e1a01004          MOV      r1,r4                 ;192
000964  e3a00001          MOV      r0,#1                 ;192
000968  ebfffffe          BL       memp_free
                  |L1.2412|
00096c  e3a00000          MOV      r0,#0                 ;194
;;;232        }
;;;233        break;
;;;234      case ESTABLISHED:
;;;235        err = tcp_send_fin(pcb);
;;;236        if (err == ERR_OK) {
;;;237          snmp_inc_tcpestabresets();
;;;238          pcb->state = FIN_WAIT_1;
;;;239        }
;;;240        break;
;;;241      case CLOSE_WAIT:
;;;242        err = tcp_send_fin(pcb);
;;;243        if (err == ERR_OK) {
;;;244          snmp_inc_tcpestabresets();
;;;245          pcb->state = LAST_ACK;
;;;246        }
;;;247        break;
;;;248      default:
;;;249        /* Has already been closed, do nothing. */
;;;250        err = ERR_OK;
;;;251        pcb = NULL;
;;;252        break;
;;;253      }
;;;254    
;;;255      if (pcb != NULL && err == ERR_OK) {
;;;256        /* To ensure all data has been sent when tcp_close returns, we have
;;;257           to make sure tcp_output doesn't fail.
;;;258           Since we don't really have to ensure all data has been sent when tcp_close
;;;259           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;260           for the return value of tcp_output for now. */
;;;261        /* @todo: When implementing SO_LINGER, this must be changed somehow:
;;;262           If SOF_LINGER is set, the data should be sent and acked before close returns.
;;;263           This can only be valid for sequential APIs, not for the raw API. */
;;;264        tcp_output(pcb);
;;;265      }
;;;266      return err;
;;;267    }
000970  e8bd87fc          POP      {r2-r10,pc}
                  |L1.2420|
000974  e3a0000a          MOV      r0,#0xa               ;188
000978  e5c40018          STRB     r0,[r4,#0x18]         ;188
00097c  e596001c          LDR      r0,[r6,#0x1c]         ;189  ; tcp_tw_pcbs
000980  e584000c          STR      r0,[r4,#0xc]          ;189
000984  e586401c          STR      r4,[r6,#0x1c]         ;189  ; tcp_tw_pcbs
000988  ebfffffe          BL       tcp_timer_needed
00098c  eafffff6          B        |L1.2412|
                  |L1.2448|
000990  e1d401ba          LDRH     r0,[r4,#0x1a]         ;208
000994  e3a05000          MOV      r5,#0                 ;207
000998  e3500000          CMP      r0,#0                 ;208
00099c  0a00000e          BEQ      |L1.2524|
0009a0  e5960010          LDR      r0,[r6,#0x10]         ;209  ; tcp_bound_pcbs
0009a4  e1500004          CMP      r0,r4                 ;209
0009a8  0590000c          LDREQ    r0,[r0,#0xc]          ;209
0009ac  05860010          STREQ    r0,[r6,#0x10]         ;209  ; tcp_bound_pcbs
0009b0  0a000008          BEQ      |L1.2520|
                  |L1.2484|
0009b4  e3500000          CMP      r0,#0                 ;209
0009b8  e5860020          STR      r0,[r6,#0x20]         ;209  ; tcp_tmp_pcb
0009bc  0a000005          BEQ      |L1.2520|
0009c0  e590000c          LDR      r0,[r0,#0xc]          ;209
0009c4  e1500004          CMP      r0,r4                 ;209
0009c8  0594000c          LDREQ    r0,[r4,#0xc]          ;209
0009cc  05961020          LDREQ    r1,[r6,#0x20]         ;209  ; tcp_tmp_pcb
0009d0  0581000c          STREQ    r0,[r1,#0xc]          ;209
0009d4  1afffff6          BNE      |L1.2484|
                  |L1.2520|
0009d8  e584700c          STR      r7,[r4,#0xc]          ;209
                  |L1.2524|
0009dc  e1a01004          MOV      r1,r4                 ;211
0009e0  e3a00001          MOV      r0,#1                 ;211
                  |L1.2532|
0009e4  ebfffffe          BL       memp_free
0009e8  ea00001d          B        |L1.2660|
                  |L1.2540|
0009ec  e59f00f0          LDR      r0,|L1.2788|
0009f0  e3a05000          MOV      r5,#0                 ;215
0009f4  e1a01004          MOV      r1,r4                 ;216
0009f8  ebfffffe          BL       tcp_pcb_remove
0009fc  e1a01004          MOV      r1,r4                 ;217
000a00  e3a00002          MOV      r0,#2                 ;217
000a04  eafffff6          B        |L1.2532|
                  |L1.2568|
000a08  e59f00d8          LDR      r0,|L1.2792|
000a0c  e3a05000          MOV      r5,#0                 ;221
000a10  e1a01004          MOV      r1,r4                 ;222
000a14  ebfffffe          BL       tcp_pcb_remove
000a18  e5c68000          STRB     r8,[r6,#0]            ;222  ; tcp_active_pcbs_changed
000a1c  eaffffee          B        |L1.2524|
                  |L1.2592|
000a20  e1a00004          MOV      r0,r4                 ;235
000a24  ebfffffe          BL       tcp_send_fin
000a28  e1b05000          MOVS     r5,r0                 ;235
000a2c  05c49018          STRBEQ   r9,[r4,#0x18]         ;238
000a30  ea000004          B        |L1.2632|
                  |L1.2612|
000a34  e1a00004          MOV      r0,r4                 ;242
000a38  ebfffffe          BL       tcp_send_fin
000a3c  e1b05000          MOVS     r5,r0                 ;242
000a40  03a00009          MOVEQ    r0,#9                 ;245
000a44  05c40018          STRBEQ   r0,[r4,#0x18]         ;245
                  |L1.2632|
000a48  e3540000          CMP      r4,#0                 ;255
000a4c  0a000004          BEQ      |L1.2660|
000a50  e3550000          CMP      r5,#0                 ;255
000a54  01a00004          MOVEQ    r0,r4                 ;264
000a58  0bfffffe          BLEQ     tcp_output
000a5c  ea000000          B        |L1.2660|
                  |L1.2656|
000a60  e3a05000          MOV      r5,#0                 ;250
                  |L1.2660|
000a64  e1a00005          MOV      r0,r5                 ;266
000a68  e8bd87fc          POP      {r2-r10,pc}
                  |L1.2668|
                          DCD      ||.text||+0x378
                  |L1.2672|
000a70  756e7365          DCB      "unsent segments leaking",0
000a74  6e742073
000a78  65676d65
000a7c  6e747320
000a80  6c65616b
000a84  696e6700
                  |L1.2696|
                          DCD      ||.text||+0x3c4
                  |L1.2700|
                          DCD      0x00000611
                  |L1.2704|
000a90  756e6163          DCB      "unacked segments leaking",0
000a94  6b656420
000a98  7365676d
000a9c  656e7473
000aa0  206c6561
000aa4  6b696e67
000aa8  00      
000aa9  00                DCB      0
000aaa  00                DCB      0
000aab  00                DCB      0
                  |L1.2732|
                          DCD      0x00000613
                  |L1.2736|
000ab0  6f6f7365          DCB      "ooseq segments leaking",0
000ab4  71207365
000ab8  676d656e
000abc  7473206c
000ac0  65616b69
000ac4  6e6700  
000ac7  00                DCB      0
                  |L1.2760|
000ac8  7063622d          DCB      "pcb->flags & TF_RXCLOSED",0
000acc  3e666c61
000ad0  67732026
000ad4  2054465f
000ad8  5258434c
000adc  4f534544
000ae0  00      
000ae1  00                DCB      0
000ae2  00                DCB      0
000ae3  00                DCB      0
                  |L1.2788|
                          DCD      ||.data||+0x14
                  |L1.2792|
                          DCD      ||.data||+0x18
                          ENDP

                  tcp_close PROC
;;;283    err_t
;;;284    tcp_close(struct tcp_pcb *pcb)
000aec  e5d01018          LDRB     r1,[r0,#0x18]
;;;285    {
;;;286    #if TCP_DEBUG
;;;287      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
;;;288      tcp_debug_print_state(pcb->state);
;;;289    #endif /* TCP_DEBUG */
;;;290    
;;;291      if (pcb->state != LISTEN) {
000af0  e3510001          CMP      r1,#1
;;;292        /* Set a flag not to receive any more data... */
;;;293        pcb->flags |= TF_RXCLOSED;
000af4  15d0101e          LDRBNE   r1,[r0,#0x1e]
000af8  13811010          ORRNE    r1,r1,#0x10
000afc  15c0101e          STRBNE   r1,[r0,#0x1e]
;;;294      }
;;;295      /* ... and close */
;;;296      return tcp_close_shutdown(pcb, 1);
000b00  e3a01001          MOV      r1,#1
000b04  eafffffe          B        tcp_close_shutdown
;;;297    }
;;;298    
                          ENDP

                  tcp_update_rcv_ann_wnd PROC
;;;577     */
;;;578    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
000b08  e92d4070          PUSH     {r4-r6,lr}
;;;579    {
000b0c  e1a04000          MOV      r4,r0
;;;580      u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
;;;581    
;;;582      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
000b10  e1d433b6          LDRH     r3,[r4,#0x36]
000b14  e5901028          LDR      r1,[r0,#0x28]         ;580
000b18  e1d0c2bc          LDRH     r12,[r0,#0x2c]        ;580
000b1c  e5900030          LDR      r0,[r0,#0x30]
000b20  e3530e7d          CMP      r3,#0x7d0
000b24  83a03e7d          MOVHI    r3,#0x7d0
000b28  e081200c          ADD      r2,r1,r12             ;580
000b2c  e0833000          ADD      r3,r3,r0
000b30  e0523003          SUBS     r3,r2,r3
;;;583        /* we can advertise more window */
;;;584        pcb->rcv_ann_wnd = pcb->rcv_wnd;
;;;585        return new_right_edge - pcb->rcv_ann_right_edge;
000b34  50420000          SUBPL    r0,r2,r0
000b38  51c4c2be          STRHPL   r12,[r4,#0x2e]        ;584
;;;586      } else {
;;;587        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;588          /* Can happen due to other end sending out of advertised window,
;;;589           * but within actual available (but not yet advertised) window */
;;;590          pcb->rcv_ann_wnd = 0;
;;;591        } else {
;;;592          /* keep the right edge of window constant */
;;;593          u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;594          LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
;;;595          pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
;;;596        }
;;;597        return 0;
;;;598      }
;;;599    }
000b3c  58bd8070          POPPL    {r4-r6,pc}
000b40  e0412000          SUB      r2,r1,r0              ;587
000b44  e3520000          CMP      r2,#0                 ;587
000b48  c3a00000          MOVGT    r0,#0                 ;590
000b4c  c1c402be          STRHGT   r0,[r4,#0x2e]         ;590
000b50  ca000008          BGT      |L1.2936|
000b54  e0405001          SUB      r5,r0,r1              ;593
000b58  e3550801          CMP      r5,#0x10000           ;594
000b5c  3a000004          BCC      |L1.2932|
000b60  e51f30fc          LDR      r3,|L1.2668|
000b64  e59f222c          LDR      r2,|L1.3480|
000b68  e51f00e8          LDR      r0,|L1.2696|
000b6c  e28f1f8a          ADR      r1,|L1.3484|
000b70  ebfffffe          BL       sysprintf
                  |L1.2932|
000b74  e1c452be          STRH     r5,[r4,#0x2e]         ;595
                  |L1.2936|
000b78  e3a00000          MOV      r0,#0                 ;597
000b7c  e8bd8070          POP      {r4-r6,pc}
;;;600    
                          ENDP

                  tcp_recved PROC
;;;609    void
;;;610    tcp_recved(struct tcp_pcb *pcb, u16_t len)
000b80  e92d4070          PUSH     {r4-r6,lr}
;;;611    {
000b84  e1a04000          MOV      r4,r0
;;;612      int wnd_inflation;
;;;613    
;;;614      /* pcb->state LISTEN not allowed here */
;;;615      LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
000b88  e5d00018          LDRB     r0,[r0,#0x18]
000b8c  e1a05001          MOV      r5,r1                 ;611
000b90  e3500001          CMP      r0,#1
000b94  1a000004          BNE      |L1.2988|
000b98  e51f3134          LDR      r3,|L1.2668|
000b9c  e59f2214          LDR      r2,|L1.3512|
000ba0  e51f0120          LDR      r0,|L1.2696|
000ba4  e28f1e21          ADR      r1,|L1.3516|
000ba8  ebfffffe          BL       sysprintf
                  |L1.2988|
;;;616        pcb->state != LISTEN);
;;;617      LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
000bac  e1d402bc          LDRH     r0,[r4,#0x2c]
000bb0  e59f122c          LDR      r1,|L1.3556|
000bb4  e0410000          SUB      r0,r1,r0
000bb8  e1500005          CMP      r0,r5
000bbc  2a000004          BCS      |L1.3028|
000bc0  e51f315c          LDR      r3,|L1.2668|
000bc4  e59f221c          LDR      r2,|L1.3560|
000bc8  e51f0148          LDR      r0,|L1.2696|
000bcc  e28f1f86          ADR      r1,|L1.3564|
000bd0  ebfffffe          BL       sysprintf
                  |L1.3028|
;;;618                  len <= 0xffff - pcb->rcv_wnd );
;;;619    
;;;620      pcb->rcv_wnd += len;
000bd4  e1d402bc          LDRH     r0,[r4,#0x2c]
000bd8  e0800005          ADD      r0,r0,r5
000bdc  e3c00801          BIC      r0,r0,#0x10000
;;;621      if (pcb->rcv_wnd > TCP_WND) {
000be0  e3500efa          CMP      r0,#0xfa0
000be4  e1c402bc          STRH     r0,[r4,#0x2c]         ;620
;;;622        pcb->rcv_wnd = TCP_WND;
000be8  83a00efa          MOVHI    r0,#0xfa0
000bec  81c402bc          STRHHI   r0,[r4,#0x2c]
;;;623      }
;;;624    
;;;625      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
000bf0  e1a00004          MOV      r0,r4
000bf4  ebfffffe          BL       tcp_update_rcv_ann_wnd
;;;626    
;;;627      /* If the change in the right edge of window is significant (default
;;;628       * watermark is TCP_WND/4), then send an explicit update now.
;;;629       * Otherwise wait for a packet to be sent in the normal course of
;;;630       * events (or more window to be available later) */
;;;631      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
000bf8  e3500ffa          CMP      r0,#0x3e8
;;;632        tcp_ack_now(pcb);
;;;633        tcp_output(pcb);
;;;634      }
;;;635    
;;;636      LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
;;;637             len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
;;;638    }
000bfc  b8bd8070          POPLT    {r4-r6,pc}
000c00  e5d4001e          LDRB     r0,[r4,#0x1e]         ;632
000c04  e3800002          ORR      r0,r0,#2              ;632
000c08  e5c4001e          STRB     r0,[r4,#0x1e]         ;632
000c0c  e1a00004          MOV      r0,r4                 ;633
000c10  e8bd4070          POP      {r4-r6,lr}            ;633
000c14  eafffffe          B        tcp_output
;;;639    
                          ENDP

                  tcp_recv_null PROC
;;;1195   err_t
;;;1196   tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000c18  e92d4010          PUSH     {r4,lr}
;;;1197   {
000c1c  e1b04002          MOVS     r4,r2
000c20  e1a00001          MOV      r0,r1
000c24  0a000004          BEQ      |L1.3132|
;;;1198     LWIP_UNUSED_ARG(arg);
;;;1199     if (p != NULL) {
;;;1200       tcp_recved(pcb, p->tot_len);
000c28  e1d410b8          LDRH     r1,[r4,#8]
000c2c  ebfffffe          BL       tcp_recved
;;;1201       pbuf_free(p);
000c30  e1a00004          MOV      r0,r4
000c34  ebfffffe          BL       pbuf_free
000c38  ea000001          B        |L1.3140|
                  |L1.3132|
;;;1202     } else if (err == ERR_OK) {
000c3c  e3530000          CMP      r3,#0
000c40  0a000001          BEQ      |L1.3148|
                  |L1.3140|
;;;1203       return tcp_close(pcb);
;;;1204     }
;;;1205     return ERR_OK;
000c44  e3a00000          MOV      r0,#0
;;;1206   }
000c48  e8bd8010          POP      {r4,pc}
                  |L1.3148|
000c4c  e8bd4010          POP      {r4,lr}               ;1203
000c50  eafffffe          B        tcp_close
;;;1207   #endif /* LWIP_CALLBACK_API */
                          ENDP

                  tcp_process_refused_data PROC
;;;1083   err_t
;;;1084   tcp_process_refused_data(struct tcp_pcb *pcb)
000c54  e92d4070          PUSH     {r4-r6,lr}
;;;1085   {
;;;1086     err_t err;
;;;1087     u8_t refused_flags = pcb->refused_data->flags;
000c58  e5905078          LDR      r5,[r0,#0x78]
000c5c  e1a04000          MOV      r4,r0                 ;1085
000c60  e5d5600d          LDRB     r6,[r5,#0xd]
;;;1088     /* set pcb->refused_data to NULL in case the callback frees it and then
;;;1089        closes the pcb */
;;;1090     struct pbuf *refused_data = pcb->refused_data;
;;;1091     pcb->refused_data = NULL;
000c64  e3a00000          MOV      r0,#0
;;;1092     /* Notify again application with data previously received. */
;;;1093     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
;;;1094     TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
000c68  e5840078          STR      r0,[r4,#0x78]
000c6c  e594c080          LDR      r12,[r4,#0x80]
000c70  e35c0000          CMP      r12,#0
000c74  0a000005          BEQ      |L1.3216|
000c78  e5940010          LDR      r0,[r4,#0x10]
000c7c  e3a03000          MOV      r3,#0
000c80  e1a02005          MOV      r2,r5
000c84  e1a01004          MOV      r1,r4
000c88  e12fff3c          BLX      r12
000c8c  ea000004          B        |L1.3236|
                  |L1.3216|
000c90  e3a03000          MOV      r3,#0
000c94  e1a02005          MOV      r2,r5
000c98  e1a01004          MOV      r1,r4
000c9c  e1a00003          MOV      r0,r3
000ca0  ebfffffe          BL       tcp_recv_null
                  |L1.3236|
;;;1095     if (err == ERR_OK) {
000ca4  e3500000          CMP      r0,#0
000ca8  0a000004          BEQ      |L1.3264|
;;;1096       /* did refused_data include a FIN? */
;;;1097       if (refused_flags & PBUF_FLAG_TCP_FIN) {
;;;1098         /* correct rcv_wnd as the application won't call tcp_recved()
;;;1099            for the FIN's seqno */
;;;1100         if (pcb->rcv_wnd != TCP_WND) {
;;;1101           pcb->rcv_wnd++;
;;;1102         }
;;;1103         TCP_EVENT_CLOSED(pcb, err);
;;;1104         if (err == ERR_ABRT) {
;;;1105           return ERR_ABRT;
;;;1106         }
;;;1107       }
;;;1108     } else if (err == ERR_ABRT) {
000cac  e370000a          CMN      r0,#0xa
;;;1109       /* if err == ERR_ABRT, 'pcb' is already deallocated */
;;;1110       /* Drop incoming packets because pcb is "full" (only if the incoming
;;;1111          segment contains data). */
;;;1112       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
;;;1113       return ERR_ABRT;
;;;1114     } else {
;;;1115       /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
;;;1116       pcb->refused_data = refused_data;
000cb0  15845078          STRNE    r5,[r4,#0x78]
;;;1117     }
;;;1118     return ERR_OK;
;;;1119   }
000cb4  08bd8070          POPEQ    {r4-r6,pc}
                  |L1.3256|
000cb8  e3a00000          MOV      r0,#0                 ;1118
000cbc  e8bd8070          POP      {r4-r6,pc}
                  |L1.3264|
000cc0  e3160020          TST      r6,#0x20              ;1097
000cc4  0afffffb          BEQ      |L1.3256|
000cc8  e1d402bc          LDRH     r0,[r4,#0x2c]         ;1100
000ccc  e3500efa          CMP      r0,#0xfa0             ;1100
000cd0  12800001          ADDNE    r0,r0,#1              ;1100
000cd4  11c402bc          STRHNE   r0,[r4,#0x2c]         ;1101
000cd8  e594c080          LDR      r12,[r4,#0x80]        ;1103
000cdc  e35c0000          CMP      r12,#0                ;1103
000ce0  0afffff4          BEQ      |L1.3256|
000ce4  e3a03000          MOV      r3,#0                 ;1103
000ce8  e5940010          LDR      r0,[r4,#0x10]         ;1103
000cec  e1a02003          MOV      r2,r3                 ;1103
000cf0  e1a01004          MOV      r1,r4                 ;1103
000cf4  e12fff3c          BLX      r12                   ;1103
000cf8  e370000a          CMN      r0,#0xa               ;1104
000cfc  1affffed          BNE      |L1.3256|
000d00  e8bd8070          POP      {r4-r6,pc}
;;;1120   
                          ENDP

                  tcp_fasttmr PROC
;;;1044   void
;;;1045   tcp_fasttmr(void)
000d04  e92d41f0          PUSH     {r4-r8,lr}
;;;1046   {
;;;1047     struct tcp_pcb *pcb;
;;;1048   
;;;1049     ++tcp_timer_ctr;
000d08  e51f699c          LDR      r6,|L1.884|
000d0c  e5d60002          LDRB     r0,[r6,#2]  ; tcp_timer_ctr
000d10  e2800001          ADD      r0,r0,#1
000d14  e5c60002          STRB     r0,[r6,#2]  ; tcp_timer_ctr
                  |L1.3352|
;;;1050   
;;;1051   tcp_fasttmr_start:
;;;1052     pcb = tcp_active_pcbs;
000d18  e5964018          LDR      r4,[r6,#0x18]  ; tcp_active_pcbs
000d1c  e3a07000          MOV      r7,#0
;;;1053   
;;;1054     while(pcb != NULL) {
000d20  ea000019          B        |L1.3468|
                  |L1.3364|
;;;1055       if (pcb->last_timer != tcp_timer_ctr) {
000d24  e5d41021          LDRB     r1,[r4,#0x21]
000d28  e5d60002          LDRB     r0,[r6,#2]  ; tcp_timer_ctr
000d2c  e1510000          CMP      r1,r0
000d30  0a000015          BEQ      |L1.3468|
;;;1056         struct tcp_pcb *next;
;;;1057         pcb->last_timer = tcp_timer_ctr;
000d34  e5c40021          STRB     r0,[r4,#0x21]
;;;1058         /* send delayed ACKs */
;;;1059         if (pcb->flags & TF_ACK_DELAY) {
000d38  e5d4001e          LDRB     r0,[r4,#0x1e]
000d3c  e3100001          TST      r0,#1
000d40  0a000006          BEQ      |L1.3424|
;;;1060           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
;;;1061           tcp_ack_now(pcb);
000d44  e3800002          ORR      r0,r0,#2
000d48  e5c4001e          STRB     r0,[r4,#0x1e]
;;;1062           tcp_output(pcb);
000d4c  e1a00004          MOV      r0,r4
000d50  ebfffffe          BL       tcp_output
;;;1063           pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
000d54  e5d4001e          LDRB     r0,[r4,#0x1e]
000d58  e3c00003          BIC      r0,r0,#3
000d5c  e5c4001e          STRB     r0,[r4,#0x1e]
                  |L1.3424|
;;;1064         }
;;;1065   
;;;1066         next = pcb->next;
;;;1067   
;;;1068         /* If there is data which was previously "refused" by upper layer */
;;;1069         if (pcb->refused_data != NULL) {
000d60  e5940078          LDR      r0,[r4,#0x78]
000d64  e594500c          LDR      r5,[r4,#0xc]
000d68  e3500000          CMP      r0,#0
000d6c  0a000005          BEQ      |L1.3464|
;;;1070           tcp_active_pcbs_changed = 0;
;;;1071           tcp_process_refused_data(pcb);
000d70  e1a00004          MOV      r0,r4
000d74  e5c67000          STRB     r7,[r6,#0]            ;1070  ; tcp_active_pcbs_changed
000d78  ebfffffe          BL       tcp_process_refused_data
;;;1072           if (tcp_active_pcbs_changed) {
000d7c  e5d60000          LDRB     r0,[r6,#0]  ; tcp_active_pcbs_changed
000d80  e3500000          CMP      r0,#0
000d84  1affffe3          BNE      |L1.3352|
                  |L1.3464|
;;;1073             /* application callback has changed the pcb list: restart the loop */
;;;1074             goto tcp_fasttmr_start;
;;;1075           }
;;;1076         }
;;;1077         pcb = next;
000d88  e1a04005          MOV      r4,r5
                  |L1.3468|
000d8c  e3540000          CMP      r4,#0                 ;1054
000d90  1affffe3          BNE      |L1.3364|
;;;1078       }
;;;1079     }
;;;1080   }
000d94  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3480|
                          DCD      0x00000252
                  |L1.3484|
000d9c  6e65775f          DCB      "new_rcv_ann_wnd <= 0xffff",0
000da0  7263765f
000da4  616e6e5f
000da8  776e6420
000dac  3c3d2030
000db0  78666666
000db4  6600    
000db6  00                DCB      0
000db7  00                DCB      0
                  |L1.3512|
                          DCD      0x00000267
                  |L1.3516|
000dbc  646f6e27          DCB      "don't call tcp_recved for listen-pcbs",0
000dc0  74206361
000dc4  6c6c2074
000dc8  63705f72
000dcc  65637665
000dd0  6420666f
000dd4  72206c69
000dd8  7374656e
000ddc  2d706362
000de0  7300    
000de2  00                DCB      0
000de3  00                DCB      0
                  |L1.3556|
                          DCD      0x0000ffff
                  |L1.3560|
                          DCD      0x00000269
                  |L1.3564|
000dec  7463705f          DCB      "tcp_recved: len would wrap rcv_wnd\n",0
000df0  72656376
000df4  65643a20
000df8  6c656e20
000dfc  776f756c
000e00  64207772
000e04  61702072
000e08  63765f77
000e0c  6e640a00
                          ENDP

                  tcp_tmr PROC
;;;140    void
;;;141    tcp_tmr(void)
000e10  e92d4010          PUSH     {r4,lr}
;;;142    {
;;;143      /* Call tcp_fasttmr() every 250 ms */
;;;144      tcp_fasttmr();
000e14  ebfffffe          BL       tcp_fasttmr
;;;145    
;;;146      if (++tcp_timer & 1) {
000e18  e51f1aac          LDR      r1,|L1.884|
000e1c  e5d10001          LDRB     r0,[r1,#1]  ; tcp_timer
000e20  e2800001          ADD      r0,r0,#1
000e24  e3100001          TST      r0,#1
000e28  e5c10001          STRB     r0,[r1,#1]  ; tcp_timer
;;;147        /* Call tcp_tmr() every 500 ms, i.e., every other timer
;;;148           tcp_tmr() is called. */
;;;149        tcp_slowtmr();
;;;150      }
;;;151    }
000e2c  08bd8010          POPEQ    {r4,pc}
000e30  e8bd4010          POP      {r4,lr}               ;149
000e34  eafffffe          B        tcp_slowtmr
;;;152    
                          ENDP

                  tcp_shutdown PROC
;;;311    err_t
;;;312    tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
000e38  e92d4010          PUSH     {r4,lr}
;;;313    {
000e3c  e1a04000          MOV      r4,r0
;;;314      if (pcb->state == LISTEN) {
000e40  e5d00018          LDRB     r0,[r0,#0x18]
000e44  e3500001          CMP      r0,#1
000e48  0a000018          BEQ      |L1.3760|
;;;315        return ERR_CONN;
;;;316      }
;;;317      if (shut_rx) {
000e4c  e3510000          CMP      r1,#0
000e50  0a00000f          BEQ      |L1.3732|
;;;318        /* shut down the receive side: set a flag not to receive any more data... */
;;;319        pcb->flags |= TF_RXCLOSED;
000e54  e5d4001e          LDRB     r0,[r4,#0x1e]
;;;320        if (shut_tx) {
000e58  e3520000          CMP      r2,#0
;;;321          /* shutting down the tx AND rx side is the same as closing for the raw API */
;;;322          return tcp_close_shutdown(pcb, 1);
000e5c  13a01001          MOVNE    r1,#1
000e60  e3800010          ORR      r0,r0,#0x10           ;319
000e64  e5c4001e          STRB     r0,[r4,#0x1e]         ;319
000e68  0a000002          BEQ      |L1.3704|
                  |L1.3692|
;;;323        }
;;;324        /* ... and free buffered data */
;;;325        if (pcb->refused_data != NULL) {
;;;326          pbuf_free(pcb->refused_data);
;;;327          pcb->refused_data = NULL;
;;;328        }
;;;329      }
;;;330      if (shut_tx) {
;;;331        /* This can't happen twice since if it succeeds, the pcb's state is changed.
;;;332           Only close in these states as the others directly deallocate the PCB */
;;;333        switch (pcb->state) {
;;;334        case SYN_RCVD:
;;;335        case ESTABLISHED:
;;;336        case CLOSE_WAIT:
;;;337          return tcp_close_shutdown(pcb, shut_rx);
000e6c  e1a00004          MOV      r0,r4
000e70  e8bd4010          POP      {r4,lr}
000e74  eafffffe          B        tcp_close_shutdown
                  |L1.3704|
000e78  e5940078          LDR      r0,[r4,#0x78]         ;325
000e7c  e3500000          CMP      r0,#0                 ;325
000e80  0a00000c          BEQ      |L1.3768|
000e84  ebfffffe          BL       pbuf_free
000e88  e3a00000          MOV      r0,#0                 ;327
000e8c  e5840078          STR      r0,[r4,#0x78]         ;327
000e90  ea000008          B        |L1.3768|
                  |L1.3732|
000e94  e3520000          CMP      r2,#0                 ;330
000e98  0a000006          BEQ      |L1.3768|
000e9c  e3500003          CMP      r0,#3                 ;333
000ea0  13500004          CMPNE    r0,#4                 ;333
000ea4  13500007          CMPNE    r0,#7                 ;333
000ea8  020110ff          ANDEQ    r1,r1,#0xff
000eac  0affffee          BEQ      |L1.3692|
                  |L1.3760|
;;;338        default:
;;;339          /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
;;;340            into CLOSED state, where the PCB is deallocated. */
;;;341          return ERR_CONN;
000eb0  e3e0000c          MVN      r0,#0xc
;;;342        }
;;;343      }
;;;344      return ERR_OK;
;;;345    }
000eb4  e8bd8010          POP      {r4,pc}
                  |L1.3768|
000eb8  e3a00000          MOV      r0,#0                 ;344
000ebc  e8bd8010          POP      {r4,pc}
;;;346    
                          ENDP

                  tcp_abandon PROC
;;;355    void
;;;356    tcp_abandon(struct tcp_pcb *pcb, int reset)
000ec0  e92d47fc          PUSH     {r2-r10,lr}
;;;357    {
000ec4  e1a04000          MOV      r4,r0
;;;358      u32_t seqno, ackno;
;;;359    #if LWIP_CALLBACK_API  
;;;360      tcp_err_fn errf;
;;;361    #endif /* LWIP_CALLBACK_API */
;;;362      void *errf_arg;
;;;363    
;;;364      /* pcb->state LISTEN not allowed here */
;;;365      LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
000ec8  e5d00018          LDRB     r0,[r0,#0x18]
000ecc  e1a09001          MOV      r9,r1                 ;357
000ed0  e3500001          CMP      r0,#1
000ed4  1a000004          BNE      |L1.3820|
000ed8  e51f3474          LDR      r3,|L1.2668|
000edc  e59f2244          LDR      r2,|L1.4392|
000ee0  e51f0460          LDR      r0,|L1.2696|
000ee4  e28f1d09          ADR      r1,|L1.4396|
000ee8  ebfffffe          BL       sysprintf
                  |L1.3820|
;;;366        pcb->state != LISTEN);
;;;367      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;368         are in an active state, call the receive function associated with
;;;369         the PCB with a NULL argument, and send an RST to the remote end. */
;;;370      if (pcb->state == TIME_WAIT) {
000eec  e5d40018          LDRB     r0,[r4,#0x18]
000ef0  e350000a          CMP      r0,#0xa
000ef4  0a000027          BEQ      |L1.3992|
;;;371        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
;;;372        memp_free(MEMP_TCP_PCB, pcb);
;;;373      } else {
;;;374        seqno = pcb->snd_nxt;
;;;375        ackno = pcb->rcv_nxt;
;;;376    #if LWIP_CALLBACK_API
;;;377        errf = pcb->errf;
;;;378    #endif /* LWIP_CALLBACK_API */
;;;379        errf_arg = pcb->callback_arg;
000ef8  e594508c          LDR      r5,[r4,#0x8c]
000efc  e5946010          LDR      r6,[r4,#0x10]
000f00  e5947028          LDR      r7,[r4,#0x28]
000f04  e5948050          LDR      r8,[r4,#0x50]
;;;380        TCP_PCB_REMOVE_ACTIVE(pcb);
000f08  e51f0428          LDR      r0,|L1.2792|
000f0c  e1a01004          MOV      r1,r4
000f10  ebfffffe          BL       tcp_pcb_remove
000f14  e51f1ba8          LDR      r1,|L1.884|
000f18  e3a00001          MOV      r0,#1
000f1c  e5c10000          STRB     r0,[r1,#0]  ; tcp_active_pcbs_changed
;;;381        if (pcb->unacked != NULL) {
000f20  e5940070          LDR      r0,[r4,#0x70]
000f24  e3500000          CMP      r0,#0
;;;382          tcp_segs_free(pcb->unacked);
000f28  1bfffffe          BLNE     tcp_segs_free
;;;383        }
;;;384        if (pcb->unsent != NULL) {
000f2c  e594006c          LDR      r0,[r4,#0x6c]
000f30  e3500000          CMP      r0,#0
;;;385          tcp_segs_free(pcb->unsent);
000f34  1bfffffe          BLNE     tcp_segs_free
;;;386        }
;;;387    #if TCP_QUEUE_OOSEQ    
;;;388        if (pcb->ooseq != NULL) {
000f38  e5940074          LDR      r0,[r4,#0x74]
000f3c  e3500000          CMP      r0,#0
;;;389          tcp_segs_free(pcb->ooseq);
000f40  1bfffffe          BLNE     tcp_segs_free
;;;390        }
;;;391    #endif /* TCP_QUEUE_OOSEQ */
;;;392        if (reset) {
000f44  e3590000          CMP      r9,#0
000f48  0a000007          BEQ      |L1.3948|
;;;393          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
;;;394          tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
000f4c  e1d401ba          LDRH     r0,[r4,#0x1a]
000f50  e1d411bc          LDRH     r1,[r4,#0x1c]
000f54  e2843004          ADD      r3,r4,#4
000f58  e1cd00f0          STRD     r0,r1,[sp,#0]
000f5c  e1a02004          MOV      r2,r4
000f60  e1a01007          MOV      r1,r7
000f64  e1a00008          MOV      r0,r8
000f68  ebfffffe          BL       tcp_rst
                  |L1.3948|
;;;395        }
;;;396        memp_free(MEMP_TCP_PCB, pcb);
000f6c  e1a01004          MOV      r1,r4
000f70  e3a00001          MOV      r0,#1
000f74  ebfffffe          BL       memp_free
;;;397        TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
000f78  e3550000          CMP      r5,#0
000f7c  0a00000b          BEQ      |L1.4016|
000f80  e1a00006          MOV      r0,r6
000f84  e1a0c005          MOV      r12,r5
000f88  e28dd008          ADD      sp,sp,#8
000f8c  e8bd47f0          POP      {r4-r10,lr}
000f90  e3e01009          MVN      r1,#9
000f94  e12fff1c          BX       r12
                  |L1.3992|
000f98  e59f01c0          LDR      r0,|L1.4448|
000f9c  e1a01004          MOV      r1,r4                 ;371
000fa0  ebfffffe          BL       tcp_pcb_remove
000fa4  e1a01004          MOV      r1,r4                 ;372
000fa8  e3a00001          MOV      r0,#1                 ;372
000fac  ebfffffe          BL       memp_free
                  |L1.4016|
;;;398      }
;;;399    }
000fb0  e8bd87fc          POP      {r2-r10,pc}
;;;400    
                          ENDP

                  tcp_abort PROC
;;;411    void
;;;412    tcp_abort(struct tcp_pcb *pcb)
000fb4  e3a01001          MOV      r1,#1
;;;413    {
;;;414      tcp_abandon(pcb, 1);
000fb8  eafffffe          B        tcp_abandon
;;;415    }
;;;416    
                          ENDP

                  tcp_new_port PROC
;;;645    static u16_t
;;;646    tcp_new_port(void)
000fbc  e92d40f0          PUSH     {r4-r7,lr}
;;;647    {
;;;648      u8_t i;
;;;649      u16_t n = 0;
;;;650      struct tcp_pcb *pcb;
;;;651      
;;;652    again:
;;;653      if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
000fc0  e51f61e4          LDR      r6,|L1.3556|
;;;654        tcp_port = TCP_LOCAL_PORT_RANGE_START;
;;;655      }
;;;656      /* Check all PCB lists. */
;;;657      for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
;;;658        for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
000fc4  e59f5198          LDR      r5,|L1.4452|
000fc8  e51f4c5c          LDR      r4,|L1.884|
000fcc  e3a0c000          MOV      r12,#0                ;649
000fd0  e3a07903          MOV      r7,#0xc000            ;654
                  |L1.4052|
000fd4  e1d400b4          LDRH     r0,[r4,#4]            ;653  ; tcp_port
000fd8  e2801001          ADD      r1,r0,#1              ;653
000fdc  e1500006          CMP      r0,r6                 ;653
000fe0  e1c410b4          STRH     r1,[r4,#4]            ;653  ; tcp_port
000fe4  01c470b4          STRHEQ   r7,[r4,#4]            ;654  ; tcp_port
000fe8  e1d420b4          LDRH     r2,[r4,#4]            ;653
000fec  e3a01000          MOV      r1,#0                 ;657
                  |L1.4080|
000ff0  e7950101          LDR      r0,[r5,r1,LSL #2]
000ff4  e5900000          LDR      r0,[r0,#0]
                  |L1.4088|
000ff8  e3500000          CMP      r0,#0
000ffc  0a000009          BEQ      |L1.4136|
;;;659          if (pcb->local_port == tcp_port) {
001000  e1d031ba          LDRH     r3,[r0,#0x1a]
001004  e1530002          CMP      r3,r2
001008  1590000c          LDRNE    r0,[r0,#0xc]          ;658
00100c  1afffff9          BNE      |L1.4088|
;;;660            if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
001010  e28c0001          ADD      r0,r12,#1
001014  e3c0c801          BIC      r12,r0,#0x10000
001018  e35c0901          CMP      r12,#0x4000
;;;661              return 0;
00101c  23a00000          MOVCS    r0,#0
001020  3affffeb          BCC      |L1.4052|
;;;662            }
;;;663            goto again;
;;;664          }
;;;665        }
;;;666      }
;;;667      return tcp_port;
;;;668    }
001024  e8bd80f0          POP      {r4-r7,pc}
                  |L1.4136|
001028  e2810001          ADD      r0,r1,#1              ;657
00102c  e20010ff          AND      r1,r0,#0xff           ;657
001030  e3510004          CMP      r1,#4                 ;657
001034  21a00802          LSLCS    r0,r2,#16             ;667
001038  21a00820          LSRCS    r0,r0,#16             ;667
00103c  3affffeb          BCC      |L1.4080|
001040  e8bd80f0          POP      {r4-r7,pc}
;;;669    
                          ENDP

                  tcp_bind PROC
;;;431    err_t
;;;432    tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
001044  e92d41f0          PUSH     {r4-r8,lr}
;;;433    {
001048  e1a07000          MOV      r7,r0
;;;434      int i;
;;;435      int max_pcb_list = NUM_TCP_PCB_LISTS;
;;;436      struct tcp_pcb *cpcb;
;;;437    
;;;438      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
00104c  e5d00018          LDRB     r0,[r0,#0x18]
001050  e1a06001          MOV      r6,r1                 ;433
001054  e3a08004          MOV      r8,#4                 ;435
001058  e3500000          CMP      r0,#0
00105c  0a000006          BEQ      |L1.4220|
001060  e51f35fc          LDR      r3,|L1.2668|
001064  e59f20fc          LDR      r2,|L1.4456|
001068  e51f05e8          LDR      r0,|L1.2696|
00106c  e28f10f8          ADR      r1,|L1.4460|
001070  ebfffffe          BL       sysprintf
001074  e3e00005          MVN      r0,#5
;;;439    
;;;440    #if SO_REUSE
;;;441      /* Unless the REUSEADDR flag is set,
;;;442         we have to check the pcbs in TIME-WAIT state, also.
;;;443         We do not dump TIME_WAIT pcb's; they can still be matched by incoming
;;;444         packets using both local and remote IP addresses and ports to distinguish.
;;;445       */
;;;446      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;447        max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
;;;448      }
;;;449    #endif /* SO_REUSE */
;;;450    
;;;451      if (port == 0) {
;;;452        port = tcp_new_port();
;;;453        if (port == 0) {
;;;454          return ERR_BUF;
;;;455        }
;;;456      }
;;;457    
;;;458      /* Check if the address already is in use (on all lists) */
;;;459      for (i = 0; i < max_pcb_list; i++) {
;;;460        for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;461          if (cpcb->local_port == port) {
;;;462    #if SO_REUSE
;;;463            /* Omit checking for the same port if both pcbs have REUSEADDR set.
;;;464               For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
;;;465               tcp_connect. */
;;;466            if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;467                !ip_get_option(cpcb, SOF_REUSEADDR))
;;;468    #endif /* SO_REUSE */
;;;469            {
;;;470              if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;471                  ip_addr_isany(ipaddr) ||
;;;472                  ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;473                return ERR_USE;
;;;474              }
;;;475            }
;;;476          }
;;;477        }
;;;478      }
;;;479    
;;;480      if (!ip_addr_isany(ipaddr)) {
;;;481        pcb->local_ip = *ipaddr;
;;;482      }
;;;483      pcb->local_port = port;
;;;484      TCP_REG(&tcp_bound_pcbs, pcb);
;;;485      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;486      return ERR_OK;
;;;487    }
001078  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4220|
00107c  e3520000          CMP      r2,#0                 ;451
001080  1a000003          BNE      |L1.4244|
001084  ebfffffe          BL       tcp_new_port
001088  e1b02000          MOVS     r2,r0                 ;452
00108c  03e00001          MVNEQ    r0,#1                 ;454
001090  08bd81f0          POPEQ    {r4-r8,pc}
                  |L1.4244|
001094  e3a0c000          MOV      r12,#0                ;459
001098  e59f00c4          LDR      r0,|L1.4452|
                  |L1.4252|
00109c  e790110c          LDR      r1,[r0,r12,LSL #2]    ;460
0010a0  e5913000          LDR      r3,[r1,#0]            ;460
0010a4  ea00000e          B        |L1.4324|
                  |L1.4264|
0010a8  e1d311ba          LDRH     r1,[r3,#0x1a]         ;461
0010ac  e1510002          CMP      r1,r2                 ;461
0010b0  1a00000a          BNE      |L1.4320|
0010b4  e3530000          CMP      r3,#0                 ;470
0010b8  15934000          LDRNE    r4,[r3,#0]            ;470
0010bc  13540000          CMPNE    r4,#0                 ;470
0010c0  0a000004          BEQ      |L1.4312|
0010c4  e3560000          CMP      r6,#0                 ;471
0010c8  15965000          LDRNE    r5,[r6,#0]            ;471
0010cc  13550000          CMPNE    r5,#0                 ;471
0010d0  11540005          CMPNE    r4,r5                 ;472
0010d4  1a000001          BNE      |L1.4320|
                  |L1.4312|
0010d8  e3e00007          MVN      r0,#7                 ;473
0010dc  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4320|
0010e0  e593300c          LDR      r3,[r3,#0xc]          ;460
                  |L1.4324|
0010e4  e3530000          CMP      r3,#0                 ;460
0010e8  1affffee          BNE      |L1.4264|
0010ec  e28cc001          ADD      r12,r12,#1            ;460
0010f0  e15c0008          CMP      r12,r8                ;459
0010f4  baffffe8          BLT      |L1.4252|
0010f8  e3560000          CMP      r6,#0                 ;480
0010fc  15960000          LDRNE    r0,[r6,#0]            ;480
001100  13500000          CMPNE    r0,#0                 ;480
001104  15870000          STRNE    r0,[r7,#0]            ;481
001108  e51f0d9c          LDR      r0,|L1.884|
00110c  e1c721ba          STRH     r2,[r7,#0x1a]         ;483
001110  e5901010          LDR      r1,[r0,#0x10]         ;484  ; tcp_bound_pcbs
001114  e587100c          STR      r1,[r7,#0xc]          ;484
001118  e5807010          STR      r7,[r0,#0x10]         ;484  ; tcp_bound_pcbs
00111c  ebfffffe          BL       tcp_timer_needed
001120  e3a00000          MOV      r0,#0                 ;486
001124  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4392|
                          DCD      0x0000016d
                  |L1.4396|
00112c  646f6e27          DCB      "don't call tcp_abort/tcp_abandon for listen-pcbs",0
001130  74206361
001134  6c6c2074
001138  63705f61
00113c  626f7274
001140  2f746370
001144  5f616261
001148  6e646f6e
00114c  20666f72
001150  206c6973
001154  74656e2d
001158  70636273
00115c  00      
00115d  00                DCB      0
00115e  00                DCB      0
00115f  00                DCB      0
                  |L1.4448|
                          DCD      ||.data||+0x1c
                  |L1.4452|
                          DCD      ||.constdata||+0x44
                  |L1.4456|
                          DCD      0x000001b6
                  |L1.4460|
00116c  7463705f          DCB      "tcp_bind: can only bind in state CLOSED",0
001170  62696e64
001174  3a206361
001178  6e206f6e
00117c  6c792062
001180  696e6420
001184  696e2073
001188  74617465
00118c  20434c4f
001190  53454400
                          ENDP

                  tcp_accept_null PROC
;;;492    static err_t
;;;493    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
001194  e3e00009          MVN      r0,#9
;;;494    {
;;;495      LWIP_UNUSED_ARG(arg);
;;;496      LWIP_UNUSED_ARG(pcb);
;;;497      LWIP_UNUSED_ARG(err);
;;;498    
;;;499      return ERR_ABRT;
;;;500    }
001198  e12fff1e          BX       lr
;;;501    #endif /* LWIP_CALLBACK_API */
                          ENDP

                  tcp_listen_with_backlog PROC
;;;517    struct tcp_pcb *
;;;518    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
00119c  e92d4070          PUSH     {r4-r6,lr}
;;;519    {
0011a0  e1a04000          MOV      r4,r0
;;;520      struct tcp_pcb_listen *lpcb;
;;;521    
;;;522      LWIP_UNUSED_ARG(backlog);
;;;523      LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
0011a4  e5d00018          LDRB     r0,[r0,#0x18]
0011a8  e3500000          CMP      r0,#0
0011ac  0a000006          BEQ      |L1.4556|
0011b0  e51f374c          LDR      r3,|L1.2668|
0011b4  e59f22c8          LDR      r2,|L1.5252|
0011b8  e51f0738          LDR      r0,|L1.2696|
0011bc  e28f1fb1          ADR      r1,|L1.5256|
0011c0  ebfffffe          BL       sysprintf
0011c4  e3a00000          MOV      r0,#0
;;;524    
;;;525      /* already listening? */
;;;526      if (pcb->state == LISTEN) {
;;;527        return pcb;
;;;528      }
;;;529    #if SO_REUSE
;;;530      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;531        /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
;;;532           is declared (listen-/connection-pcb), we have to make sure now that
;;;533           this port is only used once for every local IP. */
;;;534        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;535          if (lpcb->local_port == pcb->local_port) {
;;;536            if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
;;;537              /* this address/port is already used */
;;;538              return NULL;
;;;539            }
;;;540          }
;;;541        }
;;;542      }
;;;543    #endif /* SO_REUSE */
;;;544      lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
;;;545      if (lpcb == NULL) {
;;;546        return NULL;
;;;547      }
;;;548      lpcb->callback_arg = pcb->callback_arg;
;;;549      lpcb->local_port = pcb->local_port;
;;;550      lpcb->state = LISTEN;
;;;551      lpcb->prio = pcb->prio;
;;;552      lpcb->so_options = pcb->so_options;
;;;553      ip_set_option(lpcb, SOF_ACCEPTCONN);
;;;554      lpcb->ttl = pcb->ttl;
;;;555      lpcb->tos = pcb->tos;
;;;556      ip_addr_copy(lpcb->local_ip, pcb->local_ip);
;;;557      if (pcb->local_port != 0) {
;;;558        TCP_RMV(&tcp_bound_pcbs, pcb);
;;;559      }
;;;560      memp_free(MEMP_TCP_PCB, pcb);
;;;561    #if LWIP_CALLBACK_API
;;;562      lpcb->accept = tcp_accept_null;
;;;563    #endif /* LWIP_CALLBACK_API */
;;;564    #if TCP_LISTEN_BACKLOG
;;;565      lpcb->accepts_pending = 0;
;;;566      lpcb->backlog = (backlog ? backlog : 1);
;;;567    #endif /* TCP_LISTEN_BACKLOG */
;;;568      TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
;;;569      return (struct tcp_pcb *)lpcb;
;;;570    }
0011c8  e8bd8070          POP      {r4-r6,pc}
                  |L1.4556|
0011cc  e3a00002          MOV      r0,#2                 ;544
0011d0  ebfffffe          BL       memp_malloc
0011d4  e2505000          SUBS     r5,r0,#0              ;544
0011d8  08bd8070          POPEQ    {r4-r6,pc}
0011dc  e5940010          LDR      r0,[r4,#0x10]         ;548
0011e0  e5850010          STR      r0,[r5,#0x10]         ;548
0011e4  e1d401ba          LDRH     r0,[r4,#0x1a]         ;549
0011e8  e1c501ba          STRH     r0,[r5,#0x1a]         ;549
0011ec  e3a00001          MOV      r0,#1                 ;550
0011f0  e5c50018          STRB     r0,[r5,#0x18]         ;550
0011f4  e5d40019          LDRB     r0,[r4,#0x19]         ;551
0011f8  e5c50019          STRB     r0,[r5,#0x19]         ;551
0011fc  e5d40008          LDRB     r0,[r4,#8]            ;552
001200  e3800002          ORR      r0,r0,#2              ;553
001204  e5c50008          STRB     r0,[r5,#8]            ;553
001208  e5d4000a          LDRB     r0,[r4,#0xa]          ;554
00120c  e5c5000a          STRB     r0,[r5,#0xa]          ;554
001210  e5d40009          LDRB     r0,[r4,#9]            ;555
001214  e5c50009          STRB     r0,[r5,#9]            ;555
001218  e5940000          LDR      r0,[r4,#0]            ;556
00121c  e5850000          STR      r0,[r5,#0]            ;556
001220  e1d401ba          LDRH     r0,[r4,#0x1a]         ;557
001224  e3500000          CMP      r0,#0                 ;557
001228  0a000010          BEQ      |L1.4720|
00122c  e51f1ec0          LDR      r1,|L1.884|
001230  e5910010          LDR      r0,[r1,#0x10]         ;558  ; tcp_bound_pcbs
001234  e1500004          CMP      r0,r4                 ;558
001238  0590000c          LDREQ    r0,[r0,#0xc]          ;558
00123c  05810010          STREQ    r0,[r1,#0x10]         ;558  ; tcp_bound_pcbs
001240  0a000008          BEQ      |L1.4712|
                  |L1.4676|
001244  e3500000          CMP      r0,#0                 ;558
001248  e5810020          STR      r0,[r1,#0x20]         ;558  ; tcp_tmp_pcb
00124c  0a000005          BEQ      |L1.4712|
001250  e590000c          LDR      r0,[r0,#0xc]          ;558
001254  e1500004          CMP      r0,r4                 ;558
001258  0594000c          LDREQ    r0,[r4,#0xc]          ;558
00125c  05911020          LDREQ    r1,[r1,#0x20]         ;558  ; tcp_tmp_pcb
001260  0581000c          STREQ    r0,[r1,#0xc]          ;558
001264  1afffff6          BNE      |L1.4676|
                  |L1.4712|
001268  e3a00000          MOV      r0,#0                 ;558
00126c  e584000c          STR      r0,[r4,#0xc]          ;558
                  |L1.4720|
001270  e1a01004          MOV      r1,r4                 ;560
001274  e3a00001          MOV      r0,#1                 ;560
001278  ebfffffe          BL       memp_free
00127c  e59f0228          LDR      r0,|L1.5292|
001280  e5850014          STR      r0,[r5,#0x14]         ;562
001284  e51f07a8          LDR      r0,|L1.2788|
001288  e5901000          LDR      r1,[r0,#0]            ;568  ; tcp_listen_pcbs
00128c  e585100c          STR      r1,[r5,#0xc]          ;568
001290  e5805000          STR      r5,[r0,#0]            ;568  ; tcp_listen_pcbs
001294  ebfffffe          BL       tcp_timer_needed
001298  e1a00005          MOV      r0,r5                 ;569
00129c  e8bd8070          POP      {r4-r6,pc}
;;;571    
                          ENDP

                  tcp_eff_send_mss PROC
;;;1584   u16_t
;;;1585   tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
0012a0  e92d4010          PUSH     {r4,lr}
;;;1586   {
0012a4  e1a04000          MOV      r4,r0
;;;1587     u16_t mss_s;
;;;1588     struct netif *outif;
;;;1589   
;;;1590     outif = ip_route(addr);
0012a8  e1a00001          MOV      r0,r1
0012ac  ebfffffe          BL       ip_route
;;;1591     if ((outif != NULL) && (outif->mtu != 0)) {
0012b0  e3500000          CMP      r0,#0
0012b4  11d002b4          LDRHNE   r0,[r0,#0x24]
0012b8  13500000          CMPNE    r0,#0
0012bc  0a000005          BEQ      |L1.4824|
0012c0  e2400028          SUB      r0,r0,#0x28
;;;1592       mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
0012c4  e1a00800          LSL      r0,r0,#16
0012c8  e1a00820          LSR      r0,r0,#16
;;;1593       /* RFC 1122, chap 4.2.2.6:
;;;1594        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;1595        * We correct for TCP options in tcp_write(), and don't support IP options.
;;;1596        */
;;;1597       sendmss = LWIP_MIN(sendmss, mss_s);
0012cc  e1540000          CMP      r4,r0
0012d0  31a00004          MOVCC    r0,r4
0012d4  e1a04000          MOV      r4,r0
                  |L1.4824|
;;;1598     }
;;;1599     return sendmss;
0012d8  e1a00004          MOV      r0,r4
;;;1600   }
0012dc  e8bd8010          POP      {r4,pc}
;;;1601   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP

                  tcp_next_iss PROC
;;;1569   u32_t
;;;1570   tcp_next_iss(void)
0012e0  e51f1f74          LDR      r1,|L1.884|
;;;1571   {
;;;1572     static u32_t iss = 6510;
;;;1573     
;;;1574     iss += tcp_ticks;       /* XXX */
0012e4  e5910008          LDR      r0,[r1,#8]  ; iss, tcp_ticks
0012e8  e591200c          LDR      r2,[r1,#0xc]
0012ec  e0800002          ADD      r0,r0,r2
0012f0  e5810008          STR      r0,[r1,#8]  ; iss
;;;1575     return iss;
;;;1576   }
0012f4  e12fff1e          BX       lr
;;;1577   
                          ENDP

                  tcp_connect PROC
;;;682    err_t
;;;683    tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
0012f8  e92d47f0          PUSH     {r4-r10,lr}
;;;684          tcp_connected_fn connected)
;;;685    {
0012fc  e1a04000          MOV      r4,r0
;;;686      err_t ret;
;;;687      u32_t iss;
;;;688      u16_t old_local_port;
;;;689    
;;;690      LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
001300  e5d00018          LDRB     r0,[r0,#0x18]
001304  e1a05003          MOV      r5,r3                 ;685
001308  e1a06001          MOV      r6,r1                 ;685
00130c  e3500000          CMP      r0,#0
001310  0a000006          BEQ      |L1.4912|
001314  e51f38b0          LDR      r3,|L1.2668|
001318  e59f2190          LDR      r2,|L1.5296|
00131c  e51f089c          LDR      r0,|L1.2696|
001320  e28f1f63          ADR      r1,|L1.5300|
001324  ebfffffe          BL       sysprintf
001328  e3e00008          MVN      r0,#8
;;;691    
;;;692      LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;693      if (ipaddr != NULL) {
;;;694        pcb->remote_ip = *ipaddr;
;;;695      } else {
;;;696        return ERR_VAL;
;;;697      }
;;;698      pcb->remote_port = port;
;;;699    
;;;700      /* check if we have a route to the remote host */
;;;701      if (ip_addr_isany(&(pcb->local_ip))) {
;;;702        /* no local IP address set, yet. */
;;;703        struct netif *netif = ip_route(&(pcb->remote_ip));
;;;704        if (netif == NULL) {
;;;705          /* Don't even try to send a SYN packet if we have no route
;;;706             since that will fail. */
;;;707          return ERR_RTE;
;;;708        }
;;;709        /* Use the netif's IP address as local address. */
;;;710        ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;711      }
;;;712    
;;;713      old_local_port = pcb->local_port;
;;;714      if (pcb->local_port == 0) {
;;;715        pcb->local_port = tcp_new_port();
;;;716        if (pcb->local_port == 0) {
;;;717          return ERR_BUF;
;;;718        }
;;;719      }
;;;720    #if SO_REUSE
;;;721      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;722        /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
;;;723           now that the 5-tuple is unique. */
;;;724        struct tcp_pcb *cpcb;
;;;725        int i;
;;;726        /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
;;;727        for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
;;;728          for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;729            if ((cpcb->local_port == pcb->local_port) &&
;;;730                (cpcb->remote_port == port) &&
;;;731                ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
;;;732                ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
;;;733              /* linux returns EISCONN here, but ERR_USE should be OK for us */
;;;734              return ERR_USE;
;;;735            }
;;;736          }
;;;737        }
;;;738      }
;;;739    #endif /* SO_REUSE */
;;;740      iss = tcp_next_iss();
;;;741      pcb->rcv_nxt = 0;
;;;742      pcb->snd_nxt = iss;
;;;743      pcb->lastack = iss - 1;
;;;744      pcb->snd_lbb = iss - 1;
;;;745      pcb->rcv_wnd = TCP_WND;
;;;746      pcb->rcv_ann_wnd = TCP_WND;
;;;747      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;748      pcb->snd_wnd = TCP_WND;
;;;749      /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;750         The send MSS is updated when an MSS option is received. */
;;;751      pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
;;;752    #if TCP_CALCULATE_EFF_SEND_MSS
;;;753      pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
;;;754    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;755      pcb->cwnd = 1;
;;;756      pcb->ssthresh = pcb->mss * 10;
;;;757    #if LWIP_CALLBACK_API
;;;758      pcb->connected = connected;
;;;759    #else /* LWIP_CALLBACK_API */  
;;;760      LWIP_UNUSED_ARG(connected);
;;;761    #endif /* LWIP_CALLBACK_API */
;;;762    
;;;763      /* Send a SYN together with the MSS option. */
;;;764      ret = tcp_enqueue_flags(pcb, TCP_SYN);
;;;765      if (ret == ERR_OK) {
;;;766        /* SYN segment was enqueued, changed the pcbs state now */
;;;767        pcb->state = SYN_SENT;
;;;768        if (old_local_port != 0) {
;;;769          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;770        }
;;;771        TCP_REG_ACTIVE(pcb);
;;;772        snmp_inc_tcpactiveopens();
;;;773    
;;;774        tcp_output(pcb);
;;;775      }
;;;776      return ret;
;;;777    }
00132c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.4912|
001330  e3560000          CMP      r6,#0                 ;693
001334  03e00005          MVNEQ    r0,#5                 ;696
001338  08bd87f0          POPEQ    {r4-r10,pc}
00133c  e5960000          LDR      r0,[r6,#0]            ;694
001340  e3540000          CMP      r4,#0                 ;701
001344  e5840004          STR      r0,[r4,#4]            ;694
001348  e1c421bc          STRH     r2,[r4,#0x1c]         ;698
00134c  15940000          LDRNE    r0,[r4,#0]            ;701
001350  13500000          CMPNE    r0,#0                 ;701
001354  0a000003          BEQ      |L1.4968|
                  |L1.4952|
001358  e1d491ba          LDRH     r9,[r4,#0x1a]         ;713
00135c  e3590000          CMP      r9,#0                 ;714
001360  1a00000d          BNE      |L1.5020|
001364  ea000007          B        |L1.5000|
                  |L1.4968|
001368  e2840004          ADD      r0,r4,#4              ;703
00136c  ebfffffe          BL       ip_route
001370  e3500000          CMP      r0,#0                 ;704
001374  15900004          LDRNE    r0,[r0,#4]            ;710
001378  03e00003          MVNEQ    r0,#3                 ;707
00137c  15840000          STRNE    r0,[r4,#0]            ;710
001380  1afffff4          BNE      |L1.4952|
001384  e8bd87f0          POP      {r4-r10,pc}
                  |L1.5000|
001388  ebfffffe          BL       tcp_new_port
00138c  e3500000          CMP      r0,#0                 ;716
001390  e1c401ba          STRH     r0,[r4,#0x1a]         ;715
001394  03e00001          MVNEQ    r0,#1                 ;717
001398  08bd87f0          POPEQ    {r4-r10,pc}
                  |L1.5020|
00139c  ebfffffe          BL       tcp_next_iss
0013a0  e5840050          STR      r0,[r4,#0x50]         ;742
0013a4  e2400001          SUB      r0,r0,#1              ;742
0013a8  e3a07000          MOV      r7,#0                 ;741
0013ac  e5840048          STR      r0,[r4,#0x48]         ;744
0013b0  e5847028          STR      r7,[r4,#0x28]         ;744
0013b4  e584005c          STR      r0,[r4,#0x5c]         ;744
0013b8  e3a00efa          MOV      r0,#0xfa0             ;745
0013bc  e1c402bc          STRH     r0,[r4,#0x2c]         ;745
0013c0  e1c402be          STRH     r0,[r4,#0x2e]         ;746
0013c4  e5847030          STR      r7,[r4,#0x30]         ;747
0013c8  e1c406b0          STRH     r0,[r4,#0x60]         ;748
0013cc  e3a00f86          MOV      r0,#0x218             ;751
0013d0  e1a01006          MOV      r1,r6                 ;753
0013d4  e1c403b6          STRH     r0,[r4,#0x36]         ;751
0013d8  ebfffffe          BL       tcp_eff_send_mss
0013dc  e1c403b6          STRH     r0,[r4,#0x36]         ;753
0013e0  e0800100          ADD      r0,r0,r0,LSL #2       ;756
0013e4  e3e0180f          MVN      r1,#0xf0000           ;756
0013e8  e3a08001          MOV      r8,#1                 ;755
0013ec  e0010080          AND      r0,r1,r0,LSL #1       ;756
0013f0  e1c484bc          STRH     r8,[r4,#0x4c]         ;755
0013f4  e1c404be          STRH     r0,[r4,#0x4e]         ;756
0013f8  e3a01002          MOV      r1,#2                 ;764
0013fc  e1a00004          MOV      r0,r4                 ;764
001400  e5845084          STR      r5,[r4,#0x84]         ;764
001404  ebfffffe          BL       tcp_enqueue_flags
001408  e1b05000          MOVS     r5,r0                 ;764
00140c  1a00001a          BNE      |L1.5244|
001410  e59f60cc          LDR      r6,|L1.5348|
001414  e3a00002          MOV      r0,#2                 ;767
001418  e3590000          CMP      r9,#0                 ;768
00141c  e5c40018          STRB     r0,[r4,#0x18]         ;767
001420  0a00000e          BEQ      |L1.5216|
001424  e5960010          LDR      r0,[r6,#0x10]         ;769  ; tcp_bound_pcbs
001428  e1500004          CMP      r0,r4                 ;769
00142c  0590000c          LDREQ    r0,[r0,#0xc]          ;769
001430  05860010          STREQ    r0,[r6,#0x10]         ;769  ; tcp_bound_pcbs
001434  0a000008          BEQ      |L1.5212|
                  |L1.5176|
001438  e3500000          CMP      r0,#0                 ;769
00143c  e5860020          STR      r0,[r6,#0x20]         ;769  ; tcp_tmp_pcb
001440  0a000005          BEQ      |L1.5212|
001444  e590000c          LDR      r0,[r0,#0xc]          ;769
001448  e1500004          CMP      r0,r4                 ;769
00144c  0594000c          LDREQ    r0,[r4,#0xc]          ;769
001450  05961020          LDREQ    r1,[r6,#0x20]         ;769  ; tcp_tmp_pcb
001454  0581000c          STREQ    r0,[r1,#0xc]          ;769
001458  1afffff6          BNE      |L1.5176|
                  |L1.5212|
00145c  e584700c          STR      r7,[r4,#0xc]          ;769
                  |L1.5216|
001460  e5960018          LDR      r0,[r6,#0x18]         ;771  ; tcp_active_pcbs
001464  e584000c          STR      r0,[r4,#0xc]          ;771
001468  e5864018          STR      r4,[r6,#0x18]         ;771  ; tcp_active_pcbs
00146c  ebfffffe          BL       tcp_timer_needed
001470  e1a00004          MOV      r0,r4                 ;774
001474  e5c68000          STRB     r8,[r6,#0]            ;771  ; tcp_active_pcbs_changed
001478  ebfffffe          BL       tcp_output
                  |L1.5244|
00147c  e1a00005          MOV      r0,r5                 ;776
001480  e8bd87f0          POP      {r4-r10,pc}
                  |L1.5252|
                          DCD      0x0000020b
                  |L1.5256|
001488  7463705f          DCB      "tcp_listen: pcb already connected",0
00148c  6c697374
001490  656e3a20
001494  70636220
001498  616c7265
00149c  61647920
0014a0  636f6e6e
0014a4  65637465
0014a8  6400    
0014aa  00                DCB      0
0014ab  00                DCB      0
                  |L1.5292|
                          DCD      tcp_accept_null
                  |L1.5296|
                          DCD      0x000002b2
                  |L1.5300|
0014b4  7463705f          DCB      "tcp_connect: can only connect from state CLOSED",0
0014b8  636f6e6e
0014bc  6563743a
0014c0  2063616e
0014c4  206f6e6c
0014c8  7920636f
0014cc  6e6e6563
0014d0  74206672
0014d4  6f6d2073
0014d8  74617465
0014dc  20434c4f
0014e0  53454400
                  |L1.5348|
                          DCD      ||.data||
                          ENDP

                  tcp_setprio PROC
;;;1161   void
;;;1162   tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
0014e8  e5c01019          STRB     r1,[r0,#0x19]
;;;1163   {
;;;1164     pcb->prio = prio;
;;;1165   }
0014ec  e12fff1e          BX       lr
;;;1166   
                          ENDP

                  tcp_seg_copy PROC
;;;1175   struct tcp_seg *
;;;1176   tcp_seg_copy(struct tcp_seg *seg)
0014f0  e92d4070          PUSH     {r4-r6,lr}
;;;1177   {
0014f4  e1a05000          MOV      r5,r0
;;;1178     struct tcp_seg *cseg;
;;;1179   
;;;1180     cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
0014f8  e3a00003          MOV      r0,#3
0014fc  ebfffffe          BL       memp_malloc
001500  e1b04000          MOVS     r4,r0
;;;1181     if (cseg == NULL) {
;;;1182       return NULL;
;;;1183     }
;;;1184     SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
;;;1185     pbuf_ref(cseg->p);
;;;1186     return cseg;
;;;1187   }
001504  08bd8070          POPEQ    {r4-r6,pc}
001508  e3a02014          MOV      r2,#0x14              ;1184
00150c  e1a01005          MOV      r1,r5                 ;1184
001510  ebfffffe          BL       __aeabi_memcpy4
001514  e5940004          LDR      r0,[r4,#4]            ;1185
001518  ebfffffe          BL       pbuf_ref
00151c  e1a00004          MOV      r0,r4                 ;1186
001520  e8bd8070          POP      {r4-r6,pc}
;;;1188   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

                  tcp_alloc PROC
;;;1276   struct tcp_pcb *
;;;1277   tcp_alloc(u8_t prio)
001524  e92d41f0          PUSH     {r4-r8,lr}
;;;1278   {
001528  e1a05000          MOV      r5,r0
;;;1279     struct tcp_pcb *pcb;
;;;1280     u32_t iss;
;;;1281     
;;;1282     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
00152c  e3a00001          MOV      r0,#1
001530  ebfffffe          BL       memp_malloc
001534  e51f6058          LDR      r6,|L1.5348|
001538  e1b04000          MOVS     r4,r0
;;;1283     if (pcb == NULL) {
00153c  1a00002f          BNE      |L1.5632|
001540  e596001c          LDR      r0,[r6,#0x1c]  ; tcp_tw_pcbs
001544  e596c00c          LDR      r12,[r6,#0xc]
001548  e3a03000          MOV      r3,#0
00154c  e1a02003          MOV      r2,r3
                  |L1.5456|
001550  e3500000          CMP      r0,#0
001554  0a000006          BEQ      |L1.5492|
001558  e5901024          LDR      r1,[r0,#0x24]
00155c  e04c1001          SUB      r1,r12,r1
001560  e1510003          CMP      r1,r3
001564  21a02000          MOVCS    r2,r0
001568  e590000c          LDR      r0,[r0,#0xc]
00156c  21a03001          MOVCS    r3,r1
001570  eafffff6          B        |L1.5456|
                  |L1.5492|
001574  e3520000          CMP      r2,#0
001578  11a00002          MOVNE    r0,r2
00157c  13a01001          MOVNE    r1,#1
001580  1bfffffe          BLNE     tcp_abandon
;;;1284       /* Try killing oldest connection in TIME-WAIT. */
;;;1285       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
;;;1286       tcp_kill_timewait();
;;;1287       /* Try to allocate a tcp_pcb again. */
;;;1288       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
001584  e3a00001          MOV      r0,#1
001588  ebfffffe          BL       memp_malloc
00158c  e1b04000          MOVS     r4,r0
;;;1289       if (pcb == NULL) {
001590  1a00001a          BNE      |L1.5632|
001594  e3a04000          MOV      r4,#0
001598  e5960018          LDR      r0,[r6,#0x18]  ; tcp_active_pcbs
00159c  e596700c          LDR      r7,[r6,#0xc]
0015a0  e3a0c07f          MOV      r12,#0x7f
0015a4  e1a03004          MOV      r3,r4
;;;1290         /* Try killing active connections with lower priority than the new one. */
;;;1291         LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
;;;1292         tcp_kill_prio(prio);
0015a8  ea00000a          B        |L1.5592|
                  |L1.5548|
0015ac  e5d01019          LDRB     r1,[r0,#0x19]
0015b0  e1510005          CMP      r1,r5
0015b4  9151000c          CMPLS    r1,r12
0015b8  8a000005          BHI      |L1.5588|
0015bc  e5902024          LDR      r2,[r0,#0x24]
0015c0  e0472002          SUB      r2,r7,r2
0015c4  e1540002          CMP      r4,r2
0015c8  91a04002          MOVLS    r4,r2
0015cc  91a03000          MOVLS    r3,r0
0015d0  91a0c001          MOVLS    r12,r1
                  |L1.5588|
0015d4  e590000c          LDR      r0,[r0,#0xc]
                  |L1.5592|
0015d8  e3500000          CMP      r0,#0
0015dc  1afffff2          BNE      |L1.5548|
0015e0  e3530000          CMP      r3,#0
0015e4  11a00003          MOVNE    r0,r3
0015e8  13a01001          MOVNE    r1,#1
0015ec  1bfffffe          BLNE     tcp_abandon
;;;1293         /* Try to allocate a tcp_pcb again. */
;;;1294         pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
0015f0  e3a00001          MOV      r0,#1
0015f4  ebfffffe          BL       memp_malloc
0015f8  e1b04000          MOVS     r4,r0
;;;1295         if (pcb != NULL) {
0015fc  0a000025          BEQ      |L1.5784|
                  |L1.5632|
;;;1296           /* adjust err stats: memp_malloc failed twice before */
;;;1297           MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1298         }
;;;1299       }
;;;1300       if (pcb != NULL) {
;;;1301         /* adjust err stats: timewait PCB was freed above */
;;;1302         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1303       }
;;;1304     }
;;;1305     if (pcb != NULL) {
;;;1306       memset(pcb, 0, sizeof(struct tcp_pcb));
001600  e3a01098          MOV      r1,#0x98
001604  ebfffffe          BL       __aeabi_memclr4
;;;1307       pcb->prio = prio;
;;;1308       pcb->snd_buf = TCP_SND_BUF;
001608  e3a00e7d          MOV      r0,#0x7d0
00160c  e5c45019          STRB     r5,[r4,#0x19]         ;1307
001610  e1c406b6          STRH     r0,[r4,#0x66]
;;;1309       pcb->snd_queuelen = 0;
001614  e3a03000          MOV      r3,#0
;;;1310       pcb->rcv_wnd = TCP_WND;
001618  e3a00efa          MOV      r0,#0xfa0
00161c  e1c436b8          STRH     r3,[r4,#0x68]         ;1309
001620  e1c402bc          STRH     r0,[r4,#0x2c]
;;;1311       pcb->rcv_ann_wnd = TCP_WND;
001624  e1c402be          STRH     r0,[r4,#0x2e]
;;;1312       pcb->tos = 0;
;;;1313       pcb->ttl = TCP_TTL;
001628  e3a000ff          MOV      r0,#0xff
00162c  e5c43009          STRB     r3,[r4,#9]            ;1312
001630  e5c4000a          STRB     r0,[r4,#0xa]
;;;1314       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1315          The send MSS is updated when an MSS option is received. */
;;;1316       pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
001634  e3a00f86          MOV      r0,#0x218
001638  e1c403b6          STRH     r0,[r4,#0x36]
;;;1317       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
00163c  e3a00006          MOV      r0,#6
001640  e1c404b4          STRH     r0,[r4,#0x44]
;;;1318       pcb->sa = 0;
001644  e1c434b0          STRH     r3,[r4,#0x40]
;;;1319       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
001648  e1c404b2          STRH     r0,[r4,#0x42]
;;;1320       pcb->rtime = -1;
00164c  e3e00000          MVN      r0,#0
001650  e1c403b4          STRH     r0,[r4,#0x34]
;;;1321       pcb->cwnd = 1;
001654  e3a00001          MOV      r0,#1
001658  e1c404bc          STRH     r0,[r4,#0x4c]
;;;1322       iss = tcp_next_iss();
00165c  ebfffffe          BL       tcp_next_iss
;;;1323       pcb->snd_wl2 = iss;
;;;1324       pcb->snd_nxt = iss;
001660  e5840058          STR      r0,[r4,#0x58]
;;;1325       pcb->lastack = iss;
001664  e5840050          STR      r0,[r4,#0x50]
;;;1326       pcb->snd_lbb = iss;   
001668  e5840048          STR      r0,[r4,#0x48]
;;;1327       pcb->tmr = tcp_ticks;
00166c  e584005c          STR      r0,[r4,#0x5c]
001670  e596000c          LDR      r0,[r6,#0xc]  ; tcp_ticks
001674  e5840024          STR      r0,[r4,#0x24]
;;;1328       pcb->last_timer = tcp_timer_ctr;
001678  e5d60002          LDRB     r0,[r6,#2]  ; tcp_timer_ctr
00167c  e5c40021          STRB     r0,[r4,#0x21]
;;;1329   
;;;1330       pcb->polltmr = 0;
;;;1331   
;;;1332   #if LWIP_CALLBACK_API
;;;1333       pcb->recv = tcp_recv_null;
001680  e59f0114          LDR      r0,|L1.6044|
001684  e5c4301f          STRB     r3,[r4,#0x1f]         ;1330
001688  e5840080          STR      r0,[r4,#0x80]
;;;1334   #endif /* LWIP_CALLBACK_API */  
;;;1335       
;;;1336       /* Init KEEPALIVE timer */
;;;1337       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
00168c  e59f010c          LDR      r0,|L1.6048|
001690  e5840090          STR      r0,[r4,#0x90]
;;;1338       
;;;1339   #if LWIP_TCP_KEEPALIVE
;;;1340       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1341       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1342   #endif /* LWIP_TCP_KEEPALIVE */
;;;1343   
;;;1344       pcb->keep_cnt_sent = 0;
001694  e5c43096          STRB     r3,[r4,#0x96]
                  |L1.5784|
;;;1345     }
;;;1346     return pcb;
001698  e1a00004          MOV      r0,r4
;;;1347   }
00169c  e8bd81f0          POP      {r4-r8,pc}
;;;1348   
                          ENDP

                  tcp_new PROC
;;;1361   struct tcp_pcb *
;;;1362   tcp_new(void)
0016a0  e3a00040          MOV      r0,#0x40
;;;1363   {
;;;1364     return tcp_alloc(TCP_PRIO_NORMAL);
0016a4  eafffffe          B        tcp_alloc
;;;1365   }
;;;1366   
                          ENDP

                  tcp_arg PROC
;;;1374   void
;;;1375   tcp_arg(struct tcp_pcb *pcb, void *arg)
0016a8  e5801010          STR      r1,[r0,#0x10]
;;;1376   {
;;;1377     /* This function is allowed to be called for both listen pcbs and
;;;1378        connection pcbs. */
;;;1379     pcb->callback_arg = arg;
;;;1380   }
0016ac  e12fff1e          BX       lr
;;;1381   #if LWIP_CALLBACK_API
                          ENDP

                  tcp_recv PROC
;;;1390   void
;;;1391   tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
0016b0  e92d4070          PUSH     {r4-r6,lr}
;;;1392   {
0016b4  e1a04000          MOV      r4,r0
;;;1393     LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
0016b8  e5d00018          LDRB     r0,[r0,#0x18]
0016bc  e1a05001          MOV      r5,r1                 ;1392
0016c0  e3500001          CMP      r0,#1
0016c4  1a000004          BNE      |L1.5852|
0016c8  e51f3c64          LDR      r3,|L1.2668|
0016cc  e59f20d0          LDR      r2,|L1.6052|
0016d0  e51f0c50          LDR      r0,|L1.2696|
0016d4  e28f10cc          ADR      r1,|L1.6056|
0016d8  ebfffffe          BL       sysprintf
                  |L1.5852|
;;;1394     pcb->recv = recv;
0016dc  e5845080          STR      r5,[r4,#0x80]
;;;1395   }
0016e0  e8bd8070          POP      {r4-r6,pc}
;;;1396   
                          ENDP

                  tcp_sent PROC
;;;1404   void
;;;1405   tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
0016e4  e92d4070          PUSH     {r4-r6,lr}
;;;1406   {
0016e8  e1a04000          MOV      r4,r0
;;;1407     LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
0016ec  e5d00018          LDRB     r0,[r0,#0x18]
0016f0  e1a05001          MOV      r5,r1                 ;1406
0016f4  e3500001          CMP      r0,#1
0016f8  1a000004          BNE      |L1.5904|
0016fc  e51f3c98          LDR      r3,|L1.2668|
001700  e59f20c8          LDR      r2,|L1.6096|
001704  e51f0c84          LDR      r0,|L1.2696|
001708  e28f10c4          ADR      r1,|L1.6100|
00170c  ebfffffe          BL       sysprintf
                  |L1.5904|
;;;1408     pcb->sent = sent;
001710  e584507c          STR      r5,[r4,#0x7c]
;;;1409   }
001714  e8bd8070          POP      {r4-r6,pc}
;;;1410   
                          ENDP

                  tcp_err PROC
;;;1419   void
;;;1420   tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
001718  e92d4070          PUSH     {r4-r6,lr}
;;;1421   {
00171c  e1a04000          MOV      r4,r0
;;;1422     LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
001720  e5d00018          LDRB     r0,[r0,#0x18]
001724  e1a05001          MOV      r5,r1                 ;1421
001728  e3500001          CMP      r0,#1
00172c  1a000004          BNE      |L1.5956|
001730  e51f3ccc          LDR      r3,|L1.2668|
001734  e59f20c0          LDR      r2,|L1.6140|
001738  e51f0cb8          LDR      r0,|L1.2696|
00173c  e28f10bc          ADR      r1,|L1.6144|
001740  ebfffffe          BL       sysprintf
                  |L1.5956|
;;;1423     pcb->errf = err;
001744  e584508c          STR      r5,[r4,#0x8c]
;;;1424   }
001748  e8bd8070          POP      {r4-r6,pc}
;;;1425   
                          ENDP

                  tcp_accept PROC
;;;1434   void
;;;1435   tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
00174c  e5801014          STR      r1,[r0,#0x14]
;;;1436   {
;;;1437     /* This function is allowed to be called for both listen pcbs and
;;;1438        connection pcbs. */
;;;1439     pcb->accept = accept;
;;;1440   }
001750  e12fff1e          BX       lr
;;;1441   #endif /* LWIP_CALLBACK_API */
                          ENDP

                  tcp_poll PROC
;;;1450   void
;;;1451   tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
001754  e92d4070          PUSH     {r4-r6,lr}
;;;1452   {
001758  e1a04000          MOV      r4,r0
;;;1453     LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
00175c  e5d00018          LDRB     r0,[r0,#0x18]
001760  e1a05002          MOV      r5,r2                 ;1452
001764  e1a06001          MOV      r6,r1                 ;1452
001768  e3500001          CMP      r0,#1
00176c  1a000004          BNE      |L1.6020|
001770  e51f3d0c          LDR      r3,|L1.2668|
001774  e59f20ac          LDR      r2,|L1.6184|
001778  e51f0cf8          LDR      r0,|L1.2696|
00177c  e28f10a8          ADR      r1,|L1.6188|
001780  ebfffffe          BL       sysprintf
                  |L1.6020|
;;;1454   #if LWIP_CALLBACK_API
;;;1455     pcb->poll = poll;
001784  e5846088          STR      r6,[r4,#0x88]
;;;1456   #else /* LWIP_CALLBACK_API */  
;;;1457     LWIP_UNUSED_ARG(poll);
;;;1458   #endif /* LWIP_CALLBACK_API */  
;;;1459     pcb->pollinterval = interval;
001788  e5c45020          STRB     r5,[r4,#0x20]
;;;1460   }
00178c  e8bd8070          POP      {r4-r6,pc}
;;;1461   
                          ENDP

                  tcp_debug_state_str PROC
;;;1603   const char*
;;;1604   tcp_debug_state_str(enum tcp_state s)
001790  e59f10b4          LDR      r1,|L1.6220|
;;;1605   {
;;;1606     return tcp_state_str[s];
001794  e7910100          LDR      r0,[r1,r0,LSL #2]
;;;1607   }
001798  e12fff1e          BX       lr
;;;1608   
                          ENDP

                  |L1.6044|
                          DCD      tcp_recv_null
                  |L1.6048|
                          DCD      0x006ddd00
                  |L1.6052|
                          DCD      0x00000571
                  |L1.6056|
0017a8  696e7661          DCB      "invalid socket state for recv callback",0
0017ac  6c696420
0017b0  736f636b
0017b4  65742073
0017b8  74617465
0017bc  20666f72
0017c0  20726563
0017c4  76206361
0017c8  6c6c6261
0017cc  636b00  
0017cf  00                DCB      0
                  |L1.6096|
                          DCD      0x0000057f
                  |L1.6100|
0017d4  696e7661          DCB      "invalid socket state for sent callback",0
0017d8  6c696420
0017dc  736f636b
0017e0  65742073
0017e4  74617465
0017e8  20666f72
0017ec  2073656e
0017f0  74206361
0017f4  6c6c6261
0017f8  636b00  
0017fb  00                DCB      0
                  |L1.6140|
                          DCD      0x0000058e
                  |L1.6144|
001800  696e7661          DCB      "invalid socket state for err callback",0
001804  6c696420
001808  736f636b
00180c  65742073
001810  74617465
001814  20666f72
001818  20657272
00181c  2063616c
001820  6c626163
001824  6b00    
001826  00                DCB      0
001827  00                DCB      0
                  |L1.6184|
                          DCD      0x000005ad
                  |L1.6188|
00182c  696e7661          DCB      "invalid socket state for poll",0
001830  6c696420
001834  736f636b
001838  65742073
00183c  74617465
001840  20666f72
001844  20706f6c
001848  6c00    
00184a  00                DCB      0
00184b  00                DCB      0
                  |L1.6220|
                          DCD      ||.constdata||+0x8

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  tcp_persist_backoff
000000  03060c18          DCB      0x03,0x06,0x0c,0x18
000004  30607800          DCB      0x30,0x60,0x78,0x00
                  tcp_state_str
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x34
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x4c
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x6c
                  tcp_backoff
000034  01020304          DCB      0x01,0x02,0x03,0x04
000038  05060707          DCB      0x05,0x06,0x07,0x07
00003c  07070707          DCB      0x07,0x07,0x07,0x07
000040  07000000          DCB      0x07,0x00,0x00,0x00
                  tcp_pcb_lists
                          DCD      tcp_listen_pcbs
                          DCD      tcp_bound_pcbs
                          DCD      tcp_active_pcbs
                          DCD      tcp_tw_pcbs

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  434c4f53          DCB      "CLOSED",0
000004  454400  
000007  00                DCB      0
000008  4c495354          DCB      "LISTEN",0
00000c  454e00  
00000f  00                DCB      0
000010  53594e5f          DCB      "SYN_SENT",0
000014  53454e54
000018  00      
000019  00                DCB      0
00001a  00                DCB      0
00001b  00                DCB      0
00001c  53594e5f          DCB      "SYN_RCVD",0
000020  52435644
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
000028  45535441          DCB      "ESTABLISHED",0
00002c  424c4953
000030  48454400
000034  46494e5f          DCB      "FIN_WAIT_1",0
000038  57414954
00003c  5f3100  
00003f  00                DCB      0
000040  46494e5f          DCB      "FIN_WAIT_2",0
000044  57414954
000048  5f3200  
00004b  00                DCB      0
00004c  434c4f53          DCB      "CLOSE_WAIT",0
000050  455f5741
000054  495400  
000057  00                DCB      0
000058  434c4f53          DCB      "CLOSING",0
00005c  494e4700
000060  4c415354          DCB      "LAST_ACK",0
000064  5f41434b
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  54494d45          DCB      "TIME_WAIT",0
000070  5f574149
000074  5400    

                          AREA ||.data||, DATA, ALIGN=2

                  tcp_active_pcbs_changed
000000  00                DCB      0x00
                  tcp_timer
000001  00                DCB      0x00
                  tcp_timer_ctr
000002  0000              DCB      0x00,0x00
                  tcp_port
000004  c000              DCW      0xc000
000006  0000              DCB      0x00,0x00
                  iss
                          DCD      0x0000196e
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000
                  tcp_tmp_pcb
                          DCD      0x00000000
