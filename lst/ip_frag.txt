; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\ip_frag.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ip_frag.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\ip_frag.crf lwip-1.4.1\src\core\ipv4\ip_frag.c]
                          ARM

                          AREA ||i.ip_reass||, CODE, READONLY, ALIGN=2

                  ip_reass PROC
;;;475    struct pbuf *
;;;476    ip_reass(struct pbuf *p)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;477    {
000004  e1a08000          MOV      r8,r0
;;;478      struct pbuf *r;
;;;479      struct ip_hdr *fraghdr;
;;;480      struct ip_reassdata *ipr;
;;;481      struct ip_reass_helper *iprh;
;;;482      u16_t offset, len;
;;;483      u8_t clen;
;;;484      struct ip_reassdata *ipr_prev = NULL;
000008  e3a00000          MOV      r0,#0
00000c  e58d0000          STR      r0,[sp,#0]
;;;485    
;;;486      IPFRAG_STATS_INC(ip_frag.recv);
;;;487      snmp_inc_ipreasmreqds();
;;;488    
;;;489      fraghdr = (struct ip_hdr*)p->payload;
000010  e5985004          LDR      r5,[r8,#4]
;;;490    
;;;491      if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
000014  e5d50000          LDRB     r0,[r5,#0]
000018  e200000f          AND      r0,r0,#0xf
00001c  e3a01014          MOV      r1,#0x14
000020  e1510100          CMP      r1,r0,LSL #2
000024  0a000000          BEQ      |L1.44|
;;;492        LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
;;;493        IPFRAG_STATS_INC(ip_frag.err);
;;;494        goto nullreturn;
000028  ea0000a8          B        |L1.720|
                  |L1.44|
;;;495      }
;;;496    
;;;497      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
00002c  e5d51007          LDRB     r1,[r5,#7]
000030  e5d52006          LDRB     r2,[r5,#6]
000034  e1820401          ORR      r0,r2,r1,LSL #8
000038  ebfffffe          BL       lwip_ntohs
00003c  e3c00a0e          BIC      r0,r0,#0xe000
000040  e59f129c          LDR      r1,|L1.740|
000044  e001a180          AND      r10,r1,r0,LSL #3
;;;498      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000048  e5d51003          LDRB     r1,[r5,#3]
00004c  e5d52002          LDRB     r2,[r5,#2]
000050  e1820401          ORR      r0,r2,r1,LSL #8
000054  ebfffffe          BL       lwip_ntohs
000058  e5d51000          LDRB     r1,[r5,#0]
00005c  e201100f          AND      r1,r1,#0xf
000060  e0400101          SUB      r0,r0,r1,LSL #2
000064  e1a0b800          LSL      r11,r0,#16
000068  e1a0b82b          LSR      r11,r11,#16
;;;499    
;;;500      /* Check if we are allowed to enqueue more datagrams. */
;;;501      clen = pbuf_clen(p);
00006c  e1a00008          MOV      r0,r8
000070  ebfffffe          BL       pbuf_clen
000074  e1a06000          MOV      r6,r0
;;;502      if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
000078  e59f0268          LDR      r0,|L1.744|
00007c  e1d010b0          LDRH     r1,[r0,#0]  ; ip_reass_pbufcount
000080  e0810006          ADD      r0,r1,r6
000084  e3500004          CMP      r0,#4
000088  da00000a          BLE      |L1.184|
;;;503    #if IP_REASS_FREE_OLDEST
;;;504        if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
00008c  e1a01006          MOV      r1,r6
000090  e1a00005          MOV      r0,r5
000094  ebfffffe          BL       ip_reass_remove_oldest_datagram
000098  e3500000          CMP      r0,#0
00009c  0a000004          BEQ      |L1.180|
;;;505            ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
0000a0  e59f0240          LDR      r0,|L1.744|
0000a4  e1d000b0          LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
0000a8  e0800006          ADD      r0,r0,r6
0000ac  e3500004          CMP      r0,#4
0000b0  da000000          BLE      |L1.184|
                  |L1.180|
;;;506    #endif /* IP_REASS_FREE_OLDEST */
;;;507        {
;;;508          /* No datagram could be freed and still too many pbufs enqueued */
;;;509          LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
;;;510            ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
;;;511          IPFRAG_STATS_INC(ip_frag.memerr);
;;;512          /* @todo: send ICMP time exceeded here? */
;;;513          /* drop this pbuf */
;;;514          goto nullreturn;
0000b4  ea000085          B        |L1.720|
                  |L1.184|
;;;515        }
;;;516      }
;;;517    
;;;518      /* Look for the datagram the fragment belongs to in the current datagram queue,
;;;519       * remembering the previous in the queue for later dequeueing. */
;;;520      for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
0000b8  e59f022c          LDR      r0,|L1.748|
0000bc  e5904000          LDR      r4,[r0,#0]  ; reassdatagrams
0000c0  ea000017          B        |L1.292|
                  |L1.196|
;;;521        /* Check if the incoming fragment matches the one currently present
;;;522           in the reassembly buffer. If so, we proceed with copying the
;;;523           fragment into the buffer. */
;;;524        if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
0000c4  e285000c          ADD      r0,r5,#0xc
0000c8  ebfffffe          BL       __aeabi_uread4
0000cc  e5941014          LDR      r1,[r4,#0x14]
0000d0  e1500001          CMP      r0,r1
0000d4  1a00000c          BNE      |L1.268|
0000d8  e2850010          ADD      r0,r5,#0x10
0000dc  ebfffffe          BL       __aeabi_uread4
0000e0  e5941018          LDR      r1,[r4,#0x18]
0000e4  e1500001          CMP      r0,r1
0000e8  1a000007          BNE      |L1.268|
0000ec  e1d400bc          LDRH     r0,[r4,#0xc]
0000f0  e5d51005          LDRB     r1,[r5,#5]
0000f4  e5d52004          LDRB     r2,[r5,#4]
0000f8  e1821401          ORR      r1,r2,r1,LSL #8
0000fc  e1500001          CMP      r0,r1
000100  1a000001          BNE      |L1.268|
000104  e3a00001          MOV      r0,#1
000108  ea000000          B        |L1.272|
                  |L1.268|
00010c  e3a00000          MOV      r0,#0
                  |L1.272|
000110  e3500000          CMP      r0,#0
000114  0a000000          BEQ      |L1.284|
;;;525          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
;;;526            ntohs(IPH_ID(fraghdr))));
;;;527          IPFRAG_STATS_INC(ip_frag.cachehit);
;;;528          break;
000118  ea000003          B        |L1.300|
                  |L1.284|
;;;529        }
;;;530        ipr_prev = ipr;
00011c  e58d4000          STR      r4,[sp,#0]
000120  e5944000          LDR      r4,[r4,#0]            ;520
                  |L1.292|
000124  e3540000          CMP      r4,#0                 ;520
000128  1affffe5          BNE      |L1.196|
                  |L1.300|
00012c  e1a00000          MOV      r0,r0                 ;528
;;;531      }
;;;532    
;;;533      if (ipr == NULL) {
000130  e3540000          CMP      r4,#0
000134  1a000006          BNE      |L1.340|
;;;534      /* Enqueue a new datagram into the datagram queue */
;;;535        ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
000138  e1a01006          MOV      r1,r6
00013c  e1a00005          MOV      r0,r5
000140  ebfffffe          BL       ip_reass_enqueue_new_datagram
000144  e1a04000          MOV      r4,r0
;;;536        /* Bail if unable to enqueue */
;;;537        if(ipr == NULL) {
000148  e3540000          CMP      r4,#0
00014c  1a000010          BNE      |L1.404|
;;;538          goto nullreturn;
000150  ea00005e          B        |L1.720|
                  |L1.340|
;;;539        }
;;;540      } else {
;;;541        if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
000154  e5d51007          LDRB     r1,[r5,#7]
000158  e5d52006          LDRB     r2,[r5,#6]
00015c  e1820401          ORR      r0,r2,r1,LSL #8
000160  ebfffffe          BL       lwip_ntohs
000164  e3c00a0e          BIC      r0,r0,#0xe000
000168  e3500000          CMP      r0,#0
00016c  1a000008          BNE      |L1.404|
;;;542          ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
000170  e1d400be          LDRH     r0,[r4,#0xe]
000174  ebfffffe          BL       lwip_ntohs
000178  e3c00a0e          BIC      r0,r0,#0xe000
00017c  e3500000          CMP      r0,#0
000180  0a000003          BEQ      |L1.404|
;;;543          /* ipr->iphdr is not the header from the first fragment, but fraghdr is
;;;544           * -> copy fraghdr into ipr->iphdr since we want to have the header
;;;545           * of the first fragment (for ICMP time exceeded and later, for copying
;;;546           * all options, if supported)*/
;;;547          SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
000184  e3a02014          MOV      r2,#0x14
000188  e1a01005          MOV      r1,r5
00018c  e2840008          ADD      r0,r4,#8
000190  ebfffffe          BL       __aeabi_memcpy
                  |L1.404|
;;;548        }
;;;549      }
;;;550      /* Track the current number of pbufs current 'in-flight', in order to limit 
;;;551      the number of fragments that may be enqueued at any one time */
;;;552      ip_reass_pbufcount += clen;
000194  e59f014c          LDR      r0,|L1.744|
000198  e1d000b0          LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
00019c  e0800006          ADD      r0,r0,r6
0001a0  e59f1140          LDR      r1,|L1.744|
0001a4  e1c100b0          STRH     r0,[r1,#0]  ; ip_reass_pbufcount
;;;553    
;;;554      /* At this point, we have either created a new entry or pointing 
;;;555       * to an existing one */
;;;556    
;;;557      /* check for 'no more fragments', and update queue entry*/
;;;558      if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
0001a8  e5d50007          LDRB     r0,[r5,#7]
0001ac  e5d51006          LDRB     r1,[r5,#6]
0001b0  e1810400          ORR      r0,r1,r0,LSL #8
0001b4  e2000020          AND      r0,r0,#0x20
0001b8  e3500000          CMP      r0,#0
0001bc  1a000004          BNE      |L1.468|
;;;559        ipr->flags |= IP_REASS_FLAG_LASTFRAG;
0001c0  e5d4001e          LDRB     r0,[r4,#0x1e]
0001c4  e3800001          ORR      r0,r0,#1
0001c8  e5c4001e          STRB     r0,[r4,#0x1e]
;;;560        ipr->datagram_len = offset + len;
0001cc  e08a000b          ADD      r0,r10,r11
0001d0  e1c401bc          STRH     r0,[r4,#0x1c]
                  |L1.468|
;;;561        LWIP_DEBUGF(IP_REASS_DEBUG,
;;;562         ("ip_reass: last fragment seen, total len %"S16_F"\n",
;;;563          ipr->datagram_len));
;;;564      }
;;;565      /* find the right place to insert this pbuf */
;;;566      /* @todo: trim pbufs if fragments are overlapping */
;;;567      if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
0001d4  e1a01008          MOV      r1,r8
0001d8  e1a00004          MOV      r0,r4
0001dc  ebfffffe          BL       ip_reass_chain_frag_into_datagram_and_validate
0001e0  e3500000          CMP      r0,#0
0001e4  0a000037          BEQ      |L1.712|
;;;568        /* the totally last fragment (flag more fragments = 0) was received at least
;;;569         * once AND all fragments are received */
;;;570        ipr->datagram_len += IP_HLEN;
0001e8  e1d401bc          LDRH     r0,[r4,#0x1c]
0001ec  e2800014          ADD      r0,r0,#0x14
0001f0  e3c00801          BIC      r0,r0,#0x10000
0001f4  e1c401bc          STRH     r0,[r4,#0x1c]
;;;571    
;;;572        /* save the second pbuf before copying the header over the pointer */
;;;573        r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
0001f8  e5941004          LDR      r1,[r4,#4]
0001fc  e5910004          LDR      r0,[r1,#4]
000200  ebfffffe          BL       __aeabi_uread4
000204  e1a07000          MOV      r7,r0
;;;574    
;;;575        /* copy the original ip header back to the first pbuf */
;;;576        fraghdr = (struct ip_hdr*)(ipr->p->payload);
000208  e5940004          LDR      r0,[r4,#4]
00020c  e5905004          LDR      r5,[r0,#4]
;;;577        SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
000210  e3a02014          MOV      r2,#0x14
000214  e2841008          ADD      r1,r4,#8
000218  e1a00005          MOV      r0,r5
00021c  ebfffffe          BL       __aeabi_memcpy
;;;578        IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
000220  e1d401bc          LDRH     r0,[r4,#0x1c]
000224  ebfffffe          BL       lwip_htons
000228  e5c50002          STRB     r0,[r5,#2]
00022c  e1a00420          LSR      r0,r0,#8
000230  e5c50003          STRB     r0,[r5,#3]
;;;579        IPH_OFFSET_SET(fraghdr, 0);
000234  e3a00000          MOV      r0,#0
000238  e5c50006          STRB     r0,[r5,#6]
00023c  e5c50007          STRB     r0,[r5,#7]
;;;580        IPH_CHKSUM_SET(fraghdr, 0);
000240  e5c5000a          STRB     r0,[r5,#0xa]
000244  e5c5000b          STRB     r0,[r5,#0xb]
;;;581        /* @todo: do we need to set calculate the correct checksum? */
;;;582        IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
000248  e3a01014          MOV      r1,#0x14
00024c  e1a00005          MOV      r0,r5
000250  ebfffffe          BL       inet_chksum
000254  e5c5000a          STRB     r0,[r5,#0xa]
000258  e1a00420          LSR      r0,r0,#8
00025c  e5c5000b          STRB     r0,[r5,#0xb]
;;;583    
;;;584        p = ipr->p;
000260  e5948004          LDR      r8,[r4,#4]
;;;585    
;;;586        /* chain together the pbufs contained within the reass_data list. */
;;;587        while(r != NULL) {
000264  ea000009          B        |L1.656|
                  |L1.616|
;;;588          iprh = (struct ip_reass_helper*)r->payload;
000268  e5979004          LDR      r9,[r7,#4]
;;;589    
;;;590          /* hide the ip header for every succeding fragment */
;;;591          pbuf_header(r, -IP_HLEN);
00026c  e3e01013          MVN      r1,#0x13
000270  e1a00007          MOV      r0,r7
000274  ebfffffe          BL       pbuf_header
;;;592          pbuf_cat(p, r);
000278  e1a01007          MOV      r1,r7
00027c  e1a00008          MOV      r0,r8
000280  ebfffffe          BL       pbuf_cat
;;;593          r = iprh->next_pbuf;
000284  e1a00009          MOV      r0,r9
000288  ebfffffe          BL       __aeabi_uread4
00028c  e1a07000          MOV      r7,r0
                  |L1.656|
000290  e3570000          CMP      r7,#0                 ;587
000294  1afffff3          BNE      |L1.616|
;;;594        }
;;;595        /* release the sources allocate for the fragment queue entry */
;;;596        ip_reass_dequeue_datagram(ipr, ipr_prev);
000298  e1a00004          MOV      r0,r4
00029c  e59d1000          LDR      r1,[sp,#0]
0002a0  ebfffffe          BL       ip_reass_dequeue_datagram
;;;597    
;;;598        /* and adjust the number of pbufs currently queued for reassembly. */
;;;599        ip_reass_pbufcount -= pbuf_clen(p);
0002a4  e1a00008          MOV      r0,r8
0002a8  ebfffffe          BL       pbuf_clen
0002ac  e59f1034          LDR      r1,|L1.744|
0002b0  e1d110b0          LDRH     r1,[r1,#0]  ; ip_reass_pbufcount
0002b4  e0410000          SUB      r0,r1,r0
0002b8  e59f1028          LDR      r1,|L1.744|
0002bc  e1c100b0          STRH     r0,[r1,#0]  ; ip_reass_pbufcount
;;;600    
;;;601        /* Return the pbuf chain */
;;;602        return p;
0002c0  e1a00008          MOV      r0,r8
                  |L1.708|
;;;603      }
;;;604      /* the datagram is not (yet?) reassembled completely */
;;;605      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
;;;606      return NULL;
;;;607    
;;;608    nullreturn:
;;;609      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
;;;610      IPFRAG_STATS_INC(ip_frag.drop);
;;;611      pbuf_free(p);
;;;612      return NULL;
;;;613    }
0002c4  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.712|
0002c8  e3a00000          MOV      r0,#0                 ;606
0002cc  eafffffc          B        |L1.708|
                  |L1.720|
0002d0  e1a00000          MOV      r0,r0                 ;608
0002d4  e1a00008          MOV      r0,r8                 ;611
0002d8  ebfffffe          BL       pbuf_free
0002dc  e3a00000          MOV      r0,#0                 ;612
0002e0  eafffff7          B        |L1.708|
;;;614    #endif /* IP_REASSEMBLY */
                          ENDP

                  |L1.740|
                          DCD      0x0000ffff
                  |L1.744|
                          DCD      ip_reass_pbufcount
                  |L1.748|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_chain_frag_into_datagram_and_validate||, CODE, READONLY, ALIGN=2

                  ip_reass_chain_frag_into_datagram_and_validate PROC
;;;330    static int
;;;331    ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;332    {
000004  e1a05000          MOV      r5,r0
000008  e1a09001          MOV      r9,r1
;;;333      struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
00000c  e3a06000          MOV      r6,#0
;;;334      struct pbuf *q;
;;;335      u16_t offset,len;
;;;336      struct ip_hdr *fraghdr;
;;;337      int valid = 1;
000010  e3a0b001          MOV      r11,#1
;;;338    
;;;339      /* Extract length and fragment offset from current fragment */
;;;340      fraghdr = (struct ip_hdr*)new_p->payload; 
000014  e599a004          LDR      r10,[r9,#4]
;;;341      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000018  e5da1003          LDRB     r1,[r10,#3]
00001c  e5da2002          LDRB     r2,[r10,#2]
000020  e1820401          ORR      r0,r2,r1,LSL #8
000024  ebfffffe          BL       lwip_ntohs
000028  e5da1000          LDRB     r1,[r10,#0]
00002c  e201100f          AND      r1,r1,#0xf
000030  e0400101          SUB      r0,r0,r1,LSL #2
000034  e1a00800          LSL      r0,r0,#16
000038  e1a00820          LSR      r0,r0,#16
00003c  e58d0000          STR      r0,[sp,#0]
;;;342      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
000040  e5da1007          LDRB     r1,[r10,#7]
000044  e5da2006          LDRB     r2,[r10,#6]
000048  e1820401          ORR      r0,r2,r1,LSL #8
00004c  ebfffffe          BL       lwip_ntohs
000050  e3c00a0e          BIC      r0,r0,#0xe000
000054  e06b180b          RSB      r1,r11,r11,LSL #16
000058  e0010180          AND      r0,r1,r0,LSL #3
00005c  e58d0004          STR      r0,[sp,#4]
;;;343    
;;;344      /* overwrite the fragment's ip header from the pbuf with our helper struct,
;;;345       * and setup the embedded helper structure. */
;;;346      /* make sure the struct ip_reass_helper fits into the IP header */
;;;347      LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
000060  e1a00000          MOV      r0,r0
000064  e1a00000          MOV      r0,r0
;;;348                  sizeof(struct ip_reass_helper) <= IP_HLEN);
;;;349      iprh = (struct ip_reass_helper*)new_p->payload;
000068  e5994004          LDR      r4,[r9,#4]
;;;350      iprh->next_pbuf = NULL;
00006c  e1a01004          MOV      r1,r4
000070  e3a00000          MOV      r0,#0
000074  ebfffffe          BL       __aeabi_uwrite4
;;;351      iprh->start = offset;
000078  e59d0004          LDR      r0,[sp,#4]
00007c  e5c40004          STRB     r0,[r4,#4]
000080  e1a00420          LSR      r0,r0,#8
000084  e5c40005          STRB     r0,[r4,#5]
;;;352      iprh->end = offset + len;
000088  e59d0004          LDR      r0,[sp,#4]
00008c  e59d1000          LDR      r1,[sp,#0]
000090  e0800001          ADD      r0,r0,r1
000094  e1a00800          LSL      r0,r0,#16
000098  e1a00820          LSR      r0,r0,#16
00009c  e5c40006          STRB     r0,[r4,#6]
0000a0  e1a00420          LSR      r0,r0,#8
0000a4  e5c40007          STRB     r0,[r4,#7]
;;;353    
;;;354      /* Iterate through until we either get to the end of the list (append),
;;;355       * or we find on with a larger offset (insert). */
;;;356      for (q = ipr->p; q != NULL;) {
0000a8  e5958004          LDR      r8,[r5,#4]
0000ac  ea000045          B        |L2.456|
                  |L2.176|
;;;357        iprh_tmp = (struct ip_reass_helper*)q->payload;
0000b0  e5987004          LDR      r7,[r8,#4]
;;;358        if (iprh->start < iprh_tmp->start) {
0000b4  e5d40005          LDRB     r0,[r4,#5]
0000b8  e5d41004          LDRB     r1,[r4,#4]
0000bc  e1810400          ORR      r0,r1,r0,LSL #8
0000c0  e5d71005          LDRB     r1,[r7,#5]
0000c4  e5d72004          LDRB     r2,[r7,#4]
0000c8  e1821401          ORR      r1,r2,r1,LSL #8
0000cc  e1500001          CMP      r0,r1
0000d0  aa00001b          BGE      |L2.324|
;;;359          /* the new pbuf should be inserted before this */
;;;360          iprh->next_pbuf = q;
0000d4  e1a01004          MOV      r1,r4
0000d8  e1a00008          MOV      r0,r8
0000dc  ebfffffe          BL       __aeabi_uwrite4
;;;361          if (iprh_prev != NULL) {
0000e0  e3560000          CMP      r6,#0
0000e4  0a000014          BEQ      |L2.316|
;;;362            /* not the fragment with the lowest offset */
;;;363    #if IP_REASS_CHECK_OVERLAP
;;;364            if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
0000e8  e5d40005          LDRB     r0,[r4,#5]
0000ec  e5d41004          LDRB     r1,[r4,#4]
0000f0  e1810400          ORR      r0,r1,r0,LSL #8
0000f4  e5d61007          LDRB     r1,[r6,#7]
0000f8  e5d62006          LDRB     r2,[r6,#6]
0000fc  e1821401          ORR      r1,r2,r1,LSL #8
000100  e1500001          CMP      r0,r1
000104  ba000007          BLT      |L2.296|
000108  e5d40007          LDRB     r0,[r4,#7]
00010c  e5d41006          LDRB     r1,[r4,#6]
000110  e1810400          ORR      r0,r1,r0,LSL #8
000114  e5d71005          LDRB     r1,[r7,#5]
000118  e5d72004          LDRB     r2,[r7,#4]
00011c  e1821401          ORR      r1,r2,r1,LSL #8
000120  e1500001          CMP      r0,r1
000124  da000000          BLE      |L2.300|
                  |L2.296|
;;;365              /* fragment overlaps with previous or following, throw away */
;;;366              goto freepbuf;
000128  ea000100          B        |L2.1328|
                  |L2.300|
;;;367            }
;;;368    #endif /* IP_REASS_CHECK_OVERLAP */
;;;369            iprh_prev->next_pbuf = new_p;
00012c  e1a01006          MOV      r1,r6
000130  e1a00009          MOV      r0,r9
000134  ebfffffe          BL       __aeabi_uwrite4
000138  ea000000          B        |L2.320|
                  |L2.316|
;;;370          } else {
;;;371            /* fragment with the lowest offset */
;;;372            ipr->p = new_p;
00013c  e5859004          STR      r9,[r5,#4]
                  |L2.320|
;;;373          }
;;;374          break;
000140  ea000022          B        |L2.464|
                  |L2.324|
;;;375        } else if(iprh->start == iprh_tmp->start) {
000144  e5d40005          LDRB     r0,[r4,#5]
000148  e5d41004          LDRB     r1,[r4,#4]
00014c  e1810400          ORR      r0,r1,r0,LSL #8
000150  e5d71005          LDRB     r1,[r7,#5]
000154  e5d72004          LDRB     r2,[r7,#4]
000158  e1821401          ORR      r1,r2,r1,LSL #8
00015c  e1500001          CMP      r0,r1
000160  1a000000          BNE      |L2.360|
;;;376          /* received the same datagram twice: no need to keep the datagram */
;;;377          goto freepbuf;
000164  ea0000f1          B        |L2.1328|
                  |L2.360|
;;;378    #if IP_REASS_CHECK_OVERLAP
;;;379        } else if(iprh->start < iprh_tmp->end) {
000168  e5d40005          LDRB     r0,[r4,#5]
00016c  e5d41004          LDRB     r1,[r4,#4]
000170  e1810400          ORR      r0,r1,r0,LSL #8
000174  e5d71007          LDRB     r1,[r7,#7]
000178  e5d72006          LDRB     r2,[r7,#6]
00017c  e1821401          ORR      r1,r2,r1,LSL #8
000180  e1500001          CMP      r0,r1
000184  aa000000          BGE      |L2.396|
;;;380          /* overlap: no need to keep the new datagram */
;;;381          goto freepbuf;
000188  ea0000e8          B        |L2.1328|
                  |L2.396|
;;;382    #endif /* IP_REASS_CHECK_OVERLAP */
;;;383        } else {
;;;384          /* Check if the fragments received so far have no wholes. */
;;;385          if (iprh_prev != NULL) {
00018c  e3560000          CMP      r6,#0
000190  0a000008          BEQ      |L2.440|
;;;386            if (iprh_prev->end != iprh_tmp->start) {
000194  e5d60007          LDRB     r0,[r6,#7]
000198  e5d61006          LDRB     r1,[r6,#6]
00019c  e1810400          ORR      r0,r1,r0,LSL #8
0001a0  e5d71005          LDRB     r1,[r7,#5]
0001a4  e5d72004          LDRB     r2,[r7,#4]
0001a8  e1821401          ORR      r1,r2,r1,LSL #8
0001ac  e1500001          CMP      r0,r1
0001b0  0a000000          BEQ      |L2.440|
;;;387              /* There is a fragment missing between the current
;;;388               * and the previous fragment */
;;;389              valid = 0;
0001b4  e3a0b000          MOV      r11,#0
                  |L2.440|
;;;390            }
;;;391          }
;;;392        }
;;;393        q = iprh_tmp->next_pbuf;
0001b8  e1a00007          MOV      r0,r7
0001bc  ebfffffe          BL       __aeabi_uread4
0001c0  e1a08000          MOV      r8,r0
;;;394        iprh_prev = iprh_tmp;
0001c4  e1a06007          MOV      r6,r7
                  |L2.456|
0001c8  e3580000          CMP      r8,#0                 ;356
0001cc  1affffb7          BNE      |L2.176|
                  |L2.464|
0001d0  e1a00000          MOV      r0,r0                 ;374
;;;395      }
;;;396    
;;;397      /* If q is NULL, then we made it to the end of the list. Determine what to do now */
;;;398      if (q == NULL) {
0001d4  e3580000          CMP      r8,#0
0001d8  1a00002c          BNE      |L2.656|
;;;399        if (iprh_prev != NULL) {
0001dc  e3560000          CMP      r6,#0
0001e0  0a00001d          BEQ      |L2.604|
;;;400          /* this is (for now), the fragment with the highest offset:
;;;401           * chain it to the last fragment */
;;;402    #if IP_REASS_CHECK_OVERLAP
;;;403          LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
0001e4  e1a00000          MOV      r0,r0
0001e8  e5d60007          LDRB     r0,[r6,#7]
0001ec  e5d61006          LDRB     r1,[r6,#6]
0001f0  e1810400          ORR      r0,r1,r0,LSL #8
0001f4  e5d41005          LDRB     r1,[r4,#5]
0001f8  e5d42004          LDRB     r2,[r4,#4]
0001fc  e1821401          ORR      r1,r2,r1,LSL #8
000200  e1500001          CMP      r0,r1
000204  da000006          BLE      |L2.548|
000208  e1a00000          MOV      r0,r0
00020c  e28f3f7e          ADR      r3,|L2.1036|
000210  e59f2218          LDR      r2,|L2.1072|
000214  e28f1f86          ADR      r1,|L2.1076|
000218  e28f0f8d          ADR      r0,|L2.1108|
00021c  ebfffffe          BL       sysprintf
000220  e1a00000          MOV      r0,r0
                  |L2.548|
000224  e1a00000          MOV      r0,r0
;;;404    #endif /* IP_REASS_CHECK_OVERLAP */
;;;405          iprh_prev->next_pbuf = new_p;
000228  e1a01006          MOV      r1,r6
00022c  e1a00009          MOV      r0,r9
000230  ebfffffe          BL       __aeabi_uwrite4
;;;406          if (iprh_prev->end != iprh->start) {
000234  e5d60007          LDRB     r0,[r6,#7]
000238  e5d61006          LDRB     r1,[r6,#6]
00023c  e1810400          ORR      r0,r1,r0,LSL #8
000240  e5d41005          LDRB     r1,[r4,#5]
000244  e5d42004          LDRB     r2,[r4,#4]
000248  e1821401          ORR      r1,r2,r1,LSL #8
00024c  e1500001          CMP      r0,r1
000250  0a00000e          BEQ      |L2.656|
;;;407            valid = 0;
000254  e3a0b000          MOV      r11,#0
000258  ea00000c          B        |L2.656|
                  |L2.604|
;;;408          }
;;;409        } else {
;;;410    #if IP_REASS_CHECK_OVERLAP
;;;411          LWIP_ASSERT("no previous fragment, this must be the first fragment!",
00025c  e1a00000          MOV      r0,r0
000260  e5950004          LDR      r0,[r5,#4]
000264  e3500000          CMP      r0,#0
000268  0a000006          BEQ      |L2.648|
00026c  e1a00000          MOV      r0,r0
000270  e28f3f65          ADR      r3,|L2.1036|
000274  e59f2200          LDR      r2,|L2.1148|
000278  e28f1c02          ADR      r1,|L2.1152|
00027c  e28f0e1d          ADR      r0,|L2.1108|
000280  ebfffffe          BL       sysprintf
000284  e1a00000          MOV      r0,r0
                  |L2.648|
000288  e1a00000          MOV      r0,r0
;;;412            ipr->p == NULL);
;;;413    #endif /* IP_REASS_CHECK_OVERLAP */
;;;414          /* this is the first fragment we ever received for this ip datagram */
;;;415          ipr->p = new_p;
00028c  e5859004          STR      r9,[r5,#4]
                  |L2.656|
;;;416        }
;;;417      }
;;;418    
;;;419      /* At this point, the validation part begins: */
;;;420      /* If we already received the last fragment */
;;;421      if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
000290  e5d5001e          LDRB     r0,[r5,#0x1e]
000294  e2000001          AND      r0,r0,#1
000298  e3500000          CMP      r0,#0
00029c  0a0000a1          BEQ      |L2.1320|
;;;422        /* and had no wholes so far */
;;;423        if (valid) {
0002a0  e35b0000          CMP      r11,#0
0002a4  0a000056          BEQ      |L2.1028|
;;;424          /* then check if the rest of the fragments is here */
;;;425          /* Check if the queue starts with the first datagram */
;;;426          if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
0002a8  e5950004          LDR      r0,[r5,#4]
0002ac  e5901004          LDR      r1,[r0,#4]
0002b0  e5d10005          LDRB     r0,[r1,#5]
0002b4  e5d11004          LDRB     r1,[r1,#4]
0002b8  e1810400          ORR      r0,r1,r0,LSL #8
0002bc  e3500000          CMP      r0,#0
0002c0  0a000001          BEQ      |L2.716|
;;;427            valid = 0;
0002c4  e3a0b000          MOV      r11,#0
0002c8  ea00004d          B        |L2.1028|
                  |L2.716|
;;;428          } else {
;;;429            /* and check that there are no wholes after this datagram */
;;;430            iprh_prev = iprh;
0002cc  e1a06004          MOV      r6,r4
;;;431            q = iprh->next_pbuf;
0002d0  e1a00004          MOV      r0,r4
0002d4  ebfffffe          BL       __aeabi_uread4
0002d8  e1a08000          MOV      r8,r0
;;;432            while (q != NULL) {
0002dc  ea00000e          B        |L2.796|
                  |L2.736|
;;;433              iprh = (struct ip_reass_helper*)q->payload;
0002e0  e5984004          LDR      r4,[r8,#4]
;;;434              if (iprh_prev->end != iprh->start) {
0002e4  e5d60007          LDRB     r0,[r6,#7]
0002e8  e5d61006          LDRB     r1,[r6,#6]
0002ec  e1810400          ORR      r0,r1,r0,LSL #8
0002f0  e5d41005          LDRB     r1,[r4,#5]
0002f4  e5d42004          LDRB     r2,[r4,#4]
0002f8  e1821401          ORR      r1,r2,r1,LSL #8
0002fc  e1500001          CMP      r0,r1
000300  0a000001          BEQ      |L2.780|
;;;435                valid = 0;
000304  e3a0b000          MOV      r11,#0
;;;436                break;
000308  ea000005          B        |L2.804|
                  |L2.780|
;;;437              }
;;;438              iprh_prev = iprh;
00030c  e1a06004          MOV      r6,r4
;;;439              q = iprh->next_pbuf;
000310  e1a00004          MOV      r0,r4
000314  ebfffffe          BL       __aeabi_uread4
000318  e1a08000          MOV      r8,r0
                  |L2.796|
00031c  e3580000          CMP      r8,#0                 ;432
000320  1affffee          BNE      |L2.736|
                  |L2.804|
000324  e1a00000          MOV      r0,r0                 ;436
;;;440            }
;;;441            /* if still valid, all fragments are received
;;;442             * (because to the MF==0 already arrived */
;;;443            if (valid) {
000328  e35b0000          CMP      r11,#0
00032c  0a000034          BEQ      |L2.1028|
;;;444              LWIP_ASSERT("sanity check", ipr->p != NULL);
000330  e1a00000          MOV      r0,r0
000334  e5950004          LDR      r0,[r5,#4]
000338  e3500000          CMP      r0,#0
00033c  1a000006          BNE      |L2.860|
000340  e1a00000          MOV      r0,r0
000344  e28f30c0          ADR      r3,|L2.1036|
000348  e3a02f6f          MOV      r2,#0x1bc
00034c  e28f1f59          ADR      r1,|L2.1208|
000350  e28f00fc          ADR      r0,|L2.1108|
000354  ebfffffe          BL       sysprintf
000358  e1a00000          MOV      r0,r0
                  |L2.860|
00035c  e1a00000          MOV      r0,r0
;;;445              LWIP_ASSERT("sanity check",
000360  e1a00000          MOV      r0,r0
000364  e5950004          LDR      r0,[r5,#4]
000368  e5900004          LDR      r0,[r0,#4]
00036c  e1500004          CMP      r0,r4
000370  1a000006          BNE      |L2.912|
000374  e1a00000          MOV      r0,r0
000378  e28f308c          ADR      r3,|L2.1036|
00037c  e59f2144          LDR      r2,|L2.1224|
000380  e28f1e13          ADR      r1,|L2.1208|
000384  e28f00c8          ADR      r0,|L2.1108|
000388  ebfffffe          BL       sysprintf
00038c  e1a00000          MOV      r0,r0
                  |L2.912|
000390  e1a00000          MOV      r0,r0
;;;446                ((struct ip_reass_helper*)ipr->p->payload) != iprh);
;;;447              LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
000394  e1a00000          MOV      r0,r0
000398  e1a00004          MOV      r0,r4
00039c  ebfffffe          BL       __aeabi_uread4
0003a0  e3500000          CMP      r0,#0
0003a4  0a000006          BEQ      |L2.964|
0003a8  e1a00000          MOV      r0,r0
0003ac  e28f3058          ADR      r3,|L2.1036|
0003b0  e59f2114          LDR      r2,|L2.1228|
0003b4  e28f1f45          ADR      r1,|L2.1232|
0003b8  e28f0094          ADR      r0,|L2.1108|
0003bc  ebfffffe          BL       sysprintf
0003c0  e1a00000          MOV      r0,r0
                  |L2.964|
0003c4  e1a00000          MOV      r0,r0
;;;448                iprh->next_pbuf == NULL);
;;;449              LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
0003c8  e1a00000          MOV      r0,r0
0003cc  e5d40007          LDRB     r0,[r4,#7]
0003d0  e5d41006          LDRB     r1,[r4,#6]
0003d4  e1810400          ORR      r0,r1,r0,LSL #8
0003d8  e1d511bc          LDRH     r1,[r5,#0x1c]
0003dc  e1500001          CMP      r0,r1
0003e0  0a000006          BEQ      |L2.1024|
0003e4  e1a00000          MOV      r0,r0
0003e8  e28f301c          ADR      r3,|L2.1036|
0003ec  e59f2100          LDR      r2,|L2.1268|
0003f0  e28f1c01          ADR      r1,|L2.1272|
0003f4  e28f0058          ADR      r0,|L2.1108|
0003f8  ebfffffe          BL       sysprintf
0003fc  e1a00000          MOV      r0,r0
                  |L2.1024|
000400  e1a00000          MOV      r0,r0
                  |L2.1028|
;;;450                iprh->end == ipr->datagram_len);
;;;451            }
;;;452          }
;;;453        }
;;;454        /* If valid is 0 here, there are some fragments missing in the middle
;;;455         * (since MF == 0 has already arrived). Such datagrams simply time out if
;;;456         * no more fragments are received... */
;;;457        return valid;
000404  e1a0000b          MOV      r0,r11
                  |L2.1032|
;;;458      }
;;;459      /* If we come here, not all fragments were received, yet! */
;;;460      return 0; /* not yet valid! */
;;;461    #if IP_REASS_CHECK_OVERLAP
;;;462    freepbuf:
;;;463      ip_reass_pbufcount -= pbuf_clen(new_p);
;;;464      pbuf_free(new_p);
;;;465      return 0;
;;;466    #endif /* IP_REASS_CHECK_OVERLAP */
;;;467    }
000408  e8bd9ffc          POP      {r2-r12,pc}
                  |L2.1036|
00040c  6c776970          DCB      "lwip-1.4.1\\src\\core\\ipv4\\ip_frag.c",0
000410  2d312e34
000414  2e315c73
000418  72635c63
00041c  6f72655c
000420  69707634
000424  5c69705f
000428  66726167
00042c  2e6300  
00042f  00                DCB      0
                  |L2.1072|
                          DCD      0x00000193
                  |L2.1076|
000434  63686563          DCB      "check fragments don't overlap",0
000438  6b206672
00043c  61676d65
000440  6e747320
000444  646f6e27
000448  74206f76
00044c  65726c61
000450  7000    
000452  00                DCB      0
000453  00                DCB      0
                  |L2.1108|
000454  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000458  7274696f
00045c  6e202225
000460  73222066
000464  61696c65
000468  64206174
00046c  206c696e
000470  65202564
000474  20696e20
000478  25730a00
                  |L2.1148|
                          DCD      0x0000019b
                  |L2.1152|
000480  6e6f2070          DCB      "no previous fragment, this must be the first fragment!",0
000484  72657669
000488  6f757320
00048c  66726167
000490  6d656e74
000494  2c207468
000498  6973206d
00049c  75737420
0004a0  62652074
0004a4  68652066
0004a8  69727374
0004ac  20667261
0004b0  676d656e
0004b4  742100  
0004b7  00                DCB      0
                  |L2.1208|
0004b8  73616e69          DCB      "sanity check",0
0004bc  74792063
0004c0  6865636b
0004c4  00      
0004c5  00                DCB      0
0004c6  00                DCB      0
0004c7  00                DCB      0
                  |L2.1224|
                          DCD      0x000001bd
                  |L2.1228|
                          DCD      0x000001bf
                  |L2.1232|
0004d0  76616c69          DCB      "validate_datagram:next_pbuf!=NULL",0
0004d4  64617465
0004d8  5f646174
0004dc  61677261
0004e0  6d3a6e65
0004e4  78745f70
0004e8  62756621
0004ec  3d4e554c
0004f0  4c00    
0004f2  00                DCB      0
0004f3  00                DCB      0
                  |L2.1268|
                          DCD      0x000001c1
                  |L2.1272|
0004f8  76616c69          DCB      "validate_datagram:datagram end!=datagram len",0
0004fc  64617465
000500  5f646174
000504  61677261
000508  6d3a6461
00050c  74616772
000510  616d2065
000514  6e64213d
000518  64617461
00051c  6772616d
000520  206c656e
000524  00      
000525  00                DCB      0
000526  00                DCB      0
000527  00                DCB      0
                  |L2.1320|
000528  e3a00000          MOV      r0,#0                 ;460
00052c  eaffffb5          B        |L2.1032|
                  |L2.1328|
000530  e1a00000          MOV      r0,r0                 ;462
000534  e1a00009          MOV      r0,r9                 ;463
000538  ebfffffe          BL       pbuf_clen
00053c  e59f101c          LDR      r1,|L2.1376|
000540  e1d110b0          LDRH     r1,[r1,#0]            ;463  ; ip_reass_pbufcount
000544  e0410000          SUB      r0,r1,r0              ;463
000548  e59f1010          LDR      r1,|L2.1376|
00054c  e1c100b0          STRH     r0,[r1,#0]            ;463  ; ip_reass_pbufcount
000550  e1a00009          MOV      r0,r9                 ;464
000554  ebfffffe          BL       pbuf_free
000558  e3a00000          MOV      r0,#0                 ;465
00055c  eaffffa9          B        |L2.1032|
;;;468    
                          ENDP

                  |L2.1376|
                          DCD      ip_reass_pbufcount

                          AREA ||i.ip_reass_dequeue_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_dequeue_datagram PROC
;;;303    static void
;;;304    ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;305    {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;306      
;;;307      /* dequeue the reass struct  */
;;;308      if (reassdatagrams == ipr) {
00000c  e59f005c          LDR      r0,|L3.112|
000010  e5900000          LDR      r0,[r0,#0]  ; reassdatagrams
000014  e1500004          CMP      r0,r4
000018  1a000003          BNE      |L3.44|
;;;309        /* it was the first in the list */
;;;310        reassdatagrams = ipr->next;
00001c  e59f104c          LDR      r1,|L3.112|
000020  e5940000          LDR      r0,[r4,#0]
000024  e5810000          STR      r0,[r1,#0]  ; reassdatagrams
000028  ea00000c          B        |L3.96|
                  |L3.44|
;;;311      } else {
;;;312        /* it wasn't the first, so it must have a valid 'prev' */
;;;313        LWIP_ASSERT("sanity check linked list", prev != NULL);
00002c  e1a00000          MOV      r0,r0
000030  e3550000          CMP      r5,#0
000034  1a000006          BNE      |L3.84|
000038  e1a00000          MOV      r0,r0
00003c  e28f3030          ADR      r3,|L3.116|
000040  e59f2050          LDR      r2,|L3.152|
000044  e28f1050          ADR      r1,|L3.156|
000048  e28f0068          ADR      r0,|L3.184|
00004c  ebfffffe          BL       sysprintf
000050  e1a00000          MOV      r0,r0
                  |L3.84|
000054  e1a00000          MOV      r0,r0
;;;314        prev->next = ipr->next;
000058  e5940000          LDR      r0,[r4,#0]
00005c  e5850000          STR      r0,[r5,#0]
                  |L3.96|
;;;315      }
;;;316    
;;;317      /* now we can free the ip_reass struct */
;;;318      memp_free(MEMP_REASSDATA, ipr);
000060  e1a01004          MOV      r1,r4
000064  e3a00004          MOV      r0,#4
000068  ebfffffe          BL       memp_free
;;;319    }
00006c  e8bd8070          POP      {r4-r6,pc}
;;;320    
                          ENDP

                  |L3.112|
                          DCD      reassdatagrams
                  |L3.116|
000074  6c776970          DCB      "lwip-1.4.1\\src\\core\\ipv4\\ip_frag.c",0
000078  2d312e34
00007c  2e315c73
000080  72635c63
000084  6f72655c
000088  69707634
00008c  5c69705f
000090  66726167
000094  2e6300  
000097  00                DCB      0
                  |L3.152|
                          DCD      0x00000139
                  |L3.156|
00009c  73616e69          DCB      "sanity check linked list",0
0000a0  74792063
0000a4  6865636b
0000a8  206c696e
0000ac  6b656420
0000b0  6c697374
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L3.184|
0000b8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000bc  7274696f
0000c0  6e202225
0000c4  73222066
0000c8  61696c65
0000cc  64206174
0000d0  206c696e
0000d4  65202564
0000d8  20696e20
0000dc  25730a00

                          AREA ||i.ip_reass_enqueue_new_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_enqueue_new_datagram PROC
;;;268    static struct ip_reassdata*
;;;269    ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;270    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;271      struct ip_reassdata* ipr;
;;;272      /* No matching previous fragment found, allocate a new reassdata struct */
;;;273      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
00000c  e3a00004          MOV      r0,#4
000010  ebfffffe          BL       memp_malloc
000014  e1a04000          MOV      r4,r0
;;;274      if (ipr == NULL) {
000018  e3540000          CMP      r4,#0
00001c  1a00000b          BNE      |L4.80|
;;;275    #if IP_REASS_FREE_OLDEST
;;;276        if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
000020  e1a01006          MOV      r1,r6
000024  e1a00005          MOV      r0,r5
000028  ebfffffe          BL       ip_reass_remove_oldest_datagram
00002c  e1500006          CMP      r0,r6
000030  ba000002          BLT      |L4.64|
;;;277          ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
000034  e3a00004          MOV      r0,#4
000038  ebfffffe          BL       memp_malloc
00003c  e1a04000          MOV      r4,r0
                  |L4.64|
;;;278        }
;;;279        if (ipr == NULL)
000040  e3540000          CMP      r4,#0
000044  1a000001          BNE      |L4.80|
;;;280    #endif /* IP_REASS_FREE_OLDEST */
;;;281        {
;;;282          IPFRAG_STATS_INC(ip_frag.memerr);
;;;283          LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
;;;284          return NULL;
000048  e3a00000          MOV      r0,#0
                  |L4.76|
;;;285        }
;;;286      }
;;;287      memset(ipr, 0, sizeof(struct ip_reassdata));
;;;288      ipr->timer = IP_REASS_MAXAGE;
;;;289    
;;;290      /* enqueue the new structure to the front of the list */
;;;291      ipr->next = reassdatagrams;
;;;292      reassdatagrams = ipr;
;;;293      /* copy the ip header for later tests and input */
;;;294      /* @todo: no ip options supported? */
;;;295      SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
;;;296      return ipr;
;;;297    }
00004c  e8bd8070          POP      {r4-r6,pc}
                  |L4.80|
000050  e3a01020          MOV      r1,#0x20              ;287
000054  e1a00004          MOV      r0,r4                 ;287
000058  ebfffffe          BL       __aeabi_memclr4
00005c  e3a00003          MOV      r0,#3                 ;288
000060  e5c4001f          STRB     r0,[r4,#0x1f]         ;288
000064  e59f0024          LDR      r0,|L4.144|
000068  e5900000          LDR      r0,[r0,#0]            ;291  ; reassdatagrams
00006c  e5840000          STR      r0,[r4,#0]            ;291
000070  e59f0018          LDR      r0,|L4.144|
000074  e5804000          STR      r4,[r0,#0]            ;292  ; reassdatagrams
000078  e3a02014          MOV      r2,#0x14              ;295
00007c  e1a01005          MOV      r1,r5                 ;295
000080  e2840008          ADD      r0,r4,#8              ;295
000084  ebfffffe          BL       __aeabi_memcpy
000088  e1a00004          MOV      r0,r4                 ;296
00008c  eaffffee          B        |L4.76|
;;;298    
                          ENDP

                  |L4.144|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_free_complete_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_free_complete_datagram PROC
;;;157    static int
;;;158    ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;159    {
000004  e1a04000          MOV      r4,r0
000008  e1a08001          MOV      r8,r1
;;;160      u16_t pbufs_freed = 0;
00000c  e3a05000          MOV      r5,#0
;;;161      u8_t clen;
;;;162      struct pbuf *p;
;;;163      struct ip_reass_helper *iprh;
;;;164    
;;;165      LWIP_ASSERT("prev != ipr", prev != ipr);
000010  e1a00000          MOV      r0,r0
000014  e1580004          CMP      r8,r4
000018  1a000006          BNE      |L5.56|
00001c  e1a00000          MOV      r0,r0
000020  e28f3f6e          ADR      r3,|L5.480|
000024  e3a020a5          MOV      r2,#0xa5
000028  e28f1f75          ADR      r1,|L5.516|
00002c  e28f0f77          ADR      r0,|L5.528|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L5.56|
000038  e1a00000          MOV      r0,r0
;;;166      if (prev != NULL) {
00003c  e3580000          CMP      r8,#0
000040  0a00000b          BEQ      |L5.116|
;;;167        LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
000044  e1a00000          MOV      r0,r0
000048  e5980000          LDR      r0,[r8,#0]
00004c  e1500004          CMP      r0,r4
000050  0a000006          BEQ      |L5.112|
000054  e1a00000          MOV      r0,r0
000058  e28f3d06          ADR      r3,|L5.480|
00005c  e3a020a7          MOV      r2,#0xa7
000060  e28f1e1d          ADR      r1,|L5.568|
000064  e28f0f69          ADR      r0,|L5.528|
000068  ebfffffe          BL       sysprintf
00006c  e1a00000          MOV      r0,r0
                  |L5.112|
000070  e1a00000          MOV      r0,r0
                  |L5.116|
;;;168      }
;;;169    
;;;170      snmp_inc_ipreasmfails();
;;;171    #if LWIP_ICMP
;;;172      iprh = (struct ip_reass_helper *)ipr->p->payload;
000074  e5940004          LDR      r0,[r4,#4]
000078  e5909004          LDR      r9,[r0,#4]
;;;173      if (iprh->start == 0) {
00007c  e5d90005          LDRB     r0,[r9,#5]
000080  e5d91004          LDRB     r1,[r9,#4]
000084  e1810400          ORR      r0,r1,r0,LSL #8
000088  e3500000          CMP      r0,#0
00008c  1a00001e          BNE      |L5.268|
;;;174        /* The first fragment was received, send ICMP time exceeded. */
;;;175        /* First, de-queue the first pbuf from r->p. */
;;;176        p = ipr->p;
000090  e5947004          LDR      r7,[r4,#4]
;;;177        ipr->p = iprh->next_pbuf;
000094  e1a00009          MOV      r0,r9
000098  ebfffffe          BL       __aeabi_uread4
00009c  e5840004          STR      r0,[r4,#4]
;;;178        /* Then, copy the original header into it. */
;;;179        SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
0000a0  e3a02014          MOV      r2,#0x14
0000a4  e2841008          ADD      r1,r4,#8
0000a8  e5970004          LDR      r0,[r7,#4]
0000ac  ebfffffe          BL       __aeabi_memcpy
;;;180        icmp_time_exceeded(p, ICMP_TE_FRAG);
0000b0  e3a01001          MOV      r1,#1
0000b4  e1a00007          MOV      r0,r7
0000b8  ebfffffe          BL       icmp_time_exceeded
;;;181        clen = pbuf_clen(p);
0000bc  e1a00007          MOV      r0,r7
0000c0  ebfffffe          BL       pbuf_clen
0000c4  e1a06000          MOV      r6,r0
;;;182        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
0000c8  e1a00000          MOV      r0,r0
0000cc  e0850006          ADD      r0,r5,r6
0000d0  e3500801          CMP      r0,#0x10000
0000d4  ba000006          BLT      |L5.244|
0000d8  e1a00000          MOV      r0,r0
0000dc  e28f30fc          ADR      r3,|L5.480|
0000e0  e3a020b6          MOV      r2,#0xb6
0000e4  e28f1e16          ADR      r1,|L5.588|
0000e8  e28f0e12          ADR      r0,|L5.528|
0000ec  ebfffffe          BL       sysprintf
0000f0  e1a00000          MOV      r0,r0
                  |L5.244|
0000f4  e1a00000          MOV      r0,r0
;;;183        pbufs_freed += clen;
0000f8  e0850006          ADD      r0,r5,r6
0000fc  e1a05800          LSL      r5,r0,#16
000100  e1a05825          LSR      r5,r5,#16
;;;184        pbuf_free(p);
000104  e1a00007          MOV      r0,r7
000108  ebfffffe          BL       pbuf_free
                  |L5.268|
;;;185      }
;;;186    #endif /* LWIP_ICMP */
;;;187    
;;;188      /* First, free all received pbufs.  The individual pbufs need to be released 
;;;189         separately as they have not yet been chained */
;;;190      p = ipr->p;
00010c  e5947004          LDR      r7,[r4,#4]
;;;191      while (p != NULL) {
000110  ea000019          B        |L5.380|
                  |L5.276|
;;;192        struct pbuf *pcur;
;;;193        iprh = (struct ip_reass_helper *)p->payload;
000114  e5979004          LDR      r9,[r7,#4]
;;;194        pcur = p;
000118  e1a0a007          MOV      r10,r7
;;;195        /* get the next pointer before freeing */
;;;196        p = iprh->next_pbuf;
00011c  e1a00009          MOV      r0,r9
000120  ebfffffe          BL       __aeabi_uread4
000124  e1a07000          MOV      r7,r0
;;;197        clen = pbuf_clen(pcur);
000128  e1a0000a          MOV      r0,r10
00012c  ebfffffe          BL       pbuf_clen
000130  e1a06000          MOV      r6,r0
;;;198        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
000134  e1a00000          MOV      r0,r0
000138  e0850006          ADD      r0,r5,r6
00013c  e3500801          CMP      r0,#0x10000
000140  ba000006          BLT      |L5.352|
000144  e1a00000          MOV      r0,r0
000148  e28f3090          ADR      r3,|L5.480|
00014c  e3a020c6          MOV      r2,#0xc6
000150  e28f10f4          ADR      r1,|L5.588|
000154  e28f00b4          ADR      r0,|L5.528|
000158  ebfffffe          BL       sysprintf
00015c  e1a00000          MOV      r0,r0
                  |L5.352|
000160  e1a00000          MOV      r0,r0
;;;199        pbufs_freed += clen;
000164  e0850006          ADD      r0,r5,r6
000168  e1a05800          LSL      r5,r0,#16
00016c  e1a05825          LSR      r5,r5,#16
;;;200        pbuf_free(pcur);
000170  e1a0000a          MOV      r0,r10
000174  ebfffffe          BL       pbuf_free
;;;201      }
000178  e1a00000          MOV      r0,r0
                  |L5.380|
00017c  e3570000          CMP      r7,#0                 ;191
000180  1affffe3          BNE      |L5.276|
;;;202      /* Then, unchain the struct ip_reassdata from the list and free it. */
;;;203      ip_reass_dequeue_datagram(ipr, prev);
000184  e1a01008          MOV      r1,r8
000188  e1a00004          MOV      r0,r4
00018c  ebfffffe          BL       ip_reass_dequeue_datagram
;;;204      LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
000190  e1a00000          MOV      r0,r0
000194  e59f00d0          LDR      r0,|L5.620|
000198  e1d000b0          LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
00019c  e1500005          CMP      r0,r5
0001a0  aa000006          BGE      |L5.448|
0001a4  e1a00000          MOV      r0,r0
0001a8  e28f3030          ADR      r3,|L5.480|
0001ac  e3a020cc          MOV      r2,#0xcc
0001b0  e28f10b8          ADR      r1,|L5.624|
0001b4  e28f0054          ADR      r0,|L5.528|
0001b8  ebfffffe          BL       sysprintf
0001bc  e1a00000          MOV      r0,r0
                  |L5.448|
0001c0  e1a00000          MOV      r0,r0
;;;205      ip_reass_pbufcount -= pbufs_freed;
0001c4  e59f00a0          LDR      r0,|L5.620|
0001c8  e1d000b0          LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
0001cc  e0400005          SUB      r0,r0,r5
0001d0  e59f1094          LDR      r1,|L5.620|
0001d4  e1c100b0          STRH     r0,[r1,#0]  ; ip_reass_pbufcount
;;;206    
;;;207      return pbufs_freed;
0001d8  e1a00005          MOV      r0,r5
;;;208    }
0001dc  e8bd87f0          POP      {r4-r10,pc}
                  |L5.480|
0001e0  6c776970          DCB      "lwip-1.4.1\\src\\core\\ipv4\\ip_frag.c",0
0001e4  2d312e34
0001e8  2e315c73
0001ec  72635c63
0001f0  6f72655c
0001f4  69707634
0001f8  5c69705f
0001fc  66726167
000200  2e6300  
000203  00                DCB      0
                  |L5.516|
000204  70726576          DCB      "prev != ipr",0
000208  20213d20
00020c  69707200
                  |L5.528|
000210  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000214  7274696f
000218  6e202225
00021c  73222066
000220  61696c65
000224  64206174
000228  206c696e
00022c  65202564
000230  20696e20
000234  25730a00
                  |L5.568|
000238  70726576          DCB      "prev->next == ipr",0
00023c  2d3e6e65
000240  7874203d
000244  3d206970
000248  7200    
00024a  00                DCB      0
00024b  00                DCB      0
                  |L5.588|
00024c  70627566          DCB      "pbufs_freed + clen <= 0xffff",0
000250  735f6672
000254  65656420
000258  2b20636c
00025c  656e203c
000260  3d203078
000264  66666666
000268  00      
000269  00                DCB      0
00026a  00                DCB      0
00026b  00                DCB      0
                  |L5.620|
                          DCD      ip_reass_pbufcount
                  |L5.624|
000270  69705f72          DCB      "ip_reass_pbufcount >= clen",0
000274  65617373
000278  5f706275
00027c  66636f75
000280  6e74203e
000284  3d20636c
000288  656e00  
00028b  00                DCB      0
                          ENDP


                          AREA ||i.ip_reass_remove_oldest_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_remove_oldest_datagram PROC
;;;220    static int
;;;221    ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;222    {
000004  e1a05000          MOV      r5,r0
000008  e1a09001          MOV      r9,r1
;;;223      /* @todo Can't we simply remove the last datagram in the
;;;224       *       linked list behind reassdatagrams?
;;;225       */
;;;226      struct ip_reassdata *r, *oldest, *prev;
;;;227      int pbufs_freed = 0, pbufs_freed_current;
00000c  e3a07000          MOV      r7,#0
;;;228      int other_datagrams;
;;;229    
;;;230      /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
;;;231       * but don't free the datagram that 'fraghdr' belongs to! */
;;;232      do {
000010  e1a00000          MOV      r0,r0
                  |L6.20|
;;;233        oldest = NULL;
000014  e3a06000          MOV      r6,#0
;;;234        prev = NULL;
000018  e3a0b000          MOV      r11,#0
;;;235        other_datagrams = 0;
00001c  e3a0a000          MOV      r10,#0
;;;236        r = reassdatagrams;
000020  e59f00d0          LDR      r0,|L6.248|
000024  e5904000          LDR      r4,[r0,#0]  ; reassdatagrams
;;;237        while (r != NULL) {
000028  ea000023          B        |L6.188|
                  |L6.44|
;;;238          if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
00002c  e285000c          ADD      r0,r5,#0xc
000030  ebfffffe          BL       __aeabi_uread4
000034  e5941014          LDR      r1,[r4,#0x14]
000038  e1500001          CMP      r0,r1
00003c  1a00000a          BNE      |L6.108|
000040  e2850010          ADD      r0,r5,#0x10
000044  ebfffffe          BL       __aeabi_uread4
000048  e5941018          LDR      r1,[r4,#0x18]
00004c  e1500001          CMP      r0,r1
000050  1a000005          BNE      |L6.108|
000054  e1d400bc          LDRH     r0,[r4,#0xc]
000058  e5d51005          LDRB     r1,[r5,#5]
00005c  e5d52004          LDRB     r2,[r5,#4]
000060  e1821401          ORR      r1,r2,r1,LSL #8
000064  e1500001          CMP      r0,r1
000068  0a000001          BEQ      |L6.116|
                  |L6.108|
00006c  e3a00001          MOV      r0,#1
000070  ea000000          B        |L6.120|
                  |L6.116|
000074  e3a00000          MOV      r0,#0
                  |L6.120|
000078  e3500000          CMP      r0,#0
00007c  0a000009          BEQ      |L6.168|
;;;239            /* Not the same datagram as fraghdr */
;;;240            other_datagrams++;
000080  e28aa001          ADD      r10,r10,#1
;;;241            if (oldest == NULL) {
000084  e3560000          CMP      r6,#0
000088  1a000001          BNE      |L6.148|
;;;242              oldest = r;
00008c  e1a06004          MOV      r6,r4
000090  ea000004          B        |L6.168|
                  |L6.148|
;;;243            } else if (r->timer <= oldest->timer) {
000094  e5d4001f          LDRB     r0,[r4,#0x1f]
000098  e5d6101f          LDRB     r1,[r6,#0x1f]
00009c  e1500001          CMP      r0,r1
0000a0  ca000000          BGT      |L6.168|
;;;244              /* older than the previous oldest */
;;;245              oldest = r;
0000a4  e1a06004          MOV      r6,r4
                  |L6.168|
;;;246            }
;;;247          }
;;;248          if (r->next != NULL) {
0000a8  e5940000          LDR      r0,[r4,#0]
0000ac  e3500000          CMP      r0,#0
0000b0  0a000000          BEQ      |L6.184|
;;;249            prev = r;
0000b4  e1a0b004          MOV      r11,r4
                  |L6.184|
;;;250          }
;;;251          r = r->next;
0000b8  e5944000          LDR      r4,[r4,#0]
                  |L6.188|
0000bc  e3540000          CMP      r4,#0                 ;237
0000c0  1affffd9          BNE      |L6.44|
;;;252        }
;;;253        if (oldest != NULL) {
0000c4  e3560000          CMP      r6,#0
0000c8  0a000004          BEQ      |L6.224|
;;;254          pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
0000cc  e1a0100b          MOV      r1,r11
0000d0  e1a00006          MOV      r0,r6
0000d4  ebfffffe          BL       ip_reass_free_complete_datagram
0000d8  e1a08000          MOV      r8,r0
;;;255          pbufs_freed += pbufs_freed_current;
0000dc  e0877008          ADD      r7,r7,r8
                  |L6.224|
;;;256        }
;;;257      } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
0000e0  e1570009          CMP      r7,r9
0000e4  aa000001          BGE      |L6.240|
0000e8  e35a0001          CMP      r10,#1
0000ec  caffffc8          BGT      |L6.20|
                  |L6.240|
;;;258      return pbufs_freed;
0000f0  e1a00007          MOV      r0,r7
;;;259    }
0000f4  e8bd9ff0          POP      {r4-r12,pc}
;;;260    #endif /* IP_REASS_FREE_OLDEST */
                          ENDP

                  |L6.248|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_tmr||, CODE, READONLY, ALIGN=2

                  ip_reass_tmr PROC
;;;121    void
;;;122    ip_reass_tmr(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;123    {
;;;124      struct ip_reassdata *r, *prev = NULL;
000004  e3a05000          MOV      r5,#0
;;;125    
;;;126      r = reassdatagrams;
000008  e59f004c          LDR      r0,|L7.92|
00000c  e5904000          LDR      r4,[r0,#0]  ; reassdatagrams
;;;127      while (r != NULL) {
000010  ea00000e          B        |L7.80|
                  |L7.20|
;;;128        /* Decrement the timer. Once it reaches 0,
;;;129         * clean up the incomplete fragment assembly */
;;;130        if (r->timer > 0) {
000014  e5d4001f          LDRB     r0,[r4,#0x1f]
000018  e3500000          CMP      r0,#0
00001c  da000005          BLE      |L7.56|
;;;131          r->timer--;
000020  e5d4001f          LDRB     r0,[r4,#0x1f]
000024  e2400001          SUB      r0,r0,#1
000028  e5c4001f          STRB     r0,[r4,#0x1f]
;;;132          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
;;;133          prev = r;
00002c  e1a05004          MOV      r5,r4
;;;134          r = r->next;
000030  e5944000          LDR      r4,[r4,#0]
000034  ea000005          B        |L7.80|
                  |L7.56|
;;;135        } else {
;;;136          /* reassembly timed out */
;;;137          struct ip_reassdata *tmp;
;;;138          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
;;;139          tmp = r;
000038  e1a06004          MOV      r6,r4
;;;140          /* get the next pointer before freeing */
;;;141          r = r->next;
00003c  e5944000          LDR      r4,[r4,#0]
;;;142          /* free the helper struct and all enqueued pbufs */
;;;143          ip_reass_free_complete_datagram(tmp, prev);
000040  e1a01005          MOV      r1,r5
000044  e1a00006          MOV      r0,r6
000048  ebfffffe          BL       ip_reass_free_complete_datagram
;;;144         }
00004c  e1a00000          MOV      r0,r0
                  |L7.80|
000050  e3540000          CMP      r4,#0                 ;127
000054  1affffee          BNE      |L7.20|
;;;145       }
;;;146    }
000058  e8bd8070          POP      {r4-r6,pc}
;;;147    
                          ENDP

                  |L7.92|
                          DCD      reassdatagrams

                          AREA ||.data||, DATA, ALIGN=2

                  reassdatagrams
                          DCD      0x00000000
                  ip_reass_pbufcount
000004  0000              DCB      0x00,0x00
