; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\ip_frag.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ip_frag.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\ip_frag.crf lwip-1.4.1\src\core\ipv4\ip_frag.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ip_reass_dequeue_datagram PROC
;;;303    static void
;;;304    ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;305    {
000004  e1a04000          MOV      r4,r0
;;;306      
;;;307      /* dequeue the reass struct  */
;;;308      if (reassdatagrams == ipr) {
000008  e59f01ec          LDR      r0,|L1.508|
00000c  e1a05001          MOV      r5,r1                 ;305
000010  e5901004          LDR      r1,[r0,#4]  ; reassdatagrams
000014  e1510004          CMP      r1,r4
;;;309        /* it was the first in the list */
;;;310        reassdatagrams = ipr->next;
000018  05941000          LDREQ    r1,[r4,#0]
00001c  05801004          STREQ    r1,[r0,#4]  ; reassdatagrams
000020  0a000008          BEQ      |L1.72|
;;;311      } else {
;;;312        /* it wasn't the first, so it must have a valid 'prev' */
;;;313        LWIP_ASSERT("sanity check linked list", prev != NULL);
000024  e3550000          CMP      r5,#0
000028  1a000004          BNE      |L1.64|
00002c  e59f21f0          LDR      r2,|L1.548|
000030  e28f3f72          ADR      r3,|L1.512|
000034  e28f1f7b          ADR      r1,|L1.552|
000038  e28f0f81          ADR      r0,|L1.580|
00003c  ebfffffe          BL       sysprintf
                  |L1.64|
;;;314        prev->next = ipr->next;
000040  e5940000          LDR      r0,[r4,#0]
000044  e5850000          STR      r0,[r5,#0]
                  |L1.72|
;;;315      }
;;;316    
;;;317      /* now we can free the ip_reass struct */
;;;318      memp_free(MEMP_REASSDATA, ipr);
000048  e1a01004          MOV      r1,r4
00004c  e8bd4070          POP      {r4-r6,lr}
000050  e3a00004          MOV      r0,#4
000054  eafffffe          B        memp_free
;;;319    }
;;;320    
                          ENDP

                  ip_reass_free_complete_datagram PROC
;;;157    static int
;;;158    ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000058  e92d41f0          PUSH     {r4-r8,lr}
;;;159    {
00005c  e1a06000          MOV      r6,r0
;;;160      u16_t pbufs_freed = 0;
;;;161      u8_t clen;
;;;162      struct pbuf *p;
;;;163      struct ip_reass_helper *iprh;
;;;164    
;;;165      LWIP_ASSERT("prev != ipr", prev != ipr);
000060  e1510006          CMP      r1,r6
000064  e1a07001          MOV      r7,r1                 ;159
000068  e3a04000          MOV      r4,#0                 ;160
00006c  1a000004          BNE      |L1.132|
000070  e28f3f62          ADR      r3,|L1.512|
000074  e3a020a5          MOV      r2,#0xa5
000078  e28f1f7b          ADR      r1,|L1.620|
00007c  e28f0d07          ADR      r0,|L1.580|
000080  ebfffffe          BL       sysprintf
                  |L1.132|
;;;166      if (prev != NULL) {
000084  e3570000          CMP      r7,#0
;;;167        LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
000088  15970000          LDRNE    r0,[r7,#0]
00008c  11500006          CMPNE    r0,r6
000090  0a000004          BEQ      |L1.168|
000094  e28f3f59          ADR      r3,|L1.512|
000098  e3a020a7          MOV      r2,#0xa7
00009c  e28f1f75          ADR      r1,|L1.632|
0000a0  e28f0f67          ADR      r0,|L1.580|
0000a4  ebfffffe          BL       sysprintf
                  |L1.168|
;;;168      }
;;;169    
;;;170      snmp_inc_ipreasmfails();
;;;171    #if LWIP_ICMP
;;;172      iprh = (struct ip_reass_helper *)ipr->p->payload;
0000a8  e5965004          LDR      r5,[r6,#4]
0000ac  e5950004          LDR      r0,[r5,#4]
;;;173      if (iprh->start == 0) {
0000b0  e5d01005          LDRB     r1,[r0,#5]
0000b4  e5d02004          LDRB     r2,[r0,#4]
0000b8  e1921401          ORRS     r1,r2,r1,LSL #8
0000bc  1a000014          BNE      |L1.276|
;;;174        /* The first fragment was received, send ICMP time exceeded. */
;;;175        /* First, de-queue the first pbuf from r->p. */
;;;176        p = ipr->p;
;;;177        ipr->p = iprh->next_pbuf;
0000c0  ebfffffe          BL       __aeabi_uread4
;;;178        /* Then, copy the original header into it. */
;;;179        SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
0000c4  e5860004          STR      r0,[r6,#4]
0000c8  e5950004          LDR      r0,[r5,#4]
0000cc  e3a02014          MOV      r2,#0x14
0000d0  e2861008          ADD      r1,r6,#8
0000d4  ebfffffe          BL       __aeabi_memcpy
;;;180        icmp_time_exceeded(p, ICMP_TE_FRAG);
0000d8  e3a01001          MOV      r1,#1
0000dc  e1a00005          MOV      r0,r5
0000e0  ebfffffe          BL       icmp_time_exceeded
;;;181        clen = pbuf_clen(p);
0000e4  e1a00005          MOV      r0,r5
0000e8  ebfffffe          BL       pbuf_clen
;;;182        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
0000ec  e3500801          CMP      r0,#0x10000
0000f0  e1a04000          MOV      r4,r0                 ;181
0000f4  3a000004          BCC      |L1.268|
0000f8  e28f3c01          ADR      r3,|L1.512|
0000fc  e3a020b6          MOV      r2,#0xb6
000100  e28f1f61          ADR      r1,|L1.652|
000104  e28f0f4e          ADR      r0,|L1.580|
000108  ebfffffe          BL       sysprintf
                  |L1.268|
;;;183        pbufs_freed += clen;
;;;184        pbuf_free(p);
00010c  e1a00005          MOV      r0,r5
000110  ebfffffe          BL       pbuf_free
                  |L1.276|
;;;185      }
;;;186    #endif /* LWIP_ICMP */
;;;187    
;;;188      /* First, free all received pbufs.  The individual pbufs need to be released 
;;;189         separately as they have not yet been chained */
;;;190      p = ipr->p;
000114  e5965004          LDR      r5,[r6,#4]
;;;191      while (p != NULL) {
000118  ea000010          B        |L1.352|
                  |L1.284|
;;;192        struct pbuf *pcur;
;;;193        iprh = (struct ip_reass_helper *)p->payload;
00011c  e5950004          LDR      r0,[r5,#4]
;;;194        pcur = p;
000120  e1a08005          MOV      r8,r5
;;;195        /* get the next pointer before freeing */
;;;196        p = iprh->next_pbuf;
000124  ebfffffe          BL       __aeabi_uread4
000128  e1a05000          MOV      r5,r0
;;;197        clen = pbuf_clen(pcur);
00012c  e1a00008          MOV      r0,r8
000130  ebfffffe          BL       pbuf_clen
;;;198        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
000134  e0844000          ADD      r4,r4,r0
000138  e3540801          CMP      r4,#0x10000
00013c  3a000004          BCC      |L1.340|
000140  e28f30b8          ADR      r3,|L1.512|
000144  e3a020c6          MOV      r2,#0xc6
000148  e28f1f4f          ADR      r1,|L1.652|
00014c  e28f00f0          ADR      r0,|L1.580|
000150  ebfffffe          BL       sysprintf
                  |L1.340|
;;;199        pbufs_freed += clen;
000154  e3c44801          BIC      r4,r4,#0x10000
;;;200        pbuf_free(pcur);
000158  e1a00008          MOV      r0,r8
00015c  ebfffffe          BL       pbuf_free
                  |L1.352|
000160  e3550000          CMP      r5,#0                 ;191
000164  1affffec          BNE      |L1.284|
;;;201      }
;;;202      /* Then, unchain the struct ip_reassdata from the list and free it. */
;;;203      ip_reass_dequeue_datagram(ipr, prev);
000168  e1a01007          MOV      r1,r7
00016c  e1a00006          MOV      r0,r6
000170  ebfffffe          BL       ip_reass_dequeue_datagram
;;;204      LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
000174  e59f5080          LDR      r5,|L1.508|
000178  e1d500b0          LDRH     r0,[r5,#0]  ; ip_reass_pbufcount
00017c  e1500004          CMP      r0,r4
000180  2a000004          BCS      |L1.408|
000184  e28f3074          ADR      r3,|L1.512|
000188  e3a020cc          MOV      r2,#0xcc
00018c  e28f1f46          ADR      r1,|L1.684|
000190  e28f00ac          ADR      r0,|L1.580|
000194  ebfffffe          BL       sysprintf
                  |L1.408|
;;;205      ip_reass_pbufcount -= pbufs_freed;
000198  e1d500b0          LDRH     r0,[r5,#0]  ; ip_reass_pbufcount
00019c  e0400004          SUB      r0,r0,r4
0001a0  e1c500b0          STRH     r0,[r5,#0]  ; ip_reass_pbufcount
;;;206    
;;;207      return pbufs_freed;
0001a4  e1a00004          MOV      r0,r4
;;;208    }
0001a8  e8bd81f0          POP      {r4-r8,pc}
;;;209    
                          ENDP

                  ip_reass_tmr PROC
;;;121    void
;;;122    ip_reass_tmr(void)
0001ac  e92d4070          PUSH     {r4-r6,lr}
;;;123    {
;;;124      struct ip_reassdata *r, *prev = NULL;
;;;125    
;;;126      r = reassdatagrams;
0001b0  e59f0044          LDR      r0,|L1.508|
0001b4  e3a05000          MOV      r5,#0                 ;124
0001b8  e5904004          LDR      r4,[r0,#4]  ; reassdatagrams
0001bc  ea00000b          B        |L1.496|
                  |L1.448|
;;;127      while (r != NULL) {
;;;128        /* Decrement the timer. Once it reaches 0,
;;;129         * clean up the incomplete fragment assembly */
;;;130        if (r->timer > 0) {
0001c0  e5d4001f          LDRB     r0,[r4,#0x1f]
0001c4  e3500000          CMP      r0,#0
0001c8  0a000004          BEQ      |L1.480|
0001cc  e2400001          SUB      r0,r0,#1
;;;131          r->timer--;
;;;132          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
;;;133          prev = r;
0001d0  e1a05004          MOV      r5,r4
0001d4  e5c4001f          STRB     r0,[r4,#0x1f]         ;131
;;;134          r = r->next;
0001d8  e5944000          LDR      r4,[r4,#0]
0001dc  ea000003          B        |L1.496|
                  |L1.480|
;;;135        } else {
;;;136          /* reassembly timed out */
;;;137          struct ip_reassdata *tmp;
;;;138          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
;;;139          tmp = r;
0001e0  e1a00004          MOV      r0,r4
;;;140          /* get the next pointer before freeing */
;;;141          r = r->next;
0001e4  e5944000          LDR      r4,[r4,#0]
;;;142          /* free the helper struct and all enqueued pbufs */
;;;143          ip_reass_free_complete_datagram(tmp, prev);
0001e8  e1a01005          MOV      r1,r5
0001ec  ebfffffe          BL       ip_reass_free_complete_datagram
                  |L1.496|
0001f0  e3540000          CMP      r4,#0                 ;127
0001f4  1afffff1          BNE      |L1.448|
;;;144         }
;;;145       }
;;;146    }
0001f8  e8bd8070          POP      {r4-r6,pc}
                  |L1.508|
                          DCD      ||.data||
                  |L1.512|
000200  6c776970          DCB      "lwip-1.4.1\\src\\core\\ipv4\\ip_frag.c",0
000204  2d312e34
000208  2e315c73
00020c  72635c63
000210  6f72655c
000214  69707634
000218  5c69705f
00021c  66726167
000220  2e6300  
000223  00                DCB      0
                  |L1.548|
                          DCD      0x00000139
                  |L1.552|
000228  73616e69          DCB      "sanity check linked list",0
00022c  74792063
000230  6865636b
000234  206c696e
000238  6b656420
00023c  6c697374
000240  00      
000241  00                DCB      0
000242  00                DCB      0
000243  00                DCB      0
                  |L1.580|
000244  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000248  7274696f
00024c  6e202225
000250  73222066
000254  61696c65
000258  64206174
00025c  206c696e
000260  65202564
000264  20696e20
000268  25730a00
                  |L1.620|
00026c  70726576          DCB      "prev != ipr",0
000270  20213d20
000274  69707200
                  |L1.632|
000278  70726576          DCB      "prev->next == ipr",0
00027c  2d3e6e65
000280  7874203d
000284  3d206970
000288  7200    
00028a  00                DCB      0
00028b  00                DCB      0
                  |L1.652|
00028c  70627566          DCB      "pbufs_freed + clen <= 0xffff",0
000290  735f6672
000294  65656420
000298  2b20636c
00029c  656e203c
0002a0  3d203078
0002a4  66666666
0002a8  00      
0002a9  00                DCB      0
0002aa  00                DCB      0
0002ab  00                DCB      0
                  |L1.684|
0002ac  69705f72          DCB      "ip_reass_pbufcount >= clen",0
0002b0  65617373
0002b4  5f706275
0002b8  66636f75
0002bc  6e74203e
0002c0  3d20636c
0002c4  656e00  
0002c7  00                DCB      0
                          ENDP

                  ip_reass_remove_oldest_datagram PROC
;;;220    static int
;;;221    ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
0002c8  e92d5ff0          PUSH     {r4-r12,lr}
;;;222    {
;;;223      /* @todo Can't we simply remove the last datagram in the
;;;224       *       linked list behind reassdatagrams?
;;;225       */
;;;226      struct ip_reassdata *r, *oldest, *prev;
;;;227      int pbufs_freed = 0, pbufs_freed_current;
;;;228      int other_datagrams;
;;;229    
;;;230      /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
;;;231       * but don't free the datagram that 'fraghdr' belongs to! */
;;;232      do {
;;;233        oldest = NULL;
;;;234        prev = NULL;
;;;235        other_datagrams = 0;
;;;236        r = reassdatagrams;
0002cc  e51fb0d8          LDR      r11,|L1.508|
0002d0  e1a0a001          MOV      r10,r1                ;222
0002d4  e1a07000          MOV      r7,r0                 ;222
0002d8  e3a08000          MOV      r8,#0                 ;227
                  |L1.732|
0002dc  e3a05000          MOV      r5,#0                 ;233
0002e0  e59b4004          LDR      r4,[r11,#4]  ; reassdatagrams
0002e4  e1a09005          MOV      r9,r5                 ;234
0002e8  e1a06005          MOV      r6,r5                 ;235
                  |L1.748|
;;;237        while (r != NULL) {
0002ec  e3540000          CMP      r4,#0
0002f0  0a00001a          BEQ      |L1.864|
;;;238          if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
0002f4  e287000c          ADD      r0,r7,#0xc
0002f8  ebfffffe          BL       __aeabi_uread4
0002fc  e5941014          LDR      r1,[r4,#0x14]
000300  e1500001          CMP      r0,r1
000304  1a00000a          BNE      |L1.820|
000308  e2870010          ADD      r0,r7,#0x10
00030c  ebfffffe          BL       __aeabi_uread4
000310  e5941018          LDR      r1,[r4,#0x18]
000314  e1500001          CMP      r0,r1
000318  1a000005          BNE      |L1.820|
00031c  e5d71005          LDRB     r1,[r7,#5]
000320  e5d72004          LDRB     r2,[r7,#4]
000324  e1d400bc          LDRH     r0,[r4,#0xc]
000328  e1821401          ORR      r1,r2,r1,LSL #8
00032c  e1500001          CMP      r0,r1
000330  0a000005          BEQ      |L1.844|
                  |L1.820|
;;;239            /* Not the same datagram as fraghdr */
;;;240            other_datagrams++;
;;;241            if (oldest == NULL) {
000334  e3550000          CMP      r5,#0
;;;242              oldest = r;
;;;243            } else if (r->timer <= oldest->timer) {
000338  15d4001f          LDRBNE   r0,[r4,#0x1f]
00033c  15d5101f          LDRBNE   r1,[r5,#0x1f]
000340  e2866001          ADD      r6,r6,#1              ;241
000344  11500001          CMPNE    r0,r1
;;;244              /* older than the previous oldest */
;;;245              oldest = r;
000348  91a05004          MOVLS    r5,r4
                  |L1.844|
;;;246            }
;;;247          }
;;;248          if (r->next != NULL) {
00034c  e5940000          LDR      r0,[r4,#0]
000350  e3500000          CMP      r0,#0
;;;249            prev = r;
000354  11a09004          MOVNE    r9,r4
;;;250          }
;;;251          r = r->next;
000358  e1a04000          MOV      r4,r0
00035c  eaffffe2          B        |L1.748|
                  |L1.864|
;;;252        }
;;;253        if (oldest != NULL) {
000360  e3550000          CMP      r5,#0
000364  0a000003          BEQ      |L1.888|
;;;254          pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
000368  e1a01009          MOV      r1,r9
00036c  e1a00005          MOV      r0,r5
000370  ebfffffe          BL       ip_reass_free_complete_datagram
;;;255          pbufs_freed += pbufs_freed_current;
000374  e0888000          ADD      r8,r8,r0
                  |L1.888|
;;;256        }
;;;257      } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
000378  e15a0008          CMP      r10,r8
00037c  c3560001          CMPGT    r6,#1
;;;258      return pbufs_freed;
000380  d1a00008          MOVLE    r0,r8
000384  caffffd4          BGT      |L1.732|
;;;259    }
000388  e8bd9ff0          POP      {r4-r12,pc}
;;;260    #endif /* IP_REASS_FREE_OLDEST */
                          ENDP

                  ip_reass_chain_frag_into_datagram_and_validate PROC
;;;330    static int
;;;331    ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
00038c  e92d4ff8          PUSH     {r3-r11,lr}
;;;332    {
;;;333      struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
;;;334      struct pbuf *q;
;;;335      u16_t offset,len;
;;;336      struct ip_hdr *fraghdr;
;;;337      int valid = 1;
;;;338    
;;;339      /* Extract length and fragment offset from current fragment */
;;;340      fraghdr = (struct ip_hdr*)new_p->payload; 
000390  e5914004          LDR      r4,[r1,#4]
000394  e1a0b001          MOV      r11,r1                ;332
000398  e1a07000          MOV      r7,r0                 ;332
;;;341      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
00039c  e5d40003          LDRB     r0,[r4,#3]
0003a0  e5d41002          LDRB     r1,[r4,#2]
0003a4  e3a05000          MOV      r5,#0                 ;333
0003a8  e3a08001          MOV      r8,#1                 ;337
0003ac  e1810400          ORR      r0,r1,r0,LSL #8
0003b0  ebfffffe          BL       lwip_ntohs
0003b4  e5d41000          LDRB     r1,[r4,#0]
0003b8  e201100f          AND      r1,r1,#0xf
0003bc  e2611000          RSB      r1,r1,#0
0003c0  e0800101          ADD      r0,r0,r1,LSL #2
0003c4  e1a06800          LSL      r6,r0,#16
;;;342      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
0003c8  e5d40007          LDRB     r0,[r4,#7]
0003cc  e5d41006          LDRB     r1,[r4,#6]
0003d0  e1a06826          LSR      r6,r6,#16             ;341
0003d4  e1810400          ORR      r0,r1,r0,LSL #8
0003d8  ebfffffe          BL       lwip_ntohs
;;;343    
;;;344      /* overwrite the fragment's ip header from the pbuf with our helper struct,
;;;345       * and setup the embedded helper structure. */
;;;346      /* make sure the struct ip_reass_helper fits into the IP header */
;;;347      LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
;;;348                  sizeof(struct ip_reass_helper) <= IP_HLEN);
;;;349      iprh = (struct ip_reass_helper*)new_p->payload;
0003dc  e59b4004          LDR      r4,[r11,#4]
0003e0  e3c00a0e          BIC      r0,r0,#0xe000         ;342
0003e4  e1a09180          LSL      r9,r0,#3              ;342
;;;350      iprh->next_pbuf = NULL;
0003e8  e1a01004          MOV      r1,r4
0003ec  e3a00000          MOV      r0,#0
0003f0  ebfffffe          BL       __aeabi_uwrite4
;;;351      iprh->start = offset;
0003f4  e1a00429          LSR      r0,r9,#8
0003f8  e5c49004          STRB     r9,[r4,#4]
0003fc  e5c40005          STRB     r0,[r4,#5]
;;;352      iprh->end = offset + len;
000400  e0890006          ADD      r0,r9,r6
000404  e3c00801          BIC      r0,r0,#0x10000
000408  e1a01420          LSR      r1,r0,#8
00040c  e5c40006          STRB     r0,[r4,#6]
000410  e5c41007          STRB     r1,[r4,#7]
;;;353    
;;;354      /* Iterate through until we either get to the end of the list (append),
;;;355       * or we find on with a larger offset (insert). */
;;;356      for (q = ipr->p; q != NULL;) {
000414  e58d0000          STR      r0,[sp,#0]
000418  e597a004          LDR      r10,[r7,#4]
00041c  ea00002d          B        |L1.1240|
                  |L1.1056|
;;;357        iprh_tmp = (struct ip_reass_helper*)q->payload;
000420  e59a6004          LDR      r6,[r10,#4]
;;;358        if (iprh->start < iprh_tmp->start) {
000424  e5d60005          LDRB     r0,[r6,#5]
000428  e5d61004          LDRB     r1,[r6,#4]
00042c  e1810400          ORR      r0,r1,r0,LSL #8
000430  e1590000          CMP      r9,r0
000434  2a000016          BCS      |L1.1172|
;;;359          /* the new pbuf should be inserted before this */
;;;360          iprh->next_pbuf = q;
000438  e1a01004          MOV      r1,r4
00043c  e1a0000a          MOV      r0,r10
000440  ebfffffe          BL       __aeabi_uwrite4
;;;361          if (iprh_prev != NULL) {
000444  e3550000          CMP      r5,#0
;;;362            /* not the fragment with the lowest offset */
;;;363    #if IP_REASS_CHECK_OVERLAP
;;;364            if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
;;;365              /* fragment overlaps with previous or following, throw away */
;;;366              goto freepbuf;
;;;367            }
;;;368    #endif /* IP_REASS_CHECK_OVERLAP */
;;;369            iprh_prev->next_pbuf = new_p;
;;;370          } else {
;;;371            /* fragment with the lowest offset */
;;;372            ipr->p = new_p;
000448  0587b004          STREQ    r11,[r7,#4]
00044c  0a00000d          BEQ      |L1.1160|
000450  e5d50007          LDRB     r0,[r5,#7]            ;364
000454  e5d51006          LDRB     r1,[r5,#6]            ;364
000458  e1810400          ORR      r0,r1,r0,LSL #8       ;364
00045c  e1590000          CMP      r9,r0                 ;364
000460  3a000085          BCC      |L1.1660|
000464  e5d61005          LDRB     r1,[r6,#5]            ;364
000468  e5d62004          LDRB     r2,[r6,#4]            ;364
00046c  e59d0000          LDR      r0,[sp,#0]            ;364
000470  e1821401          ORR      r1,r2,r1,LSL #8       ;364
000474  e1510000          CMP      r1,r0                 ;364
000478  3a00007f          BCC      |L1.1660|
00047c  e1a01005          MOV      r1,r5                 ;369
000480  e1a0000b          MOV      r0,r11                ;369
000484  ebfffffe          BL       __aeabi_uwrite4
                  |L1.1160|
;;;373          }
;;;374          break;
;;;375        } else if(iprh->start == iprh_tmp->start) {
;;;376          /* received the same datagram twice: no need to keep the datagram */
;;;377          goto freepbuf;
;;;378    #if IP_REASS_CHECK_OVERLAP
;;;379        } else if(iprh->start < iprh_tmp->end) {
;;;380          /* overlap: no need to keep the new datagram */
;;;381          goto freepbuf;
;;;382    #endif /* IP_REASS_CHECK_OVERLAP */
;;;383        } else {
;;;384          /* Check if the fragments received so far have no wholes. */
;;;385          if (iprh_prev != NULL) {
;;;386            if (iprh_prev->end != iprh_tmp->start) {
;;;387              /* There is a fragment missing between the current
;;;388               * and the previous fragment */
;;;389              valid = 0;
;;;390            }
;;;391          }
;;;392        }
;;;393        q = iprh_tmp->next_pbuf;
;;;394        iprh_prev = iprh_tmp;
;;;395      }
;;;396    
;;;397      /* If q is NULL, then we made it to the end of the list. Determine what to do now */
;;;398      if (q == NULL) {
000488  e35a0000          CMP      r10,#0
00048c  0a000013          BEQ      |L1.1248|
000490  ea000036          B        |L1.1392|
                  |L1.1172|
000494  0a000078          BEQ      |L1.1660|
000498  e5d61007          LDRB     r1,[r6,#7]            ;379
00049c  e5d62006          LDRB     r2,[r6,#6]            ;379
0004a0  e1821401          ORR      r1,r2,r1,LSL #8       ;379
0004a4  e1590001          CMP      r9,r1                 ;379
0004a8  3a000073          BCC      |L1.1660|
0004ac  e3550000          CMP      r5,#0                 ;385
0004b0  0a000004          BEQ      |L1.1224|
0004b4  e5d51007          LDRB     r1,[r5,#7]            ;386
0004b8  e5d52006          LDRB     r2,[r5,#6]            ;386
0004bc  e1821401          ORR      r1,r2,r1,LSL #8       ;386
0004c0  e1510000          CMP      r1,r0                 ;386
0004c4  13a08000          MOVNE    r8,#0                 ;389
                  |L1.1224|
0004c8  e1a00006          MOV      r0,r6                 ;393
0004cc  ebfffffe          BL       __aeabi_uread4
0004d0  e1a0a000          MOV      r10,r0                ;393
0004d4  e1a05006          MOV      r5,r6                 ;394
                  |L1.1240|
0004d8  e35a0000          CMP      r10,#0                ;356
0004dc  1affffcf          BNE      |L1.1056|
                  |L1.1248|
;;;399        if (iprh_prev != NULL) {
0004e0  e3550000          CMP      r5,#0
0004e4  0a000018          BEQ      |L1.1356|
;;;400          /* this is (for now), the fragment with the highest offset:
;;;401           * chain it to the last fragment */
;;;402    #if IP_REASS_CHECK_OVERLAP
;;;403          LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
0004e8  e5d50007          LDRB     r0,[r5,#7]
0004ec  e5d51006          LDRB     r1,[r5,#6]
0004f0  e5d42004          LDRB     r2,[r4,#4]
0004f4  e1810400          ORR      r0,r1,r0,LSL #8
0004f8  e5d41005          LDRB     r1,[r4,#5]
0004fc  e1821401          ORR      r1,r2,r1,LSL #8
000500  e1500001          CMP      r0,r1
000504  9a000004          BLS      |L1.1308|
000508  e59f232c          LDR      r2,|L1.2108|
00050c  e24f3fc5          ADR      r3,|L1.512|
000510  e28f1fca          ADR      r1,|L1.2112|
000514  e24f0fb6          ADR      r0,|L1.580|
000518  ebfffffe          BL       sysprintf
                  |L1.1308|
;;;404    #endif /* IP_REASS_CHECK_OVERLAP */
;;;405          iprh_prev->next_pbuf = new_p;
00051c  e1a01005          MOV      r1,r5
000520  e1a0000b          MOV      r0,r11
000524  ebfffffe          BL       __aeabi_uwrite4
;;;406          if (iprh_prev->end != iprh->start) {
000528  e5d50007          LDRB     r0,[r5,#7]
00052c  e5d51006          LDRB     r1,[r5,#6]
000530  e5d42004          LDRB     r2,[r4,#4]
000534  e1810400          ORR      r0,r1,r0,LSL #8
000538  e5d41005          LDRB     r1,[r4,#5]
00053c  e1821401          ORR      r1,r2,r1,LSL #8
000540  e1500001          CMP      r0,r1
;;;407            valid = 0;
000544  13a08000          MOVNE    r8,#0
000548  ea000008          B        |L1.1392|
                  |L1.1356|
;;;408          }
;;;409        } else {
;;;410    #if IP_REASS_CHECK_OVERLAP
;;;411          LWIP_ASSERT("no previous fragment, this must be the first fragment!",
00054c  e5970004          LDR      r0,[r7,#4]
000550  e3500000          CMP      r0,#0
000554  0a000004          BEQ      |L1.1388|
000558  e59f2300          LDR      r2,|L1.2144|
00055c  e24f3fd9          ADR      r3,|L1.512|
000560  e28f1fbf          ADR      r1,|L1.2148|
000564  e24f0fca          ADR      r0,|L1.580|
000568  ebfffffe          BL       sysprintf
                  |L1.1388|
;;;412            ipr->p == NULL);
;;;413    #endif /* IP_REASS_CHECK_OVERLAP */
;;;414          /* this is the first fragment we ever received for this ip datagram */
;;;415          ipr->p = new_p;
00056c  e587b004          STR      r11,[r7,#4]
                  |L1.1392|
;;;416        }
;;;417      }
;;;418    
;;;419      /* At this point, the validation part begins: */
;;;420      /* If we already received the last fragment */
;;;421      if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
000570  e5d7001e          LDRB     r0,[r7,#0x1e]
000574  e2100001          ANDS     r0,r0,#1
000578  0a00003e          BEQ      |L1.1656|
;;;422        /* and had no wholes so far */
;;;423        if (valid) {
00057c  e3580000          CMP      r8,#0
000580  0a00003b          BEQ      |L1.1652|
;;;424          /* then check if the rest of the fragments is here */
;;;425          /* Check if the queue starts with the first datagram */
;;;426          if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
000584  e5976004          LDR      r6,[r7,#4]
000588  e5960004          LDR      r0,[r6,#4]
00058c  e5d01005          LDRB     r1,[r0,#5]
000590  e5d00004          LDRB     r0,[r0,#4]
000594  e1900401          ORRS     r0,r0,r1,LSL #8
000598  1a00000d          BNE      |L1.1492|
                  |L1.1436|
;;;427            valid = 0;
;;;428          } else {
;;;429            /* and check that there are no wholes after this datagram */
;;;430            iprh_prev = iprh;
00059c  e1a05004          MOV      r5,r4
;;;431            q = iprh->next_pbuf;
0005a0  e1a00005          MOV      r0,r5
0005a4  ebfffffe          BL       __aeabi_uread4
;;;432            while (q != NULL) {
0005a8  e3500000          CMP      r0,#0
0005ac  0a00000a          BEQ      |L1.1500|
;;;433              iprh = (struct ip_reass_helper*)q->payload;
0005b0  e5904004          LDR      r4,[r0,#4]
;;;434              if (iprh_prev->end != iprh->start) {
0005b4  e5d50007          LDRB     r0,[r5,#7]
0005b8  e5d51006          LDRB     r1,[r5,#6]
0005bc  e5d42004          LDRB     r2,[r4,#4]
0005c0  e1810400          ORR      r0,r1,r0,LSL #8
0005c4  e5d41005          LDRB     r1,[r4,#5]
0005c8  e1821401          ORR      r1,r2,r1,LSL #8
0005cc  e1500001          CMP      r0,r1
0005d0  0afffff1          BEQ      |L1.1436|
                  |L1.1492|
;;;435                valid = 0;
0005d4  e3a08000          MOV      r8,#0
;;;436                break;
0005d8  ea000025          B        |L1.1652|
                  |L1.1500|
;;;437              }
;;;438              iprh_prev = iprh;
;;;439              q = iprh->next_pbuf;
;;;440            }
;;;441            /* if still valid, all fragments are received
;;;442             * (because to the MF==0 already arrived */
;;;443            if (valid) {
0005dc  e3580000          CMP      r8,#0
0005e0  0a000023          BEQ      |L1.1652|
;;;444              LWIP_ASSERT("sanity check", ipr->p != NULL);
0005e4  e3560000          CMP      r6,#0
0005e8  1a000004          BNE      |L1.1536|
0005ec  e24f3ffd          ADR      r3,|L1.512|
0005f0  e3a02f6f          MOV      r2,#0x1bc
0005f4  e28f1e2a          ADR      r1,|L1.2204|
0005f8  e24f0fef          ADR      r0,|L1.580|
0005fc  ebfffffe          BL       sysprintf
                  |L1.1536|
;;;445              LWIP_ASSERT("sanity check",
000600  e5970004          LDR      r0,[r7,#4]
000604  e5900004          LDR      r0,[r0,#4]
000608  e1500004          CMP      r0,r4
00060c  1a000004          BNE      |L1.1572|
000610  e59f3294          LDR      r3,|L1.2220|
000614  e59f2294          LDR      r2,|L1.2224|
000618  e28f1f9f          ADR      r1,|L1.2204|
00061c  e24f0e3e          ADR      r0,|L1.580|
000620  ebfffffe          BL       sysprintf
                  |L1.1572|
;;;446                ((struct ip_reass_helper*)ipr->p->payload) != iprh);
;;;447              LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
000624  e1a00004          MOV      r0,r4
000628  ebfffffe          BL       __aeabi_uread4
00062c  e3500000          CMP      r0,#0
000630  0a000004          BEQ      |L1.1608|
000634  e59f3270          LDR      r3,|L1.2220|
000638  e59f2274          LDR      r2,|L1.2228|
00063c  e59f0298          LDR      r0,|L1.2268|
000640  e28f1e27          ADR      r1,|L1.2232|
000644  ebfffffe          BL       sysprintf
                  |L1.1608|
;;;448                iprh->next_pbuf == NULL);
;;;449              LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
000648  e5d40007          LDRB     r0,[r4,#7]
00064c  e5d41006          LDRB     r1,[r4,#6]
000650  e1810400          ORR      r0,r1,r0,LSL #8
000654  e1d711bc          LDRH     r1,[r7,#0x1c]
000658  e1500001          CMP      r0,r1
00065c  0a000004          BEQ      |L1.1652|
000660  e59f3244          LDR      r3,|L1.2220|
000664  e59f2274          LDR      r2,|L1.2272|
000668  e59f026c          LDR      r0,|L1.2268|
00066c  e28f1e27          ADR      r1,|L1.2276|
000670  ebfffffe          BL       sysprintf
                  |L1.1652|
;;;450                iprh->end == ipr->datagram_len);
;;;451            }
;;;452          }
;;;453        }
;;;454        /* If valid is 0 here, there are some fragments missing in the middle
;;;455         * (since MF == 0 has already arrived). Such datagrams simply time out if
;;;456         * no more fragments are received... */
;;;457        return valid;
000674  e1a00008          MOV      r0,r8
                  |L1.1656|
;;;458      }
;;;459      /* If we come here, not all fragments were received, yet! */
;;;460      return 0; /* not yet valid! */
;;;461    #if IP_REASS_CHECK_OVERLAP
;;;462    freepbuf:
;;;463      ip_reass_pbufcount -= pbuf_clen(new_p);
;;;464      pbuf_free(new_p);
;;;465      return 0;
;;;466    #endif /* IP_REASS_CHECK_OVERLAP */
;;;467    }
000678  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.1660|
00067c  e1a0000b          MOV      r0,r11                ;463
000680  ebfffffe          BL       pbuf_clen
000684  e1a01000          MOV      r1,r0                 ;463
000688  e51f0494          LDR      r0,|L1.508|
00068c  e1d020b0          LDRH     r2,[r0,#0]            ;463  ; ip_reass_pbufcount
000690  e0421001          SUB      r1,r2,r1              ;463
000694  e1c010b0          STRH     r1,[r0,#0]            ;463  ; ip_reass_pbufcount
000698  e1a0000b          MOV      r0,r11                ;464
00069c  ebfffffe          BL       pbuf_free
0006a0  e3a00000          MOV      r0,#0                 ;465
0006a4  e8bd8ff8          POP      {r3-r11,pc}
;;;468    
                          ENDP

                  ip_reass PROC
;;;475    struct pbuf *
;;;476    ip_reass(struct pbuf *p)
0006a8  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;477    {
;;;478      struct pbuf *r;
;;;479      struct ip_hdr *fraghdr;
;;;480      struct ip_reassdata *ipr;
;;;481      struct ip_reass_helper *iprh;
;;;482      u16_t offset, len;
;;;483      u8_t clen;
;;;484      struct ip_reassdata *ipr_prev = NULL;
;;;485    
;;;486      IPFRAG_STATS_INC(ip_frag.recv);
;;;487      snmp_inc_ipreasmreqds();
;;;488    
;;;489      fraghdr = (struct ip_hdr*)p->payload;
0006ac  e59d0000          LDR      r0,[sp,#0]
0006b0  e3a07000          MOV      r7,#0                 ;484
0006b4  e5904004          LDR      r4,[r0,#4]
;;;490    
;;;491      if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
0006b8  e5d40000          LDRB     r0,[r4,#0]
0006bc  e200000f          AND      r0,r0,#0xf
0006c0  e3500005          CMP      r0,#5
0006c4  1a0000e3          BNE      |L1.2648|
;;;492        LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
;;;493        IPFRAG_STATS_INC(ip_frag.err);
;;;494        goto nullreturn;
;;;495      }
;;;496    
;;;497      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
0006c8  e5d40007          LDRB     r0,[r4,#7]
0006cc  e5d41006          LDRB     r1,[r4,#6]
0006d0  e1810400          ORR      r0,r1,r0,LSL #8
0006d4  ebfffffe          BL       lwip_ntohs
0006d8  e3c00a0e          BIC      r0,r0,#0xe000
0006dc  e1a0a180          LSL      r10,r0,#3
;;;498      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
0006e0  e5d40003          LDRB     r0,[r4,#3]
0006e4  e5d41002          LDRB     r1,[r4,#2]
0006e8  e1810400          ORR      r0,r1,r0,LSL #8
0006ec  ebfffffe          BL       lwip_ntohs
0006f0  e5d41000          LDRB     r1,[r4,#0]
0006f4  e201100f          AND      r1,r1,#0xf
0006f8  e2611000          RSB      r1,r1,#0
0006fc  e0800101          ADD      r0,r0,r1,LSL #2
000700  e1a09800          LSL      r9,r0,#16
;;;499    
;;;500      /* Check if we are allowed to enqueue more datagrams. */
;;;501      clen = pbuf_clen(p);
000704  e59d0000          LDR      r0,[sp,#0]
000708  e1a09829          LSR      r9,r9,#16             ;498
00070c  ebfffffe          BL       pbuf_clen
;;;502      if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
000710  e51f851c          LDR      r8,|L1.508|
000714  e1a06000          MOV      r6,r0                 ;501
000718  e1d800b0          LDRH     r0,[r8,#0]  ; ip_reass_pbufcount
00071c  e0800006          ADD      r0,r0,r6
000720  e3500004          CMP      r0,#4
000724  9a000008          BLS      |L1.1868|
;;;503    #if IP_REASS_FREE_OLDEST
;;;504        if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
000728  e1a01006          MOV      r1,r6
00072c  e1a00004          MOV      r0,r4
000730  ebfffffe          BL       ip_reass_remove_oldest_datagram
000734  e3500000          CMP      r0,#0
000738  0a0000c6          BEQ      |L1.2648|
;;;505            ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
00073c  e1d800b0          LDRH     r0,[r8,#0]  ; ip_reass_pbufcount
000740  e0800006          ADD      r0,r0,r6
000744  e3500004          CMP      r0,#4
000748  8a0000c2          BHI      |L1.2648|
                  |L1.1868|
;;;506    #endif /* IP_REASS_FREE_OLDEST */
;;;507        {
;;;508          /* No datagram could be freed and still too many pbufs enqueued */
;;;509          LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
;;;510            ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
;;;511          IPFRAG_STATS_INC(ip_frag.memerr);
;;;512          /* @todo: send ICMP time exceeded here? */
;;;513          /* drop this pbuf */
;;;514          goto nullreturn;
;;;515        }
;;;516      }
;;;517    
;;;518      /* Look for the datagram the fragment belongs to in the current datagram queue,
;;;519       * remembering the previous in the queue for later dequeueing. */
;;;520      for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
00074c  e5985004          LDR      r5,[r8,#4]  ; reassdatagrams
000750  e3a0b000          MOV      r11,#0
000754  ea000011          B        |L1.1952|
                  |L1.1880|
;;;521        /* Check if the incoming fragment matches the one currently present
;;;522           in the reassembly buffer. If so, we proceed with copying the
;;;523           fragment into the buffer. */
;;;524        if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
000758  e284000c          ADD      r0,r4,#0xc
00075c  ebfffffe          BL       __aeabi_uread4
000760  e5951014          LDR      r1,[r5,#0x14]
000764  e1500001          CMP      r0,r1
000768  1a00000a          BNE      |L1.1944|
00076c  e2840010          ADD      r0,r4,#0x10
000770  ebfffffe          BL       __aeabi_uread4
000774  e5951018          LDR      r1,[r5,#0x18]
000778  e1500001          CMP      r0,r1
00077c  1a000005          BNE      |L1.1944|
000780  e5d41005          LDRB     r1,[r4,#5]
000784  e5d42004          LDRB     r2,[r4,#4]
000788  e1d500bc          LDRH     r0,[r5,#0xc]
00078c  e1821401          ORR      r1,r2,r1,LSL #8
000790  e1500001          CMP      r0,r1
000794  0a000004          BEQ      |L1.1964|
                  |L1.1944|
;;;525          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
;;;526            ntohs(IPH_ID(fraghdr))));
;;;527          IPFRAG_STATS_INC(ip_frag.cachehit);
;;;528          break;
;;;529        }
;;;530        ipr_prev = ipr;
000798  e1a07005          MOV      r7,r5
00079c  e5955000          LDR      r5,[r5,#0]            ;520
                  |L1.1952|
0007a0  e3550000          CMP      r5,#0                 ;520
0007a4  1affffeb          BNE      |L1.1880|
0007a8  ea000008          B        |L1.2000|
                  |L1.1964|
;;;531      }
;;;532    
;;;533      if (ipr == NULL) {
0007ac  e3550000          CMP      r5,#0
0007b0  0a000006          BEQ      |L1.2000|
;;;534      /* Enqueue a new datagram into the datagram queue */
;;;535        ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
;;;536        /* Bail if unable to enqueue */
;;;537        if(ipr == NULL) {
;;;538          goto nullreturn;
;;;539        }
;;;540      } else {
;;;541        if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
0007b4  e5d40007          LDRB     r0,[r4,#7]
0007b8  e5d41006          LDRB     r1,[r4,#6]
0007bc  e1810400          ORR      r0,r1,r0,LSL #8
0007c0  ebfffffe          BL       lwip_ntohs
0007c4  e1b00980          LSLS     r0,r0,#19
0007c8  0a000053          BEQ      |L1.2332|
0007cc  ea00005a          B        |L1.2364|
                  |L1.2000|
0007d0  e3a00004          MOV      r0,#4
0007d4  ebfffffe          BL       memp_malloc
0007d8  e1b05000          MOVS     r5,r0
0007dc  1a000008          BNE      |L1.2052|
0007e0  e1a01006          MOV      r1,r6
0007e4  e1a00004          MOV      r0,r4
0007e8  ebfffffe          BL       ip_reass_remove_oldest_datagram
0007ec  e1500006          CMP      r0,r6
0007f0  ba000047          BLT      |L1.2324|
0007f4  e3a00004          MOV      r0,#4
0007f8  ebfffffe          BL       memp_malloc
0007fc  e1b05000          MOVS     r5,r0
000800  0a000043          BEQ      |L1.2324|
                  |L1.2052|
000804  e3a01020          MOV      r1,#0x20
000808  ebfffffe          BL       __aeabi_memclr4
00080c  e3a00003          MOV      r0,#3
000810  e5c5001f          STRB     r0,[r5,#0x1f]
000814  e5980004          LDR      r0,[r8,#4]  ; reassdatagrams
000818  e3a02014          MOV      r2,#0x14
00081c  e5850000          STR      r0,[r5,#0]
000820  e1a01004          MOV      r1,r4
000824  e2850008          ADD      r0,r5,#8
000828  e5885004          STR      r5,[r8,#4]  ; reassdatagrams
00082c  ebfffffe          BL       __aeabi_memcpy
                  |L1.2096|
000830  e3550000          CMP      r5,#0                 ;537
000834  0a000087          BEQ      |L1.2648|
000838  ea00003f          B        |L1.2364|
                  |L1.2108|
                          DCD      0x00000193
                  |L1.2112|
000840  63686563          DCB      "check fragments don't overlap",0
000844  6b206672
000848  61676d65
00084c  6e747320
000850  646f6e27
000854  74206f76
000858  65726c61
00085c  7000    
00085e  00                DCB      0
00085f  00                DCB      0
                  |L1.2144|
                          DCD      0x0000019b
                  |L1.2148|
000864  6e6f2070          DCB      "no previous fragment, this must be the first fragment!",0
000868  72657669
00086c  6f757320
000870  66726167
000874  6d656e74
000878  2c207468
00087c  6973206d
000880  75737420
000884  62652074
000888  68652066
00088c  69727374
000890  20667261
000894  676d656e
000898  742100  
00089b  00                DCB      0
                  |L1.2204|
00089c  73616e69          DCB      "sanity check",0
0008a0  74792063
0008a4  6865636b
0008a8  00      
0008a9  00                DCB      0
0008aa  00                DCB      0
0008ab  00                DCB      0
                  |L1.2220|
                          DCD      ||.text||+0x200
                  |L1.2224|
                          DCD      0x000001bd
                  |L1.2228|
                          DCD      0x000001bf
                  |L1.2232|
0008b8  76616c69          DCB      "validate_datagram:next_pbuf!=NULL",0
0008bc  64617465
0008c0  5f646174
0008c4  61677261
0008c8  6d3a6e65
0008cc  78745f70
0008d0  62756621
0008d4  3d4e554c
0008d8  4c00    
0008da  00                DCB      0
0008db  00                DCB      0
                  |L1.2268|
                          DCD      ||.text||+0x244
                  |L1.2272|
                          DCD      0x000001c1
                  |L1.2276|
0008e4  76616c69          DCB      "validate_datagram:datagram end!=datagram len",0
0008e8  64617465
0008ec  5f646174
0008f0  61677261
0008f4  6d3a6461
0008f8  74616772
0008fc  616d2065
000900  6e64213d
000904  64617461
000908  6772616d
00090c  206c656e
000910  00      
000911  00                DCB      0
000912  00                DCB      0
000913  00                DCB      0
                  |L1.2324|
000914  e1a0500b          MOV      r5,r11                ;537
000918  eaffffc4          B        |L1.2096|
                  |L1.2332|
;;;542          ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
00091c  e1d500be          LDRH     r0,[r5,#0xe]
000920  ebfffffe          BL       lwip_ntohs
000924  e1b00980          LSLS     r0,r0,#19
000928  0a000003          BEQ      |L1.2364|
;;;543          /* ipr->iphdr is not the header from the first fragment, but fraghdr is
;;;544           * -> copy fraghdr into ipr->iphdr since we want to have the header
;;;545           * of the first fragment (for ICMP time exceeded and later, for copying
;;;546           * all options, if supported)*/
;;;547          SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
00092c  e3a02014          MOV      r2,#0x14
000930  e1a01004          MOV      r1,r4
000934  e2850008          ADD      r0,r5,#8
000938  ebfffffe          BL       __aeabi_memcpy
                  |L1.2364|
;;;548        }
;;;549      }
;;;550      /* Track the current number of pbufs current 'in-flight', in order to limit 
;;;551      the number of fragments that may be enqueued at any one time */
;;;552      ip_reass_pbufcount += clen;
00093c  e1d800b0          LDRH     r0,[r8,#0]  ; ip_reass_pbufcount
000940  e0800006          ADD      r0,r0,r6
000944  e1c800b0          STRH     r0,[r8,#0]  ; ip_reass_pbufcount
;;;553    
;;;554      /* At this point, we have either created a new entry or pointing 
;;;555       * to an existing one */
;;;556    
;;;557      /* check for 'no more fragments', and update queue entry*/
;;;558      if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
000948  e5d41007          LDRB     r1,[r4,#7]
00094c  e5d40006          LDRB     r0,[r4,#6]
000950  e1800401          ORR      r0,r0,r1,LSL #8
000954  e3100020          TST      r0,#0x20
000958  1a000004          BNE      |L1.2416|
;;;559        ipr->flags |= IP_REASS_FLAG_LASTFRAG;
00095c  e5d5001e          LDRB     r0,[r5,#0x1e]
000960  e3800001          ORR      r0,r0,#1
000964  e5c5001e          STRB     r0,[r5,#0x1e]
;;;560        ipr->datagram_len = offset + len;
000968  e08a0009          ADD      r0,r10,r9
00096c  e1c501bc          STRH     r0,[r5,#0x1c]
                  |L1.2416|
;;;561        LWIP_DEBUGF(IP_REASS_DEBUG,
;;;562         ("ip_reass: last fragment seen, total len %"S16_F"\n",
;;;563          ipr->datagram_len));
;;;564      }
;;;565      /* find the right place to insert this pbuf */
;;;566      /* @todo: trim pbufs if fragments are overlapping */
;;;567      if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
000970  e59d1000          LDR      r1,[sp,#0]
000974  e1a00005          MOV      r0,r5
000978  ebfffffe          BL       ip_reass_chain_frag_into_datagram_and_validate
00097c  e3500000          CMP      r0,#0
000980  0a000033          BEQ      |L1.2644|
;;;568        /* the totally last fragment (flag more fragments = 0) was received at least
;;;569         * once AND all fragments are received */
;;;570        ipr->datagram_len += IP_HLEN;
000984  e1d501bc          LDRH     r0,[r5,#0x1c]
000988  e2800014          ADD      r0,r0,#0x14
00098c  e1c501bc          STRH     r0,[r5,#0x1c]
;;;571    
;;;572        /* save the second pbuf before copying the header over the pointer */
;;;573        r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
000990  e5950004          LDR      r0,[r5,#4]
000994  e5904004          LDR      r4,[r0,#4]
000998  e1a00004          MOV      r0,r4
00099c  ebfffffe          BL       __aeabi_uread4
0009a0  e1a06000          MOV      r6,r0
;;;574    
;;;575        /* copy the original ip header back to the first pbuf */
;;;576        fraghdr = (struct ip_hdr*)(ipr->p->payload);
;;;577        SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
0009a4  e3a02014          MOV      r2,#0x14
0009a8  e2851008          ADD      r1,r5,#8
0009ac  e1a00004          MOV      r0,r4
0009b0  ebfffffe          BL       __aeabi_memcpy
;;;578        IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
0009b4  e1d501bc          LDRH     r0,[r5,#0x1c]
0009b8  ebfffffe          BL       lwip_htons
0009bc  e5c40002          STRB     r0,[r4,#2]
0009c0  e1a00420          LSR      r0,r0,#8
0009c4  e5c40003          STRB     r0,[r4,#3]
;;;579        IPH_OFFSET_SET(fraghdr, 0);
0009c8  e1a0042b          LSR      r0,r11,#8
0009cc  e5c4b006          STRB     r11,[r4,#6]
0009d0  e5c40007          STRB     r0,[r4,#7]
;;;580        IPH_CHKSUM_SET(fraghdr, 0);
0009d4  e1a0042b          LSR      r0,r11,#8
0009d8  e5c4b00a          STRB     r11,[r4,#0xa]
0009dc  e5c4000b          STRB     r0,[r4,#0xb]
;;;581        /* @todo: do we need to set calculate the correct checksum? */
;;;582        IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
0009e0  e3a01014          MOV      r1,#0x14
0009e4  e1a00004          MOV      r0,r4
0009e8  ebfffffe          BL       inet_chksum
0009ec  e5c4000a          STRB     r0,[r4,#0xa]
0009f0  e1a00420          LSR      r0,r0,#8
0009f4  e5c4000b          STRB     r0,[r4,#0xb]
;;;583    
;;;584        p = ipr->p;
0009f8  e5959004          LDR      r9,[r5,#4]
;;;585    
;;;586        /* chain together the pbufs contained within the reass_data list. */
;;;587        while(r != NULL) {
0009fc  ea000009          B        |L1.2600|
                  |L1.2560|
;;;588          iprh = (struct ip_reass_helper*)r->payload;
;;;589    
;;;590          /* hide the ip header for every succeding fragment */
;;;591          pbuf_header(r, -IP_HLEN);
000a00  e5964004          LDR      r4,[r6,#4]
000a04  e3e01013          MVN      r1,#0x13
000a08  e1a00006          MOV      r0,r6
000a0c  ebfffffe          BL       pbuf_header
;;;592          pbuf_cat(p, r);
000a10  e1a01006          MOV      r1,r6
000a14  e1a00009          MOV      r0,r9
000a18  ebfffffe          BL       pbuf_cat
;;;593          r = iprh->next_pbuf;
000a1c  e1a00004          MOV      r0,r4
000a20  ebfffffe          BL       __aeabi_uread4
000a24  e1a06000          MOV      r6,r0
                  |L1.2600|
000a28  e3560000          CMP      r6,#0                 ;587
000a2c  1afffff3          BNE      |L1.2560|
;;;594        }
;;;595        /* release the sources allocate for the fragment queue entry */
;;;596        ip_reass_dequeue_datagram(ipr, ipr_prev);
000a30  e1a01007          MOV      r1,r7
000a34  e1a00005          MOV      r0,r5
000a38  ebfffffe          BL       ip_reass_dequeue_datagram
;;;597    
;;;598        /* and adjust the number of pbufs currently queued for reassembly. */
;;;599        ip_reass_pbufcount -= pbuf_clen(p);
000a3c  e1a00009          MOV      r0,r9
000a40  ebfffffe          BL       pbuf_clen
000a44  e1d810b0          LDRH     r1,[r8,#0]  ; ip_reass_pbufcount
000a48  e0410000          SUB      r0,r1,r0
000a4c  e1c800b0          STRH     r0,[r8,#0]  ; ip_reass_pbufcount
;;;600    
;;;601        /* Return the pbuf chain */
;;;602        return p;
000a50  e1a00009          MOV      r0,r9
                  |L1.2644|
;;;603      }
;;;604      /* the datagram is not (yet?) reassembled completely */
;;;605      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
;;;606      return NULL;
;;;607    
;;;608    nullreturn:
;;;609      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
;;;610      IPFRAG_STATS_INC(ip_frag.drop);
;;;611      pbuf_free(p);
;;;612      return NULL;
;;;613    }
000a54  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.2648|
000a58  e59d0000          LDR      r0,[sp,#0]            ;611
000a5c  ebfffffe          BL       pbuf_free
000a60  e3a00000          MOV      r0,#0                 ;612
000a64  e8bd8ff8          POP      {r3-r11,pc}
;;;614    #endif /* IP_REASSEMBLY */
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  ip_reass_pbufcount
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  reassdatagrams
                          DCD      0x00000000
