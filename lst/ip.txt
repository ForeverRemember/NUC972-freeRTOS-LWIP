; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\ip.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ip.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\ip.crf lwip-1.4.1\src\core\ipv4\ip.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ip_route PROC
;;;123    struct netif *
;;;124    ip_route(ip_addr_t *dest)
000000  e1a02000          MOV      r2,r0
;;;125    {
;;;126      struct netif *netif;
;;;127    
;;;128    #ifdef LWIP_HOOK_IP4_ROUTE
;;;129      netif = LWIP_HOOK_IP4_ROUTE(dest);
;;;130      if (netif != NULL) {
;;;131        return netif;
;;;132      }
;;;133    #endif
;;;134    
;;;135      /* iterate through netifs */
;;;136      for (netif = netif_list; netif != NULL; netif = netif->next) {
000004  e59f04a4          LDR      r0,|L1.1200|
000008  ea000009          B        |L1.52|
                  |L1.12|
;;;137        /* network mask matches? */
;;;138        if (netif_is_up(netif)) {
00000c  e5d0102d          LDRB     r1,[r0,#0x2d]
000010  e3110001          TST      r1,#1
000014  0a000006          BEQ      |L1.52|
;;;139          if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
000018  e5923000          LDR      r3,[r2,#0]
00001c  e5901008          LDR      r1,[r0,#8]
000020  e590c004          LDR      r12,[r0,#4]
000024  e0033001          AND      r3,r3,r1
000028  e001100c          AND      r1,r1,r12
00002c  e1530001          CMP      r3,r1
;;;140            /* return netif on which to forward IP packet */
;;;141            return netif;
;;;142          }
;;;143        }
;;;144      }
;;;145      if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
;;;146        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;147          ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
;;;148        IP_STATS_INC(ip.rterr);
;;;149        snmp_inc_ipoutnoroutes();
;;;150        return NULL;
;;;151      }
;;;152      /* no matching netif found, use default netif */
;;;153      return netif_default;
;;;154    }
000030  012fff1e          BXEQ     lr
                  |L1.52|
000034  e5900000          LDR      r0,[r0,#0]            ;136
000038  e3500000          CMP      r0,#0                 ;136
00003c  1afffff2          BNE      |L1.12|
000040  e59f046c          LDR      r0,|L1.1204|
000044  e5900000          LDR      r0,[r0,#0]            ;145  ; netif_default
000048  e3500000          CMP      r0,#0                 ;145
00004c  15d0102d          LDRBNE   r1,[r0,#0x2d]         ;145
000050  13110001          TSTNE    r1,#1                 ;145
000054  03a00000          MOVEQ    r0,#0                 ;150
000058  e12fff1e          BX       lr
;;;155    
                          ENDP

                  ip_input PROC
;;;304    err_t
;;;305    ip_input(struct pbuf *p, struct netif *inp)
00005c  e92d4ff8          PUSH     {r3-r11,lr}
;;;306    {
000060  e1a06000          MOV      r6,r0
;;;307      struct ip_hdr *iphdr;
;;;308      struct netif *netif;
;;;309      u16_t iphdr_hlen;
;;;310      u16_t iphdr_len;
;;;311    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;312      int check_ip_src=1;
000064  e3a00001          MOV      r0,#1
;;;313    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;314    
;;;315      IP_STATS_INC(ip.recv);
;;;316      snmp_inc_ipinreceives();
;;;317    
;;;318      /* identify the IP header */
;;;319      iphdr = (struct ip_hdr *)p->payload;
000068  e58d0000          STR      r0,[sp,#0]
00006c  e5965004          LDR      r5,[r6,#4]
000070  e1a07001          MOV      r7,r1                 ;306
;;;320      if (IPH_V(iphdr) != 4) {
000074  e5d50000          LDRB     r0,[r5,#0]
000078  e3a01004          MOV      r1,#4
00007c  e1510220          CMP      r1,r0,LSR #4
000080  1a000011          BNE      |L1.204|
;;;321        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
;;;322        ip_debug_print(p);
;;;323        pbuf_free(p);
;;;324        IP_STATS_INC(ip.err);
;;;325        IP_STATS_INC(ip.drop);
;;;326        snmp_inc_ipinhdrerrors();
;;;327        return ERR_OK;
;;;328      }
;;;329    
;;;330    #ifdef LWIP_HOOK_IP4_INPUT
;;;331      if (LWIP_HOOK_IP4_INPUT(p, inp)) {
;;;332        /* the packet has been eaten */
;;;333        return ERR_OK;
;;;334      }
;;;335    #endif
;;;336    
;;;337      /* obtain IP header length in number of 32-bit words */
;;;338      iphdr_hlen = IPH_HL(iphdr);
000084  e200000f          AND      r0,r0,#0xf
;;;339      /* calculate IP header length in bytes */
;;;340      iphdr_hlen *= 4;
000088  e3e01803          MVN      r1,#0x30000
00008c  e0019100          AND      r9,r1,r0,LSL #2
;;;341      /* obtain ip length in bytes */
;;;342      iphdr_len = ntohs(IPH_LEN(iphdr));
000090  e5d50003          LDRB     r0,[r5,#3]
000094  e5d51002          LDRB     r1,[r5,#2]
000098  e1810400          ORR      r0,r1,r0,LSL #8
00009c  ebfffffe          BL       lwip_ntohs
0000a0  e1a04000          MOV      r4,r0
;;;343    
;;;344      /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
;;;345      if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
0000a4  e1d600ba          LDRH     r0,[r6,#0xa]
0000a8  e1500009          CMP      r0,r9
0000ac  21d600b8          LDRHCS   r0,[r6,#8]
0000b0  21500004          CMPCS    r0,r4
0000b4  3a000004          BCC      |L1.204|
;;;346        if (iphdr_hlen > p->len) {
;;;347          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;348            ("IP header (len %"U16_F") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",
;;;349            iphdr_hlen, p->len));
;;;350        }
;;;351        if (iphdr_len > p->tot_len) {
;;;352          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;353            ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
;;;354            iphdr_len, p->tot_len));
;;;355        }
;;;356        /* free (drop) packet pbufs */
;;;357        pbuf_free(p);
;;;358        IP_STATS_INC(ip.lenerr);
;;;359        IP_STATS_INC(ip.drop);
;;;360        snmp_inc_ipindiscards();
;;;361        return ERR_OK;
;;;362      }
;;;363    
;;;364      /* verify checksum */
;;;365    #if CHECKSUM_CHECK_IP
;;;366      if (inet_chksum(iphdr, iphdr_hlen) != 0) {
0000b8  e1a01009          MOV      r1,r9
0000bc  e1a00005          MOV      r0,r5
0000c0  ebfffffe          BL       inet_chksum
0000c4  e3500000          CMP      r0,#0
0000c8  0a000002          BEQ      |L1.216|
                  |L1.204|
0000cc  e1a00006          MOV      r0,r6                 ;323
0000d0  ebfffffe          BL       pbuf_free
0000d4  ea000058          B        |L1.572|
                  |L1.216|
;;;367    
;;;368        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;369          ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
;;;370        ip_debug_print(p);
;;;371        pbuf_free(p);
;;;372        IP_STATS_INC(ip.chkerr);
;;;373        IP_STATS_INC(ip.drop);
;;;374        snmp_inc_ipinhdrerrors();
;;;375        return ERR_OK;
;;;376      }
;;;377    #endif
;;;378    
;;;379      /* Trim pbuf. This should have been done at the netif layer,
;;;380       * but we'll do it anyway just to be sure that its done. */
;;;381      pbuf_realloc(p, iphdr_len);
0000d8  e1a01004          MOV      r1,r4
0000dc  e1a00006          MOV      r0,r6
0000e0  ebfffffe          BL       pbuf_realloc
;;;382    
;;;383      /* copy IP addresses to aligned ip_addr_t */
;;;384      ip_addr_copy(current_iphdr_dest, iphdr->dest);
0000e4  e2850010          ADD      r0,r5,#0x10
0000e8  ebfffffe          BL       __aeabi_uread4
0000ec  e59fa3c4          LDR      r10,|L1.1208|
0000f0  e58a0000          STR      r0,[r10,#0]  ; current_iphdr_dest
;;;385      ip_addr_copy(current_iphdr_src, iphdr->src);
0000f4  e285000c          ADD      r0,r5,#0xc
0000f8  ebfffffe          BL       __aeabi_uread4
0000fc  e24ab004          SUB      r11,r10,#4
;;;386    
;;;387      /* match packet against an interface, i.e. is this packet for us? */
;;;388    #if LWIP_IGMP
;;;389      if (ip_addr_ismulticast(&current_iphdr_dest)) {
;;;390        if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, &current_iphdr_dest))) {
;;;391          netif = inp;
;;;392        } else {
;;;393          netif = NULL;
;;;394        }
;;;395      } else
;;;396    #endif /* LWIP_IGMP */
;;;397      {
;;;398        /* start trying with inp. if that's not acceptable, start walking the
;;;399           list of configured netifs.
;;;400           'first' is used as a boolean to mark whether we started walking the list */
;;;401        int first = 1;
000100  e3a08001          MOV      r8,#1
;;;402        netif = inp;
000104  e1a04007          MOV      r4,r7
000108  e58b0000          STR      r0,[r11,#0]  ; current_iphdr_src
                  |L1.268|
;;;403        do {
;;;404          LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",
;;;405              ip4_addr_get_u32(&iphdr->dest), ip4_addr_get_u32(&netif->ip_addr),
;;;406              ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
;;;407              ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
;;;408              ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));
;;;409    
;;;410          /* interface is up and configured? */
;;;411          if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
00010c  e5d4002d          LDRB     r0,[r4,#0x2d]
000110  e3100001          TST      r0,#1
000114  13740004          CMNNE    r4,#4
000118  15941004          LDRNE    r1,[r4,#4]
00011c  13510000          CMPNE    r1,#0
000120  0a000009          BEQ      |L1.332|
;;;412            /* unicast to this interface address? */
;;;413            if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
000124  e59a0000          LDR      r0,[r10,#0]  ; current_iphdr_dest
000128  e1500001          CMP      r0,r1
00012c  0a000003          BEQ      |L1.320|
;;;414                /* or broadcast on this interface network address? */
;;;415                ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
000130  e1a01004          MOV      r1,r4
000134  ebfffffe          BL       ip4_addr_isbroadcast
000138  e3500000          CMP      r0,#0
00013c  0a000002          BEQ      |L1.332|
                  |L1.320|
;;;416              LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
;;;417                  netif->name[0], netif->name[1]));
;;;418              /* break out of for loop */
;;;419              break;
;;;420            }
;;;421    #if LWIP_AUTOIP
;;;422            /* connections to link-local addresses must persist after changing
;;;423               the netif's address (RFC3927 ch. 1.9) */
;;;424            if ((netif->autoip != NULL) &&
;;;425                ip_addr_cmp(&current_iphdr_dest, &(netif->autoip->llipaddr))) {
;;;426              LWIP_DEBUGF(IP_DEBUG, ("ip_input: LLA packet accepted on interface %c%c\n",
;;;427                  netif->name[0], netif->name[1]));
;;;428              /* break out of for loop */
;;;429              break;
;;;430            }
;;;431    #endif /* LWIP_AUTOIP */
;;;432          }
;;;433          if (first) {
;;;434            first = 0;
;;;435            netif = netif_list;
;;;436          } else {
;;;437            netif = netif->next;
;;;438          }
;;;439          if (netif == inp) {
;;;440            netif = netif->next;
;;;441          }
;;;442        } while(netif != NULL);
;;;443      }
;;;444    
;;;445    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;446      /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
;;;447       * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
;;;448       * According to RFC 1542 section 3.1.1, referred by RFC 2131).
;;;449       *
;;;450       * If you want to accept private broadcast communication while a netif is down,
;;;451       * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
;;;452       *
;;;453       * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
;;;454       */
;;;455      if (netif == NULL) {
000140  e3540000          CMP      r4,#0
000144  1a000013          BNE      |L1.408|
000148  ea000008          B        |L1.368|
                  |L1.332|
00014c  e3580000          CMP      r8,#0                 ;433
000150  159f0358          LDRNE    r0,|L1.1200|
000154  05944000          LDREQ    r4,[r4,#0]            ;437
000158  15904000          LDRNE    r4,[r0,#0]            ;435  ; netif_list
00015c  13a08000          MOVNE    r8,#0                 ;434
000160  e1540007          CMP      r4,r7                 ;439
000164  05944000          LDREQ    r4,[r4,#0]            ;440
000168  e3540000          CMP      r4,#0                 ;442
00016c  1affffe6          BNE      |L1.268|
                  |L1.368|
;;;456        /* remote port is DHCP server? */
;;;457        if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
000170  e5d50009          LDRB     r0,[r5,#9]
000174  e3500011          CMP      r0,#0x11
000178  1a000006          BNE      |L1.408|
;;;458          struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
00017c  e0850009          ADD      r0,r5,r9
;;;459          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
;;;460            ntohs(udphdr->dest)));
;;;461          if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
000180  e5d01003          LDRB     r1,[r0,#3]
000184  e5d00002          LDRB     r0,[r0,#2]
000188  e1800401          ORR      r0,r0,r1,LSL #8
00018c  e3500b11          CMP      r0,#0x4400
;;;462            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
;;;463            netif = inp;
000190  01a04007          MOVEQ    r4,r7
000194  0a00000c          BEQ      |L1.460|
                  |L1.408|
;;;464            check_ip_src = 0;
;;;465          }
;;;466        }
;;;467      }
;;;468    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;469    
;;;470      /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
;;;471    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;472      /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
;;;473      if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
000198  e59d0000          LDR      r0,[sp,#0]
00019c  e3500000          CMP      r0,#0
0001a0  159b0000          LDRNE    r0,[r11,#0]  ; current_iphdr_src
0001a4  13500000          CMPNE    r0,#0
0001a8  0a000007          BEQ      |L1.460|
;;;474    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;475      {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
0001ac  e1a01007          MOV      r1,r7
0001b0  ebfffffe          BL       ip4_addr_isbroadcast
0001b4  e3500000          CMP      r0,#0
0001b8  1affffc3          BNE      |L1.204|
;;;476             (ip_addr_ismulticast(&current_iphdr_src))) {
0001bc  e5db0000          LDRB     r0,[r11,#0]  ; current_iphdr_src
0001c0  e20000f0          AND      r0,r0,#0xf0
0001c4  e35000e0          CMP      r0,#0xe0
0001c8  0affffbf          BEQ      |L1.204|
                  |L1.460|
;;;477          /* packet source is not valid */
;;;478          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
;;;479          /* free (drop) packet pbufs */
;;;480          pbuf_free(p);
;;;481          IP_STATS_INC(ip.drop);
;;;482          snmp_inc_ipinaddrerrors();
;;;483          snmp_inc_ipindiscards();
;;;484          return ERR_OK;
;;;485        }
;;;486      }
;;;487    
;;;488      /* packet not for us? */
;;;489      if (netif == NULL) {
0001cc  e3540000          CMP      r4,#0
0001d0  0affffbd          BEQ      |L1.204|
;;;490        /* packet not for us, route or discard */
;;;491        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: packet not for us.\n"));
;;;492    #if IP_FORWARD
;;;493        /* non-broadcast packet? */
;;;494        if (!ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
;;;495          /* try to forward IP packet on (other) interfaces */
;;;496          ip_forward(p, iphdr, inp);
;;;497        } else
;;;498    #endif /* IP_FORWARD */
;;;499        {
;;;500          snmp_inc_ipinaddrerrors();
;;;501          snmp_inc_ipindiscards();
;;;502        }
;;;503        pbuf_free(p);
;;;504        return ERR_OK;
;;;505      }
;;;506      /* packet consists of multiple fragments? */
;;;507      if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
0001d4  e5d50007          LDRB     r0,[r5,#7]
0001d8  e5d51006          LDRB     r1,[r5,#6]
0001dc  e1810400          ORR      r0,r1,r0,LSL #8
0001e0  e3d000c0          BICS     r0,r0,#0xc0
0001e4  0a000004          BEQ      |L1.508|
;;;508    #if IP_REASSEMBLY /* packet fragment reassembly code present? */
;;;509        LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
;;;510          ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
;;;511        /* reassemble the packet*/
;;;512        p = ip_reass(p);
0001e8  e1a00006          MOV      r0,r6
0001ec  ebfffffe          BL       ip_reass
0001f0  e1b06000          MOVS     r6,r0
;;;513        /* packet not fully reassembled yet? */
;;;514        if (p == NULL) {
;;;515          return ERR_OK;
;;;516        }
;;;517        iphdr = (struct ip_hdr *)p->payload;
0001f4  15965004          LDRNE    r5,[r6,#4]
0001f8  0a00000f          BEQ      |L1.572|
                  |L1.508|
;;;518    #else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
;;;519        pbuf_free(p);
;;;520        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
;;;521          ntohs(IPH_OFFSET(iphdr))));
;;;522        IP_STATS_INC(ip.opterr);
;;;523        IP_STATS_INC(ip.drop);
;;;524        /* unsupported protocol feature */
;;;525        snmp_inc_ipinunknownprotos();
;;;526        return ERR_OK;
;;;527    #endif /* IP_REASSEMBLY */
;;;528      }
;;;529    
;;;530    #if IP_OPTIONS_ALLOWED == 0 /* no support for IP options in the IP header? */
;;;531    
;;;532    #if LWIP_IGMP
;;;533      /* there is an extra "router alert" option in IGMP messages which we allow for but do not police */
;;;534      if((iphdr_hlen > IP_HLEN) &&  (IPH_PROTO(iphdr) != IP_PROTO_IGMP)) {
;;;535    #else
;;;536      if (iphdr_hlen > IP_HLEN) {
;;;537    #endif /* LWIP_IGMP */
;;;538        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));
;;;539        pbuf_free(p);
;;;540        IP_STATS_INC(ip.opterr);
;;;541        IP_STATS_INC(ip.drop);
;;;542        /* unsupported protocol feature */
;;;543        snmp_inc_ipinunknownprotos();
;;;544        return ERR_OK;
;;;545      }
;;;546    #endif /* IP_OPTIONS_ALLOWED == 0 */
;;;547    
;;;548      /* send to upper layers */
;;;549      LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
;;;550      ip_debug_print(p);
;;;551      LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
;;;552    
;;;553      current_netif = inp;
0001fc  e59f42b8          LDR      r4,|L1.1212|
;;;554      current_header = iphdr;
000200  e5845008          STR      r5,[r4,#8]  ; current_netif, current_header
000204  e5847004          STR      r7,[r4,#4]
;;;555    
;;;556    #if LWIP_RAW
;;;557      /* raw input did not eat the packet? */
;;;558      if (raw_input(p, inp) == 0)
;;;559    #endif /* LWIP_RAW */
;;;560      {
;;;561        switch (IPH_PROTO(iphdr)) {
000208  e5d50009          LDRB     r0,[r5,#9]
00020c  e3500001          CMP      r0,#1
000210  0a000013          BEQ      |L1.612|
000214  e3500006          CMP      r0,#6
000218  0a00000d          BEQ      |L1.596|
00021c  e3500011          CMP      r0,#0x11
000220  0a000007          BEQ      |L1.580|
;;;562    #if LWIP_UDP
;;;563        case IP_PROTO_UDP:
;;;564    #if LWIP_UDPLITE
;;;565        case IP_PROTO_UDPLITE:
;;;566    #endif /* LWIP_UDPLITE */
;;;567          snmp_inc_ipindelivers();
;;;568          udp_input(p, inp);
;;;569          break;
;;;570    #endif /* LWIP_UDP */
;;;571    #if LWIP_TCP
;;;572        case IP_PROTO_TCP:
;;;573          snmp_inc_ipindelivers();
;;;574          tcp_input(p, inp);
;;;575          break;
;;;576    #endif /* LWIP_TCP */
;;;577    #if LWIP_ICMP
;;;578        case IP_PROTO_ICMP:
;;;579          snmp_inc_ipindelivers();
;;;580          icmp_input(p, inp);
;;;581          break;
;;;582    #endif /* LWIP_ICMP */
;;;583    #if LWIP_IGMP
;;;584        case IP_PROTO_IGMP:
;;;585          igmp_input(p, inp, &current_iphdr_dest);
;;;586          break;
;;;587    #endif /* LWIP_IGMP */
;;;588        default:
;;;589    #if LWIP_ICMP
;;;590          /* send ICMP destination protocol unreachable unless is was a broadcast */
;;;591          if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
000224  e59a0000          LDR      r0,[r10,#0]  ; current_iphdr_dest
000228  e1a01007          MOV      r1,r7
00022c  ebfffffe          BL       ip4_addr_isbroadcast
000230  e3500000          CMP      r0,#0
000234  0a00000e          BEQ      |L1.628|
000238  ea000015          B        |L1.660|
                  |L1.572|
00023c  e3a00000          MOV      r0,#0                 ;515
;;;592              !ip_addr_ismulticast(&current_iphdr_dest)) {
;;;593            p->payload = iphdr;
;;;594            icmp_dest_unreach(p, ICMP_DUR_PROTO);
;;;595          }
;;;596    #endif /* LWIP_ICMP */
;;;597          pbuf_free(p);
;;;598    
;;;599          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));
;;;600    
;;;601          IP_STATS_INC(ip.proterr);
;;;602          IP_STATS_INC(ip.drop);
;;;603          snmp_inc_ipinunknownprotos();
;;;604        }
;;;605      }
;;;606    
;;;607      current_netif = NULL;
;;;608      current_header = NULL;
;;;609      ip_addr_set_any(&current_iphdr_src);
;;;610      ip_addr_set_any(&current_iphdr_dest);
;;;611    
;;;612      return ERR_OK;
;;;613    }
000240  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.580|
000244  e1a01007          MOV      r1,r7                 ;568
000248  e1a00006          MOV      r0,r6                 ;568
00024c  ebfffffe          BL       udp_input
000250  ea000011          B        |L1.668|
                  |L1.596|
000254  e1a01007          MOV      r1,r7                 ;574
000258  e1a00006          MOV      r0,r6                 ;574
00025c  ebfffffe          BL       tcp_input
000260  ea00000d          B        |L1.668|
                  |L1.612|
000264  e1a01007          MOV      r1,r7                 ;580
000268  e1a00006          MOV      r0,r6                 ;580
00026c  ebfffffe          BL       icmp_input
000270  ea000009          B        |L1.668|
                  |L1.628|
000274  e5da0000          LDRB     r0,[r10,#0]           ;592  ; current_iphdr_dest
000278  e20000f0          AND      r0,r0,#0xf0           ;592
00027c  e35000e0          CMP      r0,#0xe0              ;592
000280  0a000003          BEQ      |L1.660|
000284  e3a01002          MOV      r1,#2                 ;594
000288  e1a00006          MOV      r0,r6                 ;594
00028c  e5865004          STR      r5,[r6,#4]            ;594
000290  ebfffffe          BL       icmp_dest_unreach
                  |L1.660|
000294  e1a00006          MOV      r0,r6                 ;597
000298  ebfffffe          BL       pbuf_free
                  |L1.668|
00029c  e3a00000          MOV      r0,#0                 ;607
0002a0  e5840004          STR      r0,[r4,#4]            ;608  ; current_netif
0002a4  e5840008          STR      r0,[r4,#8]            ;609  ; current_header
0002a8  e58b0000          STR      r0,[r11,#0]           ;610  ; current_iphdr_src
0002ac  e58a0000          STR      r0,[r10,#0]           ;610  ; current_iphdr_dest
0002b0  eaffffe1          B        |L1.572|
;;;614    
                          ENDP

                  ip_output_if PROC
;;;640    err_t
;;;641    ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
0002b4  e92d4ff8          PUSH     {r3-r11,lr}
;;;642                 u8_t ttl, u8_t tos,
;;;643                 u8_t proto, struct netif *netif)
;;;644    {
0002b8  e1cda2d8          LDRD     r10,r11,[sp,#0x28]
0002bc  e1a05000          MOV      r5,r0
;;;645    #if IP_OPTIONS_SEND
;;;646      return ip_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
;;;647    }
;;;648    
;;;649    /**
;;;650     * Same as ip_output_if() but with the possibility to include IP options:
;;;651     *
;;;652     * @ param ip_options pointer to the IP options, copied into the IP header
;;;653     * @ param optlen length of ip_options
;;;654     */
;;;655    err_t ip_output_if_opt(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
;;;656           u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
;;;657           u16_t optlen)
;;;658    {
;;;659    #endif /* IP_OPTIONS_SEND */
;;;660      struct ip_hdr *iphdr;
;;;661      ip_addr_t dest_addr;
;;;662    #if CHECKSUM_GEN_IP_INLINE
;;;663      u32_t chk_sum = 0;
;;;664    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;665    
;;;666      /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
;;;667         gets altered as the packet is passed down the stack */
;;;668      LWIP_ASSERT("p->ref == 1", p->ref == 1);
0002c0  e1d000be          LDRH     r0,[r0,#0xe]
0002c4  e59d7030          LDR      r7,[sp,#0x30]         ;644
0002c8  e1a09003          MOV      r9,r3                 ;644
0002cc  e3500001          CMP      r0,#1
0002d0  e1a06002          MOV      r6,r2                 ;644
0002d4  e1a08001          MOV      r8,r1                 ;644
0002d8  0a000004          BEQ      |L1.752|
0002dc  e28f3f77          ADR      r3,|L1.1216|
0002e0  e3a02fa7          MOV      r2,#0x29c
0002e4  e28f1f7d          ADR      r1,|L1.1248|
0002e8  e28f0f7f          ADR      r0,|L1.1260|
0002ec  ebfffffe          BL       sysprintf
                  |L1.752|
;;;669    
;;;670      snmp_inc_ipoutrequests();
;;;671    
;;;672      /* Should the IP header be generated or is it already included in p? */
;;;673      if (dest != IP_HDRINCL) {
0002f0  e3560000          CMP      r6,#0
0002f4  0a000045          BEQ      |L1.1040|
;;;674        u16_t ip_hlen = IP_HLEN;
;;;675    #if IP_OPTIONS_SEND
;;;676        u16_t optlen_aligned = 0;
;;;677        if (optlen != 0) {
;;;678    #if CHECKSUM_GEN_IP_INLINE
;;;679          int i;
;;;680    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;681          /* round up to a multiple of 4 */
;;;682          optlen_aligned = ((optlen + 3) & ~3);
;;;683          ip_hlen += optlen_aligned;
;;;684          /* First write in the IP options */
;;;685          if (pbuf_header(p, optlen_aligned)) {
;;;686            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output_if_opt: not enough room for IP options in pbuf\n"));
;;;687            IP_STATS_INC(ip.err);
;;;688            snmp_inc_ipoutdiscards();
;;;689            return ERR_BUF;
;;;690          }
;;;691          MEMCPY(p->payload, ip_options, optlen);
;;;692          if (optlen < optlen_aligned) {
;;;693            /* zero the remaining bytes */
;;;694            memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
;;;695          }
;;;696    #if CHECKSUM_GEN_IP_INLINE
;;;697          for (i = 0; i < optlen_aligned/2; i++) {
;;;698            chk_sum += ((u16_t*)p->payload)[i];
;;;699          }
;;;700    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;701        }
;;;702    #endif /* IP_OPTIONS_SEND */
;;;703        /* generate IP header */
;;;704        if (pbuf_header(p, IP_HLEN)) {
0002f8  e3a01014          MOV      r1,#0x14
0002fc  e1a00005          MOV      r0,r5
000300  ebfffffe          BL       pbuf_header
000304  e3500000          CMP      r0,#0
;;;705          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));
;;;706    
;;;707          IP_STATS_INC(ip.err);
;;;708          snmp_inc_ipoutdiscards();
;;;709          return ERR_BUF;
000308  13e00001          MVNNE    r0,#1
00030c  1a000049          BNE      |L1.1080|
;;;710        }
;;;711    
;;;712        iphdr = (struct ip_hdr *)p->payload;
;;;713        LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
000310  e1d500ba          LDRH     r0,[r5,#0xa]
000314  e5954004          LDR      r4,[r5,#4]            ;712
000318  e3500014          CMP      r0,#0x14
00031c  2a000004          BCS      |L1.820|
000320  e59f21ec          LDR      r2,|L1.1300|
000324  e28f3f65          ADR      r3,|L1.1216|
000328  e28f1f7a          ADR      r1,|L1.1304|
00032c  e28f0f6e          ADR      r0,|L1.1260|
000330  ebfffffe          BL       sysprintf
                  |L1.820|
;;;714                   (p->len >= sizeof(struct ip_hdr)));
;;;715    
;;;716        IPH_TTL_SET(iphdr, ttl);
000334  e5c49008          STRB     r9,[r4,#8]
;;;717        IPH_PROTO_SET(iphdr, proto);
000338  e5c4b009          STRB     r11,[r4,#9]
;;;718    #if CHECKSUM_GEN_IP_INLINE
;;;719        chk_sum += LWIP_MAKE_U16(proto, ttl);
;;;720    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;721    
;;;722        /* dest cannot be NULL here */
;;;723        ip_addr_copy(iphdr->dest, *dest);
00033c  e5960000          LDR      r0,[r6,#0]
000340  e189940b          ORR      r9,r9,r11,LSL #8      ;719
000344  e2841010          ADD      r1,r4,#0x10
000348  ebfffffe          BL       __aeabi_uwrite4
;;;724    #if CHECKSUM_GEN_IP_INLINE
;;;725        chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
00034c  e1a01800          LSL      r1,r0,#16
000350  e1a01821          LSR      r1,r1,#16
000354  e0811009          ADD      r1,r1,r9
;;;726        chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
000358  e0810820          ADD      r0,r1,r0,LSR #16
;;;727    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;728    
;;;729        IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
00035c  e3a01045          MOV      r1,#0x45
000360  e5c41000          STRB     r1,[r4,#0]
;;;730        IPH_TOS_SET(iphdr, tos);
;;;731    #if CHECKSUM_GEN_IP_INLINE
;;;732        chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
000364  e181140a          ORR      r1,r1,r10,LSL #8
000368  e0819000          ADD      r9,r1,r0
00036c  e5c4a001          STRB     r10,[r4,#1]           ;730
;;;733    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;734        IPH_LEN_SET(iphdr, htons(p->tot_len));
000370  e1d500b8          LDRH     r0,[r5,#8]
000374  ebfffffe          BL       lwip_htons
000378  e1a01420          LSR      r1,r0,#8
;;;735    #if CHECKSUM_GEN_IP_INLINE
;;;736        chk_sum += iphdr->_len;
00037c  e080a009          ADD      r10,r0,r9
000380  e5c40002          STRB     r0,[r4,#2]            ;734
;;;737    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;738        IPH_OFFSET_SET(iphdr, 0);
000384  e3a00000          MOV      r0,#0
000388  e5c41003          STRB     r1,[r4,#3]            ;734
;;;739        IPH_ID_SET(iphdr, htons(ip_id));
00038c  e59f9128          LDR      r9,|L1.1212|
000390  e5c40006          STRB     r0,[r4,#6]            ;738
000394  e5c40007          STRB     r0,[r4,#7]            ;738
000398  e1d900b0          LDRH     r0,[r9,#0]  ; ip_id
00039c  ebfffffe          BL       lwip_htons
0003a0  e1a01420          LSR      r1,r0,#8
0003a4  e5c40004          STRB     r0,[r4,#4]
;;;740    #if CHECKSUM_GEN_IP_INLINE
;;;741        chk_sum += iphdr->_id;
0003a8  e08aa000          ADD      r10,r10,r0
0003ac  e5c41005          STRB     r1,[r4,#5]            ;739
;;;742    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;743        ++ip_id;
0003b0  e1d900b0          LDRH     r0,[r9,#0]  ; ip_id
;;;744    
;;;745        if (ip_addr_isany(src)) {
0003b4  e3580000          CMP      r8,#0
;;;746          ip_addr_copy(iphdr->src, netif->ip_addr);
;;;747        } else {
;;;748          /* src cannot be NULL here */
;;;749          ip_addr_copy(iphdr->src, *src);
0003b8  e284100c          ADD      r1,r4,#0xc
0003bc  e2800001          ADD      r0,r0,#1              ;743
0003c0  e1c900b0          STRH     r0,[r9,#0]            ;743  ; ip_id
0003c4  15980000          LDRNE    r0,[r8,#0]            ;745
0003c8  13500000          CMPNE    r0,#0                 ;745
0003cc  05970004          LDREQ    r0,[r7,#4]            ;746
0003d0  ebfffffe          BL       __aeabi_uwrite4
;;;750        }
;;;751    
;;;752    #if CHECKSUM_GEN_IP_INLINE
;;;753        chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
0003d4  e284000c          ADD      r0,r4,#0xc
0003d8  ebfffffe          BL       __aeabi_uread4
0003dc  e1a01800          LSL      r1,r0,#16
0003e0  e1a01821          LSR      r1,r1,#16
0003e4  e081100a          ADD      r1,r1,r10
;;;754        chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
0003e8  e0810820          ADD      r0,r1,r0,LSR #16
;;;755        chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
0003ec  e1a01800          LSL      r1,r0,#16
0003f0  e1a01821          LSR      r1,r1,#16
0003f4  e0810820          ADD      r0,r1,r0,LSR #16
;;;756        chk_sum = (chk_sum >> 16) + chk_sum;
0003f8  e0800820          ADD      r0,r0,r0,LSR #16
;;;757        chk_sum = ~chk_sum;
0003fc  e1e00000          MVN      r0,r0
;;;758        iphdr->_chksum = chk_sum; /* network order */
000400  e5c4000a          STRB     r0,[r4,#0xa]
000404  e1a00420          LSR      r0,r0,#8
000408  e5c4000b          STRB     r0,[r4,#0xb]
00040c  ea000004          B        |L1.1060|
                  |L1.1040|
;;;759    #else /* CHECKSUM_GEN_IP_INLINE */
;;;760        IPH_CHKSUM_SET(iphdr, 0);
;;;761    #if CHECKSUM_GEN_IP
;;;762        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
;;;763    #endif
;;;764    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;765      } else {
;;;766        /* IP header already included in p */
;;;767        iphdr = (struct ip_hdr *)p->payload;
000410  e5950004          LDR      r0,[r5,#4]
000414  e2800010          ADD      r0,r0,#0x10
;;;768        ip_addr_copy(dest_addr, iphdr->dest);
000418  ebfffffe          BL       __aeabi_uread4
;;;769        dest = &dest_addr;
00041c  e1a0600d          MOV      r6,sp
000420  e58d0000          STR      r0,[sp,#0]            ;768
                  |L1.1060|
;;;770      }
;;;771    
;;;772      IP_STATS_INC(ip.xmit);
;;;773    
;;;774      LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], netif->num));
;;;775      ip_debug_print(p);
;;;776    
;;;777    #if ENABLE_LOOPBACK
;;;778      if (ip_addr_cmp(dest, &netif->ip_addr)) {
;;;779        /* Packet to self, enqueue it for loopback */
;;;780        LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
;;;781        return netif_loop_output(netif, p, dest);
;;;782      }
;;;783    #if LWIP_IGMP
;;;784      if ((p->flags & PBUF_FLAG_MCASTLOOP) != 0) {
;;;785        netif_loop_output(netif, p, dest);
;;;786      }
;;;787    #endif /* LWIP_IGMP */
;;;788    #endif /* ENABLE_LOOPBACK */
;;;789    #if IP_FRAG
;;;790      /* don't fragment if interface has mtu set to 0 [loopif] */
;;;791      if (netif->mtu && (p->tot_len > netif->mtu)) {
;;;792        return ip_frag(p, netif, dest);
;;;793      }
;;;794    #endif /* IP_FRAG */
;;;795    
;;;796      LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
;;;797      return netif->output(netif, p, dest);
000424  e5973014          LDR      r3,[r7,#0x14]
000428  e1a02006          MOV      r2,r6
00042c  e1a01005          MOV      r1,r5
000430  e1a00007          MOV      r0,r7
000434  e12fff33          BLX      r3
                  |L1.1080|
;;;798    }
000438  e8bd8ff8          POP      {r3-r11,pc}
;;;799    
                          ENDP

                  ip_output PROC
;;;817    err_t
;;;818    ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
00043c  e92d43fe          PUSH     {r1-r9,lr}
;;;819              u8_t ttl, u8_t tos, u8_t proto)
;;;820    {
000440  e1a04000          MOV      r4,r0
;;;821      struct netif *netif;
;;;822    
;;;823      /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
;;;824         gets altered as the packet is passed down the stack */
;;;825      LWIP_ASSERT("p->ref == 1", p->ref == 1);
000444  e1d000be          LDRH     r0,[r0,#0xe]
000448  e59d502c          LDR      r5,[sp,#0x2c]         ;820
00044c  e59d6028          LDR      r6,[sp,#0x28]         ;820
000450  e3500001          CMP      r0,#1
000454  e1a08003          MOV      r8,r3                 ;820
000458  e1a07002          MOV      r7,r2                 ;820
00045c  e1a09001          MOV      r9,r1                 ;820
000460  0a000004          BEQ      |L1.1144|
000464  e59f20dc          LDR      r2,|L1.1352|
000468  e28f3050          ADR      r3,|L1.1216|
00046c  e28f106c          ADR      r1,|L1.1248|
000470  e28f0074          ADR      r0,|L1.1260|
000474  ebfffffe          BL       sysprintf
                  |L1.1144|
;;;826    
;;;827      if ((netif = ip_route(dest)) == NULL) {
000478  e1a00007          MOV      r0,r7
00047c  ebfffffe          BL       ip_route
000480  e3500000          CMP      r0,#0
;;;828        LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;829          ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
;;;830        IP_STATS_INC(ip.rterr);
;;;831        return ERR_RTE;
000484  03e00003          MVNEQ    r0,#3
000488  0a000007          BEQ      |L1.1196|
;;;832      }
;;;833    
;;;834      return ip_output_if(p, src, dest, ttl, tos, proto, netif);
00048c  e58d0008          STR      r0,[sp,#8]
000490  e1a03008          MOV      r3,r8
000494  e1a02007          MOV      r2,r7
000498  e1a01009          MOV      r1,r9
00049c  e1a00004          MOV      r0,r4
0004a0  e58d5004          STR      r5,[sp,#4]
0004a4  e58d6000          STR      r6,[sp,#0]
0004a8  ebfffffe          BL       ip_output_if
                  |L1.1196|
;;;835    }
0004ac  e8bd83fe          POP      {r1-r9,pc}
                  |L1.1200|
                          DCD      netif_list
                  |L1.1204|
                          DCD      netif_default
                  |L1.1208|
                          DCD      ||.data||+0x10
                  |L1.1212|
                          DCD      ||.data||
                  |L1.1216|
0004c0  6c776970          DCB      "lwip-1.4.1\\src\\core\\ipv4\\ip.c",0
0004c4  2d312e34
0004c8  2e315c73
0004cc  72635c63
0004d0  6f72655c
0004d4  69707634
0004d8  5c69702e
0004dc  6300    
0004de  00                DCB      0
0004df  00                DCB      0
                  |L1.1248|
0004e0  702d3e72          DCB      "p->ref == 1",0
0004e4  6566203d
0004e8  3d203100
                  |L1.1260|
0004ec  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0004f0  7274696f
0004f4  6e202225
0004f8  73222066
0004fc  61696c65
000500  64206174
000504  206c696e
000508  65202564
00050c  20696e20
000510  25730a00
                  |L1.1300|
                          DCD      0x000002c9
                  |L1.1304|
000518  63686563          DCB      "check that first pbuf can hold struct ip_hdr",0
00051c  6b207468
000520  61742066
000524  69727374
000528  20706275
00052c  66206361
000530  6e20686f
000534  6c642073
000538  74727563
00053c  74206970
000540  5f686472
000544  00      
000545  00                DCB      0
000546  00                DCB      0
000547  00                DCB      0
                  |L1.1352|
                          DCD      0x00000339
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  ip_id
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  current_netif
                          DCD      0x00000000
                  current_header
                          DCD      0x00000000
                  current_iphdr_src
                          DCD      0x00000000
                  current_iphdr_dest
                          DCD      0x00000000
