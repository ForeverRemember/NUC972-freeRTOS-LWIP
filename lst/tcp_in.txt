; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\tcp_in.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tcp_in.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\tcp_in.crf lwip-1.4.1\src\core\tcp_in.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tcp_oos_insert_segment PROC
;;;799    static void
;;;800    tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;801    {
000004  e1a05000          MOV      r5,r0
;;;802      struct tcp_seg *old_seg;
;;;803    
;;;804      if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000008  e5900010          LDR      r0,[r0,#0x10]
00000c  e1a04001          MOV      r4,r1                 ;801
000010  e5d0100d          LDRB     r1,[r0,#0xd]
000014  e5d0000c          LDRB     r0,[r0,#0xc]
000018  e1800401          ORR      r0,r0,r1,LSL #8
00001c  ebfffffe          BL       lwip_ntohs
;;;805        /* received segment overlaps all following segments */
;;;806        tcp_segs_free(next);
;;;807        next = NULL;
;;;808      }
;;;809      else {
;;;810        /* delete some following segments
;;;811           oos queue may have segments with FIN flag */
;;;812        while (next &&
;;;813               TCP_SEQ_GEQ((seqno + cseg->len),
000020  e59f744c          LDR      r7,|L1.1140|
000024  e3100001          TST      r0,#1                 ;804
000028  0a000017          BEQ      |L1.140|
00002c  e1a00004          MOV      r0,r4                 ;806
000030  ebfffffe          BL       tcp_segs_free
000034  e3a04000          MOV      r4,#0                 ;807
000038  ea00002e          B        |L1.248|
                  |L1.60|
;;;814                          (next->tcphdr->seqno + next->len))) {
;;;815          /* cseg with FIN already processed */
;;;816          if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
00003c  e5d6000d          LDRB     r0,[r6,#0xd]
000040  e5d6100c          LDRB     r1,[r6,#0xc]
000044  e1810400          ORR      r0,r1,r0,LSL #8
000048  ebfffffe          BL       lwip_ntohs
00004c  e3100001          TST      r0,#1
000050  0a00000a          BEQ      |L1.128|
;;;817            TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
000054  e3a00001          MOV      r0,#1
000058  ebfffffe          BL       lwip_htons
00005c  e1a01000          MOV      r1,r0
000060  e5950010          LDR      r0,[r5,#0x10]
000064  e5d0200d          LDRB     r2,[r0,#0xd]
000068  e5d0300c          LDRB     r3,[r0,#0xc]
00006c  e1832402          ORR      r2,r3,r2,LSL #8
000070  e1811002          ORR      r1,r1,r2
000074  e5c0100c          STRB     r1,[r0,#0xc]
000078  e1a01421          LSR      r1,r1,#8
00007c  e5c0100d          STRB     r1,[r0,#0xd]
                  |L1.128|
;;;818          }
;;;819          old_seg = next;
;;;820          next = next->next;
000080  e1a00004          MOV      r0,r4
000084  e5944000          LDR      r4,[r4,#0]
;;;821          tcp_seg_free(old_seg);
000088  ebfffffe          BL       tcp_seg_free
                  |L1.140|
00008c  e3540000          CMP      r4,#0                 ;812
000090  0a000018          BEQ      |L1.248|
000094  e5946010          LDR      r6,[r4,#0x10]         ;813
000098  e2860004          ADD      r0,r6,#4              ;813
00009c  ebfffffe          BL       __aeabi_uread4
0000a0  e1d410b8          LDRH     r1,[r4,#8]            ;813
0000a4  e597200c          LDR      r2,[r7,#0xc]          ;813  ; seqno
0000a8  e0800001          ADD      r0,r0,r1              ;813
0000ac  e1d510b8          LDRH     r1,[r5,#8]            ;813
0000b0  e0811002          ADD      r1,r1,r2              ;813
0000b4  e0510000          SUBS     r0,r1,r0              ;813
0000b8  5affffdf          BPL      |L1.60|
;;;822        }
;;;823        if (next &&
;;;824            TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
0000bc  e5940010          LDR      r0,[r4,#0x10]
0000c0  e2800004          ADD      r0,r0,#4
0000c4  ebfffffe          BL       __aeabi_uread4
0000c8  e1d520b8          LDRH     r2,[r5,#8]
0000cc  e597100c          LDR      r1,[r7,#0xc]  ; seqno
0000d0  e0822001          ADD      r2,r2,r1
0000d4  e0422000          SUB      r2,r2,r0
0000d8  e3520000          CMP      r2,#0
0000dc  da000005          BLE      |L1.248|
;;;825          /* We need to trim the incoming segment. */
;;;826          cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
0000e0  e0400001          SUB      r0,r0,r1
0000e4  e1a01800          LSL      r1,r0,#16
0000e8  e1a01821          LSR      r1,r1,#16
0000ec  e1c510b8          STRH     r1,[r5,#8]
;;;827          pbuf_realloc(cseg->p, cseg->len);
0000f0  e5950004          LDR      r0,[r5,#4]
0000f4  ebfffffe          BL       pbuf_realloc
                  |L1.248|
;;;828        }
;;;829      }
;;;830      cseg->next = next;
0000f8  e5854000          STR      r4,[r5,#0]
;;;831    }
0000fc  e8bd81f0          POP      {r4-r8,pc}
;;;832    #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

                  tcp_receive PROC
;;;846    static void
;;;847    tcp_receive(struct tcp_pcb *pcb)
000100  e92d47f0          PUSH     {r4-r10,lr}
;;;848    {
000104  e1a04000          MOV      r4,r0
;;;849      struct tcp_seg *next;
;;;850    #if TCP_QUEUE_OOSEQ
;;;851      struct tcp_seg *prev, *cseg;
;;;852    #endif /* TCP_QUEUE_OOSEQ */
;;;853      struct pbuf *p;
;;;854      s32_t off;
;;;855      s16_t m;
;;;856      u32_t right_wnd_edge;
;;;857      u16_t new_tot_len;
;;;858      int found_dupack = 0;
;;;859    #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;860      u32_t ooseq_blen;
;;;861      u16_t ooseq_qlen;
;;;862    #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;863    
;;;864      LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
000108  e5d00018          LDRB     r0,[r0,#0x18]
00010c  e3500004          CMP      r0,#4
000110  2a000004          BCS      |L1.296|
000114  e28f3fd7          ADR      r3,|L1.1144|
000118  e3a02e36          MOV      r2,#0x360
00011c  e28f1fdd          ADR      r1,|L1.1176|
000120  e28f0fe3          ADR      r0,|L1.1204|
000124  ebfffffe          BL       sysprintf
                  |L1.296|
;;;865    
;;;866      if (flags & TCP_ACK) {
000128  e59f7344          LDR      r7,|L1.1140|
00012c  e3a06000          MOV      r6,#0
000130  e5d70000          LDRB     r0,[r7,#0]  ; flags
000134  e3100010          TST      r0,#0x10
000138  0a000165          BEQ      |L1.1748|
;;;867        right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
00013c  e1d436b0          LDRH     r3,[r4,#0x60]
000140  e5940058          LDR      r0,[r4,#0x58]
;;;868    
;;;869        /* Update window. */
;;;870        if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
000144  e5942054          LDR      r2,[r4,#0x54]
000148  e597100c          LDR      r1,[r7,#0xc]  ; seqno
00014c  e083c000          ADD      r12,r3,r0             ;867
000150  e0525001          SUBS     r5,r2,r1
000154  4a00000d          BMI      |L1.400|
;;;871           (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
000158  e1520001          CMP      r2,r1
00015c  1a000002          BNE      |L1.364|
000160  e5972010          LDR      r2,[r7,#0x10]  ; ackno
000164  e0502002          SUBS     r2,r0,r2
000168  4a000008          BMI      |L1.400|
                  |L1.364|
;;;872           (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
00016c  e5972010          LDR      r2,[r7,#0x10]  ; ackno
000170  e1500002          CMP      r0,r2
000174  1a000018          BNE      |L1.476|
000178  e5970004          LDR      r0,[r7,#4]  ; tcphdr
00017c  e5d0200f          LDRB     r2,[r0,#0xf]
000180  e5d0000e          LDRB     r0,[r0,#0xe]
000184  e1800402          ORR      r0,r0,r2,LSL #8
000188  e1500003          CMP      r0,r3
00018c  9a000012          BLS      |L1.476|
                  |L1.400|
;;;873          pcb->snd_wnd = tcphdr->wnd;
000190  e5970004          LDR      r0,[r7,#4]  ; tcphdr
000194  e5d0200f          LDRB     r2,[r0,#0xf]
000198  e5d0300e          LDRB     r3,[r0,#0xe]
00019c  e1832402          ORR      r2,r3,r2,LSL #8
0001a0  e1c426b0          STRH     r2,[r4,#0x60]
;;;874          /* keep track of the biggest window announced by the remote host to calculate
;;;875             the maximum segment size */
;;;876          if (pcb->snd_wnd_max < tcphdr->wnd) {
0001a4  e5d0500f          LDRB     r5,[r0,#0xf]
0001a8  e5d0000e          LDRB     r0,[r0,#0xe]
0001ac  e1d436b2          LDRH     r3,[r4,#0x62]
0001b0  e1800405          ORR      r0,r0,r5,LSL #8
0001b4  e1530000          CMP      r3,r0
;;;877            pcb->snd_wnd_max = tcphdr->wnd;
0001b8  31c406b2          STRHCC   r0,[r4,#0x62]
;;;878          }
;;;879          pcb->snd_wl1 = seqno;
;;;880          pcb->snd_wl2 = ackno;
0001bc  e5841054          STR      r1,[r4,#0x54]
0001c0  e5970010          LDR      r0,[r7,#0x10]  ; ackno
;;;881          if (pcb->snd_wnd == 0) {
0001c4  e3520000          CMP      r2,#0
0001c8  e5840058          STR      r0,[r4,#0x58]
;;;882            if (pcb->persist_backoff == 0) {
;;;883              /* start persist timer */
;;;884              pcb->persist_cnt = 0;
;;;885              pcb->persist_backoff = 1;
;;;886            }
;;;887          } else if (pcb->persist_backoff > 0) {
0001cc  e5d40095          LDRB     r0,[r4,#0x95]
0001d0  0a00000b          BEQ      |L1.516|
0001d4  e3500000          CMP      r0,#0
;;;888            /* stop persist timer */
;;;889              pcb->persist_backoff = 0;
0001d8  15c46095          STRBNE   r6,[r4,#0x95]
                  |L1.476|
;;;890          }
;;;891          LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"U16_F"\n", pcb->snd_wnd));
;;;892    #if TCP_WND_DEBUG
;;;893        } else {
;;;894          if (pcb->snd_wnd != tcphdr->wnd) {
;;;895            LWIP_DEBUGF(TCP_WND_DEBUG, 
;;;896                        ("tcp_receive: no window update lastack %"U32_F" ackno %"
;;;897                         U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
;;;898                         pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
;;;899          }
;;;900    #endif /* TCP_WND_DEBUG */
;;;901        }
;;;902    
;;;903        /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
;;;904         * duplicate ack if:
;;;905         * 1) It doesn't ACK new data 
;;;906         * 2) length of received packet is zero (i.e. no payload) 
;;;907         * 3) the advertised window hasn't changed 
;;;908         * 4) There is outstanding unacknowledged data (retransmission timer running)
;;;909         * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
;;;910         * 
;;;911         * If it passes all five, should process as a dupack: 
;;;912         * a) dupacks < 3: do nothing 
;;;913         * b) dupacks == 3: fast retransmit 
;;;914         * c) dupacks > 3: increase cwnd 
;;;915         * 
;;;916         * If it only passes 1-3, should reset dupack counter (and add to
;;;917         * stats, which we don't do in lwIP)
;;;918         *
;;;919         * If it only passes 1, should reset dupack counter
;;;920         *
;;;921         */
;;;922    
;;;923        /* Clause 1 */
;;;924        if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
0001dc  e5942048          LDR      r2,[r4,#0x48]
0001e0  e5970010          LDR      r0,[r7,#0x10]  ; ackno
0001e4  e0401002          SUB      r1,r0,r2
0001e8  e3510000          CMP      r1,#0
0001ec  ca000026          BGT      |L1.652|
;;;925          pcb->acked = 0;
0001f0  e1c466b4          STRH     r6,[r4,#0x64]
;;;926          /* Clause 2 */
;;;927          if (tcplen == 0) {
0001f4  e1d710b2          LDRH     r1,[r7,#2]  ; tcplen
0001f8  e3510000          CMP      r1,#0
0001fc  1a000020          BNE      |L1.644|
000200  ea000004          B        |L1.536|
                  |L1.516|
000204  e3500000          CMP      r0,#0                 ;882
000208  03a00001          MOVEQ    r0,#1                 ;885
00020c  05c46094          STRBEQ   r6,[r4,#0x94]         ;884
000210  05c40095          STRBEQ   r0,[r4,#0x95]         ;885
000214  eafffff0          B        |L1.476|
                  |L1.536|
;;;928            /* Clause 3 */
;;;929            if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
000218  e1d436b0          LDRH     r3,[r4,#0x60]
00021c  e5941058          LDR      r1,[r4,#0x58]
000220  e0811003          ADD      r1,r1,r3
000224  e151000c          CMP      r1,r12
000228  1a000015          BNE      |L1.644|
;;;930              /* Clause 4 */
;;;931              if (pcb->rtime >= 0) {
00022c  e1d413f4          LDRSH    r1,[r4,#0x34]
000230  e3510000          CMP      r1,#0
;;;932                /* Clause 5 */
;;;933                if (pcb->lastack == ackno) {
000234  a1520000          CMPGE    r2,r0
000238  1a000011          BNE      |L1.644|
;;;934                  found_dupack = 1;
;;;935                  if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
00023c  e5d41047          LDRB     r1,[r4,#0x47]
000240  e2810001          ADD      r0,r1,#1
000244  e20000ff          AND      r0,r0,#0xff
000248  e1500001          CMP      r0,r1
;;;936                    ++pcb->dupacks;
00024c  85c40047          STRBHI   r0,[r4,#0x47]
;;;937                  }
;;;938                  if (pcb->dupacks > 3) {
000250  e5d40047          LDRB     r0,[r4,#0x47]
000254  e3500003          CMP      r0,#3
000258  9a000006          BLS      |L1.632|
;;;939                    /* Inflate the congestion window, but not if it means that
;;;940                       the value overflows. */
;;;941                    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
00025c  e1d404bc          LDRH     r0,[r4,#0x4c]
000260  e1d413b6          LDRH     r1,[r4,#0x36]
000264  e0811000          ADD      r1,r1,r0
000268  e3c11801          BIC      r1,r1,#0x10000
00026c  e1510000          CMP      r1,r0
;;;942                      pcb->cwnd += pcb->mss;
000270  81c414bc          STRHHI   r1,[r4,#0x4c]
000274  ea0000df          B        |L1.1528|
                  |L1.632|
;;;943                    }
;;;944                  } else if (pcb->dupacks == 3) {
;;;945                    /* Do fast retransmit */
;;;946                    tcp_rexmit_fast(pcb);
000278  01a00004          MOVEQ    r0,r4
00027c  0bfffffe          BLEQ     tcp_rexmit_fast
000280  ea0000dc          B        |L1.1528|
                  |L1.644|
;;;947                  }
;;;948                }
;;;949              }
;;;950            }
;;;951          }
;;;952          /* If Clause (1) or more is true, but not a duplicate ack, reset
;;;953           * count of consecutive duplicate acks */
;;;954          if (!found_dupack) {
;;;955            pcb->dupacks = 0;
000284  e5c46047          STRB     r6,[r4,#0x47]
000288  ea0000da          B        |L1.1528|
                  |L1.652|
;;;956          }
;;;957        } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
00028c  e3510001          CMP      r1,#1
000290  4a0000a7          BMI      |L1.1332|
000294  e5942050          LDR      r2,[r4,#0x50]
000298  e0402002          SUB      r2,r0,r2
00029c  e3520000          CMP      r2,#0
0002a0  ca0000a3          BGT      |L1.1332|
;;;958          /* We come here when the ACK acknowledges new data. */
;;;959    
;;;960          /* Reset the "IN Fast Retransmit" flag, since we are no longer
;;;961             in fast retransmit. Also reset the congestion window to the
;;;962             slow start threshold. */
;;;963          if (pcb->flags & TF_INFR) {
0002a4  e5d4201e          LDRB     r2,[r4,#0x1e]
0002a8  e3120004          TST      r2,#4
0002ac  0a000003          BEQ      |L1.704|
;;;964            pcb->flags &= ~TF_INFR;
0002b0  e3c22004          BIC      r2,r2,#4
0002b4  e5c4201e          STRB     r2,[r4,#0x1e]
;;;965            pcb->cwnd = pcb->ssthresh;
0002b8  e1d424be          LDRH     r2,[r4,#0x4e]
0002bc  e1c424bc          STRH     r2,[r4,#0x4c]
                  |L1.704|
;;;966          }
;;;967    
;;;968          /* Reset the number of retransmissions. */
;;;969          pcb->nrtx = 0;
0002c0  e5c46046          STRB     r6,[r4,#0x46]
;;;970    
;;;971          /* Reset the retransmission time-out. */
;;;972          pcb->rto = (pcb->sa >> 3) + pcb->sv;
0002c4  e1d424b2          LDRH     r2,[r4,#0x42]
0002c8  e1d434f0          LDRSH    r3,[r4,#0x40]
0002cc  e08221c3          ADD      r2,r2,r3,ASR #3
0002d0  e1c424b4          STRH     r2,[r4,#0x44]
;;;973    
;;;974          /* Update the send buffer space. Diff between the two can never exceed 64K? */
;;;975          pcb->acked = (u16_t)(ackno - pcb->lastack);
0002d4  e1c416b4          STRH     r1,[r4,#0x64]
;;;976    
;;;977          pcb->snd_buf += pcb->acked;
0002d8  e1d426b6          LDRH     r2,[r4,#0x66]
0002dc  e0811002          ADD      r1,r1,r2
0002e0  e1c416b6          STRH     r1,[r4,#0x66]
;;;978    
;;;979          /* Reset the fast retransmit variables. */
;;;980          pcb->dupacks = 0;
0002e4  e5c46047          STRB     r6,[r4,#0x47]
;;;981          pcb->lastack = ackno;
0002e8  e5840048          STR      r0,[r4,#0x48]
;;;982    
;;;983          /* Update the congestion control variables (cwnd and
;;;984             ssthresh). */
;;;985          if (pcb->state >= ESTABLISHED) {
0002ec  e5d40018          LDRB     r0,[r4,#0x18]
0002f0  e3500004          CMP      r0,#4
0002f4  3a000041          BCC      |L1.1024|
;;;986            if (pcb->cwnd < pcb->ssthresh) {
0002f8  e1d454bc          LDRH     r5,[r4,#0x4c]
0002fc  e1d404be          LDRH     r0,[r4,#0x4e]
000300  e1550000          CMP      r5,r0
;;;987              if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
;;;988                pcb->cwnd += pcb->mss;
;;;989              }
;;;990              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
;;;991            } else {
;;;992              u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
000304  e1d403b6          LDRH     r0,[r4,#0x36]
000308  2a000004          BCS      |L1.800|
00030c  e0800005          ADD      r0,r0,r5              ;987
000310  e3c00801          BIC      r0,r0,#0x10000        ;987
000314  e1550000          CMP      r5,r0                 ;987
000318  2a000038          BCS      |L1.1024|
00031c  ea000008          B        |L1.836|
                  |L1.800|
000320  e0020090          MUL      r2,r0,r0
000324  e1a01005          MOV      r1,r5
000328  e1a00002          MOV      r0,r2
00032c  ebfffffe          BL       __aeabi_idivmod
000330  e0800005          ADD      r0,r0,r5
000334  e1a00800          LSL      r0,r0,#16
000338  e1a00820          LSR      r0,r0,#16
;;;993              if (new_cwnd > pcb->cwnd) {
00033c  e1500005          CMP      r0,r5
000340  9a00002e          BLS      |L1.1024|
                  |L1.836|
;;;994                pcb->cwnd = new_cwnd;
000344  e1c404bc          STRH     r0,[r4,#0x4c]
000348  ea00002c          B        |L1.1024|
                  |L1.844|
;;;995              }
;;;996              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"U16_F"\n", pcb->cwnd));
;;;997            }
;;;998          }
;;;999          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
;;;1000                                       ackno,
;;;1001                                       pcb->unacked != NULL?
;;;1002                                       ntohl(pcb->unacked->tcphdr->seqno): 0,
;;;1003                                       pcb->unacked != NULL?
;;;1004                                       ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));
;;;1005   
;;;1006         /* Remove segment from the unacknowledged list if the incoming
;;;1007            ACK acknowlegdes them. */
;;;1008         while (pcb->unacked != NULL &&
;;;1009                TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
;;;1010                            TCP_TCPLEN(pcb->unacked), ackno)) {
;;;1011           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
;;;1012                                         ntohl(pcb->unacked->tcphdr->seqno),
;;;1013                                         ntohl(pcb->unacked->tcphdr->seqno) +
;;;1014                                         TCP_TCPLEN(pcb->unacked)));
;;;1015   
;;;1016           next = pcb->unacked;
;;;1017           pcb->unacked = pcb->unacked->next;
00034c  e5950000          LDR      r0,[r5,#0]
;;;1018   
;;;1019           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
;;;1020           LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
000350  e5840070          STR      r0,[r4,#0x70]
000354  e5950004          LDR      r0,[r5,#4]
000358  ebfffffe          BL       pbuf_clen
00035c  e1d416b8          LDRH     r1,[r4,#0x68]
000360  e1500001          CMP      r0,r1
000364  9a000004          BLS      |L1.892|
000368  e28f3f42          ADR      r3,|L1.1144|
00036c  e3a02fff          MOV      r2,#0x3fc
000370  e28f1f59          ADR      r1,|L1.1244|
000374  e28f0f4e          ADR      r0,|L1.1204|
000378  ebfffffe          BL       sysprintf
                  |L1.892|
;;;1021           /* Prevent ACK for FIN to generate a sent event */
;;;1022           if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
00037c  e1d406b4          LDRH     r0,[r4,#0x64]
000380  e3500000          CMP      r0,#0
000384  0a000008          BEQ      |L1.940|
000388  e5950010          LDR      r0,[r5,#0x10]
00038c  e5d0100d          LDRB     r1,[r0,#0xd]
000390  e5d0000c          LDRB     r0,[r0,#0xc]
000394  e1800401          ORR      r0,r0,r1,LSL #8
000398  ebfffffe          BL       lwip_ntohs
00039c  e3100001          TST      r0,#1
;;;1023             pcb->acked--;
0003a0  11d406b4          LDRHNE   r0,[r4,#0x64]
0003a4  12400001          SUBNE    r0,r0,#1
0003a8  11c406b4          STRHNE   r0,[r4,#0x64]
                  |L1.940|
;;;1024           }
;;;1025   
;;;1026           pcb->snd_queuelen -= pbuf_clen(next->p);
0003ac  e5950004          LDR      r0,[r5,#4]
0003b0  ebfffffe          BL       pbuf_clen
0003b4  e1d416b8          LDRH     r1,[r4,#0x68]
0003b8  e0410000          SUB      r0,r1,r0
0003bc  e1c406b8          STRH     r0,[r4,#0x68]
;;;1027           tcp_seg_free(next);
0003c0  e1a00005          MOV      r0,r5
0003c4  ebfffffe          BL       tcp_seg_free
;;;1028   
;;;1029           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
;;;1030           if (pcb->snd_queuelen != 0) {
0003c8  e1d406b8          LDRH     r0,[r4,#0x68]
0003cc  e3500000          CMP      r0,#0
0003d0  0a00000a          BEQ      |L1.1024|
;;;1031             LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
0003d4  e5940070          LDR      r0,[r4,#0x70]
0003d8  e3500000          CMP      r0,#0
0003dc  1a00000a          BNE      |L1.1036|
0003e0  e594006c          LDR      r0,[r4,#0x6c]
0003e4  e3500000          CMP      r0,#0
0003e8  1a00004e          BNE      |L1.1320|
0003ec  e59f2110          LDR      r2,|L1.1284|
0003f0  e28f3080          ADR      r3,|L1.1144|
0003f4  e28f1f43          ADR      r1,|L1.1288|
0003f8  e28f00b4          ADR      r0,|L1.1204|
0003fc  ebfffffe          BL       sysprintf
                  |L1.1024|
000400  e5940070          LDR      r0,[r4,#0x70]         ;1008
000404  e3500000          CMP      r0,#0                 ;1008
000408  0a000046          BEQ      |L1.1320|
                  |L1.1036|
00040c  e5900010          LDR      r0,[r0,#0x10]         ;1009
000410  e2800004          ADD      r0,r0,#4              ;1009
000414  ebfffffe          BL       __aeabi_uread4
000418  ebfffffe          BL       lwip_ntohl
00041c  e1a08000          MOV      r8,r0                 ;1009
000420  e5940070          LDR      r0,[r4,#0x70]         ;1009
000424  e5900010          LDR      r0,[r0,#0x10]         ;1009
000428  e5d0100d          LDRB     r1,[r0,#0xd]          ;1009
00042c  e5d0000c          LDRB     r0,[r0,#0xc]          ;1009
000430  e1800401          ORR      r0,r0,r1,LSL #8       ;1009
000434  ebfffffe          BL       lwip_ntohs
000438  e5945070          LDR      r5,[r4,#0x70]         ;1009
00043c  e2100003          ANDS     r0,r0,#3              ;1009
000440  e1d510b8          LDRH     r1,[r5,#8]            ;1009
000444  13a00001          MOVNE    r0,#1                 ;1009
000448  e0800001          ADD      r0,r0,r1              ;1009
00044c  e5971010          LDR      r1,[r7,#0x10]         ;1009  ; ackno
000450  e0800008          ADD      r0,r0,r8              ;1009
000454  e0400001          SUB      r0,r0,r1              ;1009
000458  e3500000          CMP      r0,#0                 ;1009
00045c  daffffba          BLE      |L1.844|
;;;1032                         pcb->unsent != NULL);
;;;1033           }
;;;1034         }
;;;1035   
;;;1036         /* If there's nothing left to acknowledge, stop the retransmit
;;;1037            timer, otherwise reset it to start again */
;;;1038         if(pcb->unacked == NULL)
000460  e3550000          CMP      r5,#0
;;;1039           pcb->rtime = -1;
;;;1040         else
;;;1041           pcb->rtime = 0;
000464  11c463b4          STRHNE   r6,[r4,#0x34]
000468  0a00002e          BEQ      |L1.1320|
                  |L1.1132|
;;;1042   
;;;1043         pcb->polltmr = 0;
00046c  e5c4601f          STRB     r6,[r4,#0x1f]
000470  ea000060          B        |L1.1528|
                  |L1.1140|
                          DCD      ||.data||
                  |L1.1144|
000478  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_in.c",0
00047c  2d312e34
000480  2e315c73
000484  72635c63
000488  6f72655c
00048c  7463705f
000490  696e2e63
000494  00      
000495  00                DCB      0
000496  00                DCB      0
000497  00                DCB      0
                  |L1.1176|
000498  7463705f          DCB      "tcp_receive: wrong state",0
00049c  72656365
0004a0  6976653a
0004a4  2077726f
0004a8  6e672073
0004ac  74617465
0004b0  00      
0004b1  00                DCB      0
0004b2  00                DCB      0
0004b3  00                DCB      0
                  |L1.1204|
0004b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0004b8  7274696f
0004bc  6e202225
0004c0  73222066
0004c4  61696c65
0004c8  64206174
0004cc  206c696e
0004d0  65202564
0004d4  20696e20
0004d8  25730a00
                  |L1.1244|
0004dc  7063622d          DCB      "pcb->snd_queuelen >= pbuf_clen(next->p)",0
0004e0  3e736e64
0004e4  5f717565
0004e8  75656c65
0004ec  6e203e3d
0004f0  20706275
0004f4  665f636c
0004f8  656e286e
0004fc  6578742d
000500  3e702900
                  |L1.1284|
                          DCD      0x00000407
                  |L1.1288|
000508  7463705f          DCB      "tcp_receive: valid queue length",0
00050c  72656365
000510  6976653a
000514  2076616c
000518  69642071
00051c  75657565
000520  206c656e
000524  67746800
                  |L1.1320|
000528  e3e00000          MVN      r0,#0                 ;1039
00052c  e1c403b4          STRH     r0,[r4,#0x34]         ;1039
000530  eaffffcd          B        |L1.1132|
                  |L1.1332|
;;;1044       } else {
;;;1045         /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
;;;1046         pcb->acked = 0;
000534  e1c466b4          STRH     r6,[r4,#0x64]
000538  ea00002e          B        |L1.1528|
                  |L1.1340|
;;;1047       }
;;;1048   
;;;1049       /* We go through the ->unsent list to see if any of the segments
;;;1050          on the list are acknowledged by the ACK. This may seem
;;;1051          strange since an "unsent" segment shouldn't be acked. The
;;;1052          rationale is that lwIP puts all outstanding segments on the
;;;1053          ->unsent list after a retransmission, so these segments may
;;;1054          in fact have been sent once. */
;;;1055       while (pcb->unsent != NULL &&
;;;1056              TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
;;;1057                              TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
;;;1058         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
;;;1059                                       ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
;;;1060                                       TCP_TCPLEN(pcb->unsent)));
;;;1061   
;;;1062         next = pcb->unsent;
;;;1063         pcb->unsent = pcb->unsent->next;
00053c  e5950000          LDR      r0,[r5,#0]
;;;1064   #if TCP_OVERSIZE
;;;1065         if (pcb->unsent == NULL) {
000540  e3500000          CMP      r0,#0
000544  e584006c          STR      r0,[r4,#0x6c]         ;1063
;;;1066           pcb->unsent_oversize = 0;
000548  01c466ba          STRHEQ   r6,[r4,#0x6a]
;;;1067         }
;;;1068   #endif /* TCP_OVERSIZE */ 
;;;1069         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
;;;1070         LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
00054c  e5950004          LDR      r0,[r5,#4]
000550  ebfffffe          BL       pbuf_clen
000554  e1d416b8          LDRH     r1,[r4,#0x68]
000558  e1500001          CMP      r0,r1
00055c  9a000004          BLS      |L1.1396|
000560  e59f2494          LDR      r2,|L1.2556|
000564  e24f30f4          ADR      r3,|L1.1144|
000568  e24f1094          ADR      r1,|L1.1244|
00056c  e24f00c0          ADR      r0,|L1.1204|
000570  ebfffffe          BL       sysprintf
                  |L1.1396|
;;;1071         /* Prevent ACK for FIN to generate a sent event */
;;;1072         if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
000574  e1d406b4          LDRH     r0,[r4,#0x64]
000578  e3500000          CMP      r0,#0
00057c  0a000008          BEQ      |L1.1444|
000580  e5950010          LDR      r0,[r5,#0x10]
000584  e5d0100d          LDRB     r1,[r0,#0xd]
000588  e5d0000c          LDRB     r0,[r0,#0xc]
00058c  e1800401          ORR      r0,r0,r1,LSL #8
000590  ebfffffe          BL       lwip_ntohs
000594  e3100001          TST      r0,#1
;;;1073           pcb->acked--;
000598  11d406b4          LDRHNE   r0,[r4,#0x64]
00059c  12400001          SUBNE    r0,r0,#1
0005a0  11c406b4          STRHNE   r0,[r4,#0x64]
                  |L1.1444|
;;;1074         }
;;;1075         pcb->snd_queuelen -= pbuf_clen(next->p);
0005a4  e5950004          LDR      r0,[r5,#4]
0005a8  ebfffffe          BL       pbuf_clen
0005ac  e1d416b8          LDRH     r1,[r4,#0x68]
0005b0  e0410000          SUB      r0,r1,r0
0005b4  e1c406b8          STRH     r0,[r4,#0x68]
;;;1076         tcp_seg_free(next);
0005b8  e1a00005          MOV      r0,r5
0005bc  ebfffffe          BL       tcp_seg_free
;;;1077         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
;;;1078         if (pcb->snd_queuelen != 0) {
0005c0  e1d406b8          LDRH     r0,[r4,#0x68]
0005c4  e3500000          CMP      r0,#0
0005c8  0a00000a          BEQ      |L1.1528|
;;;1079           LWIP_ASSERT("tcp_receive: valid queue length",
0005cc  e5940070          LDR      r0,[r4,#0x70]
0005d0  e3500000          CMP      r0,#0
0005d4  1a000007          BNE      |L1.1528|
0005d8  e594006c          LDR      r0,[r4,#0x6c]
0005dc  e3500000          CMP      r0,#0
0005e0  1a000007          BNE      |L1.1540|
0005e4  e59f2414          LDR      r2,|L1.2560|
0005e8  e24f3f5e          ADR      r3,|L1.1144|
0005ec  e24f10ec          ADR      r1,|L1.1288|
0005f0  e24f0f51          ADR      r0,|L1.1204|
0005f4  ebfffffe          BL       sysprintf
                  |L1.1528|
0005f8  e594006c          LDR      r0,[r4,#0x6c]         ;1055
0005fc  e3500000          CMP      r0,#0                 ;1055
000600  0a000017          BEQ      |L1.1636|
                  |L1.1540|
000604  e5900010          LDR      r0,[r0,#0x10]         ;1056
000608  e2800004          ADD      r0,r0,#4              ;1056
00060c  ebfffffe          BL       __aeabi_uread4
000610  ebfffffe          BL       lwip_ntohl
000614  e1a08000          MOV      r8,r0                 ;1056
000618  e594006c          LDR      r0,[r4,#0x6c]         ;1056
00061c  e5900010          LDR      r0,[r0,#0x10]         ;1056
000620  e5d0100d          LDRB     r1,[r0,#0xd]          ;1056
000624  e5d0000c          LDRB     r0,[r0,#0xc]          ;1056
000628  e1800401          ORR      r0,r0,r1,LSL #8       ;1056
00062c  ebfffffe          BL       lwip_ntohs
000630  e594506c          LDR      r5,[r4,#0x6c]         ;1056
000634  e2100003          ANDS     r0,r0,#3              ;1056
000638  e1d510b8          LDRH     r1,[r5,#8]            ;1056
00063c  13a00001          MOVNE    r0,#1                 ;1056
000640  e0800001          ADD      r0,r0,r1              ;1056
000644  e0881000          ADD      r1,r8,r0              ;1056
000648  e5970010          LDR      r0,[r7,#0x10]         ;1056  ; ackno
00064c  e0501001          SUBS     r1,r0,r1              ;1056
000650  4a000003          BMI      |L1.1636|
000654  e5941050          LDR      r1,[r4,#0x50]         ;1056
000658  e0400001          SUB      r0,r0,r1              ;1056
00065c  e3500000          CMP      r0,#0                 ;1056
000660  daffffb5          BLE      |L1.1340|
                  |L1.1636|
;;;1080             pcb->unacked != NULL || pcb->unsent != NULL);
;;;1081         }
;;;1082       }
;;;1083       /* End of ACK for new data processing. */
;;;1084   
;;;1085       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
;;;1086                                   pcb->rttest, pcb->rtseq, ackno));
;;;1087   
;;;1088       /* RTT estimation calculations. This is done by checking if the
;;;1089          incoming segment acknowledges the segment we use to take a
;;;1090          round-trip time measurement. */
;;;1091       if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
000664  e5940038          LDR      r0,[r4,#0x38]
000668  e3500000          CMP      r0,#0
00066c  0a000018          BEQ      |L1.1748|
000670  e594103c          LDR      r1,[r4,#0x3c]
000674  e5972010          LDR      r2,[r7,#0x10]  ; ackno
000678  e0511002          SUBS     r1,r1,r2
00067c  5a000014          BPL      |L1.1748|
;;;1092         /* diff between this shouldn't exceed 32K since this are tcp timer ticks
;;;1093            and a round-trip shouldn't be that long... */
;;;1094         m = (s16_t)(tcp_ticks - pcb->rttest);
000680  e59f137c          LDR      r1,|L1.2564|
000684  e1d110b0          LDRH     r1,[r1,#0]  ; tcp_ticks
000688  e0410000          SUB      r0,r1,r0
;;;1095   
;;;1096         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
;;;1097                                     m, m * TCP_SLOW_INTERVAL));
;;;1098   
;;;1099         /* This is taken directly from VJs original code in his paper */
;;;1100         m = m - (pcb->sa >> 3);
00068c  e1d414f0          LDRSH    r1,[r4,#0x40]
000690  e04001c1          SUB      r0,r0,r1,ASR #3
000694  e1a00800          LSL      r0,r0,#16
000698  e1b00840          ASRS     r0,r0,#16
;;;1101         pcb->sa += m;
00069c  e0811000          ADD      r1,r1,r0
0006a0  e1a01801          LSL      r1,r1,#16
0006a4  e1a01841          ASR      r1,r1,#16
0006a8  e1c414b0          STRH     r1,[r4,#0x40]
;;;1102         if (m < 0) {
;;;1103           m = -m;
;;;1104         }
;;;1105         m = m - (pcb->sv >> 2);
0006ac  e1d424f2          LDRSH    r2,[r4,#0x42]
0006b0  42600000          RSBMI    r0,r0,#0              ;1103
0006b4  41a00800          LSLMI    r0,r0,#16             ;1103
0006b8  41a00840          ASRMI    r0,r0,#16             ;1103
0006bc  e0400142          SUB      r0,r0,r2,ASR #2
;;;1106         pcb->sv += m;
0006c0  e0800002          ADD      r0,r0,r2
0006c4  e1c404b2          STRH     r0,[r4,#0x42]
;;;1107         pcb->rto = (pcb->sa >> 3) + pcb->sv;
0006c8  e08001c1          ADD      r0,r0,r1,ASR #3
0006cc  e1c404b4          STRH     r0,[r4,#0x44]
;;;1108   
;;;1109         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
;;;1110                                     pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));
;;;1111   
;;;1112         pcb->rttest = 0;
0006d0  e5846038          STR      r6,[r4,#0x38]
                  |L1.1748|
;;;1113       }
;;;1114     }
;;;1115   
;;;1116     /* If the incoming segment contains data, we must process it
;;;1117        further unless the pcb already received a FIN.
;;;1118        (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
;;;1119        LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
;;;1120     if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
0006d4  e1d720b2          LDRH     r2,[r7,#2]  ; tcplen
;;;1121       /* This code basically does three things:
;;;1122   
;;;1123       +) If the incoming segment contains data that is the next
;;;1124       in-sequence data, this data is passed to the application. This
;;;1125       might involve trimming the first edge of the data. The rcv_nxt
;;;1126       variable and the advertised window are adjusted.
;;;1127   
;;;1128       +) If the incoming segment has data that is above the next
;;;1129       sequence number expected (->rcv_nxt), the segment is placed on
;;;1130       the ->ooseq queue. This is done by finding the appropriate
;;;1131       place in the ->ooseq queue (which is ordered by sequence
;;;1132       number) and trim the segment in both ends if needed. An
;;;1133       immediate ACK is sent to indicate that we received an
;;;1134       out-of-sequence segment.
;;;1135   
;;;1136       +) Finally, we check if the first segment on the ->ooseq queue
;;;1137       now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
;;;1138       rcv_nxt > ooseq->seqno, we must trim the first edge of the
;;;1139       segment on ->ooseq before we adjust rcv_nxt. The data in the
;;;1140       segments that are now on sequence are chained onto the
;;;1141       incoming segment so that we only need to call the application
;;;1142       once.
;;;1143       */
;;;1144   
;;;1145       /* First, we check if we must trim the first edge. We have to do
;;;1146          this if the sequence number of the incoming segment is less
;;;1147          than rcv_nxt, and the sequence number plus the length of the
;;;1148          segment is larger than rcv_nxt. */
;;;1149       /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1150             if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
;;;1151       if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
0006d8  e597100c          LDR      r1,[r7,#0xc]  ; seqno
0006dc  e3520000          CMP      r2,#0                 ;1120
0006e0  15d40018          LDRBNE   r0,[r4,#0x18]         ;1120
0006e4  13500007          CMPNE    r0,#7                 ;1120
0006e8  e5940028          LDR      r0,[r4,#0x28]
0006ec  2a0002a2          BCS      |L1.4476|
;;;1152         /* Trimming the first edge is done by pushing the payload
;;;1153            pointer in the pbuf downwards. This is somewhat tricky since
;;;1154            we do not want to discard the full contents of the pbuf up to
;;;1155            the new starting point of the data since we have to keep the
;;;1156            TCP header which is present in the first pbuf in the chain.
;;;1157   
;;;1158            What is done is really quite a nasty hack: the first pbuf in
;;;1159            the pbuf chain is pointed to by inseg.p. Since we need to be
;;;1160            able to deallocate the whole pbuf, we cannot change this
;;;1161            inseg.p pointer to point to any of the later pbufs in the
;;;1162            chain. Instead, we point the ->payload pointer in the first
;;;1163            pbuf to data in one of the later pbufs. We also set the
;;;1164            inseg.data pointer to point to the right place. This way, the
;;;1165            ->p pointer will still point to the first pbuf, but the
;;;1166            ->p->payload pointer will point to data in another pbuf.
;;;1167   
;;;1168            After we are done with adjusting the pbuf pointers we must
;;;1169            adjust the ->data pointer in the seg and the segment
;;;1170            length.*/
;;;1171   
;;;1172         off = pcb->rcv_nxt - seqno;
;;;1173         p = inseg.p;
0006f0  e59f8310          LDR      r8,|L1.2568|
0006f4  e0405001          SUB      r5,r0,r1              ;1151
0006f8  e3550001          CMP      r5,#1                 ;1151
0006fc  4a000051          BMI      |L1.2120|
000700  e0822001          ADD      r2,r2,r1              ;1151
000704  e0402002          SUB      r2,r0,r2              ;1151
000708  e2822001          ADD      r2,r2,#1              ;1151
00070c  e3520000          CMP      r2,#0                 ;1151
000710  ca00004c          BGT      |L1.2120|
000714  e5989004          LDR      r9,[r8,#4]  ; inseg
;;;1174         LWIP_ASSERT("inseg.p != NULL", inseg.p);
000718  e3590000          CMP      r9,#0
00071c  1a000004          BNE      |L1.1844|
000720  e59f22e4          LDR      r2,|L1.2572|
000724  e24f3fad          ADR      r3,|L1.1144|
000728  e28f1e2e          ADR      r1,|L1.2576|
00072c  e24f0d0a          ADR      r0,|L1.1204|
000730  ebfffffe          BL       sysprintf
                  |L1.1844|
;;;1175         LWIP_ASSERT("insane offset!", (off < 0x7fff));
000734  e59f02e4          LDR      r0,|L1.2592|
000738  e1550000          CMP      r5,r0
00073c  ba000004          BLT      |L1.1876|
000740  e59f22dc          LDR      r2,|L1.2596|
000744  e24f3fb5          ADR      r3,|L1.1144|
000748  e28f1fb6          ADR      r1,|L1.2600|
00074c  e24f0e2a          ADR      r0,|L1.1204|
000750  ebfffffe          BL       sysprintf
                  |L1.1876|
;;;1176         if (inseg.p->len < off) {
000754  e5980004          LDR      r0,[r8,#4]  ; inseg
000758  e1d010ba          LDRH     r1,[r0,#0xa]
00075c  e1510005          CMP      r1,r5
000760  aa00002f          BGE      |L1.2084|
;;;1177           LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
000764  e1d000b8          LDRH     r0,[r0,#8]
000768  e1500005          CMP      r0,r5
00076c  aa000004          BGE      |L1.1924|
000770  e59f22c0          LDR      r2,|L1.2616|
000774  e24f3fc1          ADR      r3,|L1.1144|
000778  e28f1faf          ADR      r1,|L1.2620|
00077c  e24f0e2d          ADR      r0,|L1.1204|
000780  ebfffffe          BL       sysprintf
                  |L1.1924|
;;;1178           new_tot_len = (u16_t)(inseg.p->tot_len - off);
000784  e5980004          LDR      r0,[r8,#4]  ; inseg
000788  e1d000b8          LDRH     r0,[r0,#8]
00078c  e0400005          SUB      r0,r0,r5
000790  e1a01800          LSL      r1,r0,#16
000794  e1a01821          LSR      r1,r1,#16
;;;1179           while (p->len < off) {
000798  ea000003          B        |L1.1964|
                  |L1.1948|
;;;1180             off -= p->len;
;;;1181             /* KJM following line changed (with addition of new_tot_len var)
;;;1182                to fix bug #9076
;;;1183                inseg.p->tot_len -= p->len; */
;;;1184             p->tot_len = new_tot_len;
00079c  e1c910b8          STRH     r1,[r9,#8]
;;;1185             p->len = 0;
0007a0  e1c960ba          STRH     r6,[r9,#0xa]
;;;1186             p = p->next;
0007a4  e5999000          LDR      r9,[r9,#0]
0007a8  e0455000          SUB      r5,r5,r0              ;1180
                  |L1.1964|
0007ac  e1d900ba          LDRH     r0,[r9,#0xa]          ;1179
0007b0  e1500005          CMP      r0,r5                 ;1179
0007b4  bafffff8          BLT      |L1.1948|
;;;1187           }
;;;1188           if(pbuf_header(p, (s16_t)-off)) {
0007b8  e2650000          RSB      r0,r5,#0
0007bc  e1a01800          LSL      r1,r0,#16
0007c0  e1a01841          ASR      r1,r1,#16
0007c4  e1a00009          MOV      r0,r9
0007c8  ebfffffe          BL       pbuf_header
0007cc  e3500000          CMP      r0,#0
;;;1189             /* Do we need to cope with this failing?  Assert for now */
;;;1190             LWIP_ASSERT("pbuf_header failed", 0);
0007d0  159f2274          LDRNE    r2,|L1.2636|
0007d4  124f3fd9          ADRNE    r3,|L1.1144|
0007d8  0a000002          BEQ      |L1.2024|
                  |L1.2012|
;;;1191           }
;;;1192         } else {
;;;1193           if(pbuf_header(inseg.p, (s16_t)-off)) {
;;;1194             /* Do we need to cope with this failing?  Assert for now */
;;;1195             LWIP_ASSERT("pbuf_header failed", 0);
0007dc  e28f1f9b          ADR      r1,|L1.2640|
0007e0  e24f0fcd          ADR      r0,|L1.1204|
0007e4  ebfffffe          BL       sysprintf
                  |L1.2024|
;;;1196           }
;;;1197         }
;;;1198         inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
0007e8  e5940028          LDR      r0,[r4,#0x28]
0007ec  e1d720bc          LDRH     r2,[r7,#0xc]  ; seqno
0007f0  e1d810b8          LDRH     r1,[r8,#8]  ; inseg
;;;1199         inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
0007f4  e1a05000          MOV      r5,r0
0007f8  e0402002          SUB      r2,r0,r2              ;1198
0007fc  e0411002          SUB      r1,r1,r2              ;1198
000800  e1c810b8          STRH     r1,[r8,#8]            ;1198  ; inseg
000804  e5981010          LDR      r1,[r8,#0x10]  ; inseg
000808  e587000c          STR      r0,[r7,#0xc]  ; seqno
00080c  e2811004          ADD      r1,r1,#4
000810  ebfffffe          BL       __aeabi_uwrite4
;;;1200       }
;;;1201       else {
;;;1202         if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1203           /* the whole segment is < rcv_nxt */
;;;1204           /* must be a duplicate of a packet that has already been correctly handled */
;;;1205   
;;;1206           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
;;;1207           tcp_ack_now(pcb);
;;;1208         }
;;;1209       }
;;;1210   
;;;1211       /* The sequence number must be within the window (above rcv_nxt
;;;1212          and below rcv_nxt + rcv_wnd) in order to be further
;;;1213          processed. */
;;;1214       if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
000814  e5940028          LDR      r0,[r4,#0x28]
000818  e0550000          SUBS     r0,r5,r0
00081c  4a000253          BMI      |L1.4464|
000820  ea00000d          B        |L1.2140|
                  |L1.2084|
000824  e2651000          RSB      r1,r5,#0              ;1193
000828  e1a01801          LSL      r1,r1,#16             ;1193
00082c  e1a01841          ASR      r1,r1,#16             ;1193
000830  ebfffffe          BL       pbuf_header
000834  e3500000          CMP      r0,#0                 ;1193
000838  159f2224          LDRNE    r2,|L1.2660|
00083c  124f3ff3          ADRNE    r3,|L1.1144|
000840  1affffe5          BNE      |L1.2012|
000844  eaffffe7          B        |L1.2024|
                  |L1.2120|
000848  e0510000          SUBS     r0,r1,r0              ;1202
00084c  45d4001e          LDRBMI   r0,[r4,#0x1e]         ;1207
000850  43800002          ORRMI    r0,r0,#2              ;1207
000854  45c4001e          STRBMI   r0,[r4,#0x1e]         ;1207
000858  4a000244          BMI      |L1.4464|
                  |L1.2140|
00085c  e1d412bc          LDRH     r1,[r4,#0x2c]
000860  e5940028          LDR      r0,[r4,#0x28]
000864  e0802001          ADD      r2,r0,r1
000868  e597100c          LDR      r1,[r7,#0xc]  ; seqno
00086c  e0412002          SUB      r2,r1,r2
000870  e2822001          ADD      r2,r2,#1
000874  e3520000          CMP      r2,#0
000878  ca00023c          BGT      |L1.4464|
;;;1215                           pcb->rcv_nxt + pcb->rcv_wnd - 1)){
;;;1216         if (pcb->rcv_nxt == seqno) {
00087c  e1500001          CMP      r0,r1
000880  1a00015e          BNE      |L1.3584|
;;;1217           /* The incoming segment is the next in sequence. We check if
;;;1218              we have to trim the end of the segment and update rcv_nxt
;;;1219              and pass the data to the application. */
;;;1220           tcplen = TCP_TCPLEN(&inseg);
000884  e5980010          LDR      r0,[r8,#0x10]  ; inseg
000888  e5d0100d          LDRB     r1,[r0,#0xd]
00088c  e5d0000c          LDRB     r0,[r0,#0xc]
000890  e1800401          ORR      r0,r0,r1,LSL #8
000894  ebfffffe          BL       lwip_ntohs
000898  e1d810b8          LDRH     r1,[r8,#8]  ; inseg
00089c  e2100003          ANDS     r0,r0,#3
0008a0  13a00001          MOVNE    r0,#1
0008a4  e0800001          ADD      r0,r0,r1
0008a8  e3c00801          BIC      r0,r0,#0x10000
0008ac  e1c700b2          STRH     r0,[r7,#2]  ; tcplen
;;;1221   
;;;1222           if (tcplen > pcb->rcv_wnd) {
0008b0  e1d412bc          LDRH     r1,[r4,#0x2c]
0008b4  e1510000          CMP      r1,r0
0008b8  2a00003c          BCS      |L1.2480|
;;;1223             LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1224                         ("tcp_receive: other end overran receive window"
;;;1225                          "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1226                          seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1227             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0008bc  e5980010          LDR      r0,[r8,#0x10]  ; inseg
0008c0  e5d0100d          LDRB     r1,[r0,#0xd]
0008c4  e5d0000c          LDRB     r0,[r0,#0xc]
0008c8  e1800401          ORR      r0,r0,r1,LSL #8
0008cc  ebfffffe          BL       lwip_ntohs
0008d0  e3100001          TST      r0,#1
0008d4  0a000010          BEQ      |L1.2332|
;;;1228               /* Must remove the FIN from the header as we're trimming 
;;;1229                * that byte of sequence-space from the packet */
;;;1230               TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
0008d8  e5980010          LDR      r0,[r8,#0x10]  ; inseg
0008dc  e5d0100d          LDRB     r1,[r0,#0xd]
0008e0  e5d0000c          LDRB     r0,[r0,#0xc]
0008e4  e1800401          ORR      r0,r0,r1,LSL #8
0008e8  ebfffffe          BL       lwip_ntohs
0008ec  e200003e          AND      r0,r0,#0x3e
0008f0  ebfffffe          BL       lwip_htons
0008f4  e1a01000          MOV      r1,r0
0008f8  e5980010          LDR      r0,[r8,#0x10]  ; inseg
0008fc  e5d0200d          LDRB     r2,[r0,#0xd]
000900  e5d0300c          LDRB     r3,[r0,#0xc]
000904  e1832402          ORR      r2,r3,r2,LSL #8
000908  e3c22c3f          BIC      r2,r2,#0x3f00
00090c  e1811002          ORR      r1,r1,r2
000910  e5c0100c          STRB     r1,[r0,#0xc]
000914  e1a01421          LSR      r1,r1,#8
000918  e5c0100d          STRB     r1,[r0,#0xd]
                  |L1.2332|
;;;1231             }
;;;1232             /* Adjust length of segment to fit in the window. */
;;;1233             inseg.len = pcb->rcv_wnd;
00091c  e1d402bc          LDRH     r0,[r4,#0x2c]
000920  e1c800b8          STRH     r0,[r8,#8]  ; inseg
;;;1234             if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
000924  e5980010          LDR      r0,[r8,#0x10]  ; inseg
000928  e5d0100d          LDRB     r1,[r0,#0xd]
00092c  e5d0000c          LDRB     r0,[r0,#0xc]
000930  e1800401          ORR      r0,r0,r1,LSL #8
000934  ebfffffe          BL       lwip_ntohs
000938  e3100002          TST      r0,#2
;;;1235               inseg.len -= 1;
00093c  11d800b8          LDRHNE   r0,[r8,#8]  ; inseg
000940  12400001          SUBNE    r0,r0,#1
000944  11c800b8          STRHNE   r0,[r8,#8]  ; inseg
;;;1236             }
;;;1237             pbuf_realloc(inseg.p, inseg.len);
000948  e1d810b8          LDRH     r1,[r8,#8]  ; inseg
00094c  e5980004          LDR      r0,[r8,#4]  ; inseg
000950  ebfffffe          BL       pbuf_realloc
;;;1238             tcplen = TCP_TCPLEN(&inseg);
000954  e5980010          LDR      r0,[r8,#0x10]  ; inseg
000958  e5d0100d          LDRB     r1,[r0,#0xd]
00095c  e5d0000c          LDRB     r0,[r0,#0xc]
000960  e1800401          ORR      r0,r0,r1,LSL #8
000964  ebfffffe          BL       lwip_ntohs
000968  e1d810b8          LDRH     r1,[r8,#8]  ; inseg
00096c  e2100003          ANDS     r0,r0,#3
000970  13a00001          MOVNE    r0,#1
000974  e0800001          ADD      r0,r0,r1
000978  e3c00801          BIC      r0,r0,#0x10000
00097c  e1c700b2          STRH     r0,[r7,#2]  ; tcplen
;;;1239             LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
000980  e1d422bc          LDRH     r2,[r4,#0x2c]
000984  e5941028          LDR      r1,[r4,#0x28]
000988  e0811002          ADD      r1,r1,r2
00098c  e597200c          LDR      r2,[r7,#0xc]  ; seqno
000990  e0800002          ADD      r0,r0,r2
000994  e1500001          CMP      r0,r1
000998  0a000004          BEQ      |L1.2480|
00099c  e59f30c4          LDR      r3,|L1.2664|
0009a0  e59f20c4          LDR      r2,|L1.2668|
0009a4  e59f00fc          LDR      r0,|L1.2728|
0009a8  e28f10c0          ADR      r1,|L1.2672|
0009ac  ebfffffe          BL       sysprintf
                  |L1.2480|
;;;1240                         (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1241           }
;;;1242   #if TCP_QUEUE_OOSEQ
;;;1243           /* Received in-sequence data, adjust ooseq data if:
;;;1244              - FIN has been received or
;;;1245              - inseq overlaps with ooseq */
;;;1246           if (pcb->ooseq != NULL) {
0009b0  e5940074          LDR      r0,[r4,#0x74]
0009b4  e3500000          CMP      r0,#0
0009b8  0a000099          BEQ      |L1.3108|
;;;1247             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0009bc  e5980010          LDR      r0,[r8,#0x10]  ; inseg
0009c0  e5d0100d          LDRB     r1,[r0,#0xd]
0009c4  e5d0000c          LDRB     r0,[r0,#0xc]
0009c8  e1800401          ORR      r0,r0,r1,LSL #8
0009cc  ebfffffe          BL       lwip_ntohs
0009d0  e3100001          TST      r0,#1
;;;1248               LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1249                           ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
;;;1250               /* Received in-order FIN means anything that was received
;;;1251                * out of order must now have been received in-order, so
;;;1252                * bin the ooseq queue */
;;;1253               while (pcb->ooseq != NULL) {
;;;1254                 struct tcp_seg *old_ooseq = pcb->ooseq;
;;;1255                 pcb->ooseq = pcb->ooseq->next;
;;;1256                 tcp_seg_free(old_ooseq);
;;;1257               }
;;;1258             } else {
;;;1259               next = pcb->ooseq;
0009d4  05945074          LDREQ    r5,[r4,#0x74]
0009d8  0a000055          BEQ      |L1.2868|
0009dc  ea000002          B        |L1.2540|
                  |L1.2528|
0009e0  e5901000          LDR      r1,[r0,#0]            ;1255
0009e4  e5841074          STR      r1,[r4,#0x74]         ;1255
0009e8  ebfffffe          BL       tcp_seg_free
                  |L1.2540|
0009ec  e5940074          LDR      r0,[r4,#0x74]         ;1253
0009f0  e3500000          CMP      r0,#0                 ;1253
0009f4  1afffff9          BNE      |L1.2528|
0009f8  ea000089          B        |L1.3108|
                  |L1.2556|
                          DCD      0x0000042e
                  |L1.2560|
                          DCD      0x00000437
                  |L1.2564|
                          DCD      tcp_ticks
                  |L1.2568|
                          DCD      ||.bss||
                  |L1.2572|
                          DCD      0x00000496
                  |L1.2576|
000a10  696e7365          DCB      "inseg.p != NULL",0
000a14  672e7020
000a18  213d204e
000a1c  554c4c00
                  |L1.2592|
                          DCD      0x00007fff
                  |L1.2596|
                          DCD      0x00000497
                  |L1.2600|
000a28  696e7361          DCB      "insane offset!",0
000a2c  6e65206f
000a30  66667365
000a34  742100  
000a37  00                DCB      0
                  |L1.2616|
                          DCD      0x00000499
                  |L1.2620|
000a3c  70627566          DCB      "pbuf too short!",0
000a40  20746f6f
000a44  2073686f
000a48  72742100
                  |L1.2636|
                          DCD      0x000004a6
                  |L1.2640|
000a50  70627566          DCB      "pbuf_header failed",0
000a54  5f686561
000a58  64657220
000a5c  6661696c
000a60  656400  
000a63  00                DCB      0
                  |L1.2660|
                          DCD      0x000004ab
                  |L1.2664|
                          DCD      ||.text||+0x478
                  |L1.2668|
                          DCD      0x000004d7
                  |L1.2672|
000a70  7463705f          DCB      "tcp_receive: segment not trimmed correctly to rcv_wnd\n"
000a74  72656365
000a78  6976653a
000a7c  20736567
000a80  6d656e74
000a84  206e6f74
000a88  20747269
000a8c  6d6d6564
000a90  20636f72
000a94  72656374
000a98  6c792074
000a9c  6f207263
000aa0  765f776e
000aa4  640a    
000aa6  00                DCB      0
000aa7  00                DCB      0
                  |L1.2728|
                          DCD      ||.text||+0x4b4
                  |L1.2732|
;;;1260               /* Remove all segments on ooseq that are covered by inseg already.
;;;1261                * FIN is copied from ooseq to inseg if present. */
;;;1262               while (next &&
;;;1263                      TCP_SEQ_GEQ(seqno + tcplen,
;;;1264                                  next->tcphdr->seqno + next->len)) {
;;;1265                 /* inseg cannot have FIN here (already processed above) */
;;;1266                 if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
000aac  e5d9000d          LDRB     r0,[r9,#0xd]
000ab0  e5d9100c          LDRB     r1,[r9,#0xc]
000ab4  e1810400          ORR      r0,r1,r0,LSL #8
000ab8  ebfffffe          BL       lwip_ntohs
000abc  e3100001          TST      r0,#1
000ac0  0a000018          BEQ      |L1.2856|
;;;1267                     (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
000ac4  e5980010          LDR      r0,[r8,#0x10]  ; inseg
000ac8  e5d0100d          LDRB     r1,[r0,#0xd]
000acc  e5d0000c          LDRB     r0,[r0,#0xc]
000ad0  e1800401          ORR      r0,r0,r1,LSL #8
000ad4  ebfffffe          BL       lwip_ntohs
000ad8  e3100002          TST      r0,#2
000adc  1a000011          BNE      |L1.2856|
;;;1268                   TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
000ae0  e3a00001          MOV      r0,#1
000ae4  ebfffffe          BL       lwip_htons
000ae8  e1a01000          MOV      r1,r0
000aec  e5980010          LDR      r0,[r8,#0x10]  ; inseg
000af0  e5d0200d          LDRB     r2,[r0,#0xd]
000af4  e5d0300c          LDRB     r3,[r0,#0xc]
000af8  e1832402          ORR      r2,r3,r2,LSL #8
000afc  e1811002          ORR      r1,r1,r2
000b00  e1a02421          LSR      r2,r1,#8
000b04  e5c0100c          STRB     r1,[r0,#0xc]
000b08  e5c0200d          STRB     r2,[r0,#0xd]
000b0c  e1a00001          MOV      r0,r1
;;;1269                   tcplen = TCP_TCPLEN(&inseg);
000b10  ebfffffe          BL       lwip_ntohs
000b14  e1d810b8          LDRH     r1,[r8,#8]  ; inseg
000b18  e2100003          ANDS     r0,r0,#3
000b1c  13a00001          MOVNE    r0,#1
000b20  e0800001          ADD      r0,r0,r1
000b24  e1c700b2          STRH     r0,[r7,#2]  ; tcplen
                  |L1.2856|
;;;1270                 }
;;;1271                 prev = next;
;;;1272                 next = next->next;
000b28  e1a00005          MOV      r0,r5
000b2c  e5955000          LDR      r5,[r5,#0]
;;;1273                 tcp_seg_free(prev);
000b30  ebfffffe          BL       tcp_seg_free
                  |L1.2868|
000b34  e3550000          CMP      r5,#0                 ;1262
000b38  0a000038          BEQ      |L1.3104|
000b3c  e5959010          LDR      r9,[r5,#0x10]         ;1263
000b40  e2890004          ADD      r0,r9,#4              ;1263
000b44  ebfffffe          BL       __aeabi_uread4
000b48  e1d510b8          LDRH     r1,[r5,#8]            ;1263
000b4c  e1d720b2          LDRH     r2,[r7,#2]            ;1263  ; tcplen
000b50  e0800001          ADD      r0,r0,r1              ;1263
000b54  e597100c          LDR      r1,[r7,#0xc]          ;1263  ; seqno
000b58  e0811002          ADD      r1,r1,r2              ;1263
000b5c  e0510000          SUBS     r0,r1,r0              ;1263
000b60  5affffd1          BPL      |L1.2732|
;;;1274               }
;;;1275               /* Now trim right side of inseg if it overlaps with the first
;;;1276                * segment on ooseq */
;;;1277               if (next &&
;;;1278                   TCP_SEQ_GT(seqno + tcplen,
000b64  e5950010          LDR      r0,[r5,#0x10]
000b68  e2800004          ADD      r0,r0,#4
000b6c  ebfffffe          BL       __aeabi_uread4
000b70  e1d720b2          LDRH     r2,[r7,#2]  ; tcplen
000b74  e597100c          LDR      r1,[r7,#0xc]  ; seqno
000b78  e0822001          ADD      r2,r2,r1
000b7c  e0422000          SUB      r2,r2,r0
000b80  e3520000          CMP      r2,#0
000b84  da000025          BLE      |L1.3104|
;;;1279                              next->tcphdr->seqno)) {
;;;1280                 /* inseg cannot have FIN here (already processed above) */
;;;1281                 inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
000b88  e0400001          SUB      r0,r0,r1
000b8c  e1c800b8          STRH     r0,[r8,#8]  ; inseg
;;;1282                 if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
000b90  e5980010          LDR      r0,[r8,#0x10]  ; inseg
000b94  e1a0a007          MOV      r10,r7                ;1281
000b98  e5d0100d          LDRB     r1,[r0,#0xd]
000b9c  e5d0000c          LDRB     r0,[r0,#0xc]
000ba0  e1800401          ORR      r0,r0,r1,LSL #8
000ba4  ebfffffe          BL       lwip_ntohs
000ba8  e3100002          TST      r0,#2
;;;1283                   inseg.len -= 1;
000bac  11d800b8          LDRHNE   r0,[r8,#8]  ; inseg
000bb0  12400001          SUBNE    r0,r0,#1
000bb4  11c800b8          STRHNE   r0,[r8,#8]  ; inseg
;;;1284                 }
;;;1285                 pbuf_realloc(inseg.p, inseg.len);
000bb8  e1d810b8          LDRH     r1,[r8,#8]  ; inseg
000bbc  e5980004          LDR      r0,[r8,#4]  ; inseg
000bc0  ebfffffe          BL       pbuf_realloc
;;;1286                 tcplen = TCP_TCPLEN(&inseg);
000bc4  e5980010          LDR      r0,[r8,#0x10]  ; inseg
000bc8  e5d0100d          LDRB     r1,[r0,#0xd]
000bcc  e5d0000c          LDRB     r0,[r0,#0xc]
000bd0  e1800401          ORR      r0,r0,r1,LSL #8
000bd4  ebfffffe          BL       lwip_ntohs
000bd8  e1d810b8          LDRH     r1,[r8,#8]  ; inseg
000bdc  e2100003          ANDS     r0,r0,#3
000be0  13a00001          MOVNE    r0,#1
000be4  e0800001          ADD      r0,r0,r1
000be8  e3c09801          BIC      r9,r0,#0x10000
000bec  e1ca90b2          STRH     r9,[r10,#2]  ; tcplen
;;;1287                 LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
000bf0  e5950010          LDR      r0,[r5,#0x10]
000bf4  e2800004          ADD      r0,r0,#4
000bf8  ebfffffe          BL       __aeabi_uread4
000bfc  e59a100c          LDR      r1,[r10,#0xc]  ; seqno
000c00  e0811009          ADD      r1,r1,r9
000c04  e1500001          CMP      r0,r1
000c08  0a000004          BEQ      |L1.3104|
000c0c  e51f31ac          LDR      r3,|L1.2664|
000c10  e59f22f0          LDR      r2,|L1.3848|
000c14  e51f0174          LDR      r0,|L1.2728|
000c18  e28f1fbb          ADR      r1,|L1.3852|
000c1c  ebfffffe          BL       sysprintf
                  |L1.3104|
;;;1288                             (seqno + tcplen) == next->tcphdr->seqno);
;;;1289               }
;;;1290               pcb->ooseq = next;
000c20  e5845074          STR      r5,[r4,#0x74]
                  |L1.3108|
;;;1291             }
;;;1292           }
;;;1293   #endif /* TCP_QUEUE_OOSEQ */
;;;1294   
;;;1295           pcb->rcv_nxt = seqno + tcplen;
000c24  e1d700b2          LDRH     r0,[r7,#2]  ; tcplen
000c28  e597100c          LDR      r1,[r7,#0xc]  ; seqno
000c2c  e0811000          ADD      r1,r1,r0
000c30  e5841028          STR      r1,[r4,#0x28]
;;;1296   
;;;1297           /* Update the receiver's (our) window. */
;;;1298           LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
000c34  e1d412bc          LDRH     r1,[r4,#0x2c]
000c38  e1510000          CMP      r1,r0
000c3c  2a000004          BCS      |L1.3156|
000c40  e51f31e0          LDR      r3,|L1.2664|
000c44  e59f22fc          LDR      r2,|L1.3912|
000c48  e51f01a8          LDR      r0,|L1.2728|
000c4c  e28f1fbe          ADR      r1,|L1.3916|
000c50  ebfffffe          BL       sysprintf
                  |L1.3156|
;;;1299           pcb->rcv_wnd -= tcplen;
000c54  e1d402bc          LDRH     r0,[r4,#0x2c]
000c58  e1d710b2          LDRH     r1,[r7,#2]  ; tcplen
000c5c  e0400001          SUB      r0,r0,r1
000c60  e1c402bc          STRH     r0,[r4,#0x2c]
;;;1300   
;;;1301           tcp_update_rcv_ann_wnd(pcb);
000c64  e1a00004          MOV      r0,r4
000c68  ebfffffe          BL       tcp_update_rcv_ann_wnd
;;;1302   
;;;1303           /* If there is data in the segment, we make preparations to
;;;1304              pass this up to the application. The ->recv_data variable
;;;1305              is used for holding the pbuf that goes to the
;;;1306              application. The code for reassembling out-of-sequence data
;;;1307              chains its data on this pbuf as well.
;;;1308   
;;;1309              If the segment was a FIN, we set the TF_GOT_FIN flag that will
;;;1310              be used to indicate to the application that the remote side has
;;;1311              closed its end of the connection. */
;;;1312           if (inseg.p->tot_len > 0) {
000c6c  e5980004          LDR      r0,[r8,#4]  ; inseg
000c70  e1d010b8          LDRH     r1,[r0,#8]
000c74  e3510000          CMP      r1,#0
;;;1313             recv_data = inseg.p;
000c78  15870014          STRNE    r0,[r7,#0x14]  ; recv_data
;;;1314             /* Since this pbuf now is the responsibility of the
;;;1315                application, we delete our reference to it so that we won't
;;;1316                (mistakingly) deallocate it. */
;;;1317             inseg.p = NULL;
000c7c  15886004          STRNE    r6,[r8,#4]  ; inseg
;;;1318           }
;;;1319           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000c80  e5980010          LDR      r0,[r8,#0x10]  ; inseg
000c84  e5d0100d          LDRB     r1,[r0,#0xd]
000c88  e5d0000c          LDRB     r0,[r0,#0xc]
000c8c  e1800401          ORR      r0,r0,r1,LSL #8
000c90  ebfffffe          BL       lwip_ntohs
000c94  e3100001          TST      r0,#1
;;;1320             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
;;;1321             recv_flags |= TF_GOT_FIN;
000c98  15d70001          LDRBNE   r0,[r7,#1]  ; recv_flags
000c9c  13800020          ORRNE    r0,r0,#0x20
000ca0  15c70001          STRBNE   r0,[r7,#1]  ; recv_flags
000ca4  ea000045          B        |L1.3520|
                  |L1.3240|
;;;1322           }
;;;1323   
;;;1324   #if TCP_QUEUE_OOSEQ
;;;1325           /* We now check if we have segments on the ->ooseq queue that
;;;1326              are now in sequence. */
;;;1327           while (pcb->ooseq != NULL &&
;;;1328                  pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
;;;1329   
;;;1330             cseg = pcb->ooseq;
;;;1331             seqno = pcb->ooseq->tcphdr->seqno;
000ca8  e587000c          STR      r0,[r7,#0xc]  ; seqno
;;;1332   
;;;1333             pcb->rcv_nxt += TCP_TCPLEN(cseg);
000cac  e5d8000d          LDRB     r0,[r8,#0xd]
000cb0  e5d8100c          LDRB     r1,[r8,#0xc]
000cb4  e1810400          ORR      r0,r1,r0,LSL #8
000cb8  ebfffffe          BL       lwip_ntohs
000cbc  e1d510b8          LDRH     r1,[r5,#8]
000cc0  e2100003          ANDS     r0,r0,#3
000cc4  13a00001          MOVNE    r0,#1
000cc8  e0800001          ADD      r0,r0,r1
000ccc  e5941028          LDR      r1,[r4,#0x28]
000cd0  e0800001          ADD      r0,r0,r1
;;;1334             LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
000cd4  e5840028          STR      r0,[r4,#0x28]
000cd8  e5950010          LDR      r0,[r5,#0x10]
000cdc  e5d0100d          LDRB     r1,[r0,#0xd]
000ce0  e5d0000c          LDRB     r0,[r0,#0xc]
000ce4  e1800401          ORR      r0,r0,r1,LSL #8
000ce8  ebfffffe          BL       lwip_ntohs
000cec  e1d510b8          LDRH     r1,[r5,#8]
000cf0  e2100003          ANDS     r0,r0,#3
000cf4  13a00001          MOVNE    r0,#1
000cf8  e0800001          ADD      r0,r0,r1
000cfc  e1d412bc          LDRH     r1,[r4,#0x2c]
000d00  e1500001          CMP      r0,r1
000d04  9a000004          BLS      |L1.3356|
000d08  e51f32a8          LDR      r3,|L1.2664|
000d0c  e59f2258          LDR      r2,|L1.3948|
000d10  e51f0270          LDR      r0,|L1.2728|
000d14  e28f1f95          ADR      r1,|L1.3952|
000d18  ebfffffe          BL       sysprintf
                  |L1.3356|
;;;1335                         pcb->rcv_wnd >= TCP_TCPLEN(cseg));
;;;1336             pcb->rcv_wnd -= TCP_TCPLEN(cseg);
000d1c  e5950010          LDR      r0,[r5,#0x10]
000d20  e5d0100d          LDRB     r1,[r0,#0xd]
000d24  e5d0000c          LDRB     r0,[r0,#0xc]
000d28  e1800401          ORR      r0,r0,r1,LSL #8
000d2c  ebfffffe          BL       lwip_ntohs
000d30  e1d510b8          LDRH     r1,[r5,#8]
000d34  e2100003          ANDS     r0,r0,#3
000d38  13a00001          MOVNE    r0,#1
000d3c  e0800001          ADD      r0,r0,r1
000d40  e1d412bc          LDRH     r1,[r4,#0x2c]
000d44  e0410000          SUB      r0,r1,r0
000d48  e1c402bc          STRH     r0,[r4,#0x2c]
;;;1337   
;;;1338             tcp_update_rcv_ann_wnd(pcb);
000d4c  e1a00004          MOV      r0,r4
000d50  ebfffffe          BL       tcp_update_rcv_ann_wnd
;;;1339   
;;;1340             if (cseg->p->tot_len > 0) {
000d54  e5951004          LDR      r1,[r5,#4]
000d58  e1d100b8          LDRH     r0,[r1,#8]
000d5c  e3500000          CMP      r0,#0
000d60  0a000004          BEQ      |L1.3448|
;;;1341               /* Chain this pbuf onto the pbuf that we will pass to
;;;1342                  the application. */
;;;1343               if (recv_data) {
000d64  e5970014          LDR      r0,[r7,#0x14]  ; recv_data
000d68  e3500000          CMP      r0,#0
;;;1344                 pbuf_cat(recv_data, cseg->p);
;;;1345               } else {
;;;1346                 recv_data = cseg->p;
000d6c  05871014          STREQ    r1,[r7,#0x14]  ; recv_data
000d70  1bfffffe          BLNE     pbuf_cat
;;;1347               }
;;;1348               cseg->p = NULL;
000d74  e5856004          STR      r6,[r5,#4]
                  |L1.3448|
;;;1349             }
;;;1350             if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000d78  e5950010          LDR      r0,[r5,#0x10]
000d7c  e5d0100d          LDRB     r1,[r0,#0xd]
000d80  e5d0000c          LDRB     r0,[r0,#0xc]
000d84  e1800401          ORR      r0,r0,r1,LSL #8
000d88  ebfffffe          BL       lwip_ntohs
000d8c  e3100001          TST      r0,#1
000d90  0a000006          BEQ      |L1.3504|
;;;1351               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
;;;1352               recv_flags |= TF_GOT_FIN;
000d94  e5d70001          LDRB     r0,[r7,#1]  ; recv_flags
000d98  e3800020          ORR      r0,r0,#0x20
000d9c  e5c70001          STRB     r0,[r7,#1]  ; recv_flags
;;;1353               if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
000da0  e5d40018          LDRB     r0,[r4,#0x18]
000da4  e3500004          CMP      r0,#4
;;;1354                 pcb->state = CLOSE_WAIT;
000da8  03a00007          MOVEQ    r0,#7
000dac  05c40018          STRBEQ   r0,[r4,#0x18]
                  |L1.3504|
;;;1355               } 
;;;1356             }
;;;1357   
;;;1358             pcb->ooseq = cseg->next;
000db0  e5950000          LDR      r0,[r5,#0]
000db4  e5840074          STR      r0,[r4,#0x74]
;;;1359             tcp_seg_free(cseg);
000db8  e1a00005          MOV      r0,r5
000dbc  ebfffffe          BL       tcp_seg_free
                  |L1.3520|
000dc0  e5945074          LDR      r5,[r4,#0x74]         ;1327
000dc4  e3550000          CMP      r5,#0                 ;1327
000dc8  0a000005          BEQ      |L1.3556|
000dcc  e5958010          LDR      r8,[r5,#0x10]         ;1328
000dd0  e2880004          ADD      r0,r8,#4              ;1328
000dd4  ebfffffe          BL       __aeabi_uread4
000dd8  e5941028          LDR      r1,[r4,#0x28]         ;1328
000ddc  e1500001          CMP      r0,r1                 ;1328
000de0  0affffb0          BEQ      |L1.3240|
                  |L1.3556|
;;;1360           }
;;;1361   #endif /* TCP_QUEUE_OOSEQ */
;;;1362   
;;;1363   
;;;1364           /* Acknowledge the segment(s). */
;;;1365           tcp_ack(pcb);
000de4  e5d4001e          LDRB     r0,[r4,#0x1e]
000de8  e3100001          TST      r0,#1
000dec  13c00001          BICNE    r0,r0,#1
000df0  03800001          ORREQ    r0,r0,#1
000df4  1a0000e9          BNE      |L1.4512|
                  |L1.3576|
000df8  e5c4001e          STRB     r0,[r4,#0x1e]
;;;1366   
;;;1367         } else {
;;;1368           /* We get here if the incoming segment is out-of-sequence. */
;;;1369           tcp_send_empty_ack(pcb);
;;;1370   #if TCP_QUEUE_OOSEQ
;;;1371           /* We queue the segment on the ->ooseq queue. */
;;;1372           if (pcb->ooseq == NULL) {
;;;1373             pcb->ooseq = tcp_seg_copy(&inseg);
;;;1374           } else {
;;;1375             /* If the queue is not empty, we walk through the queue and
;;;1376                try to find a place where the sequence number of the
;;;1377                incoming segment is between the sequence numbers of the
;;;1378                previous and the next segment on the ->ooseq queue. That is
;;;1379                the place where we put the incoming segment. If needed, we
;;;1380                trim the second edges of the previous and the incoming
;;;1381                segment so that it will fit into the sequence.
;;;1382   
;;;1383                If the incoming segment has the same sequence number as a
;;;1384                segment on the ->ooseq queue, we discard the segment that
;;;1385                contains less data. */
;;;1386   
;;;1387             prev = NULL;
;;;1388             for(next = pcb->ooseq; next != NULL; next = next->next) {
;;;1389               if (seqno == next->tcphdr->seqno) {
;;;1390                 /* The sequence number of the incoming segment is the
;;;1391                    same as the sequence number of the segment on
;;;1392                    ->ooseq. We check the lengths to see which one to
;;;1393                    discard. */
;;;1394                 if (inseg.len > next->len) {
;;;1395                   /* The incoming segment is larger than the old
;;;1396                      segment. We replace some segments with the new
;;;1397                      one. */
;;;1398                   cseg = tcp_seg_copy(&inseg);
;;;1399                   if (cseg != NULL) {
;;;1400                     if (prev != NULL) {
;;;1401                       prev->next = cseg;
;;;1402                     } else {
;;;1403                       pcb->ooseq = cseg;
;;;1404                     }
;;;1405                     tcp_oos_insert_segment(cseg, next);
;;;1406                   }
;;;1407                   break;
;;;1408                 } else {
;;;1409                   /* Either the lenghts are the same or the incoming
;;;1410                      segment was smaller than the old one; in either
;;;1411                      case, we ditch the incoming segment. */
;;;1412                   break;
;;;1413                 }
;;;1414               } else {
;;;1415                 if (prev == NULL) {
;;;1416                   if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
;;;1417                     /* The sequence number of the incoming segment is lower
;;;1418                        than the sequence number of the first segment on the
;;;1419                        queue. We put the incoming segment first on the
;;;1420                        queue. */
;;;1421                     cseg = tcp_seg_copy(&inseg);
;;;1422                     if (cseg != NULL) {
;;;1423                       pcb->ooseq = cseg;
;;;1424                       tcp_oos_insert_segment(cseg, next);
;;;1425                     }
;;;1426                     break;
;;;1427                   }
;;;1428                 } else {
;;;1429                   /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
;;;1430                     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
;;;1431                   if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
;;;1432                     /* The sequence number of the incoming segment is in
;;;1433                        between the sequence numbers of the previous and
;;;1434                        the next segment on ->ooseq. We trim trim the previous
;;;1435                        segment, delete next segments that included in received segment
;;;1436                        and trim received, if needed. */
;;;1437                     cseg = tcp_seg_copy(&inseg);
;;;1438                     if (cseg != NULL) {
;;;1439                       if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
;;;1440                         /* We need to trim the prev segment. */
;;;1441                         prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
;;;1442                         pbuf_realloc(prev->p, prev->len);
;;;1443                       }
;;;1444                       prev->next = cseg;
;;;1445                       tcp_oos_insert_segment(cseg, next);
;;;1446                     }
;;;1447                     break;
;;;1448                   }
;;;1449                 }
;;;1450                 /* If the "next" segment is the last segment on the
;;;1451                    ooseq queue, we add the incoming segment to the end
;;;1452                    of the list. */
;;;1453                 if (next->next == NULL &&
;;;1454                     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
;;;1455                   if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
;;;1456                     /* segment "next" already contains all data */
;;;1457                     break;
;;;1458                   }
;;;1459                   next->next = tcp_seg_copy(&inseg);
;;;1460                   if (next->next != NULL) {
;;;1461                     if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
;;;1462                       /* We need to trim the last segment. */
;;;1463                       next->len = (u16_t)(seqno - next->tcphdr->seqno);
;;;1464                       pbuf_realloc(next->p, next->len);
;;;1465                     }
;;;1466                     /* check if the remote side overruns our receive window */
;;;1467                     if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
;;;1468                       LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1469                                   ("tcp_receive: other end overran receive window"
;;;1470                                    "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1471                                    seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1472                       if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
;;;1473                         /* Must remove the FIN from the header as we're trimming 
;;;1474                          * that byte of sequence-space from the packet */
;;;1475                         TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
;;;1476                       }
;;;1477                       /* Adjust length of segment to fit in the window. */
;;;1478                       next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
;;;1479                       pbuf_realloc(next->next->p, next->next->len);
;;;1480                       tcplen = TCP_TCPLEN(next->next);
;;;1481                       LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
;;;1482                                   (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1483                     }
;;;1484                   }
;;;1485                   break;
;;;1486                 }
;;;1487               }
;;;1488               prev = next;
;;;1489             }
;;;1490           }
;;;1491   #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;1492           /* Check that the data on ooseq doesn't exceed one of the limits
;;;1493              and throw away everything above that limit. */
;;;1494           ooseq_blen = 0;
;;;1495           ooseq_qlen = 0;
;;;1496           prev = NULL;
;;;1497           for(next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
;;;1498             struct pbuf *p = next->p;
;;;1499             ooseq_blen += p->tot_len;
;;;1500             ooseq_qlen += pbuf_clen(p);
;;;1501             if ((ooseq_blen > TCP_OOSEQ_MAX_BYTES) ||
;;;1502                 (ooseq_qlen > TCP_OOSEQ_MAX_PBUFS)) {
;;;1503                /* too much ooseq data, dump this and everything after it */
;;;1504                tcp_segs_free(next);
;;;1505                if (prev == NULL) {
;;;1506                  /* first ooseq segment is too much, dump the whole queue */
;;;1507                  pcb->ooseq = NULL;
;;;1508                } else {
;;;1509                  /* just dump 'next' and everything after it */
;;;1510                  prev->next = NULL;
;;;1511                }
;;;1512                break;
;;;1513             }
;;;1514           }
;;;1515   #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;1516   #endif /* TCP_QUEUE_OOSEQ */
;;;1517         }
;;;1518       } else {
;;;1519         /* The incoming segment is not withing the window. */
;;;1520         tcp_send_empty_ack(pcb);
;;;1521       }
;;;1522     } else {
;;;1523       /* Segments with length 0 is taken care of here. Segments that
;;;1524          fall out of the window are ACKed. */
;;;1525       /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
;;;1526         TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
;;;1527       if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
;;;1528         tcp_ack_now(pcb);
;;;1529       }
;;;1530     }
;;;1531   }
000dfc  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3584|
000e00  e1a00004          MOV      r0,r4                 ;1369
000e04  ebfffffe          BL       tcp_send_empty_ack
000e08  e5945074          LDR      r5,[r4,#0x74]         ;1372
000e0c  e3550000          CMP      r5,#0                 ;1372
000e10  1597900c          LDRNE    r9,[r7,#0xc]          ;870
000e14  13a06000          MOVNE    r6,#0                 ;1387
000e18  0a000012          BEQ      |L1.3688|
                  |L1.3612|
000e1c  e5950010          LDR      r0,[r5,#0x10]         ;1389
000e20  e2800004          ADD      r0,r0,#4              ;1389
000e24  ebfffffe          BL       __aeabi_uread4
000e28  e1500009          CMP      r0,r9                 ;1389
000e2c  e1a0a000          MOV      r10,r0                ;1389
000e30  1a000010          BNE      |L1.3704|
000e34  e1d800b8          LDRH     r0,[r8,#8]            ;1394  ; inseg
000e38  e1d510b8          LDRH     r1,[r5,#8]            ;1394
000e3c  e1500001          CMP      r0,r1                 ;1394
000e40  98bd87f0          POPLS    {r4-r10,pc}
000e44  e51f0444          LDR      r0,|L1.2568|
000e48  ebfffffe          BL       tcp_seg_copy
000e4c  e3500000          CMP      r0,#0                 ;1399
000e50  08bd87f0          POPEQ    {r4-r10,pc}
000e54  e3560000          CMP      r6,#0                 ;1400
000e58  15860000          STRNE    r0,[r6,#0]            ;1401
000e5c  0a000053          BEQ      |L1.4016|
                  |L1.3680|
000e60  e1a01005          MOV      r1,r5                 ;1405
000e64  ea000025          B        |L1.3840|
                  |L1.3688|
000e68  e51f0468          LDR      r0,|L1.2568|
000e6c  ebfffffe          BL       tcp_seg_copy
000e70  e5840074          STR      r0,[r4,#0x74]         ;1373
000e74  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3704|
000e78  e3560000          CMP      r6,#0                 ;1415
000e7c  0a000045          BEQ      |L1.3992|
000e80  e5960010          LDR      r0,[r6,#0x10]         ;1431
000e84  e2800004          ADD      r0,r0,#4              ;1431
000e88  ebfffffe          BL       __aeabi_uread4
000e8c  e0490000          SUB      r0,r9,r0              ;1431
000e90  e3500001          CMP      r0,#1                 ;1431
000e94  4a000047          BMI      |L1.4024|
000e98  e049000a          SUB      r0,r9,r10             ;1431
000e9c  e2800001          ADD      r0,r0,#1              ;1431
000ea0  e3500000          CMP      r0,#0                 ;1431
000ea4  ca000043          BGT      |L1.4024|
000ea8  e51f04a8          LDR      r0,|L1.2568|
000eac  ebfffffe          BL       tcp_seg_copy
000eb0  e1b04000          MOVS     r4,r0                 ;1437
000eb4  08bd87f0          POPEQ    {r4-r10,pc}
000eb8  e5960010          LDR      r0,[r6,#0x10]         ;1439
000ebc  e2800004          ADD      r0,r0,#4              ;1439
000ec0  ebfffffe          BL       __aeabi_uread4
000ec4  e1d610b8          LDRH     r1,[r6,#8]            ;1439
000ec8  e0802001          ADD      r2,r0,r1              ;1439
000ecc  e597100c          LDR      r1,[r7,#0xc]          ;1439  ; seqno
000ed0  e0422001          SUB      r2,r2,r1              ;1439
000ed4  e3520000          CMP      r2,#0                 ;1439
000ed8  da000005          BLE      |L1.3828|
000edc  e0410000          SUB      r0,r1,r0              ;1441
000ee0  e1a01800          LSL      r1,r0,#16             ;1441
000ee4  e1a01821          LSR      r1,r1,#16             ;1441
000ee8  e1c610b8          STRH     r1,[r6,#8]            ;1441
000eec  e5960004          LDR      r0,[r6,#4]            ;1442
000ef0  ebfffffe          BL       pbuf_realloc
                  |L1.3828|
000ef4  e1a01005          MOV      r1,r5                 ;1445
000ef8  e1a00004          MOV      r0,r4                 ;1445
000efc  e5864000          STR      r4,[r6,#0]            ;1445
                  |L1.3840|
000f00  e8bd47f0          POP      {r4-r10,lr}           ;1445
000f04  eafffffe          B        tcp_oos_insert_segment
                  |L1.3848|
                          DCD      0x00000507
                  |L1.3852|
000f0c  7463705f          DCB      "tcp_receive: segment not trimmed correctly to ooseq que"
000f10  72656365
000f14  6976653a
000f18  20736567
000f1c  6d656e74
000f20  206e6f74
000f24  20747269
000f28  6d6d6564
000f2c  20636f72
000f30  72656374
000f34  6c792074
000f38  6f206f6f
000f3c  73657120
000f40  717565  
000f43  75650a00          DCB      "ue\n",0
000f47  00                DCB      0
                  |L1.3912|
                          DCD      0x00000512
                  |L1.3916|
000f4c  7463705f          DCB      "tcp_receive: tcplen > rcv_wnd\n",0
000f50  72656365
000f54  6976653a
000f58  20746370
000f5c  6c656e20
000f60  3e207263
000f64  765f776e
000f68  640a00  
000f6b  00                DCB      0
                  |L1.3948|
                          DCD      0x00000536
                  |L1.3952|
000f70  7463705f          DCB      "tcp_receive: ooseq tcplen > rcv_wnd\n",0
000f74  72656365
000f78  6976653a
000f7c  206f6f73
000f80  65712074
000f84  63706c65
000f88  6e203e20
000f8c  7263765f
000f90  776e640a
000f94  00      
000f95  00                DCB      0
000f96  00                DCB      0
000f97  00                DCB      0
                  |L1.3992|
000f98  e059000a          SUBS     r0,r9,r10             ;1416
000f9c  5a000005          BPL      |L1.4024|
000fa0  e51f05a0          LDR      r0,|L1.2568|
000fa4  ebfffffe          BL       tcp_seg_copy
000fa8  e3500000          CMP      r0,#0                 ;1422
000fac  08bd87f0          POPEQ    {r4-r10,pc}
                  |L1.4016|
000fb0  e5840074          STR      r0,[r4,#0x74]         ;1423
000fb4  eaffffa9          B        |L1.3680|
                  |L1.4024|
000fb8  e5951000          LDR      r1,[r5,#0]            ;1453
000fbc  e3510000          CMP      r1,#0                 ;1453
000fc0  1a000066          BNE      |L1.4448|
000fc4  e049000a          SUB      r0,r9,r10             ;1454
000fc8  e3500000          CMP      r0,#0                 ;1454
000fcc  da000063          BLE      |L1.4448|
000fd0  e5950010          LDR      r0,[r5,#0x10]         ;1455
000fd4  e5d0100d          LDRB     r1,[r0,#0xd]          ;1455
000fd8  e5d0000c          LDRB     r0,[r0,#0xc]          ;1455
000fdc  e1800401          ORR      r0,r0,r1,LSL #8       ;1455
000fe0  ebfffffe          BL       lwip_ntohs
000fe4  e3100001          TST      r0,#1                 ;1455
000fe8  18bd87f0          POPNE    {r4-r10,pc}
000fec  e51f05ec          LDR      r0,|L1.2568|
000ff0  ebfffffe          BL       tcp_seg_copy
000ff4  e3500000          CMP      r0,#0                 ;1460
000ff8  e5850000          STR      r0,[r5,#0]            ;1459
000ffc  08bd87f0          POPEQ    {r4-r10,pc}
001000  e5950010          LDR      r0,[r5,#0x10]         ;1461
001004  e2800004          ADD      r0,r0,#4              ;1461
001008  ebfffffe          BL       __aeabi_uread4
00100c  e1d510b8          LDRH     r1,[r5,#8]            ;1461
001010  e0802001          ADD      r2,r0,r1              ;1461
001014  e597100c          LDR      r1,[r7,#0xc]          ;1461  ; seqno
001018  e0422001          SUB      r2,r2,r1              ;1461
00101c  e3520000          CMP      r2,#0                 ;1461
001020  da000005          BLE      |L1.4156|
001024  e0410000          SUB      r0,r1,r0              ;1463
001028  e1a01800          LSL      r1,r0,#16             ;1463
00102c  e1a01821          LSR      r1,r1,#16             ;1463
001030  e1c510b8          STRH     r1,[r5,#8]            ;1463
001034  e5950004          LDR      r0,[r5,#4]            ;1464
001038  ebfffffe          BL       pbuf_realloc
                  |L1.4156|
00103c  e1d412bc          LDRH     r1,[r4,#0x2c]         ;1467
001040  e5940028          LDR      r0,[r4,#0x28]         ;1467
001044  e597200c          LDR      r2,[r7,#0xc]          ;1467  ; seqno
001048  e0800001          ADD      r0,r0,r1              ;1467
00104c  e1d710b2          LDRH     r1,[r7,#2]            ;1467  ; tcplen
001050  e0811002          ADD      r1,r1,r2              ;1467
001054  e1500001          CMP      r0,r1                 ;1467
001058  28bd87f0          POPCS    {r4-r10,pc}
00105c  e5950000          LDR      r0,[r5,#0]            ;1472
001060  e5900010          LDR      r0,[r0,#0x10]         ;1472
001064  e5d0100d          LDRB     r1,[r0,#0xd]          ;1472
001068  e5d0000c          LDRB     r0,[r0,#0xc]          ;1472
00106c  e1800401          ORR      r0,r0,r1,LSL #8       ;1472
001070  ebfffffe          BL       lwip_ntohs
001074  e3100001          TST      r0,#1                 ;1472
001078  0a000012          BEQ      |L1.4296|
00107c  e5950000          LDR      r0,[r5,#0]            ;1475
001080  e5900010          LDR      r0,[r0,#0x10]         ;1475
001084  e5d0100d          LDRB     r1,[r0,#0xd]          ;1475
001088  e5d0000c          LDRB     r0,[r0,#0xc]          ;1475
00108c  e1800401          ORR      r0,r0,r1,LSL #8       ;1475
001090  ebfffffe          BL       lwip_ntohs
001094  e200003e          AND      r0,r0,#0x3e           ;1475
001098  ebfffffe          BL       lwip_htons
00109c  e1a01000          MOV      r1,r0                 ;1475
0010a0  e5950000          LDR      r0,[r5,#0]            ;1475
0010a4  e5900010          LDR      r0,[r0,#0x10]         ;1475
0010a8  e5d0200d          LDRB     r2,[r0,#0xd]          ;1475
0010ac  e5d0300c          LDRB     r3,[r0,#0xc]          ;1475
0010b0  e1832402          ORR      r2,r3,r2,LSL #8       ;1475
0010b4  e3c22c3f          BIC      r2,r2,#0x3f00         ;1475
0010b8  e1811002          ORR      r1,r1,r2              ;1475
0010bc  e5c0100c          STRB     r1,[r0,#0xc]          ;1475
0010c0  e1a01421          LSR      r1,r1,#8              ;1475
0010c4  e5c0100d          STRB     r1,[r0,#0xd]          ;1475
                  |L1.4296|
0010c8  e1d402b8          LDRH     r0,[r4,#0x28]         ;1478
0010cc  e1d412bc          LDRH     r1,[r4,#0x2c]         ;1478
0010d0  e0800001          ADD      r0,r0,r1              ;1478
0010d4  e1d710bc          LDRH     r1,[r7,#0xc]          ;1478  ; seqno
0010d8  e0400001          SUB      r0,r0,r1              ;1478
0010dc  e1a01800          LSL      r1,r0,#16             ;1478
0010e0  e5950000          LDR      r0,[r5,#0]            ;1478
0010e4  e1a01821          LSR      r1,r1,#16             ;1478
0010e8  e1c010b8          STRH     r1,[r0,#8]            ;1478
0010ec  e5950000          LDR      r0,[r5,#0]            ;1479
0010f0  e5900004          LDR      r0,[r0,#4]            ;1479
0010f4  ebfffffe          BL       pbuf_realloc
0010f8  e5950000          LDR      r0,[r5,#0]            ;1480
0010fc  e5900010          LDR      r0,[r0,#0x10]         ;1480
001100  e5d0100d          LDRB     r1,[r0,#0xd]          ;1480
001104  e5d0000c          LDRB     r0,[r0,#0xc]          ;1480
001108  e1800401          ORR      r0,r0,r1,LSL #8       ;1480
00110c  ebfffffe          BL       lwip_ntohs
001110  e5951000          LDR      r1,[r5,#0]            ;1480
001114  e2100003          ANDS     r0,r0,#3              ;1480
001118  e1d110b8          LDRH     r1,[r1,#8]            ;1480
00111c  13a00001          MOVNE    r0,#1                 ;1480
001120  e0800001          ADD      r0,r0,r1              ;1480
001124  e3c00801          BIC      r0,r0,#0x10000        ;1480
001128  e1c700b2          STRH     r0,[r7,#2]            ;1480  ; tcplen
00112c  e1d422bc          LDRH     r2,[r4,#0x2c]         ;1481
001130  e5941028          LDR      r1,[r4,#0x28]         ;1481
001134  e0811002          ADD      r1,r1,r2              ;1481
001138  e597200c          LDR      r2,[r7,#0xc]          ;1481  ; seqno
00113c  e0800002          ADD      r0,r0,r2              ;1481
001140  e1500001          CMP      r0,r1                 ;1481
001144  08bd87f0          POPEQ    {r4-r10,pc}
001148  e8bd47f0          POP      {r4-r10,lr}           ;1481
00114c  e51f36ec          LDR      r3,|L1.2664|
001150  e59f2480          LDR      r2,|L1.5592|
001154  e59f1480          LDR      r1,|L1.5596|
001158  e51f06b8          LDR      r0,|L1.2728|
00115c  eafffffe          B        sysprintf
                  |L1.4448|
001160  e1a06005          MOV      r6,r5                 ;1488
001164  e1b05001          MOVS     r5,r1                 ;1388
001168  1affff2b          BNE      |L1.3612|
00116c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.4464|
001170  e1a00004          MOV      r0,r4                 ;1520
001174  e8bd47f0          POP      {r4-r10,lr}           ;1520
001178  eafffffe          B        tcp_send_empty_ack
                  |L1.4476|
00117c  e0512000          SUBS     r2,r1,r0              ;1527
001180  4a000005          BMI      |L1.4508|
001184  e1d422bc          LDRH     r2,[r4,#0x2c]         ;1527
001188  e0800002          ADD      r0,r0,r2              ;1527
00118c  e0410000          SUB      r0,r1,r0              ;1527
001190  e2800001          ADD      r0,r0,#1              ;1527
001194  e3500000          CMP      r0,#0                 ;1527
001198  d8bd87f0          POPLE    {r4-r10,pc}
                  |L1.4508|
00119c  e5d4001e          LDRB     r0,[r4,#0x1e]         ;1528
                  |L1.4512|
0011a0  e3800002          ORR      r0,r0,#2              ;1528
0011a4  eaffff13          B        |L1.3576|
;;;1532   
                          ENDP

                  tcp_parseopt PROC
;;;1541   static void
;;;1542   tcp_parseopt(struct tcp_pcb *pcb)
0011a8  e92d4070          PUSH     {r4-r6,lr}
;;;1543   {
;;;1544     u16_t c, max_c;
;;;1545     u16_t mss;
;;;1546     u8_t *opts, opt;
;;;1547   #if LWIP_TCP_TIMESTAMPS
;;;1548     u32_t tsval;
;;;1549   #endif
;;;1550   
;;;1551     opts = (u8_t *)tcphdr + TCP_HLEN;
0011ac  e51f6d40          LDR      r6,|L1.1140|
0011b0  e1a05000          MOV      r5,r0                 ;1543
0011b4  e5960004          LDR      r0,[r6,#4]  ; tcphdr
;;;1552   
;;;1553     /* Parse the TCP MSS option, if present. */
;;;1554     if(TCPH_HDRLEN(tcphdr) > 0x5) {
0011b8  e5d0100d          LDRB     r1,[r0,#0xd]
0011bc  e2804014          ADD      r4,r0,#0x14           ;1551
0011c0  e5d0000c          LDRB     r0,[r0,#0xc]
0011c4  e1800401          ORR      r0,r0,r1,LSL #8
0011c8  ebfffffe          BL       lwip_ntohs
0011cc  e3a01005          MOV      r1,#5
0011d0  e1510620          CMP      r1,r0,LSR #12
;;;1555       max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
;;;1556       for (c = 0; c < max_c; ) {
;;;1557         opt = opts[c];
;;;1558         switch (opt) {
;;;1559         case 0x00:
;;;1560           /* End of options. */
;;;1561           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
;;;1562           return;
;;;1563         case 0x01:
;;;1564           /* NOP option. */
;;;1565           ++c;
;;;1566           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
;;;1567           break;
;;;1568         case 0x02:
;;;1569           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
;;;1570           if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
;;;1571             /* Bad length */
;;;1572             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1573             return;
;;;1574           }
;;;1575           /* An MSS option with the right option length. */
;;;1576           mss = (opts[c + 2] << 8) | opts[c + 3];
;;;1577           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
;;;1578           pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
;;;1579           /* Advance to next option */
;;;1580           c += 0x04;
;;;1581           break;
;;;1582   #if LWIP_TCP_TIMESTAMPS
;;;1583         case 0x08:
;;;1584           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
;;;1585           if (opts[c + 1] != 0x0A || c + 0x0A > max_c) {
;;;1586             /* Bad length */
;;;1587             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1588             return;
;;;1589           }
;;;1590           /* TCP timestamp option with valid length */
;;;1591           tsval = (opts[c+2]) | (opts[c+3] << 8) | 
;;;1592             (opts[c+4] << 16) | (opts[c+5] << 24);
;;;1593           if (flags & TCP_SYN) {
;;;1594             pcb->ts_recent = ntohl(tsval);
;;;1595             pcb->flags |= TF_TIMESTAMP;
;;;1596           } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno+tcplen)) {
;;;1597             pcb->ts_recent = ntohl(tsval);
;;;1598           }
;;;1599           /* Advance to next option */
;;;1600           c += 0x0A;
;;;1601           break;
;;;1602   #endif
;;;1603         default:
;;;1604           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
;;;1605           if (opts[c + 1] == 0) {
;;;1606             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1607             /* If the length field is zero, the options are malformed
;;;1608                and we don't process them further. */
;;;1609             return;
;;;1610           }
;;;1611           /* All other options have a length field, so that we easily
;;;1612              can skip past them. */
;;;1613           c += opts[c + 1];
;;;1614         }
;;;1615       }
;;;1616     }
;;;1617   }
0011d4  28bd8070          POPCS    {r4-r6,pc}
0011d8  e5960004          LDR      r0,[r6,#4]            ;1555  ; tcphdr
0011dc  e5d0100d          LDRB     r1,[r0,#0xd]          ;1555
0011e0  e5d0000c          LDRB     r0,[r0,#0xc]          ;1555
0011e4  e1800401          ORR      r0,r0,r1,LSL #8       ;1555
0011e8  ebfffffe          BL       lwip_ntohs
0011ec  e3e01004          MVN      r1,#4                 ;1555
0011f0  e0810620          ADD      r0,r1,r0,LSR #12      ;1555
0011f4  e1a01821          LSR      r1,r1,#16             ;1555
0011f8  e001c100          AND      r12,r1,r0,LSL #2      ;1555
0011fc  e3a01000          MOV      r1,#0                 ;1556
001200  ea00000d          B        |L1.4668|
                  |L1.4612|
001204  e7d42001          LDRB     r2,[r4,r1]            ;1557
001208  e3520000          CMP      r2,#0                 ;1558
00120c  08bd8070          POPEQ    {r4-r6,pc}
001210  e3520001          CMP      r2,#1                 ;1558
001214  02810001          ADDEQ    r0,r1,#1              ;1565
001218  0a000006          BEQ      |L1.4664|
00121c  e3520002          CMP      r2,#2                 ;1558
001220  0a000008          BEQ      |L1.4680|
001224  e0840001          ADD      r0,r4,r1              ;1605
001228  e5d00001          LDRB     r0,[r0,#1]            ;1605
00122c  e3500000          CMP      r0,#0                 ;1605
001230  10800001          ADDNE    r0,r0,r1              ;1613
001234  08bd8070          POPEQ    {r4-r6,pc}
                  |L1.4664|
001238  e3c01801          BIC      r1,r0,#0x10000        ;1613
                  |L1.4668|
00123c  e151000c          CMP      r1,r12                ;1556
001240  28bd8070          POPCS    {r4-r6,pc}
001244  eaffffee          B        |L1.4612|
                  |L1.4680|
001248  e0842001          ADD      r2,r4,r1              ;1570
00124c  e5d20001          LDRB     r0,[r2,#1]            ;1570
001250  e3500004          CMP      r0,#4                 ;1570
001254  18bd8070          POPNE    {r4-r6,pc}
001258  e2813004          ADD      r3,r1,#4              ;1570
00125c  e153000c          CMP      r3,r12                ;1570
001260  88bd8070          POPHI    {r4-r6,pc}
001264  e5d20003          LDRB     r0,[r2,#3]            ;1576
001268  e5d21002          LDRB     r1,[r2,#2]            ;1576
00126c  e1801401          ORR      r1,r0,r1,LSL #8       ;1576
001270  e3510ffa          CMP      r1,#0x3e8             ;1578
001274  8a000001          BHI      |L1.4736|
001278  e3510000          CMP      r1,#0                 ;1578
00127c  1a000000          BNE      |L1.4740|
                  |L1.4736|
001280  e3a01ffa          MOV      r1,#0x3e8             ;1578
                  |L1.4740|
001284  e1c513b6          STRH     r1,[r5,#0x36]         ;1578
001288  e3c31801          BIC      r1,r3,#0x10000        ;1580
00128c  eaffffea          B        |L1.4668|
;;;1618   
                          ENDP

                  tcp_process PROC
;;;574    static err_t
;;;575    tcp_process(struct tcp_pcb *pcb)
001290  e92d5ffc          PUSH     {r2-r12,lr}
;;;576    {
;;;577      struct tcp_seg *rseg;
;;;578      u8_t acceptable = 0;
;;;579      err_t err;
;;;580    
;;;581      err = ERR_OK;
;;;582    
;;;583      /* Process incoming RST segments. */
;;;584      if (flags & TCP_RST) {
001294  e51fae28          LDR      r10,|L1.1140|
001298  e1a04000          MOV      r4,r0                 ;576
00129c  e5da0000          LDRB     r0,[r10,#0]  ; flags
0012a0  e3100004          TST      r0,#4
0012a4  0a000020          BEQ      |L1.4908|
;;;585        /* First, determine if the reset is acceptable. */
;;;586        if (pcb->state == SYN_SENT) {
0012a8  e5d42018          LDRB     r2,[r4,#0x18]
0012ac  e3520002          CMP      r2,#2
0012b0  0a00000b          BEQ      |L1.4836|
;;;587          if (ackno == pcb->snd_nxt) {
;;;588            acceptable = 1;
;;;589          }
;;;590        } else {
;;;591          if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
0012b4  e5940028          LDR      r0,[r4,#0x28]
0012b8  e59a100c          LDR      r1,[r10,#0xc]  ; seqno
0012bc  e0513000          SUBS     r3,r1,r0
0012c0  4a00017b          BMI      |L1.6324|
0012c4  e1d432bc          LDRH     r3,[r4,#0x2c]
0012c8  e0800003          ADD      r0,r0,r3
0012cc  e0410000          SUB      r0,r1,r0
0012d0  e3500000          CMP      r0,#0
0012d4  ca000176          BGT      |L1.6324|
;;;592                              pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;593            acceptable = 1;
;;;594          }
;;;595        }
;;;596    
;;;597        if (acceptable) {
;;;598          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
;;;599          LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
0012d8  e3520000          CMP      r2,#0
0012dc  1a00000a          BNE      |L1.4876|
0012e0  ea000004          B        |L1.4856|
                  |L1.4836|
0012e4  e5941050          LDR      r1,[r4,#0x50]         ;587
0012e8  e59a0010          LDR      r0,[r10,#0x10]        ;587  ; ackno
0012ec  e1510000          CMP      r1,r0                 ;587
0012f0  1a00016f          BNE      |L1.6324|
0012f4  ea000004          B        |L1.4876|
                  |L1.4856|
0012f8  e51f3898          LDR      r3,|L1.2664|
0012fc  e59f22dc          LDR      r2,|L1.5600|
001300  e51f0860          LDR      r0,|L1.2728|
001304  e28f1fb6          ADR      r1,|L1.5604|
001308  ebfffffe          BL       sysprintf
                  |L1.4876|
;;;600          recv_flags |= TF_RESET;
00130c  e5da0001          LDRB     r0,[r10,#1]  ; recv_flags
001310  e3800008          ORR      r0,r0,#8
001314  e5ca0001          STRB     r0,[r10,#1]  ; recv_flags
;;;601          pcb->flags &= ~TF_ACK_DELAY;
001318  e5d4001e          LDRB     r0,[r4,#0x1e]
00131c  e3c00001          BIC      r0,r0,#1
001320  e5c4001e          STRB     r0,[r4,#0x1e]
;;;602          return ERR_RST;
001324  e3e0000a          MVN      r0,#0xa
;;;603        } else {
;;;604          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;605           seqno, pcb->rcv_nxt));
;;;606          LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;607           seqno, pcb->rcv_nxt));
;;;608          return ERR_OK;
;;;609        }
;;;610      }
;;;611    
;;;612      if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
;;;613        /* Cope with new connection attempt after remote end crashed */
;;;614        tcp_ack_now(pcb);
;;;615        return ERR_OK;
;;;616      }
;;;617      
;;;618      if ((pcb->flags & TF_RXCLOSED) == 0) {
;;;619        /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
;;;620        pcb->tmr = tcp_ticks;
;;;621      }
;;;622      pcb->keep_cnt_sent = 0;
;;;623    
;;;624      tcp_parseopt(pcb);
;;;625    
;;;626      /* Do different things depending on the TCP state. */
;;;627      switch (pcb->state) {
;;;628      case SYN_SENT:
;;;629        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
;;;630         pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
;;;631        /* received SYN ACK with expected sequence number? */
;;;632        if ((flags & TCP_ACK) && (flags & TCP_SYN)
;;;633            && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
;;;634          pcb->snd_buf++;
;;;635          pcb->rcv_nxt = seqno + 1;
;;;636          pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;637          pcb->lastack = ackno;
;;;638          pcb->snd_wnd = tcphdr->wnd;
;;;639          pcb->snd_wnd_max = tcphdr->wnd;
;;;640          pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
;;;641          pcb->state = ESTABLISHED;
;;;642    
;;;643    #if TCP_CALCULATE_EFF_SEND_MSS
;;;644          pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
;;;645    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;646    
;;;647          /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
;;;648           * but for the default value of pcb->mss) */
;;;649          pcb->ssthresh = pcb->mss * 10;
;;;650    
;;;651          pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;652          LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
;;;653          --pcb->snd_queuelen;
;;;654          LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;655          rseg = pcb->unacked;
;;;656          pcb->unacked = rseg->next;
;;;657          tcp_seg_free(rseg);
;;;658    
;;;659          /* If there's nothing left to acknowledge, stop the retransmit
;;;660             timer, otherwise reset it to start again */
;;;661          if(pcb->unacked == NULL)
;;;662            pcb->rtime = -1;
;;;663          else {
;;;664            pcb->rtime = 0;
;;;665            pcb->nrtx = 0;
;;;666          }
;;;667    
;;;668          /* Call the user specified function to call when sucessfully
;;;669           * connected. */
;;;670          TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
;;;671          if (err == ERR_ABRT) {
;;;672            return ERR_ABRT;
;;;673          }
;;;674          tcp_ack_now(pcb);
;;;675        }
;;;676        /* received ACK? possibly a half-open connection */
;;;677        else if (flags & TCP_ACK) {
;;;678          /* send a RST to bring the other side in a non-synchronized state. */
;;;679          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;680            tcphdr->dest, tcphdr->src);
;;;681        }
;;;682        break;
;;;683      case SYN_RCVD:
;;;684        if (flags & TCP_ACK) {
;;;685          /* expected ACK number? */
;;;686          if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
;;;687            u16_t old_cwnd;
;;;688            pcb->state = ESTABLISHED;
;;;689            LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;690    #if LWIP_CALLBACK_API
;;;691            LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
;;;692    #endif
;;;693            /* Call the accept function. */
;;;694            TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
;;;695            if (err != ERR_OK) {
;;;696              /* If the accept function returns with an error, we abort
;;;697               * the connection. */
;;;698              /* Already aborted? */
;;;699              if (err != ERR_ABRT) {
;;;700                tcp_abort(pcb);
;;;701              }
;;;702              return ERR_ABRT;
;;;703            }
;;;704            old_cwnd = pcb->cwnd;
;;;705            /* If there was any data contained within this ACK,
;;;706             * we'd better pass it on to the application as well. */
;;;707            tcp_receive(pcb);
;;;708    
;;;709            /* Prevent ACK for SYN to generate a sent event */
;;;710            if (pcb->acked != 0) {
;;;711              pcb->acked--;
;;;712            }
;;;713    
;;;714            pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;715    
;;;716            if (recv_flags & TF_GOT_FIN) {
;;;717              tcp_ack_now(pcb);
;;;718              pcb->state = CLOSE_WAIT;
;;;719            }
;;;720          } else {
;;;721            /* incorrect ACK number, send RST */
;;;722            tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;723                    tcphdr->dest, tcphdr->src);
;;;724          }
;;;725        } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
;;;726          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
;;;727          tcp_rexmit(pcb);
;;;728        }
;;;729        break;
;;;730      case CLOSE_WAIT:
;;;731        /* FALLTHROUGH */
;;;732      case ESTABLISHED:
;;;733        tcp_receive(pcb);
;;;734        if (recv_flags & TF_GOT_FIN) { /* passive close */
;;;735          tcp_ack_now(pcb);
;;;736          pcb->state = CLOSE_WAIT;
;;;737        }
;;;738        break;
;;;739      case FIN_WAIT_1:
;;;740        tcp_receive(pcb);
;;;741        if (recv_flags & TF_GOT_FIN) {
;;;742          if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;743            LWIP_DEBUGF(TCP_DEBUG,
;;;744              ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;745            tcp_ack_now(pcb);
;;;746            tcp_pcb_purge(pcb);
;;;747            TCP_RMV_ACTIVE(pcb);
;;;748            pcb->state = TIME_WAIT;
;;;749            TCP_REG(&tcp_tw_pcbs, pcb);
;;;750          } else {
;;;751            tcp_ack_now(pcb);
;;;752            pcb->state = CLOSING;
;;;753          }
;;;754        } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;755          pcb->state = FIN_WAIT_2;
;;;756        }
;;;757        break;
;;;758      case FIN_WAIT_2:
;;;759        tcp_receive(pcb);
;;;760        if (recv_flags & TF_GOT_FIN) {
;;;761          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;762          tcp_ack_now(pcb);
;;;763          tcp_pcb_purge(pcb);
;;;764          TCP_RMV_ACTIVE(pcb);
;;;765          pcb->state = TIME_WAIT;
;;;766          TCP_REG(&tcp_tw_pcbs, pcb);
;;;767        }
;;;768        break;
;;;769      case CLOSING:
;;;770        tcp_receive(pcb);
;;;771        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;772          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;773          tcp_pcb_purge(pcb);
;;;774          TCP_RMV_ACTIVE(pcb);
;;;775          pcb->state = TIME_WAIT;
;;;776          TCP_REG(&tcp_tw_pcbs, pcb);
;;;777        }
;;;778        break;
;;;779      case LAST_ACK:
;;;780        tcp_receive(pcb);
;;;781        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;782          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;783          /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
;;;784          recv_flags |= TF_CLOSED;
;;;785        }
;;;786        break;
;;;787      default:
;;;788        break;
;;;789      }
;;;790      return ERR_OK;
;;;791    }
001328  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.4908|
00132c  e3100002          TST      r0,#2                 ;612
001330  15d40018          LDRBNE   r0,[r4,#0x18]         ;612
001334  13500002          CMPNE    r0,#2                 ;612
001338  13500003          CMPNE    r0,#3                 ;612
00133c  0a000003          BEQ      |L1.4944|
                  |L1.4928|
001340  e5d4001e          LDRB     r0,[r4,#0x1e]         ;614
001344  e3800002          ORR      r0,r0,#2              ;614
001348  e5c4001e          STRB     r0,[r4,#0x1e]         ;614
00134c  ea000158          B        |L1.6324|
                  |L1.4944|
001350  e5d4001e          LDRB     r0,[r4,#0x1e]         ;618
001354  e3100010          TST      r0,#0x10              ;618
001358  051f095c          LDREQ    r0,|L1.2564|
00135c  05900000          LDREQ    r0,[r0,#0]            ;620  ; tcp_ticks
001360  05840024          STREQ    r0,[r4,#0x24]         ;620
001364  e3a00000          MOV      r0,#0                 ;622
001368  e5c40096          STRB     r0,[r4,#0x96]         ;622
00136c  e1a00004          MOV      r0,r4                 ;624
001370  ebfffffe          BL       tcp_parseopt
001374  e5d40018          LDRB     r0,[r4,#0x18]         ;627
001378  e59f8284          LDR      r8,|L1.5636|
00137c  e59f6284          LDR      r6,|L1.5640|
001380  e59fb284          LDR      r11,|L1.5644|
001384  e59f5284          LDR      r5,|L1.5648|
001388  e2400002          SUB      r0,r0,#2              ;747
00138c  e3500008          CMP      r0,#8                 ;627
001390  e3a07001          MOV      r7,#1                 ;588
001394  e3a0900a          MOV      r9,#0xa               ;748
001398  308ff100          ADDCC    pc,pc,r0,LSL #2       ;627
00139c  ea000144          B        |L1.6324|
0013a0  ea000006          B        |L1.5056|
0013a4  ea000065          B        |L1.5440|
0013a8  ea0000d3          B        |L1.5884|
0013ac  ea0000d5          B        |L1.5896|
0013b0  ea000104          B        |L1.6088|
0013b4  ea0000d0          B        |L1.5884|
0013b8  ea000116          B        |L1.6168|
0013bc  ea000131          B        |L1.6280|
                  |L1.5056|
0013c0  e5da0000          LDRB     r0,[r10,#0]           ;632  ; flags
0013c4  e3100010          TST      r0,#0x10              ;632
0013c8  0a000139          BEQ      |L1.6324|
0013cc  e3100002          TST      r0,#2                 ;632
0013d0  0a00004b          BEQ      |L1.5380|
0013d4  e5940070          LDR      r0,[r4,#0x70]         ;633
0013d8  e5900010          LDR      r0,[r0,#0x10]         ;633
0013dc  e2800004          ADD      r0,r0,#4              ;633
0013e0  ebfffffe          BL       __aeabi_uread4
0013e4  ebfffffe          BL       lwip_ntohl
0013e8  e2801001          ADD      r1,r0,#1              ;633
0013ec  e59a0010          LDR      r0,[r10,#0x10]        ;633  ; ackno
0013f0  e1510000          CMP      r1,r0                 ;633
0013f4  1a00003f          BNE      |L1.5368|
0013f8  e1d416b6          LDRH     r1,[r4,#0x66]         ;634
0013fc  e2811001          ADD      r1,r1,#1              ;634
001400  e1c416b6          STRH     r1,[r4,#0x66]         ;634
001404  e59a100c          LDR      r1,[r10,#0xc]         ;635  ; seqno
001408  e2812001          ADD      r2,r1,#1              ;635
00140c  e5842028          STR      r2,[r4,#0x28]         ;636
001410  e5840048          STR      r0,[r4,#0x48]         ;638
001414  e5842030          STR      r2,[r4,#0x30]         ;638
001418  e59a0004          LDR      r0,[r10,#4]           ;638  ; tcphdr
00141c  e5d0200f          LDRB     r2,[r0,#0xf]          ;638
001420  e5d0300e          LDRB     r3,[r0,#0xe]          ;638
001424  e1832402          ORR      r2,r3,r2,LSL #8       ;638
001428  e1c426b0          STRH     r2,[r4,#0x60]         ;638
00142c  e5d0200f          LDRB     r2,[r0,#0xf]          ;639
001430  e5d0000e          LDRB     r0,[r0,#0xe]          ;639
001434  e1800402          ORR      r0,r0,r2,LSL #8       ;639
001438  e1c406b2          STRH     r0,[r4,#0x62]         ;639
00143c  e2410001          SUB      r0,r1,#1              ;640
001440  e5840054          STR      r0,[r4,#0x54]         ;640
001444  e3a00004          MOV      r0,#4                 ;641
001448  e5c40018          STRB     r0,[r4,#0x18]         ;641
00144c  e1d403b6          LDRH     r0,[r4,#0x36]         ;644
001450  e2841004          ADD      r1,r4,#4              ;644
001454  ebfffffe          BL       tcp_eff_send_mss
001458  e0801100          ADD      r1,r0,r0,LSL #2       ;649
00145c  e3e0280f          MVN      r2,#0xf0000           ;649
001460  e0021081          AND      r1,r2,r1,LSL #1       ;649
001464  e1c403b6          STRH     r0,[r4,#0x36]         ;644
001468  e1c414be          STRH     r1,[r4,#0x4e]         ;649
00146c  e1d414bc          LDRH     r1,[r4,#0x4c]         ;651
001470  e3510001          CMP      r1,#1                 ;651
001474  01a00080          LSLEQ    r0,r0,#1              ;651
001478  e1c404bc          STRH     r0,[r4,#0x4c]         ;651
00147c  e1d406b8          LDRH     r0,[r4,#0x68]         ;652
001480  e3500000          CMP      r0,#0                 ;652
001484  1a000004          BNE      |L1.5276|
001488  e51f3a28          LDR      r3,|L1.2664|
00148c  e51f09ec          LDR      r0,|L1.2728|
001490  e3a02fa3          MOV      r2,#0x28c             ;652
001494  e28f1f5e          ADR      r1,|L1.5652|
001498  ebfffffe          BL       sysprintf
                  |L1.5276|
00149c  e1d406b8          LDRH     r0,[r4,#0x68]         ;653
0014a0  e2400001          SUB      r0,r0,#1              ;653
0014a4  e1c406b8          STRH     r0,[r4,#0x68]         ;653
0014a8  e5940070          LDR      r0,[r4,#0x70]         ;656
0014ac  e5901000          LDR      r1,[r0,#0]            ;656
0014b0  e5841070          STR      r1,[r4,#0x70]         ;656
0014b4  ebfffffe          BL       tcp_seg_free
0014b8  e5940070          LDR      r0,[r4,#0x70]         ;661
0014bc  e3500000          CMP      r0,#0                 ;661
0014c0  03e00000          MVNEQ    r0,#0                 ;662
0014c4  13a00000          MOVNE    r0,#0                 ;664
0014c8  e1c403b4          STRH     r0,[r4,#0x34]         ;664
0014cc  15c40046          STRBNE   r0,[r4,#0x46]         ;665
0014d0  e5943084          LDR      r3,[r4,#0x84]         ;670
0014d4  e3530000          CMP      r3,#0                 ;670
0014d8  0affff98          BEQ      |L1.4928|
0014dc  e5940010          LDR      r0,[r4,#0x10]         ;670
0014e0  e3a02000          MOV      r2,#0                 ;670
0014e4  e1a01004          MOV      r1,r4                 ;670
0014e8  e12fff33          BLX      r3                    ;670
0014ec  e370000a          CMN      r0,#0xa               ;671
0014f0  08bd9ffc          POPEQ    {r2-r12,pc}
0014f4  eaffff91          B        |L1.4928|
                  |L1.5368|
0014f8  e5da0000          LDRB     r0,[r10,#0]           ;677  ; flags
0014fc  e3100010          TST      r0,#0x10              ;677
001500  0a0000eb          BEQ      |L1.6324|
                  |L1.5380|
001504  e59a0004          LDR      r0,[r10,#4]           ;679  ; tcphdr
001508  e59f311c          LDR      r3,|L1.5676|
00150c  e5d01001          LDRB     r1,[r0,#1]            ;679
001510  e5d02000          LDRB     r2,[r0,#0]            ;679
001514  e1821401          ORR      r1,r2,r1,LSL #8       ;679
001518  e5d02003          LDRB     r2,[r0,#3]            ;679
00151c  e5d00002          LDRB     r0,[r0,#2]            ;679
001520  e1800402          ORR      r0,r0,r2,LSL #8       ;679
001524  e1cd00f0          STRD     r0,r1,[sp,#0]         ;679
001528  e1da10b2          LDRH     r1,[r10,#2]           ;679  ; tcplen
00152c  e59a000c          LDR      r0,[r10,#0xc]         ;679  ; seqno
001530  e59f20f8          LDR      r2,|L1.5680|
001534  e0811000          ADD      r1,r1,r0              ;679
001538  e59a0010          LDR      r0,[r10,#0x10]        ;679  ; ackno
00153c  ea000063          B        |L1.5840|
                  |L1.5440|
001540  e5da0000          LDRB     r0,[r10,#0]           ;684  ; flags
001544  e3100010          TST      r0,#0x10              ;684
001548  0a000062          BEQ      |L1.5848|
00154c  e5940048          LDR      r0,[r4,#0x48]         ;686
001550  e59ac010          LDR      r12,[r10,#0x10]       ;686  ; ackno
001554  e04c0000          SUB      r0,r12,r0             ;686
001558  e3500001          CMP      r0,#1                 ;686
00155c  4a00004d          BMI      |L1.5784|
001560  e5940050          LDR      r0,[r4,#0x50]         ;686
001564  e04c0000          SUB      r0,r12,r0             ;686
001568  e3500000          CMP      r0,#0                 ;686
00156c  ca000049          BGT      |L1.5784|
001570  e3a00004          MOV      r0,#4                 ;688
001574  e5c40018          STRB     r0,[r4,#0x18]         ;688
001578  e5940014          LDR      r0,[r4,#0x14]         ;691
00157c  e3500000          CMP      r0,#0                 ;691
001580  1a000007          BNE      |L1.5540|
001584  e51f3b24          LDR      r3,|L1.2664|
001588  e59f20a4          LDR      r2,|L1.5684|
00158c  e51f0aec          LDR      r0,|L1.2728|
001590  e28f10a0          ADR      r1,|L1.5688|
001594  ebfffffe          BL       sysprintf
001598  e5940014          LDR      r0,[r4,#0x14]         ;694
00159c  e3500000          CMP      r0,#0                 ;694
0015a0  0a000008          BEQ      |L1.5576|
                  |L1.5540|
0015a4  e5943014          LDR      r3,[r4,#0x14]         ;694
0015a8  e5940010          LDR      r0,[r4,#0x10]         ;694
0015ac  e3a02000          MOV      r2,#0                 ;694
0015b0  e1a01004          MOV      r1,r4                 ;694
0015b4  e12fff33          BLX      r3                    ;694
0015b8  e3500000          CMP      r0,#0                 ;695
0015bc  0a000022          BEQ      |L1.5708|
0015c0  e370000a          CMN      r0,#0xa               ;699
0015c4  0a000001          BEQ      |L1.5584|
                  |L1.5576|
0015c8  e1a00004          MOV      r0,r4                 ;700
0015cc  ebfffffe          BL       tcp_abort
                  |L1.5584|
0015d0  e3e00009          MVN      r0,#9                 ;702
0015d4  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.5592|
                          DCD      0x000005c9
                  |L1.5596|
                          DCD      ||.text||+0xa70
                  |L1.5600|
                          DCD      0x00000257
                  |L1.5604|
0015e4  7463705f          DCB      "tcp_input: pcb->state != CLOSED",0
0015e8  696e7075
0015ec  743a2070
0015f0  63622d3e
0015f4  73746174
0015f8  6520213d
0015fc  20434c4f
001600  53454400
                  |L1.5636|
                          DCD      tcp_active_pcbs_changed
                  |L1.5640|
                          DCD      tcp_tw_pcbs
                  |L1.5644|
                          DCD      tcp_active_pcbs
                  |L1.5648|
                          DCD      tcp_tmp_pcb
                  |L1.5652|
001614  7063622d          DCB      "pcb->snd_queuelen > 0",0
001618  3e736e64
00161c  5f717565
001620  75656c65
001624  6e203e20
001628  3000    
00162a  00                DCB      0
00162b  00                DCB      0
                  |L1.5676|
                          DCD      current_iphdr_src
                  |L1.5680|
                          DCD      current_iphdr_dest
                  |L1.5684|
                          DCD      0x000002b3
                  |L1.5688|
001638  7063622d          DCB      "pcb->accept != NULL",0
00163c  3e616363
001640  65707420
001644  213d204e
001648  554c4c00
                  |L1.5708|
00164c  e1d454bc          LDRH     r5,[r4,#0x4c]         ;704
001650  e1a00004          MOV      r0,r4                 ;707
001654  ebfffffe          BL       tcp_receive
001658  e1d406b4          LDRH     r0,[r4,#0x64]         ;710
00165c  e3500000          CMP      r0,#0                 ;710
001660  12400001          SUBNE    r0,r0,#1              ;710
001664  11c406b4          STRHNE   r0,[r4,#0x64]         ;711
001668  e1d403b6          LDRH     r0,[r4,#0x36]         ;714
00166c  e3550001          CMP      r5,#1                 ;714
001670  01a00080          LSLEQ    r0,r0,#1              ;714
001674  e1c404bc          STRH     r0,[r4,#0x4c]         ;714
                  |L1.5752|
001678  e5da0001          LDRB     r0,[r10,#1]           ;716  ; recv_flags
00167c  e3100020          TST      r0,#0x20              ;716
001680  0a00008b          BEQ      |L1.6324|
001684  e5d4001e          LDRB     r0,[r4,#0x1e]         ;735
001688  e3800002          ORR      r0,r0,#2              ;735
00168c  e5c4001e          STRB     r0,[r4,#0x1e]         ;735
001690  e3a00007          MOV      r0,#7                 ;736
001694  ea000041          B        |L1.6048|
                  |L1.5784|
001698  e59a0004          LDR      r0,[r10,#4]           ;722  ; tcphdr
00169c  e51f3078          LDR      r3,|L1.5676|
0016a0  e5d01001          LDRB     r1,[r0,#1]            ;722
0016a4  e5d02000          LDRB     r2,[r0,#0]            ;722
0016a8  e1821401          ORR      r1,r2,r1,LSL #8       ;722
0016ac  e5d02003          LDRB     r2,[r0,#3]            ;722
0016b0  e5d00002          LDRB     r0,[r0,#2]            ;722
0016b4  e1800402          ORR      r0,r0,r2,LSL #8       ;722
0016b8  e1cd00f0          STRD     r0,r1,[sp,#0]         ;722
0016bc  e1da10b2          LDRH     r1,[r10,#2]           ;722  ; tcplen
0016c0  e59a000c          LDR      r0,[r10,#0xc]         ;722  ; seqno
0016c4  e51f209c          LDR      r2,|L1.5680|
0016c8  e0811000          ADD      r1,r1,r0              ;722
0016cc  e1a0000c          MOV      r0,r12                ;722
                  |L1.5840|
0016d0  ebfffffe          BL       tcp_rst
0016d4  ea000076          B        |L1.6324|
                  |L1.5848|
0016d8  e3100002          TST      r0,#2                 ;725
0016dc  0a000074          BEQ      |L1.6324|
0016e0  e5940028          LDR      r0,[r4,#0x28]         ;725
0016e4  e59a100c          LDR      r1,[r10,#0xc]         ;725  ; seqno
0016e8  e2400001          SUB      r0,r0,#1              ;725
0016ec  e1500001          CMP      r0,r1                 ;725
0016f0  01a00004          MOVEQ    r0,r4                 ;727
0016f4  0bfffffe          BLEQ     tcp_rexmit
0016f8  ea00006d          B        |L1.6324|
                  |L1.5884|
0016fc  e1a00004          MOV      r0,r4                 ;733
001700  ebfffffe          BL       tcp_receive
001704  eaffffdb          B        |L1.5752|
                  |L1.5896|
001708  e1a00004          MOV      r0,r4                 ;740
00170c  ebfffffe          BL       tcp_receive
001710  e5da0001          LDRB     r0,[r10,#1]           ;741  ; recv_flags
001714  e3100020          TST      r0,#0x20              ;741
001718  e5da0000          LDRB     r0,[r10,#0]           ;754  ; flags
00171c  e2000010          AND      r0,r0,#0x10           ;754
001720  0a000020          BEQ      |L1.6056|
001724  e3500000          CMP      r0,#0                 ;742
001728  0a000018          BEQ      |L1.6032|
00172c  e5940050          LDR      r0,[r4,#0x50]         ;742
001730  e59a1010          LDR      r1,[r10,#0x10]        ;742  ; ackno
001734  e1500001          CMP      r0,r1                 ;742
001738  1a000014          BNE      |L1.6032|
00173c  e5d4001e          LDRB     r0,[r4,#0x1e]         ;745
001740  e3800002          ORR      r0,r0,#2              ;745
001744  e5c4001e          STRB     r0,[r4,#0x1e]         ;745
001748  e1a00004          MOV      r0,r4                 ;746
00174c  ebfffffe          BL       tcp_pcb_purge
001750  e59b0000          LDR      r0,[r11,#0]           ;747  ; tcp_active_pcbs
001754  e1500004          CMP      r0,r4                 ;747
001758  1a000002          BNE      |L1.5992|
                  |L1.5980|
00175c  e590000c          LDR      r0,[r0,#0xc]          ;747
001760  e58b0000          STR      r0,[r11,#0]           ;747  ; tcp_active_pcbs
001764  ea000040          B        |L1.6252|
                  |L1.5992|
001768  e3500000          CMP      r0,#0                 ;747
00176c  e5850000          STR      r0,[r5,#0]            ;747  ; tcp_tmp_pcb
001770  0a00003d          BEQ      |L1.6252|
001774  e590000c          LDR      r0,[r0,#0xc]          ;747
001778  e1500004          CMP      r0,r4                 ;747
00177c  1afffff9          BNE      |L1.5992|
                  |L1.6016|
001780  e594000c          LDR      r0,[r4,#0xc]          ;747
001784  e5951000          LDR      r1,[r5,#0]            ;747  ; tcp_tmp_pcb
001788  e581000c          STR      r0,[r1,#0xc]          ;747
00178c  ea000036          B        |L1.6252|
                  |L1.6032|
001790  e5d4001e          LDRB     r0,[r4,#0x1e]         ;751
001794  e3800002          ORR      r0,r0,#2              ;751
001798  e5c4001e          STRB     r0,[r4,#0x1e]         ;751
00179c  e3a00008          MOV      r0,#8                 ;752
                  |L1.6048|
0017a0  e5c40018          STRB     r0,[r4,#0x18]         ;718
0017a4  ea000042          B        |L1.6324|
                  |L1.6056|
0017a8  e3500000          CMP      r0,#0                 ;754
0017ac  0a000040          BEQ      |L1.6324|
0017b0  e5940050          LDR      r0,[r4,#0x50]         ;754
0017b4  e59a1010          LDR      r1,[r10,#0x10]        ;754  ; ackno
0017b8  e1500001          CMP      r0,r1                 ;754
0017bc  03a00006          MOVEQ    r0,#6                 ;755
0017c0  0afffff6          BEQ      |L1.6048|
0017c4  ea00003a          B        |L1.6324|
                  |L1.6088|
0017c8  e1a00004          MOV      r0,r4                 ;759
0017cc  ebfffffe          BL       tcp_receive
0017d0  e5da0001          LDRB     r0,[r10,#1]           ;760  ; recv_flags
0017d4  e3100020          TST      r0,#0x20              ;760
0017d8  0a000035          BEQ      |L1.6324|
0017dc  e5d4001e          LDRB     r0,[r4,#0x1e]         ;762
0017e0  e3800002          ORR      r0,r0,#2              ;762
0017e4  e5c4001e          STRB     r0,[r4,#0x1e]         ;762
0017e8  e1a00004          MOV      r0,r4                 ;763
0017ec  ebfffffe          BL       tcp_pcb_purge
0017f0  e59b0000          LDR      r0,[r11,#0]           ;764  ; tcp_active_pcbs
0017f4  e1500004          CMP      r0,r4                 ;764
0017f8  0affffd7          BEQ      |L1.5980|
                  |L1.6140|
0017fc  e3500000          CMP      r0,#0                 ;764
001800  e5850000          STR      r0,[r5,#0]            ;764  ; tcp_tmp_pcb
001804  0a000018          BEQ      |L1.6252|
001808  e590000c          LDR      r0,[r0,#0xc]          ;764
00180c  e1500004          CMP      r0,r4                 ;764
001810  1afffff9          BNE      |L1.6140|
001814  eaffffd9          B        |L1.6016|
                  |L1.6168|
001818  e1a00004          MOV      r0,r4                 ;770
00181c  ebfffffe          BL       tcp_receive
001820  e5da0000          LDRB     r0,[r10,#0]           ;771  ; flags
001824  e3100010          TST      r0,#0x10              ;771
001828  0a000021          BEQ      |L1.6324|
00182c  e5940050          LDR      r0,[r4,#0x50]         ;771
001830  e59a1010          LDR      r1,[r10,#0x10]        ;771  ; ackno
001834  e1500001          CMP      r0,r1                 ;771
001838  1a00001d          BNE      |L1.6324|
00183c  e1a00004          MOV      r0,r4                 ;773
001840  ebfffffe          BL       tcp_pcb_purge
001844  e59b0000          LDR      r0,[r11,#0]           ;774  ; tcp_active_pcbs
001848  e1500004          CMP      r0,r4                 ;774
00184c  0affffc2          BEQ      |L1.5980|
                  |L1.6224|
001850  e3500000          CMP      r0,#0                 ;774
001854  e5850000          STR      r0,[r5,#0]            ;774  ; tcp_tmp_pcb
001858  0a000003          BEQ      |L1.6252|
00185c  e590000c          LDR      r0,[r0,#0xc]          ;774
001860  e1500004          CMP      r0,r4                 ;774
001864  1afffff9          BNE      |L1.6224|
001868  eaffffc4          B        |L1.6016|
                  |L1.6252|
00186c  e5c87000          STRB     r7,[r8,#0]            ;774  ; tcp_active_pcbs_changed
001870  e5c49018          STRB     r9,[r4,#0x18]         ;775
001874  e5960000          LDR      r0,[r6,#0]            ;776  ; tcp_tw_pcbs
001878  e584000c          STR      r0,[r4,#0xc]          ;776
00187c  e5864000          STR      r4,[r6,#0]            ;776  ; tcp_tw_pcbs
001880  ebfffffe          BL       tcp_timer_needed
001884  ea00000a          B        |L1.6324|
                  |L1.6280|
001888  e1a00004          MOV      r0,r4                 ;780
00188c  ebfffffe          BL       tcp_receive
001890  e5da0000          LDRB     r0,[r10,#0]           ;781  ; flags
001894  e3100010          TST      r0,#0x10              ;781
001898  0a000005          BEQ      |L1.6324|
00189c  e5940050          LDR      r0,[r4,#0x50]         ;781
0018a0  e59a1010          LDR      r1,[r10,#0x10]        ;781  ; ackno
0018a4  e1500001          CMP      r0,r1                 ;781
0018a8  05da0001          LDRBEQ   r0,[r10,#1]           ;784  ; recv_flags
0018ac  03800010          ORREQ    r0,r0,#0x10           ;784
0018b0  05ca0001          STRBEQ   r0,[r10,#1]           ;784  ; recv_flags
                  |L1.6324|
0018b4  e3a00000          MOV      r0,#0                 ;790
0018b8  e8bd9ffc          POP      {r2-r12,pc}
;;;792    
                          ENDP

                  tcp_listen_input PROC
;;;439    static err_t
;;;440    tcp_listen_input(struct tcp_pcb_listen *pcb)
0018bc  e92d407c          PUSH     {r2-r6,lr}
;;;441    {
;;;442      struct tcp_pcb *npcb;
;;;443      err_t rc;
;;;444    
;;;445      if (flags & TCP_RST) {
0018c0  e59f64d0          LDR      r6,|L1.7576|
0018c4  e1a05000          MOV      r5,r0                 ;441
0018c8  e5d60000          LDRB     r0,[r6,#0]  ; flags
0018cc  e3100004          TST      r0,#4
0018d0  1a000058          BNE      |L1.6712|
;;;446        /* An incoming RST should be ignored. Return. */
;;;447        return ERR_OK;
;;;448      }
;;;449    
;;;450      /* In the LISTEN state, we check for incoming SYN segments,
;;;451         creates a new PCB, and responds with a SYN|ACK. */
;;;452      if (flags & TCP_ACK) {
0018d4  e3100010          TST      r0,#0x10
0018d8  0a00000f          BEQ      |L1.6428|
;;;453        /* For incoming segments with the ACK flag set, respond with a
;;;454           RST. */
;;;455        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
;;;456        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
0018dc  e5960004          LDR      r0,[r6,#4]  ; tcphdr
0018e0  e51f32bc          LDR      r3,|L1.5676|
0018e4  e5d01001          LDRB     r1,[r0,#1]
0018e8  e5d02000          LDRB     r2,[r0,#0]
0018ec  e1821401          ORR      r1,r2,r1,LSL #8
0018f0  e5d02003          LDRB     r2,[r0,#3]
0018f4  e5d00002          LDRB     r0,[r0,#2]
0018f8  e1800402          ORR      r0,r0,r2,LSL #8
0018fc  e1cd00f0          STRD     r0,r1,[sp,#0]
001900  e1d610b2          LDRH     r1,[r6,#2]  ; tcplen
001904  e596000c          LDR      r0,[r6,#0xc]  ; seqno
001908  e51f22e0          LDR      r2,|L1.5680|
00190c  e0811000          ADD      r1,r1,r0
001910  e5960010          LDR      r0,[r6,#0x10]  ; ackno
001914  ebfffffe          BL       tcp_rst
001918  ea000046          B        |L1.6712|
                  |L1.6428|
;;;457          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;458      } else if (flags & TCP_SYN) {
00191c  e3100002          TST      r0,#2
001920  0a000044          BEQ      |L1.6712|
;;;459        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
;;;460    #if TCP_LISTEN_BACKLOG
;;;461        if (pcb->accepts_pending >= pcb->backlog) {
;;;462          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
;;;463          return ERR_ABRT;
;;;464        }
;;;465    #endif /* TCP_LISTEN_BACKLOG */
;;;466        npcb = tcp_alloc(pcb->prio);
001924  e5d50019          LDRB     r0,[r5,#0x19]
001928  ebfffffe          BL       tcp_alloc
00192c  e1b04000          MOVS     r4,r0
;;;467        /* If a new PCB could not be created (probably due to lack of memory),
;;;468           we don't do anything, but rely on the sender will retransmit the
;;;469           SYN at a time when we have more memory available. */
;;;470        if (npcb == NULL) {
;;;471          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
;;;472          TCP_STATS_INC(tcp.memerr);
;;;473          return ERR_MEM;
001930  03e00000          MVNEQ    r0,#0
001934  0a00003b          BEQ      |L1.6696|
;;;474        }
;;;475    #if TCP_LISTEN_BACKLOG
;;;476        pcb->accepts_pending++;
;;;477    #endif /* TCP_LISTEN_BACKLOG */
;;;478        /* Set up the new PCB. */
;;;479        ip_addr_copy(npcb->local_ip, current_iphdr_dest);
001938  e51f0310          LDR      r0,|L1.5680|
00193c  e5900000          LDR      r0,[r0,#0]  ; current_iphdr_dest
001940  e5840000          STR      r0,[r4,#0]
;;;480        npcb->local_port = pcb->local_port;
001944  e1d501ba          LDRH     r0,[r5,#0x1a]
001948  e1c401ba          STRH     r0,[r4,#0x1a]
;;;481        ip_addr_copy(npcb->remote_ip, current_iphdr_src);
00194c  e51f0328          LDR      r0,|L1.5676|
001950  e5900000          LDR      r0,[r0,#0]  ; current_iphdr_src
;;;482        npcb->remote_port = tcphdr->src;
001954  e5840004          STR      r0,[r4,#4]
001958  e5960004          LDR      r0,[r6,#4]  ; tcphdr
00195c  e5d01001          LDRB     r1,[r0,#1]
001960  e5d02000          LDRB     r2,[r0,#0]
001964  e1821401          ORR      r1,r2,r1,LSL #8
001968  e1c411bc          STRH     r1,[r4,#0x1c]
;;;483        npcb->state = SYN_RCVD;
00196c  e3a01003          MOV      r1,#3
001970  e5c41018          STRB     r1,[r4,#0x18]
;;;484        npcb->rcv_nxt = seqno + 1;
001974  e596100c          LDR      r1,[r6,#0xc]  ; seqno
001978  e2812001          ADD      r2,r1,#1
;;;485        npcb->rcv_ann_right_edge = npcb->rcv_nxt;
00197c  e5842028          STR      r2,[r4,#0x28]
001980  e5842030          STR      r2,[r4,#0x30]
;;;486        npcb->snd_wnd = tcphdr->wnd;
001984  e5d0300f          LDRB     r3,[r0,#0xf]
001988  e5d0200e          LDRB     r2,[r0,#0xe]
00198c  e1822403          ORR      r2,r2,r3,LSL #8
001990  e1c426b0          STRH     r2,[r4,#0x60]
;;;487        npcb->snd_wnd_max = tcphdr->wnd;
001994  e5d0300f          LDRB     r3,[r0,#0xf]
001998  e5d0000e          LDRB     r0,[r0,#0xe]
00199c  e1800403          ORR      r0,r0,r3,LSL #8
0019a0  e1c406b2          STRH     r0,[r4,#0x62]
;;;488        npcb->ssthresh = npcb->snd_wnd;
;;;489        npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
0019a4  e2410001          SUB      r0,r1,#1
0019a8  e1c424be          STRH     r2,[r4,#0x4e]         ;488
;;;490        npcb->callback_arg = pcb->callback_arg;
0019ac  e5840054          STR      r0,[r4,#0x54]
0019b0  e5950010          LDR      r0,[r5,#0x10]
;;;491    #if LWIP_CALLBACK_API
;;;492        npcb->accept = pcb->accept;
0019b4  e5840010          STR      r0,[r4,#0x10]
0019b8  e5950014          LDR      r0,[r5,#0x14]
0019bc  e5840014          STR      r0,[r4,#0x14]
;;;493    #endif /* LWIP_CALLBACK_API */
;;;494        /* inherit socket options */
;;;495        npcb->so_options = pcb->so_options & SOF_INHERITED;
0019c0  e5d50008          LDRB     r0,[r5,#8]
0019c4  e200008c          AND      r0,r0,#0x8c
0019c8  e5c40008          STRB     r0,[r4,#8]
;;;496        /* Register the new PCB so that we can begin receiving segments
;;;497           for it. */
;;;498        TCP_REG_ACTIVE(npcb);
0019cc  e51f03c8          LDR      r0,|L1.5644|
0019d0  e5901000          LDR      r1,[r0,#0]  ; tcp_active_pcbs
0019d4  e584100c          STR      r1,[r4,#0xc]
0019d8  e5804000          STR      r4,[r0,#0]  ; tcp_active_pcbs
0019dc  ebfffffe          BL       tcp_timer_needed
0019e0  e51f13e4          LDR      r1,|L1.5636|
0019e4  e3a00001          MOV      r0,#1
0019e8  e5c10000          STRB     r0,[r1,#0]  ; tcp_active_pcbs_changed
;;;499    
;;;500        /* Parse any options in the SYN. */
;;;501        tcp_parseopt(npcb);
0019ec  e1a00004          MOV      r0,r4
0019f0  ebfffffe          BL       tcp_parseopt
;;;502    #if TCP_CALCULATE_EFF_SEND_MSS
;;;503        npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
0019f4  e1d403b6          LDRH     r0,[r4,#0x36]
0019f8  e2841004          ADD      r1,r4,#4
0019fc  ebfffffe          BL       tcp_eff_send_mss
001a00  e1c403b6          STRH     r0,[r4,#0x36]
;;;504    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;505    
;;;506        snmp_inc_tcppassiveopens();
;;;507    
;;;508        /* Send a SYN|ACK together with the MSS option. */
;;;509        rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
001a04  e3a01012          MOV      r1,#0x12
001a08  e1a00004          MOV      r0,r4
001a0c  ebfffffe          BL       tcp_enqueue_flags
001a10  e1b05000          MOVS     r5,r0
;;;510        if (rc != ERR_OK) {
001a14  0a000004          BEQ      |L1.6700|
;;;511          tcp_abandon(npcb, 0);
001a18  e3a01000          MOV      r1,#0
001a1c  e1a00004          MOV      r0,r4
001a20  ebfffffe          BL       tcp_abandon
;;;512          return rc;
001a24  e1a00005          MOV      r0,r5
                  |L1.6696|
;;;513        }
;;;514        return tcp_output(npcb);
;;;515      }
;;;516      return ERR_OK;
;;;517    }
001a28  e8bd807c          POP      {r2-r6,pc}
                  |L1.6700|
001a2c  e1a00004          MOV      r0,r4                 ;514
001a30  ebfffffe          BL       tcp_output
001a34  e8bd807c          POP      {r2-r6,pc}
                  |L1.6712|
001a38  e3a00000          MOV      r0,#0                 ;516
001a3c  e8bd807c          POP      {r2-r6,pc}
;;;518    
                          ENDP

                  tcp_input PROC
;;;91     void
;;;92     tcp_input(struct pbuf *p, struct netif *inp)
001a40  e92d47fc          PUSH     {r2-r10,lr}
;;;93     {
001a44  e1a05000          MOV      r5,r0
;;;94       struct tcp_pcb *pcb, *prev;
;;;95       struct tcp_pcb_listen *lpcb;
;;;96     #if SO_REUSE
;;;97       struct tcp_pcb *lpcb_prev = NULL;
;;;98       struct tcp_pcb_listen *lpcb_any = NULL;
;;;99     #endif /* SO_REUSE */
;;;100      u8_t hdrlen;
;;;101      err_t err;
;;;102    
;;;103      PERF_START;
;;;104    
;;;105      TCP_STATS_INC(tcp.recv);
;;;106      snmp_inc_tcpinsegs();
;;;107    
;;;108      iphdr = (struct ip_hdr *)p->payload;
001a48  e5900004          LDR      r0,[r0,#4]
001a4c  e59f6344          LDR      r6,|L1.7576|
001a50  e1a04001          MOV      r4,r1                 ;93
001a54  e5860008          STR      r0,[r6,#8]  ; iphdr
;;;109      tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
001a58  e5d01000          LDRB     r1,[r0,#0]
001a5c  e201200f          AND      r2,r1,#0xf
001a60  e0800102          ADD      r0,r0,r2,LSL #2
001a64  e5860004          STR      r0,[r6,#4]  ; tcphdr
;;;110    
;;;111    #if TCP_INPUT_DEBUG
;;;112      tcp_debug_print(tcphdr);
;;;113    #endif
;;;114    
;;;115      /* remove header from payload */
;;;116      if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
001a68  e1a00102          LSL      r0,r2,#2
001a6c  e2601000          RSB      r1,r0,#0
001a70  e1a00005          MOV      r0,r5
001a74  ebfffffe          BL       pbuf_header
001a78  e3500000          CMP      r0,#0
001a7c  1a0001d3          BNE      |L1.8656|
001a80  e1d500b8          LDRH     r0,[r5,#8]
001a84  e3500014          CMP      r0,#0x14
001a88  3a0001d0          BCC      |L1.8656|
;;;117        /* drop short packets */
;;;118        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
;;;119        TCP_STATS_INC(tcp.lenerr);
;;;120        goto dropped;
;;;121      }
;;;122    
;;;123      /* Don't even process incoming broadcasts/multicasts. */
;;;124      if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
001a8c  e51f7464          LDR      r7,|L1.5680|
001a90  e1a01004          MOV      r1,r4
001a94  e5970000          LDR      r0,[r7,#0]  ; current_iphdr_dest
001a98  ebfffffe          BL       ip4_addr_isbroadcast
001a9c  e3500000          CMP      r0,#0
001aa0  1a0001ca          BNE      |L1.8656|
;;;125          ip_addr_ismulticast(&current_iphdr_dest)) {
001aa4  e5d70000          LDRB     r0,[r7,#0]  ; current_iphdr_dest
001aa8  e20000f0          AND      r0,r0,#0xf0
001aac  e35000e0          CMP      r0,#0xe0
001ab0  0a0001c6          BEQ      |L1.8656|
;;;126        TCP_STATS_INC(tcp.proterr);
;;;127        goto dropped;
;;;128      }
;;;129    
;;;130    #if CHECKSUM_CHECK_TCP
;;;131      /* Verify TCP checksum. */
;;;132      if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
001ab4  e1d500b8          LDRH     r0,[r5,#8]
001ab8  e51f1494          LDR      r1,|L1.5676|
001abc  e3a03006          MOV      r3,#6
001ac0  e58d0000          STR      r0,[sp,#0]
001ac4  e2872000          ADD      r2,r7,#0
001ac8  e1a00005          MOV      r0,r5
001acc  ebfffffe          BL       inet_chksum_pseudo
001ad0  e3500000          CMP      r0,#0
001ad4  1a0001bd          BNE      |L1.8656|
;;;133          IP_PROTO_TCP, p->tot_len) != 0) {
;;;134          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
;;;135            inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;136          IP_PROTO_TCP, p->tot_len)));
;;;137    #if TCP_DEBUG
;;;138        tcp_debug_print(tcphdr);
;;;139    #endif /* TCP_DEBUG */
;;;140        TCP_STATS_INC(tcp.chkerr);
;;;141        goto dropped;
;;;142      }
;;;143    #endif
;;;144    
;;;145      /* Move the payload pointer in the pbuf so that it points to the
;;;146         TCP data instead of the TCP header. */
;;;147      hdrlen = TCPH_HDRLEN(tcphdr);
001ad8  e5960004          LDR      r0,[r6,#4]  ; tcphdr
001adc  e5d0100d          LDRB     r1,[r0,#0xd]
001ae0  e5d0000c          LDRB     r0,[r0,#0xc]
001ae4  e1800401          ORR      r0,r0,r1,LSL #8
001ae8  ebfffffe          BL       lwip_ntohs
001aec  e1a00620          LSR      r0,r0,#12
;;;148      if(pbuf_header(p, -(hdrlen * 4))){
001af0  e1a00100          LSL      r0,r0,#2
001af4  e2601000          RSB      r1,r0,#0
001af8  e1a00005          MOV      r0,r5
001afc  ebfffffe          BL       pbuf_header
001b00  e3500000          CMP      r0,#0
001b04  1a0001b1          BNE      |L1.8656|
;;;149        /* drop short packets */
;;;150        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
;;;151        TCP_STATS_INC(tcp.lenerr);
;;;152        goto dropped;
;;;153      }
;;;154    
;;;155      /* Convert fields in TCP header to host byte order. */
;;;156      tcphdr->src = ntohs(tcphdr->src);
001b08  e5960004          LDR      r0,[r6,#4]  ; tcphdr
001b0c  e5d01001          LDRB     r1,[r0,#1]
001b10  e5d00000          LDRB     r0,[r0,#0]
001b14  e1800401          ORR      r0,r0,r1,LSL #8
001b18  ebfffffe          BL       lwip_ntohs
001b1c  e1a01000          MOV      r1,r0
001b20  e5960004          LDR      r0,[r6,#4]  ; tcphdr
001b24  e5c01000          STRB     r1,[r0,#0]
001b28  e1a01421          LSR      r1,r1,#8
001b2c  e5c01001          STRB     r1,[r0,#1]
;;;157      tcphdr->dest = ntohs(tcphdr->dest);
001b30  e5d01003          LDRB     r1,[r0,#3]
001b34  e5d00002          LDRB     r0,[r0,#2]
001b38  e1800401          ORR      r0,r0,r1,LSL #8
001b3c  ebfffffe          BL       lwip_ntohs
001b40  e1a01000          MOV      r1,r0
001b44  e5960004          LDR      r0,[r6,#4]  ; tcphdr
001b48  e5c01002          STRB     r1,[r0,#2]
001b4c  e1a01421          LSR      r1,r1,#8
001b50  e5c01003          STRB     r1,[r0,#3]
001b54  e2800004          ADD      r0,r0,#4
;;;158      seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
001b58  ebfffffe          BL       __aeabi_uread4
001b5c  ebfffffe          BL       lwip_ntohl
001b60  e5964004          LDR      r4,[r6,#4]  ; tcphdr
001b64  e2841004          ADD      r1,r4,#4
001b68  ebfffffe          BL       __aeabi_uwrite4
001b6c  e586000c          STR      r0,[r6,#0xc]  ; seqno
;;;159      ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
001b70  e2840008          ADD      r0,r4,#8
001b74  ebfffffe          BL       __aeabi_uread4
001b78  ebfffffe          BL       lwip_ntohl
001b7c  e5964004          LDR      r4,[r6,#4]  ; tcphdr
001b80  e2841008          ADD      r1,r4,#8
001b84  ebfffffe          BL       __aeabi_uwrite4
001b88  e5860010          STR      r0,[r6,#0x10]  ; ackno
;;;160      tcphdr->wnd = ntohs(tcphdr->wnd);
001b8c  e5d4000f          LDRB     r0,[r4,#0xf]
001b90  e5d4100e          LDRB     r1,[r4,#0xe]
001b94  e1810400          ORR      r0,r1,r0,LSL #8
001b98  ebfffffe          BL       lwip_ntohs
001b9c  e1a01000          MOV      r1,r0
001ba0  e5960004          LDR      r0,[r6,#4]  ; tcphdr
001ba4  e5c0100e          STRB     r1,[r0,#0xe]
001ba8  e1a01421          LSR      r1,r1,#8
001bac  e5c0100f          STRB     r1,[r0,#0xf]
;;;161    
;;;162      flags = TCPH_FLAGS(tcphdr);
001bb0  e5d0100d          LDRB     r1,[r0,#0xd]
001bb4  e5d0000c          LDRB     r0,[r0,#0xc]
001bb8  e1800401          ORR      r0,r0,r1,LSL #8
001bbc  ebfffffe          BL       lwip_ntohs
001bc0  e200003f          AND      r0,r0,#0x3f
001bc4  e5c60000          STRB     r0,[r6,#0]  ; flags
;;;163      tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
001bc8  e1d510b8          LDRH     r1,[r5,#8]
001bcc  e2100003          ANDS     r0,r0,#3
001bd0  13a00001          MOVNE    r0,#1
;;;164    
;;;165      /* Demultiplex an incoming segment. First, we check if it is destined
;;;166         for an active connection. */
;;;167      prev = NULL;
;;;168    
;;;169      
;;;170      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
001bd4  e51fa5d0          LDR      r10,|L1.5644|
001bd8  e0800001          ADD      r0,r0,r1              ;163
001bdc  e1c600b2          STRH     r0,[r6,#2]            ;163  ; tcplen
001be0  e51f95bc          LDR      r9,|L1.5676|
001be4  e59a4000          LDR      r4,[r10,#0]           ;132  ; tcp_active_pcbs
001be8  e3a08000          MOV      r8,#0                 ;167
001bec  ea000046          B        |L1.7436|
                  |L1.7152|
;;;171        LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
001bf0  e5d40018          LDRB     r0,[r4,#0x18]
001bf4  e3500000          CMP      r0,#0
001bf8  1a000004          BNE      |L1.7184|
001bfc  e59f3198          LDR      r3,|L1.7580|
001c00  e59f01c0          LDR      r0,|L1.7624|
001c04  e3a020ab          MOV      r2,#0xab
001c08  e28f1e19          ADR      r1,|L1.7584|
001c0c  ebfffffe          BL       sysprintf
                  |L1.7184|
;;;172        LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
001c10  e5d40018          LDRB     r0,[r4,#0x18]
001c14  e350000a          CMP      r0,#0xa
001c18  1a000004          BNE      |L1.7216|
001c1c  e59f3178          LDR      r3,|L1.7580|
001c20  e59f01a0          LDR      r0,|L1.7624|
001c24  e3a020ac          MOV      r2,#0xac
001c28  e28f1f67          ADR      r1,|L1.7628|
001c2c  ebfffffe          BL       sysprintf
                  |L1.7216|
;;;173        LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
001c30  e5d40018          LDRB     r0,[r4,#0x18]
001c34  e3500001          CMP      r0,#1
001c38  1a000004          BNE      |L1.7248|
001c3c  e59f3158          LDR      r3,|L1.7580|
001c40  e59f0180          LDR      r0,|L1.7624|
001c44  e3a020ad          MOV      r2,#0xad
001c48  e28f1f6a          ADR      r1,|L1.7672|
001c4c  ebfffffe          BL       sysprintf
                  |L1.7248|
;;;174        if (pcb->remote_port == tcphdr->src &&
001c50  e5960004          LDR      r0,[r6,#4]  ; tcphdr
001c54  e1d411bc          LDRH     r1,[r4,#0x1c]
001c58  e5d02001          LDRB     r2,[r0,#1]
001c5c  e5d03000          LDRB     r3,[r0,#0]
001c60  e1832402          ORR      r2,r3,r2,LSL #8
001c64  e1510002          CMP      r1,r2
001c68  1a000025          BNE      |L1.7428|
;;;175           pcb->local_port == tcphdr->dest &&
001c6c  e5d02003          LDRB     r2,[r0,#3]
001c70  e5d00002          LDRB     r0,[r0,#2]
001c74  e1d411ba          LDRH     r1,[r4,#0x1a]
001c78  e1800402          ORR      r0,r0,r2,LSL #8
001c7c  e1510000          CMP      r1,r0
;;;176           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
001c80  05940004          LDREQ    r0,[r4,#4]
001c84  05991000          LDREQ    r1,[r9,#0]  ; current_iphdr_src
001c88  01500001          CMPEQ    r0,r1
;;;177           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
001c8c  05940000          LDREQ    r0,[r4,#0]
001c90  05971000          LDREQ    r1,[r7,#0]  ; current_iphdr_dest
001c94  01500001          CMPEQ    r0,r1
001c98  1a000019          BNE      |L1.7428|
;;;178    
;;;179          /* Move this PCB to the front of the list so that subsequent
;;;180             lookups will be faster (we exploit locality in TCP segment
;;;181             arrivals). */
;;;182          LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
001c9c  e594000c          LDR      r0,[r4,#0xc]
001ca0  e1500004          CMP      r0,r4
001ca4  1a000004          BNE      |L1.7356|
001ca8  e59f30ec          LDR      r3,|L1.7580|
001cac  e59f0114          LDR      r0,|L1.7624|
001cb0  e3a020b6          MOV      r2,#0xb6
001cb4  e28f1f59          ADR      r1,|L1.7712|
001cb8  ebfffffe          BL       sysprintf
                  |L1.7356|
;;;183          if (prev != NULL) {
001cbc  e3580000          CMP      r8,#0
001cc0  0a000004          BEQ      |L1.7384|
;;;184            prev->next = pcb->next;
001cc4  e594000c          LDR      r0,[r4,#0xc]
;;;185            pcb->next = tcp_active_pcbs;
001cc8  e588000c          STR      r0,[r8,#0xc]
001ccc  e59a0000          LDR      r0,[r10,#0]  ; tcp_active_pcbs
;;;186            tcp_active_pcbs = pcb;
001cd0  e584000c          STR      r0,[r4,#0xc]
001cd4  e58a4000          STR      r4,[r10,#0]  ; tcp_active_pcbs
                  |L1.7384|
;;;187          }
;;;188          LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
001cd8  e594000c          LDR      r0,[r4,#0xc]
001cdc  e1500004          CMP      r0,r4
001ce0  1a000004          BNE      |L1.7416|
001ce4  e59f30b0          LDR      r3,|L1.7580|
001ce8  e59f00d8          LDR      r0,|L1.7624|
001cec  e3a020bc          MOV      r2,#0xbc
001cf0  e28f1f55          ADR      r1,|L1.7756|
001cf4  ebfffffe          BL       sysprintf
                  |L1.7416|
;;;189          break;
;;;190        }
;;;191        prev = pcb;
;;;192      }
;;;193    
;;;194      if (pcb == NULL) {
001cf8  e3540000          CMP      r4,#0
001cfc  0a000004          BEQ      |L1.7444|
001d00  ea000090          B        |L1.8008|
                  |L1.7428|
001d04  e1a08004          MOV      r8,r4                 ;191
001d08  e594400c          LDR      r4,[r4,#0xc]          ;170
                  |L1.7436|
001d0c  e3540000          CMP      r4,#0                 ;170
001d10  1affffb6          BNE      |L1.7152|
                  |L1.7444|
;;;195        /* If it did not go to an active connection, we check the connections
;;;196           in the TIME-WAIT state. */
;;;197        for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
001d14  e51f0714          LDR      r0,|L1.5640|
001d18  e5904000          LDR      r4,[r0,#0]  ; tcp_tw_pcbs
001d1c  ea000062          B        |L1.7852|
                  |L1.7456|
;;;198          LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
001d20  e5d40018          LDRB     r0,[r4,#0x18]
001d24  e350000a          CMP      r0,#0xa
001d28  0a000004          BEQ      |L1.7488|
001d2c  e59f3068          LDR      r3,|L1.7580|
001d30  e59f0090          LDR      r0,|L1.7624|
001d34  e3a020c6          MOV      r2,#0xc6
001d38  e28f1f4e          ADR      r1,|L1.7800|
001d3c  ebfffffe          BL       sysprintf
                  |L1.7488|
;;;199          if (pcb->remote_port == tcphdr->src &&
001d40  e5960004          LDR      r0,[r6,#4]  ; tcphdr
001d44  e1d411bc          LDRH     r1,[r4,#0x1c]
001d48  e5d02001          LDRB     r2,[r0,#1]
001d4c  e5d03000          LDRB     r3,[r0,#0]
001d50  e1832402          ORR      r2,r3,r2,LSL #8
001d54  e1510002          CMP      r1,r2
001d58  1a000052          BNE      |L1.7848|
;;;200             pcb->local_port == tcphdr->dest &&
001d5c  e5d02003          LDRB     r2,[r0,#3]
001d60  e5d00002          LDRB     r0,[r0,#2]
001d64  e1d411ba          LDRH     r1,[r4,#0x1a]
001d68  e1800402          ORR      r0,r0,r2,LSL #8
001d6c  e1510000          CMP      r1,r0
;;;201             ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
001d70  05940004          LDREQ    r0,[r4,#4]
001d74  05991000          LDREQ    r1,[r9,#0]  ; current_iphdr_src
001d78  01500001          CMPEQ    r0,r1
;;;202             ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
001d7c  05940000          LDREQ    r0,[r4,#0]
001d80  05971000          LDREQ    r1,[r7,#0]  ; current_iphdr_dest
001d84  01500001          CMPEQ    r0,r1
001d88  1a000046          BNE      |L1.7848|
;;;203            /* We don't really care enough to move this PCB to the front
;;;204               of the list since we are not very likely to receive that
;;;205               many segments for connections in TIME-WAIT. */
;;;206            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
;;;207            tcp_timewait_input(pcb);
001d8c  e1a00004          MOV      r0,r4
001d90  ebfffffe          BL       tcp_timewait_input
;;;208            pbuf_free(p);
;;;209            return;
001d94  ea00010d          B        |L1.8656|
                  |L1.7576|
                          DCD      ||.data||
                  |L1.7580|
                          DCD      ||.text||+0x478
                  |L1.7584|
001da0  7463705f          DCB      "tcp_input: active pcb->state != CLOSED",0
001da4  696e7075
001da8  743a2061
001dac  63746976
001db0  65207063
001db4  622d3e73
001db8  74617465
001dbc  20213d20
001dc0  434c4f53
001dc4  454400  
001dc7  00                DCB      0
                  |L1.7624|
                          DCD      ||.text||+0x4b4
                  |L1.7628|
001dcc  7463705f          DCB      "tcp_input: active pcb->state != TIME-WAIT",0
001dd0  696e7075
001dd4  743a2061
001dd8  63746976
001ddc  65207063
001de0  622d3e73
001de4  74617465
001de8  20213d20
001dec  54494d45
001df0  2d574149
001df4  5400    
001df6  00                DCB      0
001df7  00                DCB      0
                  |L1.7672|
001df8  7463705f          DCB      "tcp_input: active pcb->state != LISTEN",0
001dfc  696e7075
001e00  743a2061
001e04  63746976
001e08  65207063
001e0c  622d3e73
001e10  74617465
001e14  20213d20
001e18  4c495354
001e1c  454e00  
001e1f  00                DCB      0
                  |L1.7712|
001e20  7463705f          DCB      "tcp_input: pcb->next != pcb (before cache)",0
001e24  696e7075
001e28  743a2070
001e2c  63622d3e
001e30  6e657874
001e34  20213d20
001e38  70636220
001e3c  28626566
001e40  6f726520
001e44  63616368
001e48  652900  
001e4b  00                DCB      0
                  |L1.7756|
001e4c  7463705f          DCB      "tcp_input: pcb->next != pcb (after cache)",0
001e50  696e7075
001e54  743a2070
001e58  63622d3e
001e5c  6e657874
001e60  20213d20
001e64  70636220
001e68  28616674
001e6c  65722063
001e70  61636865
001e74  2900    
001e76  00                DCB      0
001e77  00                DCB      0
                  |L1.7800|
001e78  7463705f          DCB      "tcp_input: TIME-WAIT pcb->state == TIME-WAIT",0
001e7c  696e7075
001e80  743a2054
001e84  494d452d
001e88  57414954
001e8c  20706362
001e90  2d3e7374
001e94  61746520
001e98  3d3d2054
001e9c  494d452d
001ea0  57414954
001ea4  00      
001ea5  00                DCB      0
001ea6  00                DCB      0
001ea7  00                DCB      0
                  |L1.7848|
001ea8  e594400c          LDR      r4,[r4,#0xc]          ;197
                  |L1.7852|
001eac  e3540000          CMP      r4,#0                 ;197
001eb0  1affff9a          BNE      |L1.7456|
;;;210          }
;;;211        }
;;;212    
;;;213        /* Finally, if we still did not get a match, we check all PCBs that
;;;214           are LISTENing for incoming connections. */
;;;215        prev = NULL;
;;;216        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
001eb4  e59f83d4          LDR      r8,|L1.8848|
001eb8  e5961004          LDR      r1,[r6,#4]            ;124
001ebc  e5980000          LDR      r0,[r8,#0]  ; tcp_listen_pcbs
001ec0  e5977000          LDR      r7,[r7,#0]            ;124
001ec4  e3a03000          MOV      r3,#0                 ;215
001ec8  e1a0c000          MOV      r12,r0
001ecc  ea00000e          B        |L1.7948|
                  |L1.7888|
;;;217          if (lpcb->local_port == tcphdr->dest) {
001ed0  e5d19003          LDRB     r9,[r1,#3]
001ed4  e5d1a002          LDRB     r10,[r1,#2]
001ed8  e1d021ba          LDRH     r2,[r0,#0x1a]
001edc  e18a9409          ORR      r9,r10,r9,LSL #8
001ee0  e1520009          CMP      r2,r9
001ee4  1a000006          BNE      |L1.7940|
;;;218    #if SO_REUSE
;;;219            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
;;;220              /* found an exact match */
;;;221              break;
;;;222            } else if(ip_addr_isany(&(lpcb->local_ip))) {
;;;223              /* found an ANY-match */
;;;224              lpcb_any = lpcb;
;;;225              lpcb_prev = prev;
;;;226            }
;;;227    #else /* SO_REUSE */
;;;228            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
001ee8  e5902000          LDR      r2,[r0,#0]
001eec  e1520007          CMP      r2,r7
001ef0  0a000008          BEQ      |L1.7960|
;;;229                ip_addr_isany(&(lpcb->local_ip))) {
001ef4  e3500000          CMP      r0,#0
001ef8  0a000010          BEQ      |L1.8000|
001efc  e3520000          CMP      r2,#0
001f00  0a000006          BEQ      |L1.7968|
                  |L1.7940|
;;;230              /* found a match */
;;;231              break;
;;;232            }
;;;233    #endif /* SO_REUSE */
;;;234          }
;;;235          prev = (struct tcp_pcb *)lpcb;
001f04  e1a03000          MOV      r3,r0
001f08  e590000c          LDR      r0,[r0,#0xc]          ;216
                  |L1.7948|
001f0c  e3500000          CMP      r0,#0                 ;216
001f10  1affffee          BNE      |L1.7888|
001f14  ea000009          B        |L1.8000|
                  |L1.7960|
;;;236        }
;;;237    #if SO_REUSE
;;;238        /* first try specific local IP */
;;;239        if (lpcb == NULL) {
;;;240          /* only pass to ANY if no specific local IP has been found */
;;;241          lpcb = lpcb_any;
;;;242          prev = lpcb_prev;
;;;243        }
;;;244    #endif /* SO_REUSE */
;;;245        if (lpcb != NULL) {
001f18  e3500000          CMP      r0,#0
001f1c  0a000007          BEQ      |L1.8000|
                  |L1.7968|
;;;246          /* Move this PCB to the front of the list so that subsequent
;;;247             lookups will be faster (we exploit locality in TCP segment
;;;248             arrivals). */
;;;249          if (prev != NULL) {
001f20  e3530000          CMP      r3,#0
001f24  0a000003          BEQ      |L1.7992|
;;;250            ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
001f28  e590100c          LDR      r1,[r0,#0xc]
;;;251                  /* our successor is the remainder of the listening list */
;;;252            lpcb->next = tcp_listen_pcbs.listen_pcbs;
001f2c  e583100c          STR      r1,[r3,#0xc]
;;;253                  /* put this listening pcb at the head of the listening list */
;;;254            tcp_listen_pcbs.listen_pcbs = lpcb;
001f30  e580c00c          STR      r12,[r0,#0xc]
001f34  e5880000          STR      r0,[r8,#0]  ; tcp_listen_pcbs
                  |L1.7992|
;;;255          }
;;;256        
;;;257          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
;;;258          tcp_listen_input(lpcb);
001f38  ebfffffe          BL       tcp_listen_input
;;;259          pbuf_free(p);
;;;260          return;
001f3c  ea0000a3          B        |L1.8656|
                  |L1.8000|
;;;261        }
;;;262      }
;;;263    
;;;264    #if TCP_INPUT_DEBUG
;;;265      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
;;;266      tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
;;;267      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
;;;268    #endif /* TCP_INPUT_DEBUG */
;;;269    
;;;270    
;;;271      if (pcb != NULL) {
001f40  e3540000          CMP      r4,#0
001f44  0a00008c          BEQ      |L1.8572|
                  |L1.8008|
;;;272        /* The incoming segment belongs to a connection. */
;;;273    #if TCP_INPUT_DEBUG
;;;274    #if TCP_DEBUG
;;;275        tcp_debug_print_state(pcb->state);
;;;276    #endif /* TCP_DEBUG */
;;;277    #endif /* TCP_INPUT_DEBUG */
;;;278    
;;;279        /* Set up a tcp_seg structure. */
;;;280        inseg.next = NULL;
001f48  e59f8344          LDR      r8,|L1.8852|
001f4c  e3a07000          MOV      r7,#0
001f50  e5887000          STR      r7,[r8,#0]  ; inseg
;;;281        inseg.len = p->tot_len;
001f54  e1d500b8          LDRH     r0,[r5,#8]
001f58  e1c800b8          STRH     r0,[r8,#8]  ; inseg
;;;282        inseg.p = p;
;;;283        inseg.tcphdr = tcphdr;
001f5c  e5885004          STR      r5,[r8,#4]  ; inseg
001f60  e5960004          LDR      r0,[r6,#4]  ; tcphdr
;;;284    
;;;285        recv_data = NULL;
001f64  e5880010          STR      r0,[r8,#0x10]  ; inseg
001f68  e5867014          STR      r7,[r6,#0x14]  ; recv_data
;;;286        recv_flags = 0;
001f6c  e5c67001          STRB     r7,[r6,#1]  ; recv_flags
;;;287    
;;;288        if (flags & TCP_PSH) {
001f70  e5d60000          LDRB     r0,[r6,#0]  ; flags
001f74  e3100008          TST      r0,#8
;;;289          p->flags |= PBUF_FLAG_PUSH;
001f78  15d5000d          LDRBNE   r0,[r5,#0xd]
001f7c  13800001          ORRNE    r0,r0,#1
001f80  15c5000d          STRBNE   r0,[r5,#0xd]
;;;290        }
;;;291    
;;;292        /* If there is data which was previously "refused" by upper layer */
;;;293        if (pcb->refused_data != NULL) {
001f84  e5940078          LDR      r0,[r4,#0x78]
001f88  e3500000          CMP      r0,#0
001f8c  0a000008          BEQ      |L1.8116|
;;;294          if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
001f90  e1a00004          MOV      r0,r4
001f94  ebfffffe          BL       tcp_process_refused_data
001f98  e370000a          CMN      r0,#0xa
001f9c  0a00006e          BEQ      |L1.8540|
;;;295            ((pcb->refused_data != NULL) && (tcplen > 0))) {
001fa0  e5940078          LDR      r0,[r4,#0x78]
001fa4  e3500000          CMP      r0,#0
001fa8  11d600b2          LDRHNE   r0,[r6,#2]  ; tcplen
001fac  13500000          CMPNE    r0,#0
001fb0  1a000069          BNE      |L1.8540|
                  |L1.8116|
;;;296            /* pcb has been aborted or refused data is still refused and the new
;;;297               segment contains data */
;;;298            TCP_STATS_INC(tcp.drop);
;;;299            snmp_inc_tcpinerrs();
;;;300            goto aborted;
;;;301          }
;;;302        }
;;;303        tcp_input_pcb = pcb;
;;;304        err = tcp_process(pcb);
001fb4  e1a00004          MOV      r0,r4
001fb8  e5864018          STR      r4,[r6,#0x18]         ;303  ; tcp_input_pcb
001fbc  ebfffffe          BL       tcp_process
;;;305        /* A return value of ERR_ABRT means that tcp_abort() was called
;;;306           and that the pcb has been freed. If so, we don't do anything. */
;;;307        if (err != ERR_ABRT) {
001fc0  e370000a          CMN      r0,#0xa
001fc4  0a000064          BEQ      |L1.8540|
;;;308          if (recv_flags & TF_RESET) {
001fc8  e5d60001          LDRB     r0,[r6,#1]  ; recv_flags
001fcc  e3100008          TST      r0,#8
001fd0  0a00000c          BEQ      |L1.8200|
;;;309            /* TF_RESET means that the connection was reset by the other
;;;310               end. We then call the error callback to inform the
;;;311               application that the connection is dead before we
;;;312               deallocate the PCB. */
;;;313            TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
001fd4  e594208c          LDR      r2,[r4,#0x8c]
001fd8  e3520000          CMP      r2,#0
001fdc  15940010          LDRNE    r0,[r4,#0x10]
001fe0  13e0100a          MVNNE    r1,#0xa
001fe4  0a000000          BEQ      |L1.8172|
                  |L1.8168|
001fe8  e12fff32          BLX      r2
                  |L1.8172|
;;;314            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;315            memp_free(MEMP_TCP_PCB, pcb);
;;;316          } else if (recv_flags & TF_CLOSED) {
;;;317            /* The connection has been closed and we will deallocate the
;;;318               PCB. */
;;;319            if (!(pcb->flags & TF_RXCLOSED)) {
;;;320              /* Connection closed although the application has only shut down the
;;;321                 tx side: call the PCB's err callback and indicate the closure to
;;;322                 ensure the application doesn't continue using the PCB. */
;;;323              TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
;;;324            }
;;;325            tcp_pcb_remove(&tcp_active_pcbs, pcb);
001fec  e51f09e8          LDR      r0,|L1.5644|
001ff0  e1a01004          MOV      r1,r4
001ff4  ebfffffe          BL       tcp_pcb_remove
;;;326            memp_free(MEMP_TCP_PCB, pcb);
001ff8  e1a01004          MOV      r1,r4
001ffc  e3a00001          MOV      r0,#1
002000  ebfffffe          BL       memp_free
002004  ea000054          B        |L1.8540|
                  |L1.8200|
002008  e3100010          TST      r0,#0x10              ;316
00200c  0a000008          BEQ      |L1.8244|
002010  e5d4001e          LDRB     r0,[r4,#0x1e]         ;319
002014  e3100010          TST      r0,#0x10              ;319
002018  1afffff3          BNE      |L1.8172|
00201c  e594208c          LDR      r2,[r4,#0x8c]         ;323
002020  e3520000          CMP      r2,#0                 ;323
002024  15940010          LDRNE    r0,[r4,#0x10]         ;323
002028  13e0100b          MVNNE    r1,#0xb               ;323
00202c  1affffed          BNE      |L1.8168|
002030  eaffffed          B        |L1.8172|
                  |L1.8244|
;;;327          } else {
;;;328            err = ERR_OK;
;;;329            /* If the application has registered a "sent" function to be
;;;330               called when new send buffer space is available, we call it
;;;331               now. */
;;;332            if (pcb->acked > 0) {
002034  e1d426b4          LDRH     r2,[r4,#0x64]
002038  e3520000          CMP      r2,#0
;;;333              TCP_EVENT_SENT(pcb, pcb->acked, err);
00203c  1594307c          LDRNE    r3,[r4,#0x7c]
002040  13530000          CMPNE    r3,#0
002044  0a000004          BEQ      |L1.8284|
002048  e5940010          LDR      r0,[r4,#0x10]
00204c  e1a01004          MOV      r1,r4
002050  e12fff33          BLX      r3
;;;334              if (err == ERR_ABRT) {
002054  e370000a          CMN      r0,#0xa
002058  0a00003f          BEQ      |L1.8540|
                  |L1.8284|
;;;335                goto aborted;
;;;336              }
;;;337            }
;;;338    
;;;339            if (recv_data != NULL) {
00205c  e5960014          LDR      r0,[r6,#0x14]  ; recv_data
002060  e3500000          CMP      r0,#0
002064  0a000022          BEQ      |L1.8436|
;;;340              LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
002068  e5940078          LDR      r0,[r4,#0x78]
00206c  e3500000          CMP      r0,#0
002070  0a000004          BEQ      |L1.8328|
002074  e51f32e0          LDR      r3,|L1.7580|
002078  e51f02b8          LDR      r0,|L1.7624|
00207c  e3a02f55          MOV      r2,#0x154
002080  e28f1e21          ADR      r1,|L1.8856|
002084  ebfffffe          BL       sysprintf
                  |L1.8328|
;;;341              if (pcb->flags & TF_RXCLOSED) {
002088  e5d4001e          LDRB     r0,[r4,#0x1e]
00208c  e3100010          TST      r0,#0x10
002090  0a000004          BEQ      |L1.8360|
;;;342                /* received data although already closed -> abort (send RST) to
;;;343                   notify the remote host that not all data has been processed */
;;;344                pbuf_free(recv_data);
002094  e5960014          LDR      r0,[r6,#0x14]  ; recv_data
002098  ebfffffe          BL       pbuf_free
;;;345                tcp_abort(pcb);
00209c  e1a00004          MOV      r0,r4
0020a0  ebfffffe          BL       tcp_abort
;;;346                goto aborted;
0020a4  ea00002c          B        |L1.8540|
                  |L1.8360|
;;;347              }
;;;348    
;;;349              /* Notify application that data has been received. */
;;;350              TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
0020a8  e594c080          LDR      r12,[r4,#0x80]
0020ac  e35c0000          CMP      r12,#0
0020b0  0a000005          BEQ      |L1.8396|
0020b4  e5940010          LDR      r0,[r4,#0x10]
0020b8  e5962014          LDR      r2,[r6,#0x14]  ; recv_data
0020bc  e3a03000          MOV      r3,#0
0020c0  e1a01004          MOV      r1,r4
0020c4  e12fff3c          BLX      r12
0020c8  ea000004          B        |L1.8416|
                  |L1.8396|
0020cc  e3a03000          MOV      r3,#0
0020d0  e5962014          LDR      r2,[r6,#0x14]  ; recv_data
0020d4  e1a01004          MOV      r1,r4
0020d8  e1a00003          MOV      r0,r3
0020dc  ebfffffe          BL       tcp_recv_null
                  |L1.8416|
;;;351              if (err == ERR_ABRT) {
0020e0  e370000a          CMN      r0,#0xa
0020e4  0a00001c          BEQ      |L1.8540|
;;;352                goto aborted;
;;;353              }
;;;354    
;;;355              /* If the upper layer can't receive this data, store it */
;;;356              if (err != ERR_OK) {
0020e8  e3500000          CMP      r0,#0
;;;357                pcb->refused_data = recv_data;
0020ec  15960014          LDRNE    r0,[r6,#0x14]  ; recv_data
0020f0  15840078          STRNE    r0,[r4,#0x78]
                  |L1.8436|
;;;358                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
;;;359              }
;;;360            }
;;;361    
;;;362            /* If a FIN segment was received, we call the callback
;;;363               function with a NULL buffer to indicate EOF. */
;;;364            if (recv_flags & TF_GOT_FIN) {
0020f4  e5d60001          LDRB     r0,[r6,#1]  ; recv_flags
0020f8  e3100020          TST      r0,#0x20
0020fc  0a000013          BEQ      |L1.8528|
;;;365              if (pcb->refused_data != NULL) {
002100  e5940078          LDR      r0,[r4,#0x78]
002104  e3500000          CMP      r0,#0
;;;366                /* Delay this if we have refused data. */
;;;367                pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
002108  15d0100d          LDRBNE   r1,[r0,#0xd]
00210c  13811020          ORRNE    r1,r1,#0x20
002110  15c0100d          STRBNE   r1,[r0,#0xd]
002114  1a00000d          BNE      |L1.8528|
;;;368              } else {
;;;369                /* correct rcv_wnd as the application won't call tcp_recved()
;;;370                   for the FIN's seqno */
;;;371                if (pcb->rcv_wnd != TCP_WND) {
002118  e1d402bc          LDRH     r0,[r4,#0x2c]
00211c  e3500efa          CMP      r0,#0xfa0
002120  12800001          ADDNE    r0,r0,#1
;;;372                  pcb->rcv_wnd++;
002124  11c402bc          STRHNE   r0,[r4,#0x2c]
;;;373                }
;;;374                TCP_EVENT_CLOSED(pcb, err);
002128  e594c080          LDR      r12,[r4,#0x80]
00212c  e35c0000          CMP      r12,#0
002130  0a000006          BEQ      |L1.8528|
002134  e3a03000          MOV      r3,#0
002138  e5940010          LDR      r0,[r4,#0x10]
00213c  e1a02003          MOV      r2,r3
002140  e1a01004          MOV      r1,r4
002144  e12fff3c          BLX      r12
;;;375                if (err == ERR_ABRT) {
002148  e370000a          CMN      r0,#0xa
00214c  0a000002          BEQ      |L1.8540|
                  |L1.8528|
;;;376                  goto aborted;
;;;377                }
;;;378              }
;;;379            }
;;;380    
;;;381            tcp_input_pcb = NULL;
;;;382            /* Try to send something out. */
;;;383            tcp_output(pcb);
002150  e1a00004          MOV      r0,r4
002154  e5867018          STR      r7,[r6,#0x18]  ; tcp_input_pcb
002158  ebfffffe          BL       tcp_output
                  |L1.8540|
;;;384    #if TCP_INPUT_DEBUG
;;;385    #if TCP_DEBUG
;;;386            tcp_debug_print_state(pcb->state);
;;;387    #endif /* TCP_DEBUG */
;;;388    #endif /* TCP_INPUT_DEBUG */
;;;389          }
;;;390        }
;;;391        /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
;;;392           Below this line, 'pcb' may not be dereferenced! */
;;;393    aborted:
;;;394        tcp_input_pcb = NULL;
;;;395        recv_data = NULL;
00215c  e5867018          STR      r7,[r6,#0x18]  ; tcp_input_pcb
;;;396    
;;;397        /* give up our reference to inseg.p */
;;;398        if (inseg.p != NULL)
002160  e5867014          STR      r7,[r6,#0x14]  ; recv_data
002164  e5980004          LDR      r0,[r8,#4]  ; inseg
002168  e3500000          CMP      r0,#0
00216c  0a000001          BEQ      |L1.8568|
;;;399        {
;;;400          pbuf_free(inseg.p);
002170  ebfffffe          BL       pbuf_free
;;;401          inseg.p = NULL;
002174  e5887004          STR      r7,[r8,#4]  ; inseg
                  |L1.8568|
;;;402        }
;;;403      } else {
;;;404    
;;;405        /* If no matching PCB was found, send a TCP RST (reset) to the
;;;406           sender. */
;;;407        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
;;;408        if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
;;;409          TCP_STATS_INC(tcp.proterr);
;;;410          TCP_STATS_INC(tcp.drop);
;;;411          tcp_rst(ackno, seqno + tcplen,
;;;412            ip_current_dest_addr(), ip_current_src_addr(),
;;;413            tcphdr->dest, tcphdr->src);
;;;414        }
;;;415        pbuf_free(p);
;;;416      }
;;;417    
;;;418      LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;419      PERF_STOP("tcp_input");
;;;420      return;
;;;421    dropped:
;;;422      TCP_STATS_INC(tcp.drop);
;;;423      snmp_inc_tcpinerrs();
;;;424      pbuf_free(p);
;;;425    }
002178  e8bd87fc          POP      {r2-r10,pc}
                  |L1.8572|
00217c  e5d1000d          LDRB     r0,[r1,#0xd]          ;408
002180  e5d1100c          LDRB     r1,[r1,#0xc]          ;408
002184  e1810400          ORR      r0,r1,r0,LSL #8       ;408
002188  ebfffffe          BL       lwip_ntohs
00218c  e3100004          TST      r0,#4                 ;408
002190  1a00000e          BNE      |L1.8656|
002194  e5960004          LDR      r0,[r6,#4]            ;411  ; tcphdr
002198  e51f3b74          LDR      r3,|L1.5676|
00219c  e5d01001          LDRB     r1,[r0,#1]            ;411
0021a0  e5d02000          LDRB     r2,[r0,#0]            ;411
0021a4  e1821401          ORR      r1,r2,r1,LSL #8       ;411
0021a8  e5d02003          LDRB     r2,[r0,#3]            ;411
0021ac  e5d00002          LDRB     r0,[r0,#2]            ;411
0021b0  e1800402          ORR      r0,r0,r2,LSL #8       ;411
0021b4  e1cd00f0          STRD     r0,r1,[sp,#0]         ;411
0021b8  e1d610b2          LDRH     r1,[r6,#2]            ;411  ; tcplen
0021bc  e596000c          LDR      r0,[r6,#0xc]          ;411  ; seqno
0021c0  e51f2b98          LDR      r2,|L1.5680|
0021c4  e0811000          ADD      r1,r1,r0              ;411
0021c8  e5960010          LDR      r0,[r6,#0x10]         ;411  ; ackno
0021cc  ebfffffe          BL       tcp_rst
                  |L1.8656|
0021d0  e1a00005          MOV      r0,r5                 ;424
0021d4  ebfffffe          BL       pbuf_free
0021d8  e8bd87fc          POP      {r2-r10,pc}
;;;426    
                          ENDP

                  tcp_timewait_input PROC
;;;528    static err_t
;;;529    tcp_timewait_input(struct tcp_pcb *pcb)
0021dc  e92d401c          PUSH     {r2-r4,lr}
;;;530    {
;;;531      /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
;;;532      /* RFC 793 3.9 Event Processing - Segment Arrives:
;;;533       * - first check sequence number - we skip that one in TIME_WAIT (always
;;;534       *   acceptable since we only send ACKs)
;;;535       * - second check the RST bit (... return) */
;;;536      if (flags & TCP_RST)  {
0021e0  e51fc450          LDR      r12,|L1.7576|
0021e4  e5dc2000          LDRB     r2,[r12,#0]  ; flags
0021e8  e3120004          TST      r2,#4
0021ec  1a000025          BNE      |L1.8840|
0021f0  e28c1000          ADD      r1,r12,#0
;;;537        return ERR_OK;
;;;538      }
;;;539      /* - fourth, check the SYN bit, */
;;;540      if (flags & TCP_SYN) {
;;;541        /* If an incoming segment is not acceptable, an acknowledgment
;;;542           should be sent in reply */
;;;543        if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;544          /* If the SYN is in the window it is an error, send a reset */
;;;545          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
0021f4  e1d110b2          LDRH     r1,[r1,#2]
0021f8  e3120002          TST      r2,#2                 ;540
0021fc  0a000016          BEQ      |L1.8796|
002200  e5903028          LDR      r3,[r0,#0x28]         ;543
002204  e59c200c          LDR      r2,[r12,#0xc]         ;543  ; seqno
002208  e0524003          SUBS     r4,r2,r3              ;543
00220c  4a000016          BMI      |L1.8812|
002210  e1d042bc          LDRH     r4,[r0,#0x2c]         ;543
002214  e0833004          ADD      r3,r3,r4              ;543
002218  e0423003          SUB      r3,r2,r3              ;543
00221c  e3530000          CMP      r3,#0                 ;543
002220  ca000011          BGT      |L1.8812|
002224  e59c0004          LDR      r0,[r12,#4]  ; tcphdr
002228  e0811002          ADD      r1,r1,r2
00222c  e5d03001          LDRB     r3,[r0,#1]
002230  e5d04000          LDRB     r4,[r0,#0]
002234  e51f2c0c          LDR      r2,|L1.5680|
002238  e1843403          ORR      r3,r4,r3,LSL #8
00223c  e5d04003          LDRB     r4,[r0,#3]
002240  e5d00002          LDRB     r0,[r0,#2]
002244  e1800404          ORR      r0,r0,r4,LSL #8
002248  e88d0009          STM      sp,{r0,r3}
00224c  e51f3c28          LDR      r3,|L1.5676|
002250  e59c0010          LDR      r0,[r12,#0x10]  ; ackno
002254  ebfffffe          BL       tcp_rst
;;;546            tcphdr->dest, tcphdr->src);
;;;547          return ERR_OK;
002258  ea00000a          B        |L1.8840|
                  |L1.8796|
;;;548        }
;;;549      } else if (flags & TCP_FIN) {
00225c  e3120001          TST      r2,#1
;;;550        /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
;;;551             Restart the 2 MSL time-wait timeout.*/
;;;552        pcb->tmr = tcp_ticks;
002260  159f204c          LDRNE    r2,|L1.8884|
002264  15922000          LDRNE    r2,[r2,#0]  ; tcp_ticks
002268  15802024          STRNE    r2,[r0,#0x24]
                  |L1.8812|
;;;553      }
;;;554    
;;;555      if ((tcplen > 0))  {
00226c  e3510000          CMP      r1,#0
002270  0a000004          BEQ      |L1.8840|
;;;556        /* Acknowledge data, FIN or out-of-window SYN */
;;;557        pcb->flags |= TF_ACK_NOW;
002274  e5d0101e          LDRB     r1,[r0,#0x1e]
002278  e3811002          ORR      r1,r1,#2
00227c  e5c0101e          STRB     r1,[r0,#0x1e]
;;;558        return tcp_output(pcb);
002280  ebfffffe          BL       tcp_output
;;;559      }
;;;560      return ERR_OK;
;;;561    }
002284  e8bd801c          POP      {r2-r4,pc}
                  |L1.8840|
002288  e3a00000          MOV      r0,#0                 ;560
00228c  e8bd801c          POP      {r2-r4,pc}
                  |L1.8848|
                          DCD      tcp_listen_pcbs
                  |L1.8852|
                          DCD      ||.bss||
                  |L1.8856|
002298  7063622d          DCB      "pcb->refused_data == NULL",0
00229c  3e726566
0022a0  75736564
0022a4  5f646174
0022a8  61203d3d
0022ac  204e554c
0022b0  4c00    
0022b2  00                DCB      0
0022b3  00                DCB      0
                  |L1.8884|
                          DCD      tcp_ticks
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  inseg
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  flags
000000  00                DCB      0x00
                  recv_flags
000001  00                DCB      0x00
                  tcplen
000002  0000              DCB      0x00,0x00
                  tcphdr
                          DCD      0x00000000
                  iphdr
                          DCD      0x00000000
                  seqno
                          DCD      0x00000000
                  ackno
                          DCD      0x00000000
                  recv_data
                          DCD      0x00000000
                  tcp_input_pcb
                          DCD      0x00000000
