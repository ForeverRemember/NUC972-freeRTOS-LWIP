; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tcp_in.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tcp_in.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\tcp_in.crf lwip-1.4.1\src\core\tcp_in.c]
                          ARM

                          AREA ||i.tcp_input||, CODE, READONLY, ALIGN=2

                  tcp_input PROC
;;;91     void
;;;92     tcp_input(struct pbuf *p, struct netif *inp)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;93     {
000004  e1a06000          MOV      r6,r0
000008  e1a0a001          MOV      r10,r1
;;;94       struct tcp_pcb *pcb, *prev;
;;;95       struct tcp_pcb_listen *lpcb;
;;;96     #if SO_REUSE
;;;97       struct tcp_pcb *lpcb_prev = NULL;
;;;98       struct tcp_pcb_listen *lpcb_any = NULL;
;;;99     #endif /* SO_REUSE */
;;;100      u8_t hdrlen;
;;;101      err_t err;
;;;102    
;;;103      PERF_START;
;;;104    
;;;105      TCP_STATS_INC(tcp.recv);
;;;106      snmp_inc_tcpinsegs();
;;;107    
;;;108      iphdr = (struct ip_hdr *)p->payload;
00000c  e59f13c0          LDR      r1,|L1.980|
000010  e5960004          LDR      r0,[r6,#4]
000014  e5810000          STR      r0,[r1,#0]  ; iphdr
;;;109      tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
000018  e2810000          ADD      r0,r1,#0
00001c  e5961004          LDR      r1,[r6,#4]
000020  e5900000          LDR      r0,[r0,#0]  ; iphdr
000024  e5d00000          LDRB     r0,[r0,#0]
000028  e200000f          AND      r0,r0,#0xf
00002c  e0810100          ADD      r0,r1,r0,LSL #2
000030  e59f13a0          LDR      r1,|L1.984|
000034  e5810000          STR      r0,[r1,#0]  ; tcphdr
;;;110    
;;;111    #if TCP_INPUT_DEBUG
;;;112      tcp_debug_print(tcphdr);
;;;113    #endif
;;;114    
;;;115      /* remove header from payload */
;;;116      if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
000038  e59f0394          LDR      r0,|L1.980|
00003c  e5900000          LDR      r0,[r0,#0]  ; iphdr
000040  e5d00000          LDRB     r0,[r0,#0]
000044  e1a00e00          LSL      r0,r0,#28
000048  e1a00d20          LSR      r0,r0,#26
00004c  e2601000          RSB      r1,r0,#0
000050  e1a00006          MOV      r0,r6
000054  ebfffffe          BL       pbuf_header
000058  e3500000          CMP      r0,#0
00005c  1a000002          BNE      |L1.108|
000060  e1d600b8          LDRH     r0,[r6,#8]
000064  e3500014          CMP      r0,#0x14
000068  2a000000          BCS      |L1.112|
                  |L1.108|
;;;117        /* drop short packets */
;;;118        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
;;;119        TCP_STATS_INC(tcp.lenerr);
;;;120        goto dropped;
00006c  ea0002a6          B        |L1.2828|
                  |L1.112|
;;;121      }
;;;122    
;;;123      /* Don't even process incoming broadcasts/multicasts. */
;;;124      if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
000070  e59f1364          LDR      r1,|L1.988|
000074  e5910000          LDR      r0,[r1,#0]  ; current_iphdr_dest
000078  e1a0100a          MOV      r1,r10
00007c  ebfffffe          BL       ip4_addr_isbroadcast
000080  e3500000          CMP      r0,#0
000084  1a000004          BNE      |L1.156|
;;;125          ip_addr_ismulticast(&current_iphdr_dest)) {
000088  e59f034c          LDR      r0,|L1.988|
00008c  e5d00000          LDRB     r0,[r0,#0]  ; current_iphdr_dest
000090  e20000f0          AND      r0,r0,#0xf0
000094  e35000e0          CMP      r0,#0xe0
000098  1a000000          BNE      |L1.160|
                  |L1.156|
;;;126        TCP_STATS_INC(tcp.proterr);
;;;127        goto dropped;
00009c  ea00029a          B        |L1.2828|
                  |L1.160|
;;;128      }
;;;129    
;;;130    #if CHECKSUM_CHECK_TCP
;;;131      /* Verify TCP checksum. */
;;;132      if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
0000a0  e1d600b8          LDRH     r0,[r6,#8]
0000a4  e3a03006          MOV      r3,#6
0000a8  e59f232c          LDR      r2,|L1.988|
0000ac  e59f132c          LDR      r1,|L1.992|
0000b0  e58d0000          STR      r0,[sp,#0]
0000b4  e1a00006          MOV      r0,r6
0000b8  ebfffffe          BL       inet_chksum_pseudo
0000bc  e3500000          CMP      r0,#0
0000c0  0a000000          BEQ      |L1.200|
;;;133          IP_PROTO_TCP, p->tot_len) != 0) {
;;;134          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
;;;135            inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;136          IP_PROTO_TCP, p->tot_len)));
;;;137    #if TCP_DEBUG
;;;138        tcp_debug_print(tcphdr);
;;;139    #endif /* TCP_DEBUG */
;;;140        TCP_STATS_INC(tcp.chkerr);
;;;141        goto dropped;
0000c4  ea000290          B        |L1.2828|
                  |L1.200|
;;;142      }
;;;143    #endif
;;;144    
;;;145      /* Move the payload pointer in the pbuf so that it points to the
;;;146         TCP data instead of the TCP header. */
;;;147      hdrlen = TCPH_HDRLEN(tcphdr);
0000c8  e59f1308          LDR      r1,|L1.984|
0000cc  e5912000          LDR      r2,[r1,#0]  ; tcphdr
0000d0  e5d2100d          LDRB     r1,[r2,#0xd]
0000d4  e5d2200c          LDRB     r2,[r2,#0xc]
0000d8  e1820401          ORR      r0,r2,r1,LSL #8
0000dc  ebfffffe          BL       lwip_ntohs
0000e0  e1a09640          ASR      r9,r0,#12
;;;148      if(pbuf_header(p, -(hdrlen * 4))){
0000e4  e1a00109          LSL      r0,r9,#2
0000e8  e2601000          RSB      r1,r0,#0
0000ec  e1a00006          MOV      r0,r6
0000f0  ebfffffe          BL       pbuf_header
0000f4  e3500000          CMP      r0,#0
0000f8  0a000000          BEQ      |L1.256|
;;;149        /* drop short packets */
;;;150        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
;;;151        TCP_STATS_INC(tcp.lenerr);
;;;152        goto dropped;
0000fc  ea000282          B        |L1.2828|
                  |L1.256|
;;;153      }
;;;154    
;;;155      /* Convert fields in TCP header to host byte order. */
;;;156      tcphdr->src = ntohs(tcphdr->src);
000100  e59f12d0          LDR      r1,|L1.984|
000104  e5912000          LDR      r2,[r1,#0]  ; tcphdr
000108  e5d21001          LDRB     r1,[r2,#1]
00010c  e5d22000          LDRB     r2,[r2,#0]
000110  e1820401          ORR      r0,r2,r1,LSL #8
000114  ebfffffe          BL       lwip_ntohs
000118  e59f12b8          LDR      r1,|L1.984|
00011c  e5911000          LDR      r1,[r1,#0]  ; tcphdr
000120  e5c10000          STRB     r0,[r1,#0]
000124  e1a00420          LSR      r0,r0,#8
000128  e5c10001          STRB     r0,[r1,#1]
;;;157      tcphdr->dest = ntohs(tcphdr->dest);
00012c  e59f12a4          LDR      r1,|L1.984|
000130  e5912000          LDR      r2,[r1,#0]  ; tcphdr
000134  e5d21003          LDRB     r1,[r2,#3]
000138  e5d22002          LDRB     r2,[r2,#2]
00013c  e1820401          ORR      r0,r2,r1,LSL #8
000140  ebfffffe          BL       lwip_ntohs
000144  e59f128c          LDR      r1,|L1.984|
000148  e5911000          LDR      r1,[r1,#0]  ; tcphdr
00014c  e5c10002          STRB     r0,[r1,#2]
000150  e1a00420          LSR      r0,r0,#8
000154  e5c10003          STRB     r0,[r1,#3]
;;;158      seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
000158  e59f0278          LDR      r0,|L1.984|
00015c  e5900000          LDR      r0,[r0,#0]  ; tcphdr
000160  e2800004          ADD      r0,r0,#4
000164  ebfffffe          BL       __aeabi_uread4
000168  e58d0004          STR      r0,[sp,#4]
00016c  ebfffffe          BL       lwip_ntohl
000170  e1a0b000          MOV      r11,r0
000174  e59f025c          LDR      r0,|L1.984|
000178  e5900000          LDR      r0,[r0,#0]  ; tcphdr
00017c  e2801004          ADD      r1,r0,#4
000180  e1a0000b          MOV      r0,r11
000184  ebfffffe          BL       __aeabi_uwrite4
000188  e59f1254          LDR      r1,|L1.996|
00018c  e5810000          STR      r0,[r1,#0]  ; seqno
;;;159      ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
000190  e59f0240          LDR      r0,|L1.984|
000194  e5900000          LDR      r0,[r0,#0]  ; tcphdr
000198  e2800008          ADD      r0,r0,#8
00019c  ebfffffe          BL       __aeabi_uread4
0001a0  e58d0004          STR      r0,[sp,#4]
0001a4  ebfffffe          BL       lwip_ntohl
0001a8  e1a0b000          MOV      r11,r0
0001ac  e59f0224          LDR      r0,|L1.984|
0001b0  e5900000          LDR      r0,[r0,#0]  ; tcphdr
0001b4  e2801008          ADD      r1,r0,#8
0001b8  e1a0000b          MOV      r0,r11
0001bc  ebfffffe          BL       __aeabi_uwrite4
0001c0  e59f1220          LDR      r1,|L1.1000|
0001c4  e5810000          STR      r0,[r1,#0]  ; ackno
;;;160      tcphdr->wnd = ntohs(tcphdr->wnd);
0001c8  e59f1208          LDR      r1,|L1.984|
0001cc  e5912000          LDR      r2,[r1,#0]  ; tcphdr
0001d0  e5d2100f          LDRB     r1,[r2,#0xf]
0001d4  e5d2200e          LDRB     r2,[r2,#0xe]
0001d8  e1820401          ORR      r0,r2,r1,LSL #8
0001dc  ebfffffe          BL       lwip_ntohs
0001e0  e59f11f0          LDR      r1,|L1.984|
0001e4  e5911000          LDR      r1,[r1,#0]  ; tcphdr
0001e8  e5c1000e          STRB     r0,[r1,#0xe]
0001ec  e1a00420          LSR      r0,r0,#8
0001f0  e5c1000f          STRB     r0,[r1,#0xf]
;;;161    
;;;162      flags = TCPH_FLAGS(tcphdr);
0001f4  e59f11dc          LDR      r1,|L1.984|
0001f8  e5912000          LDR      r2,[r1,#0]  ; tcphdr
0001fc  e5d2100d          LDRB     r1,[r2,#0xd]
000200  e5d2200c          LDRB     r2,[r2,#0xc]
000204  e1820401          ORR      r0,r2,r1,LSL #8
000208  ebfffffe          BL       lwip_ntohs
00020c  e200003f          AND      r0,r0,#0x3f
000210  e59f11d4          LDR      r1,|L1.1004|
000214  e5c10000          STRB     r0,[r1,#0]  ; flags
;;;163      tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
000218  e1d600b8          LDRH     r0,[r6,#8]
00021c  e5d11000          LDRB     r1,[r1,#0]  ; flags
000220  e2011003          AND      r1,r1,#3
000224  e3510000          CMP      r1,#0
000228  0a000001          BEQ      |L1.564|
00022c  e3a01001          MOV      r1,#1
000230  ea000000          B        |L1.568|
                  |L1.564|
000234  e3a01000          MOV      r1,#0
                  |L1.568|
000238  e0800001          ADD      r0,r0,r1
00023c  e59f11ac          LDR      r1,|L1.1008|
000240  e1c100b0          STRH     r0,[r1,#0]  ; tcplen
;;;164    
;;;165      /* Demultiplex an incoming segment. First, we check if it is destined
;;;166         for an active connection. */
;;;167      prev = NULL;
000244  e3a07000          MOV      r7,#0
;;;168    
;;;169      
;;;170      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000248  e59f01a4          LDR      r0,|L1.1012|
00024c  e5904000          LDR      r4,[r0,#0]  ; tcp_active_pcbs
000250  ea0000b1          B        |L1.1308|
                  |L1.596|
;;;171        LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
000254  e1a00000          MOV      r0,r0
000258  e5d40018          LDRB     r0,[r4,#0x18]
00025c  e3500000          CMP      r0,#0
000260  1a000006          BNE      |L1.640|
000264  e1a00000          MOV      r0,r0
000268  e28f3f62          ADR      r3,|L1.1016|
00026c  e3a020ab          MOV      r2,#0xab
000270  e28f1e1a          ADR      r1,|L1.1048|
000274  e28f0f71          ADR      r0,|L1.1088|
000278  ebfffffe          BL       sysprintf
00027c  e1a00000          MOV      r0,r0
                  |L1.640|
000280  e1a00000          MOV      r0,r0
;;;172        LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
000284  e1a00000          MOV      r0,r0
000288  e5d40018          LDRB     r0,[r4,#0x18]
00028c  e350000a          CMP      r0,#0xa
000290  1a000006          BNE      |L1.688|
000294  e1a00000          MOV      r0,r0
000298  e28f3f56          ADR      r3,|L1.1016|
00029c  e3a020ac          MOV      r2,#0xac
0002a0  e28f1d07          ADR      r1,|L1.1128|
0002a4  e28f0f65          ADR      r0,|L1.1088|
0002a8  ebfffffe          BL       sysprintf
0002ac  e1a00000          MOV      r0,r0
                  |L1.688|
0002b0  e1a00000          MOV      r0,r0
;;;173        LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
0002b4  e1a00000          MOV      r0,r0
0002b8  e5d40018          LDRB     r0,[r4,#0x18]
0002bc  e3500001          CMP      r0,#1
0002c0  1a000006          BNE      |L1.736|
0002c4  e1a00000          MOV      r0,r0
0002c8  e28f3f4a          ADR      r3,|L1.1016|
0002cc  e3a020ad          MOV      r2,#0xad
0002d0  e28f1f6f          ADR      r1,|L1.1172|
0002d4  e28f0f59          ADR      r0,|L1.1088|
0002d8  ebfffffe          BL       sysprintf
0002dc  e1a00000          MOV      r0,r0
                  |L1.736|
0002e0  e1a00000          MOV      r0,r0
;;;174        if (pcb->remote_port == tcphdr->src &&
0002e4  e1d401bc          LDRH     r0,[r4,#0x1c]
0002e8  e59f10e8          LDR      r1,|L1.984|
0002ec  e5911000          LDR      r1,[r1,#0]  ; tcphdr
0002f0  e5d12001          LDRB     r2,[r1,#1]
0002f4  e5d11000          LDRB     r1,[r1,#0]
0002f8  e1811402          ORR      r1,r1,r2,LSL #8
0002fc  e1500001          CMP      r0,r1
000300  1a000083          BNE      |L1.1300|
;;;175           pcb->local_port == tcphdr->dest &&
000304  e1d401ba          LDRH     r0,[r4,#0x1a]
000308  e59f10c8          LDR      r1,|L1.984|
00030c  e5912000          LDR      r2,[r1,#0]  ; tcphdr
000310  e5d21003          LDRB     r1,[r2,#3]
000314  e5d22002          LDRB     r2,[r2,#2]
000318  e1821401          ORR      r1,r2,r1,LSL #8
00031c  e1500001          CMP      r0,r1
000320  1a00007b          BNE      |L1.1300|
;;;176           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
000324  e59f10b4          LDR      r1,|L1.992|
000328  e5940004          LDR      r0,[r4,#4]
00032c  e5911000          LDR      r1,[r1,#0]  ; current_iphdr_src
000330  e1500001          CMP      r0,r1
000334  1a000076          BNE      |L1.1300|
;;;177           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
000338  e59f109c          LDR      r1,|L1.988|
00033c  e5940000          LDR      r0,[r4,#0]
000340  e5911000          LDR      r1,[r1,#0]  ; current_iphdr_dest
000344  e1500001          CMP      r0,r1
000348  1a000071          BNE      |L1.1300|
;;;178    
;;;179          /* Move this PCB to the front of the list so that subsequent
;;;180             lookups will be faster (we exploit locality in TCP segment
;;;181             arrivals). */
;;;182          LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
00034c  e1a00000          MOV      r0,r0
000350  e594000c          LDR      r0,[r4,#0xc]
000354  e1500004          CMP      r0,r4
000358  1a000006          BNE      |L1.888|
00035c  e1a00000          MOV      r0,r0
000360  e28f3090          ADR      r3,|L1.1016|
000364  e3a020b6          MOV      r2,#0xb6
000368  e28f1f53          ADR      r1,|L1.1212|
00036c  e28f00cc          ADR      r0,|L1.1088|
000370  ebfffffe          BL       sysprintf
000374  e1a00000          MOV      r0,r0
                  |L1.888|
000378  e1a00000          MOV      r0,r0
;;;183          if (prev != NULL) {
00037c  e3570000          CMP      r7,#0
000380  0a000006          BEQ      |L1.928|
;;;184            prev->next = pcb->next;
000384  e594000c          LDR      r0,[r4,#0xc]
000388  e587000c          STR      r0,[r7,#0xc]
;;;185            pcb->next = tcp_active_pcbs;
00038c  e59f0060          LDR      r0,|L1.1012|
000390  e5900000          LDR      r0,[r0,#0]  ; tcp_active_pcbs
000394  e584000c          STR      r0,[r4,#0xc]
;;;186            tcp_active_pcbs = pcb;
000398  e59f0054          LDR      r0,|L1.1012|
00039c  e5804000          STR      r4,[r0,#0]  ; tcp_active_pcbs
                  |L1.928|
;;;187          }
;;;188          LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
0003a0  e1a00000          MOV      r0,r0
0003a4  e594000c          LDR      r0,[r4,#0xc]
0003a8  e1500004          CMP      r0,r4
0003ac  1a000006          BNE      |L1.972|
0003b0  e1a00000          MOV      r0,r0
0003b4  e28f303c          ADR      r3,|L1.1016|
0003b8  e3a020bc          MOV      r2,#0xbc
0003bc  e28f1f49          ADR      r1,|L1.1256|
0003c0  e28f0078          ADR      r0,|L1.1088|
0003c4  ebfffffe          BL       sysprintf
0003c8  e1a00000          MOV      r0,r0
                  |L1.972|
0003cc  e1a00000          MOV      r0,r0
;;;189          break;
0003d0  ea000053          B        |L1.1316|
                  |L1.980|
                          DCD      iphdr
                  |L1.984|
                          DCD      tcphdr
                  |L1.988|
                          DCD      current_iphdr_dest
                  |L1.992|
                          DCD      current_iphdr_src
                  |L1.996|
                          DCD      seqno
                  |L1.1000|
                          DCD      ackno
                  |L1.1004|
                          DCD      flags
                  |L1.1008|
                          DCD      tcplen
                  |L1.1012|
                          DCD      tcp_active_pcbs
                  |L1.1016|
0003f8  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_in.c",0
0003fc  2d312e34
000400  2e315c73
000404  72635c63
000408  6f72655c
00040c  7463705f
000410  696e2e63
000414  00      
000415  00                DCB      0
000416  00                DCB      0
000417  00                DCB      0
                  |L1.1048|
000418  7463705f          DCB      "tcp_input: active pcb->state != CLOSED",0
00041c  696e7075
000420  743a2061
000424  63746976
000428  65207063
00042c  622d3e73
000430  74617465
000434  20213d20
000438  434c4f53
00043c  454400  
00043f  00                DCB      0
                  |L1.1088|
000440  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000444  7274696f
000448  6e202225
00044c  73222066
000450  61696c65
000454  64206174
000458  206c696e
00045c  65202564
000460  20696e20
000464  25730a00
                  |L1.1128|
000468  7463705f          DCB      "tcp_input: active pcb->state != TIME-WAIT",0
00046c  696e7075
000470  743a2061
000474  63746976
000478  65207063
00047c  622d3e73
000480  74617465
000484  20213d20
000488  54494d45
00048c  2d574149
000490  5400    
000492  00                DCB      0
000493  00                DCB      0
                  |L1.1172|
000494  7463705f          DCB      "tcp_input: active pcb->state != LISTEN",0
000498  696e7075
00049c  743a2061
0004a0  63746976
0004a4  65207063
0004a8  622d3e73
0004ac  74617465
0004b0  20213d20
0004b4  4c495354
0004b8  454e00  
0004bb  00                DCB      0
                  |L1.1212|
0004bc  7463705f          DCB      "tcp_input: pcb->next != pcb (before cache)",0
0004c0  696e7075
0004c4  743a2070
0004c8  63622d3e
0004cc  6e657874
0004d0  20213d20
0004d4  70636220
0004d8  28626566
0004dc  6f726520
0004e0  63616368
0004e4  652900  
0004e7  00                DCB      0
                  |L1.1256|
0004e8  7463705f          DCB      "tcp_input: pcb->next != pcb (after cache)",0
0004ec  696e7075
0004f0  743a2070
0004f4  63622d3e
0004f8  6e657874
0004fc  20213d20
000500  70636220
000504  28616674
000508  65722063
00050c  61636865
000510  2900    
000512  00                DCB      0
000513  00                DCB      0
                  |L1.1300|
;;;190        }
;;;191        prev = pcb;
000514  e1a07004          MOV      r7,r4
000518  e594400c          LDR      r4,[r4,#0xc]          ;170
                  |L1.1308|
00051c  e3540000          CMP      r4,#0                 ;170
000520  1affff4b          BNE      |L1.596|
                  |L1.1316|
000524  e1a00000          MOV      r0,r0                 ;189
;;;192      }
;;;193    
;;;194      if (pcb == NULL) {
000528  e3540000          CMP      r4,#0
00052c  1a00005c          BNE      |L1.1700|
;;;195        /* If it did not go to an active connection, we check the connections
;;;196           in the TIME-WAIT state. */
;;;197        for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
000530  e59f031c          LDR      r0,|L1.2132|
000534  e5904000          LDR      r4,[r0,#0]  ; tcp_tw_pcbs
000538  ea00002b          B        |L1.1516|
                  |L1.1340|
;;;198          LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
00053c  e1a00000          MOV      r0,r0
000540  e5d40018          LDRB     r0,[r4,#0x18]
000544  e350000a          CMP      r0,#0xa
000548  0a000006          BEQ      |L1.1384|
00054c  e1a00000          MOV      r0,r0
000550  e24f3e16          ADR      r3,|L1.1016|
000554  e3a020c6          MOV      r2,#0xc6
000558  e28f1fbe          ADR      r1,|L1.2136|
00055c  e24f0f49          ADR      r0,|L1.1088|
000560  ebfffffe          BL       sysprintf
000564  e1a00000          MOV      r0,r0
                  |L1.1384|
000568  e1a00000          MOV      r0,r0
;;;199          if (pcb->remote_port == tcphdr->src &&
00056c  e1d401bc          LDRH     r0,[r4,#0x1c]
000570  e51f11a0          LDR      r1,|L1.984|
000574  e5911000          LDR      r1,[r1,#0]  ; tcphdr
000578  e5d12001          LDRB     r2,[r1,#1]
00057c  e5d11000          LDRB     r1,[r1,#0]
000580  e1811402          ORR      r1,r1,r2,LSL #8
000584  e1500001          CMP      r0,r1
000588  1a000016          BNE      |L1.1512|
;;;200             pcb->local_port == tcphdr->dest &&
00058c  e1d401ba          LDRH     r0,[r4,#0x1a]
000590  e51f11c0          LDR      r1,|L1.984|
000594  e5912000          LDR      r2,[r1,#0]  ; tcphdr
000598  e5d21003          LDRB     r1,[r2,#3]
00059c  e5d22002          LDRB     r2,[r2,#2]
0005a0  e1821401          ORR      r1,r2,r1,LSL #8
0005a4  e1500001          CMP      r0,r1
0005a8  1a00000e          BNE      |L1.1512|
;;;201             ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
0005ac  e51f11d4          LDR      r1,|L1.992|
0005b0  e5940004          LDR      r0,[r4,#4]
0005b4  e5911000          LDR      r1,[r1,#0]  ; current_iphdr_src
0005b8  e1500001          CMP      r0,r1
0005bc  1a000009          BNE      |L1.1512|
;;;202             ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
0005c0  e51f11ec          LDR      r1,|L1.988|
0005c4  e5940000          LDR      r0,[r4,#0]
0005c8  e5911000          LDR      r1,[r1,#0]  ; current_iphdr_dest
0005cc  e1500001          CMP      r0,r1
0005d0  1a000004          BNE      |L1.1512|
;;;203            /* We don't really care enough to move this PCB to the front
;;;204               of the list since we are not very likely to receive that
;;;205               many segments for connections in TIME-WAIT. */
;;;206            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
;;;207            tcp_timewait_input(pcb);
0005d4  e1a00004          MOV      r0,r4
0005d8  ebfffffe          BL       tcp_timewait_input
;;;208            pbuf_free(p);
0005dc  e1a00006          MOV      r0,r6
0005e0  ebfffffe          BL       pbuf_free
                  |L1.1508|
;;;209            return;
;;;210          }
;;;211        }
;;;212    
;;;213        /* Finally, if we still did not get a match, we check all PCBs that
;;;214           are LISTENing for incoming connections. */
;;;215        prev = NULL;
;;;216        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;217          if (lpcb->local_port == tcphdr->dest) {
;;;218    #if SO_REUSE
;;;219            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
;;;220              /* found an exact match */
;;;221              break;
;;;222            } else if(ip_addr_isany(&(lpcb->local_ip))) {
;;;223              /* found an ANY-match */
;;;224              lpcb_any = lpcb;
;;;225              lpcb_prev = prev;
;;;226            }
;;;227    #else /* SO_REUSE */
;;;228            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
;;;229                ip_addr_isany(&(lpcb->local_ip))) {
;;;230              /* found a match */
;;;231              break;
;;;232            }
;;;233    #endif /* SO_REUSE */
;;;234          }
;;;235          prev = (struct tcp_pcb *)lpcb;
;;;236        }
;;;237    #if SO_REUSE
;;;238        /* first try specific local IP */
;;;239        if (lpcb == NULL) {
;;;240          /* only pass to ANY if no specific local IP has been found */
;;;241          lpcb = lpcb_any;
;;;242          prev = lpcb_prev;
;;;243        }
;;;244    #endif /* SO_REUSE */
;;;245        if (lpcb != NULL) {
;;;246          /* Move this PCB to the front of the list so that subsequent
;;;247             lookups will be faster (we exploit locality in TCP segment
;;;248             arrivals). */
;;;249          if (prev != NULL) {
;;;250            ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
;;;251                  /* our successor is the remainder of the listening list */
;;;252            lpcb->next = tcp_listen_pcbs.listen_pcbs;
;;;253                  /* put this listening pcb at the head of the listening list */
;;;254            tcp_listen_pcbs.listen_pcbs = lpcb;
;;;255          }
;;;256        
;;;257          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
;;;258          tcp_listen_input(lpcb);
;;;259          pbuf_free(p);
;;;260          return;
;;;261        }
;;;262      }
;;;263    
;;;264    #if TCP_INPUT_DEBUG
;;;265      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
;;;266      tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
;;;267      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
;;;268    #endif /* TCP_INPUT_DEBUG */
;;;269    
;;;270    
;;;271      if (pcb != NULL) {
;;;272        /* The incoming segment belongs to a connection. */
;;;273    #if TCP_INPUT_DEBUG
;;;274    #if TCP_DEBUG
;;;275        tcp_debug_print_state(pcb->state);
;;;276    #endif /* TCP_DEBUG */
;;;277    #endif /* TCP_INPUT_DEBUG */
;;;278    
;;;279        /* Set up a tcp_seg structure. */
;;;280        inseg.next = NULL;
;;;281        inseg.len = p->tot_len;
;;;282        inseg.p = p;
;;;283        inseg.tcphdr = tcphdr;
;;;284    
;;;285        recv_data = NULL;
;;;286        recv_flags = 0;
;;;287    
;;;288        if (flags & TCP_PSH) {
;;;289          p->flags |= PBUF_FLAG_PUSH;
;;;290        }
;;;291    
;;;292        /* If there is data which was previously "refused" by upper layer */
;;;293        if (pcb->refused_data != NULL) {
;;;294          if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
;;;295            ((pcb->refused_data != NULL) && (tcplen > 0))) {
;;;296            /* pcb has been aborted or refused data is still refused and the new
;;;297               segment contains data */
;;;298            TCP_STATS_INC(tcp.drop);
;;;299            snmp_inc_tcpinerrs();
;;;300            goto aborted;
;;;301          }
;;;302        }
;;;303        tcp_input_pcb = pcb;
;;;304        err = tcp_process(pcb);
;;;305        /* A return value of ERR_ABRT means that tcp_abort() was called
;;;306           and that the pcb has been freed. If so, we don't do anything. */
;;;307        if (err != ERR_ABRT) {
;;;308          if (recv_flags & TF_RESET) {
;;;309            /* TF_RESET means that the connection was reset by the other
;;;310               end. We then call the error callback to inform the
;;;311               application that the connection is dead before we
;;;312               deallocate the PCB. */
;;;313            TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
;;;314            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;315            memp_free(MEMP_TCP_PCB, pcb);
;;;316          } else if (recv_flags & TF_CLOSED) {
;;;317            /* The connection has been closed and we will deallocate the
;;;318               PCB. */
;;;319            if (!(pcb->flags & TF_RXCLOSED)) {
;;;320              /* Connection closed although the application has only shut down the
;;;321                 tx side: call the PCB's err callback and indicate the closure to
;;;322                 ensure the application doesn't continue using the PCB. */
;;;323              TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
;;;324            }
;;;325            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;326            memp_free(MEMP_TCP_PCB, pcb);
;;;327          } else {
;;;328            err = ERR_OK;
;;;329            /* If the application has registered a "sent" function to be
;;;330               called when new send buffer space is available, we call it
;;;331               now. */
;;;332            if (pcb->acked > 0) {
;;;333              TCP_EVENT_SENT(pcb, pcb->acked, err);
;;;334              if (err == ERR_ABRT) {
;;;335                goto aborted;
;;;336              }
;;;337            }
;;;338    
;;;339            if (recv_data != NULL) {
;;;340              LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
;;;341              if (pcb->flags & TF_RXCLOSED) {
;;;342                /* received data although already closed -> abort (send RST) to
;;;343                   notify the remote host that not all data has been processed */
;;;344                pbuf_free(recv_data);
;;;345                tcp_abort(pcb);
;;;346                goto aborted;
;;;347              }
;;;348    
;;;349              /* Notify application that data has been received. */
;;;350              TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
;;;351              if (err == ERR_ABRT) {
;;;352                goto aborted;
;;;353              }
;;;354    
;;;355              /* If the upper layer can't receive this data, store it */
;;;356              if (err != ERR_OK) {
;;;357                pcb->refused_data = recv_data;
;;;358                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
;;;359              }
;;;360            }
;;;361    
;;;362            /* If a FIN segment was received, we call the callback
;;;363               function with a NULL buffer to indicate EOF. */
;;;364            if (recv_flags & TF_GOT_FIN) {
;;;365              if (pcb->refused_data != NULL) {
;;;366                /* Delay this if we have refused data. */
;;;367                pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
;;;368              } else {
;;;369                /* correct rcv_wnd as the application won't call tcp_recved()
;;;370                   for the FIN's seqno */
;;;371                if (pcb->rcv_wnd != TCP_WND) {
;;;372                  pcb->rcv_wnd++;
;;;373                }
;;;374                TCP_EVENT_CLOSED(pcb, err);
;;;375                if (err == ERR_ABRT) {
;;;376                  goto aborted;
;;;377                }
;;;378              }
;;;379            }
;;;380    
;;;381            tcp_input_pcb = NULL;
;;;382            /* Try to send something out. */
;;;383            tcp_output(pcb);
;;;384    #if TCP_INPUT_DEBUG
;;;385    #if TCP_DEBUG
;;;386            tcp_debug_print_state(pcb->state);
;;;387    #endif /* TCP_DEBUG */
;;;388    #endif /* TCP_INPUT_DEBUG */
;;;389          }
;;;390        }
;;;391        /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
;;;392           Below this line, 'pcb' may not be dereferenced! */
;;;393    aborted:
;;;394        tcp_input_pcb = NULL;
;;;395        recv_data = NULL;
;;;396    
;;;397        /* give up our reference to inseg.p */
;;;398        if (inseg.p != NULL)
;;;399        {
;;;400          pbuf_free(inseg.p);
;;;401          inseg.p = NULL;
;;;402        }
;;;403      } else {
;;;404    
;;;405        /* If no matching PCB was found, send a TCP RST (reset) to the
;;;406           sender. */
;;;407        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
;;;408        if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
;;;409          TCP_STATS_INC(tcp.proterr);
;;;410          TCP_STATS_INC(tcp.drop);
;;;411          tcp_rst(ackno, seqno + tcplen,
;;;412            ip_current_dest_addr(), ip_current_src_addr(),
;;;413            tcphdr->dest, tcphdr->src);
;;;414        }
;;;415        pbuf_free(p);
;;;416      }
;;;417    
;;;418      LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;419      PERF_STOP("tcp_input");
;;;420      return;
;;;421    dropped:
;;;422      TCP_STATS_INC(tcp.drop);
;;;423      snmp_inc_tcpinerrs();
;;;424      pbuf_free(p);
;;;425    }
0005e4  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.1512|
0005e8  e594400c          LDR      r4,[r4,#0xc]          ;197
                  |L1.1516|
0005ec  e3540000          CMP      r4,#0                 ;197
0005f0  1affffd1          BNE      |L1.1340|
0005f4  e3a07000          MOV      r7,#0                 ;215
0005f8  e59f0288          LDR      r0,|L1.2184|
0005fc  e5905000          LDR      r5,[r0,#0]            ;216  ; tcp_listen_pcbs
000600  ea000014          B        |L1.1624|
                  |L1.1540|
000604  e1d521ba          LDRH     r2,[r5,#0x1a]         ;217
000608  e51f0238          LDR      r0,|L1.984|
00060c  e5901000          LDR      r1,[r0,#0]            ;217  ; tcphdr
000610  e5d10003          LDRB     r0,[r1,#3]            ;217
000614  e5d11002          LDRB     r1,[r1,#2]            ;217
000618  e1810400          ORR      r0,r1,r0,LSL #8       ;217
00061c  e1520000          CMP      r2,r0                 ;217
000620  1a00000a          BNE      |L1.1616|
000624  e51f1250          LDR      r1,|L1.988|
000628  e5950000          LDR      r0,[r5,#0]            ;228
00062c  e5911000          LDR      r1,[r1,#0]            ;228  ; current_iphdr_dest
000630  e1500001          CMP      r0,r1                 ;228
000634  0a000004          BEQ      |L1.1612|
000638  e3550000          CMP      r5,#0                 ;229
00063c  0a000002          BEQ      |L1.1612|
000640  e5950000          LDR      r0,[r5,#0]            ;229
000644  e3500000          CMP      r0,#0                 ;229
000648  1a000000          BNE      |L1.1616|
                  |L1.1612|
00064c  ea000003          B        |L1.1632|
                  |L1.1616|
000650  e1a07005          MOV      r7,r5                 ;235
000654  e595500c          LDR      r5,[r5,#0xc]          ;216
                  |L1.1624|
000658  e3550000          CMP      r5,#0                 ;216
00065c  1affffe8          BNE      |L1.1540|
                  |L1.1632|
000660  e1a00000          MOV      r0,r0                 ;231
000664  e3550000          CMP      r5,#0                 ;245
000668  0a00000d          BEQ      |L1.1700|
00066c  e3570000          CMP      r7,#0                 ;249
000670  0a000006          BEQ      |L1.1680|
000674  e595000c          LDR      r0,[r5,#0xc]          ;250
000678  e587000c          STR      r0,[r7,#0xc]          ;250
00067c  e59f0204          LDR      r0,|L1.2184|
000680  e5900000          LDR      r0,[r0,#0]            ;252  ; tcp_listen_pcbs
000684  e585000c          STR      r0,[r5,#0xc]          ;252
000688  e59f01f8          LDR      r0,|L1.2184|
00068c  e5805000          STR      r5,[r0,#0]            ;254  ; tcp_listen_pcbs
                  |L1.1680|
000690  e1a00005          MOV      r0,r5                 ;258
000694  ebfffffe          BL       tcp_listen_input
000698  e1a00006          MOV      r0,r6                 ;259
00069c  ebfffffe          BL       pbuf_free
0006a0  eaffffcf          B        |L1.1508|
                  |L1.1700|
0006a4  e3540000          CMP      r4,#0                 ;271
0006a8  0a0000f3          BEQ      |L1.2684|
0006ac  e3a00000          MOV      r0,#0                 ;280
0006b0  e59f11d4          LDR      r1,|L1.2188|
0006b4  e5810000          STR      r0,[r1,#0]            ;280  ; inseg
0006b8  e1d600b8          LDRH     r0,[r6,#8]            ;281
0006bc  e1c100b8          STRH     r0,[r1,#8]            ;281  ; inseg
0006c0  e2810000          ADD      r0,r1,#0              ;282
0006c4  e5806004          STR      r6,[r0,#4]            ;282  ; inseg
0006c8  e51f02f8          LDR      r0,|L1.984|
0006cc  e5900000          LDR      r0,[r0,#0]            ;283  ; tcphdr
0006d0  e5810010          STR      r0,[r1,#0x10]         ;283  ; inseg
0006d4  e3a00000          MOV      r0,#0                 ;285
0006d8  e59f11b0          LDR      r1,|L1.2192|
0006dc  e5810000          STR      r0,[r1,#0]            ;285  ; recv_data
0006e0  e59f11ac          LDR      r1,|L1.2196|
0006e4  e5c10000          STRB     r0,[r1,#0]            ;286  ; recv_flags
0006e8  e51f0304          LDR      r0,|L1.1004|
0006ec  e5d00000          LDRB     r0,[r0,#0]            ;288  ; flags
0006f0  e2000008          AND      r0,r0,#8              ;288
0006f4  e3500000          CMP      r0,#0                 ;288
0006f8  0a000002          BEQ      |L1.1800|
0006fc  e5d6000d          LDRB     r0,[r6,#0xd]          ;289
000700  e3800001          ORR      r0,r0,#1              ;289
000704  e5c6000d          STRB     r0,[r6,#0xd]          ;289
                  |L1.1800|
000708  e5940078          LDR      r0,[r4,#0x78]         ;293
00070c  e3500000          CMP      r0,#0                 ;293
000710  0a00000b          BEQ      |L1.1860|
000714  e1a00004          MOV      r0,r4                 ;294
000718  ebfffffe          BL       tcp_process_refused_data
00071c  e370000a          CMN      r0,#0xa               ;294
000720  0a000006          BEQ      |L1.1856|
000724  e5940078          LDR      r0,[r4,#0x78]         ;295
000728  e3500000          CMP      r0,#0                 ;295
00072c  0a000004          BEQ      |L1.1860|
000730  e51f0348          LDR      r0,|L1.1008|
000734  e1d000b0          LDRH     r0,[r0,#0]            ;295  ; tcplen
000738  e3500000          CMP      r0,#0                 ;295
00073c  da000000          BLE      |L1.1860|
                  |L1.1856|
000740  ea0000bd          B        |L1.2620|
                  |L1.1860|
000744  e59f014c          LDR      r0,|L1.2200|
000748  e5804000          STR      r4,[r0,#0]            ;303  ; tcp_input_pcb
00074c  e1a00004          MOV      r0,r4                 ;304
000750  ebfffffe          BL       tcp_process
000754  e1a08000          MOV      r8,r0                 ;304
000758  e378000a          CMN      r8,#0xa               ;307
00075c  0a0000b5          BEQ      |L1.2616|
000760  e59f012c          LDR      r0,|L1.2196|
000764  e5d00000          LDRB     r0,[r0,#0]            ;308  ; recv_flags
000768  e2000008          AND      r0,r0,#8              ;308
00076c  e3500000          CMP      r0,#0                 ;308
000770  0a00000f          BEQ      |L1.1972|
000774  e1a00000          MOV      r0,r0                 ;313
000778  e594008c          LDR      r0,[r4,#0x8c]         ;313
00077c  e3500000          CMP      r0,#0                 ;313
000780  0a000003          BEQ      |L1.1940|
000784  e3e0100a          MVN      r1,#0xa               ;313
000788  e5940010          LDR      r0,[r4,#0x10]         ;313
00078c  e594208c          LDR      r2,[r4,#0x8c]         ;313
000790  e12fff32          BLX      r2                    ;313
                  |L1.1940|
000794  e1a00000          MOV      r0,r0                 ;313
000798  e1a01004          MOV      r1,r4                 ;314
00079c  e51f03b0          LDR      r0,|L1.1012|
0007a0  ebfffffe          BL       tcp_pcb_remove
0007a4  e1a01004          MOV      r1,r4                 ;315
0007a8  e3a00001          MOV      r0,#1                 ;315
0007ac  ebfffffe          BL       memp_free
0007b0  ea0000a0          B        |L1.2616|
                  |L1.1972|
0007b4  e59f00d8          LDR      r0,|L1.2196|
0007b8  e5d00000          LDRB     r0,[r0,#0]            ;316  ; recv_flags
0007bc  e2000010          AND      r0,r0,#0x10           ;316
0007c0  e3500000          CMP      r0,#0                 ;316
0007c4  0a000013          BEQ      |L1.2072|
0007c8  e5d4001e          LDRB     r0,[r4,#0x1e]         ;319
0007cc  e2000010          AND      r0,r0,#0x10           ;319
0007d0  e3500000          CMP      r0,#0                 ;319
0007d4  1a000008          BNE      |L1.2044|
0007d8  e1a00000          MOV      r0,r0                 ;323
0007dc  e594008c          LDR      r0,[r4,#0x8c]         ;323
0007e0  e3500000          CMP      r0,#0                 ;323
0007e4  0a000003          BEQ      |L1.2040|
0007e8  e3e0100b          MVN      r1,#0xb               ;323
0007ec  e5940010          LDR      r0,[r4,#0x10]         ;323
0007f0  e594208c          LDR      r2,[r4,#0x8c]         ;323
0007f4  e12fff32          BLX      r2                    ;323
                  |L1.2040|
0007f8  e1a00000          MOV      r0,r0                 ;323
                  |L1.2044|
0007fc  e1a01004          MOV      r1,r4                 ;325
000800  e51f0414          LDR      r0,|L1.1012|
000804  ebfffffe          BL       tcp_pcb_remove
000808  e1a01004          MOV      r1,r4                 ;326
00080c  e3a00001          MOV      r0,#1                 ;326
000810  ebfffffe          BL       memp_free
000814  ea000087          B        |L1.2616|
                  |L1.2072|
000818  e3a08000          MOV      r8,#0                 ;328
00081c  e1d406b4          LDRH     r0,[r4,#0x64]         ;332
000820  e3500000          CMP      r0,#0                 ;332
000824  da000021          BLE      |L1.2224|
000828  e1a00000          MOV      r0,r0                 ;333
00082c  e594007c          LDR      r0,[r4,#0x7c]         ;333
000830  e3500000          CMP      r0,#0                 ;333
000834  0a000018          BEQ      |L1.2204|
000838  e1d426b4          LDRH     r2,[r4,#0x64]         ;333
00083c  e5940010          LDR      r0,[r4,#0x10]         ;333
000840  e594307c          LDR      r3,[r4,#0x7c]         ;333
000844  e1a01004          MOV      r1,r4                 ;333
000848  e12fff33          BLX      r3                    ;333
00084c  e1a08000          MOV      r8,r0                 ;333
000850  ea000012          B        |L1.2208|
                  |L1.2132|
                          DCD      tcp_tw_pcbs
                  |L1.2136|
000858  7463705f          DCB      "tcp_input: TIME-WAIT pcb->state == TIME-WAIT",0
00085c  696e7075
000860  743a2054
000864  494d452d
000868  57414954
00086c  20706362
000870  2d3e7374
000874  61746520
000878  3d3d2054
00087c  494d452d
000880  57414954
000884  00      
000885  00                DCB      0
000886  00                DCB      0
000887  00                DCB      0
                  |L1.2184|
                          DCD      tcp_listen_pcbs
                  |L1.2188|
                          DCD      inseg
                  |L1.2192|
                          DCD      recv_data
                  |L1.2196|
                          DCD      recv_flags
                  |L1.2200|
                          DCD      tcp_input_pcb
                  |L1.2204|
00089c  e3a08000          MOV      r8,#0                 ;333
                  |L1.2208|
0008a0  e1a00000          MOV      r0,r0                 ;333
0008a4  e378000a          CMN      r8,#0xa               ;334
0008a8  1a000000          BNE      |L1.2224|
0008ac  ea000062          B        |L1.2620|
                  |L1.2224|
0008b0  e51f0028          LDR      r0,|L1.2192|
0008b4  e5900000          LDR      r0,[r0,#0]            ;339  ; recv_data
0008b8  e3500000          CMP      r0,#0                 ;339
0008bc  0a000032          BEQ      |L1.2444|
0008c0  e1a00000          MOV      r0,r0                 ;340
0008c4  e5940078          LDR      r0,[r4,#0x78]         ;340
0008c8  e3500000          CMP      r0,#0                 ;340
0008cc  0a000006          BEQ      |L1.2284|
0008d0  e1a00000          MOV      r0,r0                 ;340
0008d4  e59f3244          LDR      r3,|L1.2848|
0008d8  e3a02f55          MOV      r2,#0x154             ;340
0008dc  e28f1d09          ADR      r1,|L1.2852|
0008e0  e59f0258          LDR      r0,|L1.2880|
0008e4  ebfffffe          BL       sysprintf
0008e8  e1a00000          MOV      r0,r0                 ;340
                  |L1.2284|
0008ec  e1a00000          MOV      r0,r0                 ;340
0008f0  e5d4001e          LDRB     r0,[r4,#0x1e]         ;341
0008f4  e2000010          AND      r0,r0,#0x10           ;341
0008f8  e3500000          CMP      r0,#0                 ;341
0008fc  0a000005          BEQ      |L1.2328|
000900  e51f0078          LDR      r0,|L1.2192|
000904  e5900000          LDR      r0,[r0,#0]            ;344  ; recv_data
000908  ebfffffe          BL       pbuf_free
00090c  e1a00004          MOV      r0,r4                 ;345
000910  ebfffffe          BL       tcp_abort
000914  ea000048          B        |L1.2620|
                  |L1.2328|
000918  e1a00000          MOV      r0,r0                 ;350
00091c  e5940080          LDR      r0,[r4,#0x80]         ;350
000920  e3500000          CMP      r0,#0                 ;350
000924  0a000008          BEQ      |L1.2380|
000928  e3a03000          MOV      r3,#0                 ;350
00092c  e51f10a4          LDR      r1,|L1.2192|
000930  e5940010          LDR      r0,[r4,#0x10]         ;350
000934  e594c080          LDR      r12,[r4,#0x80]        ;350
000938  e5912000          LDR      r2,[r1,#0]            ;350  ; recv_data
00093c  e1a01004          MOV      r1,r4                 ;350
000940  e12fff3c          BLX      r12                   ;350
000944  e1a08000          MOV      r8,r0                 ;350
000948  ea000006          B        |L1.2408|
                  |L1.2380|
00094c  e3a03000          MOV      r3,#0                 ;350
000950  e51f00c8          LDR      r0,|L1.2192|
000954  e1a01004          MOV      r1,r4                 ;350
000958  e5902000          LDR      r2,[r0,#0]            ;350  ; recv_data
00095c  e1a00003          MOV      r0,r3                 ;350
000960  ebfffffe          BL       tcp_recv_null
000964  e1a08000          MOV      r8,r0                 ;350
                  |L1.2408|
000968  e1a00000          MOV      r0,r0                 ;350
00096c  e378000a          CMN      r8,#0xa               ;351
000970  1a000000          BNE      |L1.2424|
000974  ea000030          B        |L1.2620|
                  |L1.2424|
000978  e3580000          CMP      r8,#0                 ;356
00097c  0a000002          BEQ      |L1.2444|
000980  e51f00f8          LDR      r0,|L1.2192|
000984  e5900000          LDR      r0,[r0,#0]            ;357  ; recv_data
000988  e5840078          STR      r0,[r4,#0x78]         ;357
                  |L1.2444|
00098c  e51f0100          LDR      r0,|L1.2196|
000990  e5d00000          LDRB     r0,[r0,#0]            ;364  ; recv_flags
000994  e2000020          AND      r0,r0,#0x20           ;364
000998  e3500000          CMP      r0,#0                 ;364
00099c  0a000020          BEQ      |L1.2596|
0009a0  e5940078          LDR      r0,[r4,#0x78]         ;365
0009a4  e3500000          CMP      r0,#0                 ;365
0009a8  0a000005          BEQ      |L1.2500|
0009ac  e5940078          LDR      r0,[r4,#0x78]         ;367
0009b0  e5d0000d          LDRB     r0,[r0,#0xd]          ;367
0009b4  e3800020          ORR      r0,r0,#0x20           ;367
0009b8  e5941078          LDR      r1,[r4,#0x78]         ;367
0009bc  e5c1000d          STRB     r0,[r1,#0xd]          ;367
0009c0  ea000017          B        |L1.2596|
                  |L1.2500|
0009c4  e1d402bc          LDRH     r0,[r4,#0x2c]         ;371
0009c8  e3500efa          CMP      r0,#0xfa0             ;371
0009cc  0a000003          BEQ      |L1.2528|
0009d0  e1d402bc          LDRH     r0,[r4,#0x2c]         ;372
0009d4  e2800001          ADD      r0,r0,#1              ;372
0009d8  e3c00801          BIC      r0,r0,#0x10000        ;372
0009dc  e1c402bc          STRH     r0,[r4,#0x2c]         ;372
                  |L1.2528|
0009e0  e1a00000          MOV      r0,r0                 ;374
0009e4  e5940080          LDR      r0,[r4,#0x80]         ;374
0009e8  e3500000          CMP      r0,#0                 ;374
0009ec  0a000007          BEQ      |L1.2576|
0009f0  e3a03000          MOV      r3,#0                 ;374
0009f4  e1a02003          MOV      r2,r3                 ;374
0009f8  e5940010          LDR      r0,[r4,#0x10]         ;374
0009fc  e594c080          LDR      r12,[r4,#0x80]        ;374
000a00  e1a01004          MOV      r1,r4                 ;374
000a04  e12fff3c          BLX      r12                   ;374
000a08  e1a08000          MOV      r8,r0                 ;374
000a0c  ea000000          B        |L1.2580|
                  |L1.2576|
000a10  e3a08000          MOV      r8,#0                 ;374
                  |L1.2580|
000a14  e1a00000          MOV      r0,r0                 ;374
000a18  e378000a          CMN      r8,#0xa               ;375
000a1c  1a000000          BNE      |L1.2596|
000a20  ea000005          B        |L1.2620|
                  |L1.2596|
000a24  e3a00000          MOV      r0,#0                 ;381
000a28  e51f1198          LDR      r1,|L1.2200|
000a2c  e5810000          STR      r0,[r1,#0]            ;381  ; tcp_input_pcb
000a30  e1a00004          MOV      r0,r4                 ;383
000a34  ebfffffe          BL       tcp_output
                  |L1.2616|
000a38  e1a00000          MOV      r0,r0                 ;393
                  |L1.2620|
000a3c  e3a00000          MOV      r0,#0                 ;394
000a40  e51f11b0          LDR      r1,|L1.2200|
000a44  e5810000          STR      r0,[r1,#0]            ;394  ; tcp_input_pcb
000a48  e51f11c0          LDR      r1,|L1.2192|
000a4c  e5810000          STR      r0,[r1,#0]            ;395  ; recv_data
000a50  e51f01cc          LDR      r0,|L1.2188|
000a54  e5900004          LDR      r0,[r0,#4]            ;398  ; inseg
000a58  e3500000          CMP      r0,#0                 ;398
000a5c  0a000027          BEQ      |L1.2816|
000a60  e51f11dc          LDR      r1,|L1.2188|
000a64  e5910004          LDR      r0,[r1,#4]            ;400  ; inseg
000a68  ebfffffe          BL       pbuf_free
000a6c  e3a00000          MOV      r0,#0                 ;401
000a70  e51f11ec          LDR      r1,|L1.2188|
000a74  e5810004          STR      r0,[r1,#4]            ;401  ; inseg
000a78  ea000020          B        |L1.2816|
                  |L1.2684|
000a7c  e51f16ac          LDR      r1,|L1.984|
000a80  e5912000          LDR      r2,[r1,#0]            ;408  ; tcphdr
000a84  e5d2100d          LDRB     r1,[r2,#0xd]          ;408
000a88  e5d2200c          LDRB     r2,[r2,#0xc]          ;408
000a8c  e1820401          ORR      r0,r2,r1,LSL #8       ;408
000a90  ebfffffe          BL       lwip_ntohs
000a94  e2000004          AND      r0,r0,#4              ;408
000a98  e3500000          CMP      r0,#0                 ;408
000a9c  1a000015          BNE      |L1.2808|
000aa0  e51f06d0          LDR      r0,|L1.984|
000aa4  e5901000          LDR      r1,[r0,#0]            ;411  ; tcphdr
000aa8  e5d10001          LDRB     r0,[r1,#1]            ;411
000aac  e5d11000          LDRB     r1,[r1,#0]            ;411
000ab0  e1810400          ORR      r0,r1,r0,LSL #8       ;411
000ab4  e51f16e4          LDR      r1,|L1.984|
000ab8  e5911000          LDR      r1,[r1,#0]            ;411  ; tcphdr
000abc  e5d12003          LDRB     r2,[r1,#3]            ;411
000ac0  e5d11002          LDRB     r1,[r1,#2]            ;411
000ac4  e1811402          ORR      r1,r1,r2,LSL #8       ;411
000ac8  e58d0004          STR      r0,[sp,#4]            ;411
000acc  e51f06f0          LDR      r0,|L1.996|
000ad0  e58d1000          STR      r1,[sp,#0]            ;411
000ad4  e5900000          LDR      r0,[r0,#0]            ;411  ; seqno
000ad8  e51f26f0          LDR      r2,|L1.1008|
000adc  e1d220b0          LDRH     r2,[r2,#0]            ;411  ; tcplen
000ae0  e0801002          ADD      r1,r0,r2              ;411
000ae4  e51f370c          LDR      r3,|L1.992|
000ae8  e51f2714          LDR      r2,|L1.988|
000aec  e51f070c          LDR      r0,|L1.1000|
000af0  e5900000          LDR      r0,[r0,#0]            ;411  ; ackno
000af4  ebfffffe          BL       tcp_rst
                  |L1.2808|
000af8  e1a00006          MOV      r0,r6                 ;415
000afc  ebfffffe          BL       pbuf_free
                  |L1.2816|
000b00  e1a00000          MOV      r0,r0                 ;418
000b04  e1a00000          MOV      r0,r0                 ;418
000b08  eafffeb5          B        |L1.1508|
                  |L1.2828|
000b0c  e1a00000          MOV      r0,r0                 ;421
000b10  e1a00006          MOV      r0,r6                 ;424
000b14  ebfffffe          BL       pbuf_free
000b18  e1a00000          MOV      r0,r0
000b1c  eafffeb0          B        |L1.1508|
                  |L1.2848|
                          DCD      ||i.tcp_input||+0x3f8
                  |L1.2852|
000b24  7063622d          DCB      "pcb->refused_data == NULL",0
000b28  3e726566
000b2c  75736564
000b30  5f646174
000b34  61203d3d
000b38  204e554c
000b3c  4c00    
000b3e  00                DCB      0
000b3f  00                DCB      0
                  |L1.2880|
                          DCD      ||i.tcp_input||+0x440
                          ENDP


                          AREA ||i.tcp_listen_input||, CODE, READONLY, ALIGN=2

                  tcp_listen_input PROC
;;;439    static err_t
;;;440    tcp_listen_input(struct tcp_pcb_listen *pcb)
000000  e92d407c          PUSH     {r2-r6,lr}
;;;441    {
000004  e1a05000          MOV      r5,r0
;;;442      struct tcp_pcb *npcb;
;;;443      err_t rc;
;;;444    
;;;445      if (flags & TCP_RST) {
000008  e59f01fc          LDR      r0,|L2.524|
00000c  e5d00000          LDRB     r0,[r0,#0]  ; flags
000010  e2000004          AND      r0,r0,#4
000014  e3500000          CMP      r0,#0
000018  0a000001          BEQ      |L2.36|
;;;446        /* An incoming RST should be ignored. Return. */
;;;447        return ERR_OK;
00001c  e3a00000          MOV      r0,#0
                  |L2.32|
;;;448      }
;;;449    
;;;450      /* In the LISTEN state, we check for incoming SYN segments,
;;;451         creates a new PCB, and responds with a SYN|ACK. */
;;;452      if (flags & TCP_ACK) {
;;;453        /* For incoming segments with the ACK flag set, respond with a
;;;454           RST. */
;;;455        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
;;;456        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
;;;457          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;458      } else if (flags & TCP_SYN) {
;;;459        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
;;;460    #if TCP_LISTEN_BACKLOG
;;;461        if (pcb->accepts_pending >= pcb->backlog) {
;;;462          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
;;;463          return ERR_ABRT;
;;;464        }
;;;465    #endif /* TCP_LISTEN_BACKLOG */
;;;466        npcb = tcp_alloc(pcb->prio);
;;;467        /* If a new PCB could not be created (probably due to lack of memory),
;;;468           we don't do anything, but rely on the sender will retransmit the
;;;469           SYN at a time when we have more memory available. */
;;;470        if (npcb == NULL) {
;;;471          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
;;;472          TCP_STATS_INC(tcp.memerr);
;;;473          return ERR_MEM;
;;;474        }
;;;475    #if TCP_LISTEN_BACKLOG
;;;476        pcb->accepts_pending++;
;;;477    #endif /* TCP_LISTEN_BACKLOG */
;;;478        /* Set up the new PCB. */
;;;479        ip_addr_copy(npcb->local_ip, current_iphdr_dest);
;;;480        npcb->local_port = pcb->local_port;
;;;481        ip_addr_copy(npcb->remote_ip, current_iphdr_src);
;;;482        npcb->remote_port = tcphdr->src;
;;;483        npcb->state = SYN_RCVD;
;;;484        npcb->rcv_nxt = seqno + 1;
;;;485        npcb->rcv_ann_right_edge = npcb->rcv_nxt;
;;;486        npcb->snd_wnd = tcphdr->wnd;
;;;487        npcb->snd_wnd_max = tcphdr->wnd;
;;;488        npcb->ssthresh = npcb->snd_wnd;
;;;489        npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
;;;490        npcb->callback_arg = pcb->callback_arg;
;;;491    #if LWIP_CALLBACK_API
;;;492        npcb->accept = pcb->accept;
;;;493    #endif /* LWIP_CALLBACK_API */
;;;494        /* inherit socket options */
;;;495        npcb->so_options = pcb->so_options & SOF_INHERITED;
;;;496        /* Register the new PCB so that we can begin receiving segments
;;;497           for it. */
;;;498        TCP_REG_ACTIVE(npcb);
;;;499    
;;;500        /* Parse any options in the SYN. */
;;;501        tcp_parseopt(npcb);
;;;502    #if TCP_CALCULATE_EFF_SEND_MSS
;;;503        npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
;;;504    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;505    
;;;506        snmp_inc_tcppassiveopens();
;;;507    
;;;508        /* Send a SYN|ACK together with the MSS option. */
;;;509        rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
;;;510        if (rc != ERR_OK) {
;;;511          tcp_abandon(npcb, 0);
;;;512          return rc;
;;;513        }
;;;514        return tcp_output(npcb);
;;;515      }
;;;516      return ERR_OK;
;;;517    }
000020  e8bd807c          POP      {r2-r6,pc}
                  |L2.36|
000024  e59f01e0          LDR      r0,|L2.524|
000028  e5d00000          LDRB     r0,[r0,#0]            ;452  ; flags
00002c  e2000010          AND      r0,r0,#0x10           ;452
000030  e3500000          CMP      r0,#0                 ;452
000034  0a000016          BEQ      |L2.148|
000038  e59f01d0          LDR      r0,|L2.528|
00003c  e5900000          LDR      r0,[r0,#0]            ;456  ; tcphdr
000040  e5d01001          LDRB     r1,[r0,#1]            ;456
000044  e5d00000          LDRB     r0,[r0,#0]            ;456
000048  e1800401          ORR      r0,r0,r1,LSL #8       ;456
00004c  e59f11bc          LDR      r1,|L2.528|
000050  e5912000          LDR      r2,[r1,#0]            ;456  ; tcphdr
000054  e5d21003          LDRB     r1,[r2,#3]            ;456
000058  e5d22002          LDRB     r2,[r2,#2]            ;456
00005c  e1821401          ORR      r1,r2,r1,LSL #8       ;456
000060  e58d0004          STR      r0,[sp,#4]            ;456
000064  e59f01a8          LDR      r0,|L2.532|
000068  e58d1000          STR      r1,[sp,#0]            ;456
00006c  e5900000          LDR      r0,[r0,#0]            ;456  ; seqno
000070  e59f21a0          LDR      r2,|L2.536|
000074  e1d220b0          LDRH     r2,[r2,#0]            ;456  ; tcplen
000078  e0801002          ADD      r1,r0,r2              ;456
00007c  e59f3198          LDR      r3,|L2.540|
000080  e59f2198          LDR      r2,|L2.544|
000084  e59f0198          LDR      r0,|L2.548|
000088  e5900000          LDR      r0,[r0,#0]            ;456  ; ackno
00008c  ebfffffe          BL       tcp_rst
000090  ea00005b          B        |L2.516|
                  |L2.148|
000094  e59f0170          LDR      r0,|L2.524|
000098  e5d00000          LDRB     r0,[r0,#0]            ;458  ; flags
00009c  e2000002          AND      r0,r0,#2              ;458
0000a0  e3500000          CMP      r0,#0                 ;458
0000a4  0a000056          BEQ      |L2.516|
0000a8  e5d50019          LDRB     r0,[r5,#0x19]         ;466
0000ac  ebfffffe          BL       tcp_alloc
0000b0  e1a04000          MOV      r4,r0                 ;466
0000b4  e3540000          CMP      r4,#0                 ;470
0000b8  1a000001          BNE      |L2.196|
0000bc  e3e00000          MVN      r0,#0                 ;473
0000c0  eaffffd6          B        |L2.32|
                  |L2.196|
0000c4  e59f0154          LDR      r0,|L2.544|
0000c8  e5900000          LDR      r0,[r0,#0]            ;479  ; current_iphdr_dest
0000cc  e5840000          STR      r0,[r4,#0]            ;479
0000d0  e1d501ba          LDRH     r0,[r5,#0x1a]         ;480
0000d4  e1c401ba          STRH     r0,[r4,#0x1a]         ;480
0000d8  e59f013c          LDR      r0,|L2.540|
0000dc  e5900000          LDR      r0,[r0,#0]            ;481  ; current_iphdr_src
0000e0  e5840004          STR      r0,[r4,#4]            ;481
0000e4  e59f0124          LDR      r0,|L2.528|
0000e8  e5901000          LDR      r1,[r0,#0]            ;482  ; tcphdr
0000ec  e5d10001          LDRB     r0,[r1,#1]            ;482
0000f0  e5d11000          LDRB     r1,[r1,#0]            ;482
0000f4  e1810400          ORR      r0,r1,r0,LSL #8       ;482
0000f8  e1c401bc          STRH     r0,[r4,#0x1c]         ;482
0000fc  e3a00003          MOV      r0,#3                 ;483
000100  e5c40018          STRB     r0,[r4,#0x18]         ;483
000104  e59f0108          LDR      r0,|L2.532|
000108  e5900000          LDR      r0,[r0,#0]            ;484  ; seqno
00010c  e2800001          ADD      r0,r0,#1              ;484
000110  e5840028          STR      r0,[r4,#0x28]         ;484
000114  e5940028          LDR      r0,[r4,#0x28]         ;485
000118  e5840030          STR      r0,[r4,#0x30]         ;485
00011c  e59f00ec          LDR      r0,|L2.528|
000120  e5901000          LDR      r1,[r0,#0]            ;486  ; tcphdr
000124  e5d1000f          LDRB     r0,[r1,#0xf]          ;486
000128  e5d1100e          LDRB     r1,[r1,#0xe]          ;486
00012c  e1810400          ORR      r0,r1,r0,LSL #8       ;486
000130  e1c406b0          STRH     r0,[r4,#0x60]         ;486
000134  e59f00d4          LDR      r0,|L2.528|
000138  e5901000          LDR      r1,[r0,#0]            ;487  ; tcphdr
00013c  e5d1000f          LDRB     r0,[r1,#0xf]          ;487
000140  e5d1100e          LDRB     r1,[r1,#0xe]          ;487
000144  e1810400          ORR      r0,r1,r0,LSL #8       ;487
000148  e1c406b2          STRH     r0,[r4,#0x62]         ;487
00014c  e1d406b0          LDRH     r0,[r4,#0x60]         ;488
000150  e1c404be          STRH     r0,[r4,#0x4e]         ;488
000154  e59f00b8          LDR      r0,|L2.532|
000158  e5900000          LDR      r0,[r0,#0]            ;489  ; seqno
00015c  e2400001          SUB      r0,r0,#1              ;489
000160  e5840054          STR      r0,[r4,#0x54]         ;489
000164  e5950010          LDR      r0,[r5,#0x10]         ;490
000168  e5840010          STR      r0,[r4,#0x10]         ;490
00016c  e5950014          LDR      r0,[r5,#0x14]         ;492
000170  e5840014          STR      r0,[r4,#0x14]         ;492
000174  e5d50008          LDRB     r0,[r5,#8]            ;495
000178  e200008c          AND      r0,r0,#0x8c           ;495
00017c  e5c40008          STRB     r0,[r4,#8]            ;495
000180  e1a00000          MOV      r0,r0                 ;498
000184  e1a00000          MOV      r0,r0                 ;498
000188  e59f0098          LDR      r0,|L2.552|
00018c  e5900000          LDR      r0,[r0,#0]            ;498  ; tcp_active_pcbs
000190  e584000c          STR      r0,[r4,#0xc]          ;498
000194  e59f008c          LDR      r0,|L2.552|
000198  e5804000          STR      r4,[r0,#0]            ;498  ; tcp_active_pcbs
00019c  ebfffffe          BL       tcp_timer_needed
0001a0  e1a00000          MOV      r0,r0                 ;498
0001a4  e3a00001          MOV      r0,#1                 ;498
0001a8  e59f107c          LDR      r1,|L2.556|
0001ac  e5c10000          STRB     r0,[r1,#0]            ;498  ; tcp_active_pcbs_changed
0001b0  e1a00000          MOV      r0,r0                 ;498
0001b4  e1a00004          MOV      r0,r4                 ;501
0001b8  ebfffffe          BL       tcp_parseopt
0001bc  e1d403b6          LDRH     r0,[r4,#0x36]         ;503
0001c0  e2841004          ADD      r1,r4,#4              ;503
0001c4  ebfffffe          BL       tcp_eff_send_mss
0001c8  e1c403b6          STRH     r0,[r4,#0x36]         ;503
0001cc  e3a01012          MOV      r1,#0x12              ;509
0001d0  e1a00004          MOV      r0,r4                 ;509
0001d4  ebfffffe          BL       tcp_enqueue_flags
0001d8  e1a06000          MOV      r6,r0                 ;509
0001dc  e3560000          CMP      r6,#0                 ;510
0001e0  0a000004          BEQ      |L2.504|
0001e4  e3a01000          MOV      r1,#0                 ;511
0001e8  e1a00004          MOV      r0,r4                 ;511
0001ec  ebfffffe          BL       tcp_abandon
0001f0  e1a00006          MOV      r0,r6                 ;512
0001f4  eaffff89          B        |L2.32|
                  |L2.504|
0001f8  e1a00004          MOV      r0,r4                 ;514
0001fc  ebfffffe          BL       tcp_output
000200  eaffff86          B        |L2.32|
                  |L2.516|
000204  e3a00000          MOV      r0,#0                 ;516
000208  eaffff84          B        |L2.32|
;;;518    
                          ENDP

                  |L2.524|
                          DCD      flags
                  |L2.528|
                          DCD      tcphdr
                  |L2.532|
                          DCD      seqno
                  |L2.536|
                          DCD      tcplen
                  |L2.540|
                          DCD      current_iphdr_src
                  |L2.544|
                          DCD      current_iphdr_dest
                  |L2.548|
                          DCD      ackno
                  |L2.552|
                          DCD      tcp_active_pcbs
                  |L2.556|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_oos_insert_segment||, CODE, READONLY, ALIGN=2

                  tcp_oos_insert_segment PROC
;;;799    static void
;;;800    tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;801    {
000004  e1a05000          MOV      r5,r0
000008  e1a04001          MOV      r4,r1
;;;802      struct tcp_seg *old_seg;
;;;803    
;;;804      if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
00000c  e5951010          LDR      r1,[r5,#0x10]
000010  e5d1200d          LDRB     r2,[r1,#0xd]
000014  e5d1100c          LDRB     r1,[r1,#0xc]
000018  e1810402          ORR      r0,r1,r2,LSL #8
00001c  ebfffffe          BL       lwip_ntohs
000020  e2000001          AND      r0,r0,#1
000024  e3500000          CMP      r0,#0
000028  0a000003          BEQ      |L3.60|
;;;805        /* received segment overlaps all following segments */
;;;806        tcp_segs_free(next);
00002c  e1a00004          MOV      r0,r4
000030  ebfffffe          BL       tcp_segs_free
;;;807        next = NULL;
000034  e3a04000          MOV      r4,#0
000038  ea00003a          B        |L3.296|
                  |L3.60|
;;;808      }
;;;809      else {
;;;810        /* delete some following segments
;;;811           oos queue may have segments with FIN flag */
;;;812        while (next &&
00003c  ea000016          B        |L3.156|
                  |L3.64|
;;;813               TCP_SEQ_GEQ((seqno + cseg->len),
;;;814                          (next->tcphdr->seqno + next->len))) {
;;;815          /* cseg with FIN already processed */
;;;816          if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
000040  e5941010          LDR      r1,[r4,#0x10]
000044  e5d1200d          LDRB     r2,[r1,#0xd]
000048  e5d1100c          LDRB     r1,[r1,#0xc]
00004c  e1810402          ORR      r0,r1,r2,LSL #8
000050  ebfffffe          BL       lwip_ntohs
000054  e2000001          AND      r0,r0,#1
000058  e3500000          CMP      r0,#0
00005c  0a00000a          BEQ      |L3.140|
;;;817            TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
000060  e3a00001          MOV      r0,#1
000064  ebfffffe          BL       lwip_htons
000068  e5952010          LDR      r2,[r5,#0x10]
00006c  e5d2100d          LDRB     r1,[r2,#0xd]
000070  e5d2200c          LDRB     r2,[r2,#0xc]
000074  e1821401          ORR      r1,r2,r1,LSL #8
000078  e1800001          ORR      r0,r0,r1
00007c  e5951010          LDR      r1,[r5,#0x10]
000080  e5c1000c          STRB     r0,[r1,#0xc]
000084  e1a00420          LSR      r0,r0,#8
000088  e5c1000d          STRB     r0,[r1,#0xd]
                  |L3.140|
;;;818          }
;;;819          old_seg = next;
00008c  e1a06004          MOV      r6,r4
;;;820          next = next->next;
000090  e5944000          LDR      r4,[r4,#0]
;;;821          tcp_seg_free(old_seg);
000094  e1a00006          MOV      r0,r6
000098  ebfffffe          BL       tcp_seg_free
                  |L3.156|
00009c  e3540000          CMP      r4,#0                 ;812
0000a0  0a00000a          BEQ      |L3.208|
0000a4  e5941010          LDR      r1,[r4,#0x10]         ;813
0000a8  e2810004          ADD      r0,r1,#4              ;813
0000ac  ebfffffe          BL       __aeabi_uread4
0000b0  e1d410b8          LDRH     r1,[r4,#8]            ;813
0000b4  e0800001          ADD      r0,r0,r1              ;813
0000b8  e1d510b8          LDRH     r1,[r5,#8]            ;813
0000bc  e59f206c          LDR      r2,|L3.304|
0000c0  e5922000          LDR      r2,[r2,#0]            ;813  ; seqno
0000c4  e0811002          ADD      r1,r1,r2              ;813
0000c8  e0510000          SUBS     r0,r1,r0              ;813
0000cc  5affffdb          BPL      |L3.64|
                  |L3.208|
;;;822        }
;;;823        if (next &&
0000d0  e3540000          CMP      r4,#0
0000d4  0a000013          BEQ      |L3.296|
;;;824            TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
0000d8  e5941010          LDR      r1,[r4,#0x10]
0000dc  e2810004          ADD      r0,r1,#4
0000e0  ebfffffe          BL       __aeabi_uread4
0000e4  e1d510b8          LDRH     r1,[r5,#8]
0000e8  e59f2040          LDR      r2,|L3.304|
0000ec  e5922000          LDR      r2,[r2,#0]  ; seqno
0000f0  e0811002          ADD      r1,r1,r2
0000f4  e0410000          SUB      r0,r1,r0
0000f8  e3500000          CMP      r0,#0
0000fc  da000009          BLE      |L3.296|
;;;825          /* We need to trim the incoming segment. */
;;;826          cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
000100  e5941010          LDR      r1,[r4,#0x10]
000104  e2810004          ADD      r0,r1,#4
000108  ebfffffe          BL       __aeabi_uread4
00010c  e59f101c          LDR      r1,|L3.304|
000110  e1d110b0          LDRH     r1,[r1,#0]  ; seqno
000114  e0400001          SUB      r0,r0,r1
000118  e1c500b8          STRH     r0,[r5,#8]
;;;827          pbuf_realloc(cseg->p, cseg->len);
00011c  e1d510b8          LDRH     r1,[r5,#8]
000120  e5950004          LDR      r0,[r5,#4]
000124  ebfffffe          BL       pbuf_realloc
                  |L3.296|
;;;828        }
;;;829      }
;;;830      cseg->next = next;
000128  e5854000          STR      r4,[r5,#0]
;;;831    }
00012c  e8bd8070          POP      {r4-r6,pc}
;;;832    #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

                  |L3.304|
                          DCD      seqno

                          AREA ||i.tcp_parseopt||, CODE, READONLY, ALIGN=2

                  tcp_parseopt PROC
;;;1541   static void
;;;1542   tcp_parseopt(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1543   {
000004  e1a08000          MOV      r8,r0
;;;1544     u16_t c, max_c;
;;;1545     u16_t mss;
;;;1546     u8_t *opts, opt;
;;;1547   #if LWIP_TCP_TIMESTAMPS
;;;1548     u32_t tsval;
;;;1549   #endif
;;;1550   
;;;1551     opts = (u8_t *)tcphdr + TCP_HLEN;
000008  e59f0140          LDR      r0,|L4.336|
00000c  e5900000          LDR      r0,[r0,#0]  ; tcphdr
000010  e2805014          ADD      r5,r0,#0x14
;;;1552   
;;;1553     /* Parse the TCP MSS option, if present. */
;;;1554     if(TCPH_HDRLEN(tcphdr) > 0x5) {
000014  e59f1134          LDR      r1,|L4.336|
000018  e5912000          LDR      r2,[r1,#0]  ; tcphdr
00001c  e5d2100d          LDRB     r1,[r2,#0xd]
000020  e5d2200c          LDRB     r2,[r2,#0xc]
000024  e1820401          ORR      r0,r2,r1,LSL #8
000028  ebfffffe          BL       lwip_ntohs
00002c  e3a01005          MOV      r1,#5
000030  e1510640          CMP      r1,r0,ASR #12
000034  aa000043          BGE      |L4.328|
;;;1555       max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
000038  e59f1110          LDR      r1,|L4.336|
00003c  e5912000          LDR      r2,[r1,#0]  ; tcphdr
000040  e5d2100d          LDRB     r1,[r2,#0xd]
000044  e5d2200c          LDRB     r2,[r2,#0xc]
000048  e1820401          ORR      r0,r2,r1,LSL #8
00004c  ebfffffe          BL       lwip_ntohs
000050  e3a01005          MOV      r1,#5
000054  e0610640          RSB      r0,r1,r0,ASR #12
000058  e59f10f4          LDR      r1,|L4.340|
00005c  e0016100          AND      r6,r1,r0,LSL #2
;;;1556       for (c = 0; c < max_c; ) {
000060  e3a04000          MOV      r4,#0
000064  ea000035          B        |L4.320|
                  |L4.104|
;;;1557         opt = opts[c];
000068  e7d59004          LDRB     r9,[r5,r4]
;;;1558         switch (opt) {
00006c  e3590000          CMP      r9,#0
000070  0a000004          BEQ      |L4.136|
000074  e3590001          CMP      r9,#1
000078  0a000004          BEQ      |L4.144|
00007c  e3590002          CMP      r9,#2
000080  1a000021          BNE      |L4.268|
000084  ea000006          B        |L4.164|
                  |L4.136|
;;;1559         case 0x00:
000088  e1a00000          MOV      r0,r0
                  |L4.140|
;;;1560           /* End of options. */
;;;1561           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
;;;1562           return;
;;;1563         case 0x01:
;;;1564           /* NOP option. */
;;;1565           ++c;
;;;1566           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
;;;1567           break;
;;;1568         case 0x02:
;;;1569           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
;;;1570           if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
;;;1571             /* Bad length */
;;;1572             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1573             return;
;;;1574           }
;;;1575           /* An MSS option with the right option length. */
;;;1576           mss = (opts[c + 2] << 8) | opts[c + 3];
;;;1577           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
;;;1578           pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
;;;1579           /* Advance to next option */
;;;1580           c += 0x04;
;;;1581           break;
;;;1582   #if LWIP_TCP_TIMESTAMPS
;;;1583         case 0x08:
;;;1584           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
;;;1585           if (opts[c + 1] != 0x0A || c + 0x0A > max_c) {
;;;1586             /* Bad length */
;;;1587             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1588             return;
;;;1589           }
;;;1590           /* TCP timestamp option with valid length */
;;;1591           tsval = (opts[c+2]) | (opts[c+3] << 8) | 
;;;1592             (opts[c+4] << 16) | (opts[c+5] << 24);
;;;1593           if (flags & TCP_SYN) {
;;;1594             pcb->ts_recent = ntohl(tsval);
;;;1595             pcb->flags |= TF_TIMESTAMP;
;;;1596           } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno+tcplen)) {
;;;1597             pcb->ts_recent = ntohl(tsval);
;;;1598           }
;;;1599           /* Advance to next option */
;;;1600           c += 0x0A;
;;;1601           break;
;;;1602   #endif
;;;1603         default:
;;;1604           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
;;;1605           if (opts[c + 1] == 0) {
;;;1606             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1607             /* If the length field is zero, the options are malformed
;;;1608                and we don't process them further. */
;;;1609             return;
;;;1610           }
;;;1611           /* All other options have a length field, so that we easily
;;;1612              can skip past them. */
;;;1613           c += opts[c + 1];
;;;1614         }
;;;1615       }
;;;1616     }
;;;1617   }
00008c  e8bd87f0          POP      {r4-r10,pc}
                  |L4.144|
000090  e1a00000          MOV      r0,r0                 ;1563
000094  e2840001          ADD      r0,r4,#1              ;1565
000098  e1a04800          LSL      r4,r0,#16             ;1565
00009c  e1a04824          LSR      r4,r4,#16             ;1565
0000a0  ea000025          B        |L4.316|
                  |L4.164|
0000a4  e1a00000          MOV      r0,r0                 ;1568
0000a8  e2840001          ADD      r0,r4,#1              ;1570
0000ac  e7d50000          LDRB     r0,[r5,r0]            ;1570
0000b0  e3500004          CMP      r0,#4                 ;1570
0000b4  1a000002          BNE      |L4.196|
0000b8  e2840004          ADD      r0,r4,#4              ;1570
0000bc  e1500006          CMP      r0,r6                 ;1570
0000c0  da000000          BLE      |L4.200|
                  |L4.196|
0000c4  eafffff0          B        |L4.140|
                  |L4.200|
0000c8  e2840003          ADD      r0,r4,#3              ;1576
0000cc  e7d50000          LDRB     r0,[r5,r0]            ;1576
0000d0  e2841002          ADD      r1,r4,#2              ;1576
0000d4  e7d51001          LDRB     r1,[r5,r1]            ;1576
0000d8  e1807401          ORR      r7,r0,r1,LSL #8       ;1576
0000dc  e3570ffa          CMP      r7,#0x3e8             ;1578
0000e0  ca000001          BGT      |L4.236|
0000e4  e3570000          CMP      r7,#0                 ;1578
0000e8  1a000001          BNE      |L4.244|
                  |L4.236|
0000ec  e3a00ffa          MOV      r0,#0x3e8             ;1578
0000f0  ea000000          B        |L4.248|
                  |L4.244|
0000f4  e1a00007          MOV      r0,r7                 ;1578
                  |L4.248|
0000f8  e1c803b6          STRH     r0,[r8,#0x36]         ;1578
0000fc  e2840004          ADD      r0,r4,#4              ;1580
000100  e1a04800          LSL      r4,r0,#16             ;1580
000104  e1a04824          LSR      r4,r4,#16             ;1580
000108  ea00000b          B        |L4.316|
                  |L4.268|
00010c  e1a00000          MOV      r0,r0                 ;1603
000110  e2840001          ADD      r0,r4,#1              ;1605
000114  e7d50000          LDRB     r0,[r5,r0]            ;1605
000118  e3500000          CMP      r0,#0                 ;1605
00011c  1a000000          BNE      |L4.292|
000120  eaffffd9          B        |L4.140|
                  |L4.292|
000124  e2840001          ADD      r0,r4,#1              ;1613
000128  e7d50000          LDRB     r0,[r5,r0]            ;1613
00012c  e0800004          ADD      r0,r0,r4              ;1613
000130  e1a04800          LSL      r4,r0,#16             ;1613
000134  e1a04824          LSR      r4,r4,#16             ;1613
000138  e1a00000          MOV      r0,r0                 ;1558
                  |L4.316|
00013c  e1a00000          MOV      r0,r0                 ;1567
                  |L4.320|
000140  e1540006          CMP      r4,r6                 ;1556
000144  baffffc7          BLT      |L4.104|
                  |L4.328|
000148  e1a00000          MOV      r0,r0
00014c  eaffffce          B        |L4.140|
;;;1618   
                          ENDP

                  |L4.336|
                          DCD      tcphdr
                  |L4.340|
                          DCD      0x0000ffff

                          AREA ||i.tcp_process||, CODE, READONLY, ALIGN=2

                  tcp_process PROC
;;;574    static err_t
;;;575    tcp_process(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;576    {
000004  e1a04000          MOV      r4,r0
;;;577      struct tcp_seg *rseg;
;;;578      u8_t acceptable = 0;
000008  e3a08000          MOV      r8,#0
;;;579      err_t err;
;;;580    
;;;581      err = ERR_OK;
00000c  e3a06000          MOV      r6,#0
;;;582    
;;;583      /* Process incoming RST segments. */
;;;584      if (flags & TCP_RST) {
000010  e59f0334          LDR      r0,|L5.844|
000014  e5d00000          LDRB     r0,[r0,#0]  ; flags
000018  e2000004          AND      r0,r0,#4
00001c  e3500000          CMP      r0,#0
000020  0a000031          BEQ      |L5.236|
;;;585        /* First, determine if the reset is acceptable. */
;;;586        if (pcb->state == SYN_SENT) {
000024  e5d40018          LDRB     r0,[r4,#0x18]
000028  e3500002          CMP      r0,#2
00002c  1a000006          BNE      |L5.76|
;;;587          if (ackno == pcb->snd_nxt) {
000030  e59f1318          LDR      r1,|L5.848|
000034  e5940050          LDR      r0,[r4,#0x50]
000038  e5911000          LDR      r1,[r1,#0]  ; ackno
00003c  e1500001          CMP      r0,r1
000040  1a00000f          BNE      |L5.132|
;;;588            acceptable = 1;
000044  e3a08001          MOV      r8,#1
000048  ea00000d          B        |L5.132|
                  |L5.76|
;;;589          }
;;;590        } else {
;;;591          if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
00004c  e59f1300          LDR      r1,|L5.852|
000050  e5940028          LDR      r0,[r4,#0x28]
000054  e5911000          LDR      r1,[r1,#0]  ; seqno
000058  e0510000          SUBS     r0,r1,r0
00005c  4a000008          BMI      |L5.132|
000060  e5940028          LDR      r0,[r4,#0x28]
000064  e1d412bc          LDRH     r1,[r4,#0x2c]
000068  e0800001          ADD      r0,r0,r1
00006c  e59f12e0          LDR      r1,|L5.852|
000070  e5911000          LDR      r1,[r1,#0]  ; seqno
000074  e0410000          SUB      r0,r1,r0
000078  e3500000          CMP      r0,#0
00007c  ca000000          BGT      |L5.132|
;;;592                              pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;593            acceptable = 1;
000080  e3a08001          MOV      r8,#1
                  |L5.132|
;;;594          }
;;;595        }
;;;596    
;;;597        if (acceptable) {
000084  e3580000          CMP      r8,#0
000088  0a000015          BEQ      |L5.228|
;;;598          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
;;;599          LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
00008c  e1a00000          MOV      r0,r0
000090  e5d40018          LDRB     r0,[r4,#0x18]
000094  e3500000          CMP      r0,#0
000098  1a000006          BNE      |L5.184|
00009c  e1a00000          MOV      r0,r0
0000a0  e28f3e2b          ADR      r3,|L5.856|
0000a4  e59f22cc          LDR      r2,|L5.888|
0000a8  e28f1fb3          ADR      r1,|L5.892|
0000ac  e28f0fba          ADR      r0,|L5.924|
0000b0  ebfffffe          BL       sysprintf
0000b4  e1a00000          MOV      r0,r0
                  |L5.184|
0000b8  e1a00000          MOV      r0,r0
;;;600          recv_flags |= TF_RESET;
0000bc  e59f0300          LDR      r0,|L5.964|
0000c0  e5d00000          LDRB     r0,[r0,#0]  ; recv_flags
0000c4  e3800008          ORR      r0,r0,#8
0000c8  e59f12f4          LDR      r1,|L5.964|
0000cc  e5c10000          STRB     r0,[r1,#0]  ; recv_flags
;;;601          pcb->flags &= ~TF_ACK_DELAY;
0000d0  e5d4001e          LDRB     r0,[r4,#0x1e]
0000d4  e3c00001          BIC      r0,r0,#1
0000d8  e5c4001e          STRB     r0,[r4,#0x1e]
;;;602          return ERR_RST;
0000dc  e3e0000a          MVN      r0,#0xa
                  |L5.224|
;;;603        } else {
;;;604          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;605           seqno, pcb->rcv_nxt));
;;;606          LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;607           seqno, pcb->rcv_nxt));
;;;608          return ERR_OK;
;;;609        }
;;;610      }
;;;611    
;;;612      if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
;;;613        /* Cope with new connection attempt after remote end crashed */
;;;614        tcp_ack_now(pcb);
;;;615        return ERR_OK;
;;;616      }
;;;617      
;;;618      if ((pcb->flags & TF_RXCLOSED) == 0) {
;;;619        /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
;;;620        pcb->tmr = tcp_ticks;
;;;621      }
;;;622      pcb->keep_cnt_sent = 0;
;;;623    
;;;624      tcp_parseopt(pcb);
;;;625    
;;;626      /* Do different things depending on the TCP state. */
;;;627      switch (pcb->state) {
;;;628      case SYN_SENT:
;;;629        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
;;;630         pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
;;;631        /* received SYN ACK with expected sequence number? */
;;;632        if ((flags & TCP_ACK) && (flags & TCP_SYN)
;;;633            && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
;;;634          pcb->snd_buf++;
;;;635          pcb->rcv_nxt = seqno + 1;
;;;636          pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;637          pcb->lastack = ackno;
;;;638          pcb->snd_wnd = tcphdr->wnd;
;;;639          pcb->snd_wnd_max = tcphdr->wnd;
;;;640          pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
;;;641          pcb->state = ESTABLISHED;
;;;642    
;;;643    #if TCP_CALCULATE_EFF_SEND_MSS
;;;644          pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
;;;645    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;646    
;;;647          /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
;;;648           * but for the default value of pcb->mss) */
;;;649          pcb->ssthresh = pcb->mss * 10;
;;;650    
;;;651          pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;652          LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
;;;653          --pcb->snd_queuelen;
;;;654          LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;655          rseg = pcb->unacked;
;;;656          pcb->unacked = rseg->next;
;;;657          tcp_seg_free(rseg);
;;;658    
;;;659          /* If there's nothing left to acknowledge, stop the retransmit
;;;660             timer, otherwise reset it to start again */
;;;661          if(pcb->unacked == NULL)
;;;662            pcb->rtime = -1;
;;;663          else {
;;;664            pcb->rtime = 0;
;;;665            pcb->nrtx = 0;
;;;666          }
;;;667    
;;;668          /* Call the user specified function to call when sucessfully
;;;669           * connected. */
;;;670          TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
;;;671          if (err == ERR_ABRT) {
;;;672            return ERR_ABRT;
;;;673          }
;;;674          tcp_ack_now(pcb);
;;;675        }
;;;676        /* received ACK? possibly a half-open connection */
;;;677        else if (flags & TCP_ACK) {
;;;678          /* send a RST to bring the other side in a non-synchronized state. */
;;;679          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;680            tcphdr->dest, tcphdr->src);
;;;681        }
;;;682        break;
;;;683      case SYN_RCVD:
;;;684        if (flags & TCP_ACK) {
;;;685          /* expected ACK number? */
;;;686          if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
;;;687            u16_t old_cwnd;
;;;688            pcb->state = ESTABLISHED;
;;;689            LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;690    #if LWIP_CALLBACK_API
;;;691            LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
;;;692    #endif
;;;693            /* Call the accept function. */
;;;694            TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
;;;695            if (err != ERR_OK) {
;;;696              /* If the accept function returns with an error, we abort
;;;697               * the connection. */
;;;698              /* Already aborted? */
;;;699              if (err != ERR_ABRT) {
;;;700                tcp_abort(pcb);
;;;701              }
;;;702              return ERR_ABRT;
;;;703            }
;;;704            old_cwnd = pcb->cwnd;
;;;705            /* If there was any data contained within this ACK,
;;;706             * we'd better pass it on to the application as well. */
;;;707            tcp_receive(pcb);
;;;708    
;;;709            /* Prevent ACK for SYN to generate a sent event */
;;;710            if (pcb->acked != 0) {
;;;711              pcb->acked--;
;;;712            }
;;;713    
;;;714            pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;715    
;;;716            if (recv_flags & TF_GOT_FIN) {
;;;717              tcp_ack_now(pcb);
;;;718              pcb->state = CLOSE_WAIT;
;;;719            }
;;;720          } else {
;;;721            /* incorrect ACK number, send RST */
;;;722            tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;723                    tcphdr->dest, tcphdr->src);
;;;724          }
;;;725        } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
;;;726          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
;;;727          tcp_rexmit(pcb);
;;;728        }
;;;729        break;
;;;730      case CLOSE_WAIT:
;;;731        /* FALLTHROUGH */
;;;732      case ESTABLISHED:
;;;733        tcp_receive(pcb);
;;;734        if (recv_flags & TF_GOT_FIN) { /* passive close */
;;;735          tcp_ack_now(pcb);
;;;736          pcb->state = CLOSE_WAIT;
;;;737        }
;;;738        break;
;;;739      case FIN_WAIT_1:
;;;740        tcp_receive(pcb);
;;;741        if (recv_flags & TF_GOT_FIN) {
;;;742          if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;743            LWIP_DEBUGF(TCP_DEBUG,
;;;744              ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;745            tcp_ack_now(pcb);
;;;746            tcp_pcb_purge(pcb);
;;;747            TCP_RMV_ACTIVE(pcb);
;;;748            pcb->state = TIME_WAIT;
;;;749            TCP_REG(&tcp_tw_pcbs, pcb);
;;;750          } else {
;;;751            tcp_ack_now(pcb);
;;;752            pcb->state = CLOSING;
;;;753          }
;;;754        } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;755          pcb->state = FIN_WAIT_2;
;;;756        }
;;;757        break;
;;;758      case FIN_WAIT_2:
;;;759        tcp_receive(pcb);
;;;760        if (recv_flags & TF_GOT_FIN) {
;;;761          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;762          tcp_ack_now(pcb);
;;;763          tcp_pcb_purge(pcb);
;;;764          TCP_RMV_ACTIVE(pcb);
;;;765          pcb->state = TIME_WAIT;
;;;766          TCP_REG(&tcp_tw_pcbs, pcb);
;;;767        }
;;;768        break;
;;;769      case CLOSING:
;;;770        tcp_receive(pcb);
;;;771        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;772          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;773          tcp_pcb_purge(pcb);
;;;774          TCP_RMV_ACTIVE(pcb);
;;;775          pcb->state = TIME_WAIT;
;;;776          TCP_REG(&tcp_tw_pcbs, pcb);
;;;777        }
;;;778        break;
;;;779      case LAST_ACK:
;;;780        tcp_receive(pcb);
;;;781        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;782          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;783          /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
;;;784          recv_flags |= TF_CLOSED;
;;;785        }
;;;786        break;
;;;787      default:
;;;788        break;
;;;789      }
;;;790      return ERR_OK;
;;;791    }
0000e0  e8bd81fc          POP      {r2-r8,pc}
                  |L5.228|
0000e4  e3a00000          MOV      r0,#0                 ;608
0000e8  eafffffc          B        |L5.224|
                  |L5.236|
0000ec  e59f0258          LDR      r0,|L5.844|
0000f0  e5d00000          LDRB     r0,[r0,#0]            ;612  ; flags
0000f4  e2000002          AND      r0,r0,#2              ;612
0000f8  e3500000          CMP      r0,#0                 ;612
0000fc  0a00000c          BEQ      |L5.308|
000100  e5d40018          LDRB     r0,[r4,#0x18]         ;612
000104  e3500002          CMP      r0,#2                 ;612
000108  0a000009          BEQ      |L5.308|
00010c  e5d40018          LDRB     r0,[r4,#0x18]         ;612
000110  e3500003          CMP      r0,#3                 ;612
000114  0a000006          BEQ      |L5.308|
000118  e1a00000          MOV      r0,r0                 ;614
00011c  e5d4001e          LDRB     r0,[r4,#0x1e]         ;614
000120  e3800002          ORR      r0,r0,#2              ;614
000124  e5c4001e          STRB     r0,[r4,#0x1e]         ;614
000128  e1a00000          MOV      r0,r0                 ;614
00012c  e3a00000          MOV      r0,#0                 ;615
000130  eaffffea          B        |L5.224|
                  |L5.308|
000134  e5d4001e          LDRB     r0,[r4,#0x1e]         ;618
000138  e2000010          AND      r0,r0,#0x10           ;618
00013c  e3500000          CMP      r0,#0                 ;618
000140  1a000002          BNE      |L5.336|
000144  e59f027c          LDR      r0,|L5.968|
000148  e5900000          LDR      r0,[r0,#0]            ;620  ; tcp_ticks
00014c  e5840024          STR      r0,[r4,#0x24]         ;620
                  |L5.336|
000150  e3a00000          MOV      r0,#0                 ;622
000154  e5c40096          STRB     r0,[r4,#0x96]         ;622
000158  e1a00004          MOV      r0,r4                 ;624
00015c  ebfffffe          BL       tcp_parseopt
000160  e5d40018          LDRB     r0,[r4,#0x18]         ;627
000164  e2400002          SUB      r0,r0,#2              ;627
000168  e3500008          CMP      r0,#8                 ;627
00016c  308ff100          ADDCC    pc,pc,r0,LSL #2       ;627
000170  ea00025c          B        |L5.2792|
000174  ea000006          B        |L5.404|
000178  ea0000c2          B        |L5.1160|
00017c  ea00013a          B        |L5.1644|
000180  ea000148          B        |L5.1704|
000184  ea0001b8          B        |L5.2156|
000188  ea000135          B        |L5.1636|
00018c  ea0001fc          B        |L5.2436|
000190  ea000241          B        |L5.2716|
                  |L5.404|
000194  e1a00000          MOV      r0,r0                 ;628
000198  e59f01ac          LDR      r0,|L5.844|
00019c  e5d00000          LDRB     r0,[r0,#0]            ;632  ; flags
0001a0  e2000010          AND      r0,r0,#0x10           ;632
0001a4  e3500000          CMP      r0,#0                 ;632
0001a8  0a00009a          BEQ      |L5.1048|
0001ac  e59f0198          LDR      r0,|L5.844|
0001b0  e5d00000          LDRB     r0,[r0,#0]            ;632  ; flags
0001b4  e2000002          AND      r0,r0,#2              ;632
0001b8  e3500000          CMP      r0,#0                 ;632
0001bc  0a000095          BEQ      |L5.1048|
0001c0  e5941070          LDR      r1,[r4,#0x70]         ;633
0001c4  e5911010          LDR      r1,[r1,#0x10]         ;633
0001c8  e2810004          ADD      r0,r1,#4              ;633
0001cc  ebfffffe          BL       __aeabi_uread4
0001d0  e1a07000          MOV      r7,r0                 ;633
0001d4  ebfffffe          BL       lwip_ntohl
0001d8  e2800001          ADD      r0,r0,#1              ;633
0001dc  e59f116c          LDR      r1,|L5.848|
0001e0  e5911000          LDR      r1,[r1,#0]            ;633  ; ackno
0001e4  e1500001          CMP      r0,r1                 ;633
0001e8  1a00008a          BNE      |L5.1048|
0001ec  e1d406b6          LDRH     r0,[r4,#0x66]         ;634
0001f0  e2800001          ADD      r0,r0,#1              ;634
0001f4  e3c00801          BIC      r0,r0,#0x10000        ;634
0001f8  e1c406b6          STRH     r0,[r4,#0x66]         ;634
0001fc  e59f0150          LDR      r0,|L5.852|
000200  e5900000          LDR      r0,[r0,#0]            ;635  ; seqno
000204  e2800001          ADD      r0,r0,#1              ;635
000208  e5840028          STR      r0,[r4,#0x28]         ;635
00020c  e5940028          LDR      r0,[r4,#0x28]         ;636
000210  e5840030          STR      r0,[r4,#0x30]         ;636
000214  e59f0134          LDR      r0,|L5.848|
000218  e5900000          LDR      r0,[r0,#0]            ;637  ; ackno
00021c  e5840048          STR      r0,[r4,#0x48]         ;637
000220  e59f01a4          LDR      r0,|L5.972|
000224  e5900000          LDR      r0,[r0,#0]            ;638  ; tcphdr
000228  e5d0100f          LDRB     r1,[r0,#0xf]          ;638
00022c  e5d0000e          LDRB     r0,[r0,#0xe]          ;638
000230  e1800401          ORR      r0,r0,r1,LSL #8       ;638
000234  e1c406b0          STRH     r0,[r4,#0x60]         ;638
000238  e59f018c          LDR      r0,|L5.972|
00023c  e5901000          LDR      r1,[r0,#0]            ;639  ; tcphdr
000240  e5d1000f          LDRB     r0,[r1,#0xf]          ;639
000244  e5d1100e          LDRB     r1,[r1,#0xe]          ;639
000248  e1810400          ORR      r0,r1,r0,LSL #8       ;639
00024c  e1c406b2          STRH     r0,[r4,#0x62]         ;639
000250  e59f00fc          LDR      r0,|L5.852|
000254  e5900000          LDR      r0,[r0,#0]            ;640  ; seqno
000258  e2400001          SUB      r0,r0,#1              ;640
00025c  e5840054          STR      r0,[r4,#0x54]         ;640
000260  e3a00004          MOV      r0,#4                 ;641
000264  e5c40018          STRB     r0,[r4,#0x18]         ;641
000268  e1d403b6          LDRH     r0,[r4,#0x36]         ;644
00026c  e2841004          ADD      r1,r4,#4              ;644
000270  ebfffffe          BL       tcp_eff_send_mss
000274  e1c403b6          STRH     r0,[r4,#0x36]         ;644
000278  e1d403b6          LDRH     r0,[r4,#0x36]         ;649
00027c  e0800100          ADD      r0,r0,r0,LSL #2       ;649
000280  e59f1148          LDR      r1,|L5.976|
000284  e0010080          AND      r0,r1,r0,LSL #1       ;649
000288  e1c404be          STRH     r0,[r4,#0x4e]         ;649
00028c  e1d404bc          LDRH     r0,[r4,#0x4c]         ;651
000290  e3500001          CMP      r0,#1                 ;651
000294  1a000002          BNE      |L5.676|
000298  e1d403b6          LDRH     r0,[r4,#0x36]         ;651
00029c  e1a00080          LSL      r0,r0,#1              ;651
0002a0  ea000000          B        |L5.680|
                  |L5.676|
0002a4  e1d403b6          LDRH     r0,[r4,#0x36]         ;651
                  |L5.680|
0002a8  e1c404bc          STRH     r0,[r4,#0x4c]         ;651
0002ac  e1a00000          MOV      r0,r0                 ;652
0002b0  e1d406b8          LDRH     r0,[r4,#0x68]         ;652
0002b4  e3500000          CMP      r0,#0                 ;652
0002b8  ca000006          BGT      |L5.728|
0002bc  e1a00000          MOV      r0,r0                 ;652
0002c0  e28f3090          ADR      r3,|L5.856|
0002c4  e3a02fa3          MOV      r2,#0x28c             ;652
0002c8  e28f1f41          ADR      r1,|L5.980|
0002cc  e28f00c8          ADR      r0,|L5.924|
0002d0  ebfffffe          BL       sysprintf
0002d4  e1a00000          MOV      r0,r0                 ;652
                  |L5.728|
0002d8  e1a00000          MOV      r0,r0                 ;652
0002dc  e1d406b8          LDRH     r0,[r4,#0x68]         ;653
0002e0  e2400001          SUB      r0,r0,#1              ;653
0002e4  e1c406b8          STRH     r0,[r4,#0x68]         ;653
0002e8  e5945070          LDR      r5,[r4,#0x70]         ;655
0002ec  e5950000          LDR      r0,[r5,#0]            ;656
0002f0  e5840070          STR      r0,[r4,#0x70]         ;656
0002f4  e1a00005          MOV      r0,r5                 ;657
0002f8  ebfffffe          BL       tcp_seg_free
0002fc  e5940070          LDR      r0,[r4,#0x70]         ;661
000300  e3500000          CMP      r0,#0                 ;661
000304  1a000002          BNE      |L5.788|
000308  e3e00000          MVN      r0,#0                 ;662
00030c  e1c403b4          STRH     r0,[r4,#0x34]         ;662
000310  ea000002          B        |L5.800|
                  |L5.788|
000314  e3a00000          MOV      r0,#0                 ;664
000318  e1c403b4          STRH     r0,[r4,#0x34]         ;664
00031c  e5c40046          STRB     r0,[r4,#0x46]         ;665
                  |L5.800|
000320  e1a00000          MOV      r0,r0                 ;670
000324  e5940084          LDR      r0,[r4,#0x84]         ;670
000328  e3500000          CMP      r0,#0                 ;670
00032c  0a00002e          BEQ      |L5.1004|
000330  e3a02000          MOV      r2,#0                 ;670
000334  e5940010          LDR      r0,[r4,#0x10]         ;670
000338  e5943084          LDR      r3,[r4,#0x84]         ;670
00033c  e1a01004          MOV      r1,r4                 ;670
000340  e12fff33          BLX      r3                    ;670
000344  e1a06000          MOV      r6,r0                 ;670
000348  ea000028          B        |L5.1008|
                  |L5.844|
                          DCD      flags
                  |L5.848|
                          DCD      ackno
                  |L5.852|
                          DCD      seqno
                  |L5.856|
000358  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_in.c",0
00035c  2d312e34
000360  2e315c73
000364  72635c63
000368  6f72655c
00036c  7463705f
000370  696e2e63
000374  00      
000375  00                DCB      0
000376  00                DCB      0
000377  00                DCB      0
                  |L5.888|
                          DCD      0x00000257
                  |L5.892|
00037c  7463705f          DCB      "tcp_input: pcb->state != CLOSED",0
000380  696e7075
000384  743a2070
000388  63622d3e
00038c  73746174
000390  6520213d
000394  20434c4f
000398  53454400
                  |L5.924|
00039c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0003a0  7274696f
0003a4  6e202225
0003a8  73222066
0003ac  61696c65
0003b0  64206174
0003b4  206c696e
0003b8  65202564
0003bc  20696e20
0003c0  25730a00
                  |L5.964|
                          DCD      recv_flags
                  |L5.968|
                          DCD      tcp_ticks
                  |L5.972|
                          DCD      tcphdr
                  |L5.976|
                          DCD      0x0000ffff
                  |L5.980|
0003d4  7063622d          DCB      "pcb->snd_queuelen > 0",0
0003d8  3e736e64
0003dc  5f717565
0003e0  75656c65
0003e4  6e203e20
0003e8  3000    
0003ea  00                DCB      0
0003eb  00                DCB      0
                  |L5.1004|
0003ec  e3a06000          MOV      r6,#0                 ;670
                  |L5.1008|
0003f0  e1a00000          MOV      r0,r0                 ;670
0003f4  e376000a          CMN      r6,#0xa               ;671
0003f8  1a000001          BNE      |L5.1028|
0003fc  e3e00009          MVN      r0,#9                 ;672
000400  eaffff36          B        |L5.224|
                  |L5.1028|
000404  e1a00000          MOV      r0,r0                 ;674
000408  e5d4001e          LDRB     r0,[r4,#0x1e]         ;674
00040c  e3800002          ORR      r0,r0,#2              ;674
000410  e5c4001e          STRB     r0,[r4,#0x1e]         ;674
000414  ea00001a          B        |L5.1156|
                  |L5.1048|
000418  e51f00d4          LDR      r0,|L5.844|
00041c  e5d00000          LDRB     r0,[r0,#0]            ;677  ; flags
000420  e2000010          AND      r0,r0,#0x10           ;677
000424  e3500000          CMP      r0,#0                 ;677
000428  0a000015          BEQ      |L5.1156|
00042c  e51f0068          LDR      r0,|L5.972|
000430  e5900000          LDR      r0,[r0,#0]            ;679  ; tcphdr
000434  e5d01001          LDRB     r1,[r0,#1]            ;679
000438  e5d00000          LDRB     r0,[r0,#0]            ;679
00043c  e1800401          ORR      r0,r0,r1,LSL #8       ;679
000440  e51f107c          LDR      r1,|L5.972|
000444  e5912000          LDR      r2,[r1,#0]            ;679  ; tcphdr
000448  e5d21003          LDRB     r1,[r2,#3]            ;679
00044c  e5d22002          LDRB     r2,[r2,#2]            ;679
000450  e1821401          ORR      r1,r2,r1,LSL #8       ;679
000454  e58d0004          STR      r0,[sp,#4]            ;679
000458  e51f010c          LDR      r0,|L5.852|
00045c  e58d1000          STR      r1,[sp,#0]            ;679
000460  e5900000          LDR      r0,[r0,#0]            ;679  ; seqno
000464  e59f2378          LDR      r2,|L5.2020|
000468  e1d220b0          LDRH     r2,[r2,#0]            ;679  ; tcplen
00046c  e0801002          ADD      r1,r0,r2              ;679
000470  e59f3370          LDR      r3,|L5.2024|
000474  e59f2370          LDR      r2,|L5.2028|
000478  e51f0130          LDR      r0,|L5.848|
00047c  e5900000          LDR      r0,[r0,#0]            ;679  ; ackno
000480  ebfffffe          BL       tcp_rst
                  |L5.1156|
000484  ea000199          B        |L5.2800|
                  |L5.1160|
000488  e1a00000          MOV      r0,r0                 ;683
00048c  e51f0148          LDR      r0,|L5.844|
000490  e5d00000          LDRB     r0,[r0,#0]            ;684  ; flags
000494  e2000010          AND      r0,r0,#0x10           ;684
000498  e3500000          CMP      r0,#0                 ;684
00049c  0a000062          BEQ      |L5.1580|
0004a0  e5940048          LDR      r0,[r4,#0x48]         ;686
0004a4  e2800001          ADD      r0,r0,#1              ;686
0004a8  e51f1160          LDR      r1,|L5.848|
0004ac  e5911000          LDR      r1,[r1,#0]            ;686  ; ackno
0004b0  e0510000          SUBS     r0,r1,r0              ;686
0004b4  4a000045          BMI      |L5.1488|
0004b8  e51f1170          LDR      r1,|L5.848|
0004bc  e5940050          LDR      r0,[r4,#0x50]         ;686
0004c0  e5911000          LDR      r1,[r1,#0]            ;686  ; ackno
0004c4  e0410000          SUB      r0,r1,r0              ;686
0004c8  e3500000          CMP      r0,#0                 ;686
0004cc  ca00003f          BGT      |L5.1488|
0004d0  e3a00004          MOV      r0,#4                 ;688
0004d4  e5c40018          STRB     r0,[r4,#0x18]         ;688
0004d8  e1a00000          MOV      r0,r0                 ;691
0004dc  e5940014          LDR      r0,[r4,#0x14]         ;691
0004e0  e3500000          CMP      r0,#0                 ;691
0004e4  1a000006          BNE      |L5.1284|
0004e8  e1a00000          MOV      r0,r0                 ;691
0004ec  e24f3f67          ADR      r3,|L5.856|
0004f0  e59f22f8          LDR      r2,|L5.2032|
0004f4  e28f1fbe          ADR      r1,|L5.2036|
0004f8  e24f0f59          ADR      r0,|L5.924|
0004fc  ebfffffe          BL       sysprintf
000500  e1a00000          MOV      r0,r0                 ;691
                  |L5.1284|
000504  e1a00000          MOV      r0,r0                 ;691
000508  e1a00000          MOV      r0,r0                 ;694
00050c  e5940014          LDR      r0,[r4,#0x14]         ;694
000510  e3500000          CMP      r0,#0                 ;694
000514  0a000006          BEQ      |L5.1332|
000518  e3a02000          MOV      r2,#0                 ;694
00051c  e5940010          LDR      r0,[r4,#0x10]         ;694
000520  e5943014          LDR      r3,[r4,#0x14]         ;694
000524  e1a01004          MOV      r1,r4                 ;694
000528  e12fff33          BLX      r3                    ;694
00052c  e1a06000          MOV      r6,r0                 ;694
000530  ea000000          B        |L5.1336|
                  |L5.1332|
000534  e3e0600d          MVN      r6,#0xd               ;694
                  |L5.1336|
000538  e1a00000          MOV      r0,r0                 ;694
00053c  e3560000          CMP      r6,#0                 ;695
000540  0a000005          BEQ      |L5.1372|
000544  e376000a          CMN      r6,#0xa               ;699
000548  0a000001          BEQ      |L5.1364|
00054c  e1a00004          MOV      r0,r4                 ;700
000550  ebfffffe          BL       tcp_abort
                  |L5.1364|
000554  e3e00009          MVN      r0,#9                 ;702
000558  eafffee0          B        |L5.224|
                  |L5.1372|
00055c  e1d474bc          LDRH     r7,[r4,#0x4c]         ;704
000560  e1a00004          MOV      r0,r4                 ;707
000564  ebfffffe          BL       tcp_receive
000568  e1d406b4          LDRH     r0,[r4,#0x64]         ;710
00056c  e3500000          CMP      r0,#0                 ;710
000570  0a000002          BEQ      |L5.1408|
000574  e1d406b4          LDRH     r0,[r4,#0x64]         ;711
000578  e2400001          SUB      r0,r0,#1              ;711
00057c  e1c406b4          STRH     r0,[r4,#0x64]         ;711
                  |L5.1408|
000580  e3570001          CMP      r7,#1                 ;714
000584  1a000002          BNE      |L5.1428|
000588  e1d403b6          LDRH     r0,[r4,#0x36]         ;714
00058c  e1a00080          LSL      r0,r0,#1              ;714
000590  ea000000          B        |L5.1432|
                  |L5.1428|
000594  e1d403b6          LDRH     r0,[r4,#0x36]         ;714
                  |L5.1432|
000598  e1c404bc          STRH     r0,[r4,#0x4c]         ;714
00059c  e51f01e0          LDR      r0,|L5.964|
0005a0  e5d00000          LDRB     r0,[r0,#0]            ;716  ; recv_flags
0005a4  e2000020          AND      r0,r0,#0x20           ;716
0005a8  e3500000          CMP      r0,#0                 ;716
0005ac  0a000006          BEQ      |L5.1484|
0005b0  e1a00000          MOV      r0,r0                 ;717
0005b4  e5d4001e          LDRB     r0,[r4,#0x1e]         ;717
0005b8  e3800002          ORR      r0,r0,#2              ;717
0005bc  e5c4001e          STRB     r0,[r4,#0x1e]         ;717
0005c0  e1a00000          MOV      r0,r0                 ;717
0005c4  e3a00007          MOV      r0,#7                 ;718
0005c8  e5c40018          STRB     r0,[r4,#0x18]         ;718
                  |L5.1484|
0005cc  ea000023          B        |L5.1632|
                  |L5.1488|
0005d0  e51f020c          LDR      r0,|L5.972|
0005d4  e5901000          LDR      r1,[r0,#0]            ;722  ; tcphdr
0005d8  e5d10001          LDRB     r0,[r1,#1]            ;722
0005dc  e5d11000          LDRB     r1,[r1,#0]            ;722
0005e0  e1810400          ORR      r0,r1,r0,LSL #8       ;722
0005e4  e51f1220          LDR      r1,|L5.972|
0005e8  e5912000          LDR      r2,[r1,#0]            ;722  ; tcphdr
0005ec  e5d21003          LDRB     r1,[r2,#3]            ;722
0005f0  e5d22002          LDRB     r2,[r2,#2]            ;722
0005f4  e1821401          ORR      r1,r2,r1,LSL #8       ;722
0005f8  e58d0004          STR      r0,[sp,#4]            ;722
0005fc  e51f02b0          LDR      r0,|L5.852|
000600  e58d1000          STR      r1,[sp,#0]            ;722
000604  e5900000          LDR      r0,[r0,#0]            ;722  ; seqno
000608  e59f21d4          LDR      r2,|L5.2020|
00060c  e1d220b0          LDRH     r2,[r2,#0]            ;722  ; tcplen
000610  e0801002          ADD      r1,r0,r2              ;722
000614  e59f31cc          LDR      r3,|L5.2024|
000618  e59f21cc          LDR      r2,|L5.2028|
00061c  e51f02d4          LDR      r0,|L5.848|
000620  e5900000          LDR      r0,[r0,#0]            ;722  ; ackno
000624  ebfffffe          BL       tcp_rst
000628  ea00000c          B        |L5.1632|
                  |L5.1580|
00062c  e51f02e8          LDR      r0,|L5.844|
000630  e5d00000          LDRB     r0,[r0,#0]            ;725  ; flags
000634  e2000002          AND      r0,r0,#2              ;725
000638  e3500000          CMP      r0,#0                 ;725
00063c  0a000007          BEQ      |L5.1632|
000640  e5940028          LDR      r0,[r4,#0x28]         ;725
000644  e2400001          SUB      r0,r0,#1              ;725
000648  e51f12fc          LDR      r1,|L5.852|
00064c  e5911000          LDR      r1,[r1,#0]            ;725  ; seqno
000650  e1500001          CMP      r0,r1                 ;725
000654  1a000001          BNE      |L5.1632|
000658  e1a00004          MOV      r0,r4                 ;727
00065c  ebfffffe          BL       tcp_rexmit
                  |L5.1632|
000660  ea000122          B        |L5.2800|
                  |L5.1636|
000664  e1a00000          MOV      r0,r0                 ;730
000668  e1a00000          MOV      r0,r0                 ;732
                  |L5.1644|
00066c  e1a00004          MOV      r0,r4                 ;733
000670  ebfffffe          BL       tcp_receive
000674  e51f02b8          LDR      r0,|L5.964|
000678  e5d00000          LDRB     r0,[r0,#0]            ;734  ; recv_flags
00067c  e2000020          AND      r0,r0,#0x20           ;734
000680  e3500000          CMP      r0,#0                 ;734
000684  0a000006          BEQ      |L5.1700|
000688  e1a00000          MOV      r0,r0                 ;735
00068c  e5d4001e          LDRB     r0,[r4,#0x1e]         ;735
000690  e3800002          ORR      r0,r0,#2              ;735
000694  e5c4001e          STRB     r0,[r4,#0x1e]         ;735
000698  e1a00000          MOV      r0,r0                 ;735
00069c  e3a00007          MOV      r0,#7                 ;736
0006a0  e5c40018          STRB     r0,[r4,#0x18]         ;736
                  |L5.1700|
0006a4  ea000111          B        |L5.2800|
                  |L5.1704|
0006a8  e1a00000          MOV      r0,r0                 ;739
0006ac  e1a00004          MOV      r0,r4                 ;740
0006b0  ebfffffe          BL       tcp_receive
0006b4  e51f02f8          LDR      r0,|L5.964|
0006b8  e5d00000          LDRB     r0,[r0,#0]            ;741  ; recv_flags
0006bc  e2000020          AND      r0,r0,#0x20           ;741
0006c0  e3500000          CMP      r0,#0                 ;741
0006c4  0a00005b          BEQ      |L5.2104|
0006c8  e51f0384          LDR      r0,|L5.844|
0006cc  e5d00000          LDRB     r0,[r0,#0]            ;742  ; flags
0006d0  e2000010          AND      r0,r0,#0x10           ;742
0006d4  e3500000          CMP      r0,#0                 ;742
0006d8  0a00004e          BEQ      |L5.2072|
0006dc  e51f1394          LDR      r1,|L5.848|
0006e0  e5940050          LDR      r0,[r4,#0x50]         ;742
0006e4  e5911000          LDR      r1,[r1,#0]            ;742  ; ackno
0006e8  e1500001          CMP      r0,r1                 ;742
0006ec  1a000049          BNE      |L5.2072|
0006f0  e1a00000          MOV      r0,r0                 ;745
0006f4  e5d4001e          LDRB     r0,[r4,#0x1e]         ;745
0006f8  e3800002          ORR      r0,r0,#2              ;745
0006fc  e5c4001e          STRB     r0,[r4,#0x1e]         ;745
000700  e1a00000          MOV      r0,r0                 ;745
000704  e1a00004          MOV      r0,r4                 ;746
000708  ebfffffe          BL       tcp_pcb_purge
00070c  e1a00000          MOV      r0,r0                 ;747
000710  e1a00000          MOV      r0,r0                 ;747
000714  e59f00ec          LDR      r0,|L5.2056|
000718  e5900000          LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
00071c  e1500004          CMP      r0,r4                 ;747
000720  1a000005          BNE      |L5.1852|
000724  e59f00dc          LDR      r0,|L5.2056|
000728  e5900000          LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
00072c  e590000c          LDR      r0,[r0,#0xc]          ;747
000730  e59f10d0          LDR      r1,|L5.2056|
000734  e5810000          STR      r0,[r1,#0]            ;747  ; tcp_active_pcbs
000738  ea000018          B        |L5.1952|
                  |L5.1852|
00073c  e59f00c4          LDR      r0,|L5.2056|
000740  e5900000          LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
000744  e59f10c0          LDR      r1,|L5.2060|
000748  e5810000          STR      r0,[r1,#0]            ;747  ; tcp_tmp_pcb
00074c  ea00000e          B        |L5.1932|
                  |L5.1872|
000750  e59f00b4          LDR      r0,|L5.2060|
000754  e5900000          LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
000758  e590000c          LDR      r0,[r0,#0xc]          ;747
00075c  e1500004          CMP      r0,r4                 ;747
000760  1a000004          BNE      |L5.1912|
000764  e59f10a0          LDR      r1,|L5.2060|
000768  e594000c          LDR      r0,[r4,#0xc]          ;747
00076c  e5911000          LDR      r1,[r1,#0]            ;747  ; tcp_tmp_pcb
000770  e581000c          STR      r0,[r1,#0xc]          ;747
000774  ea000008          B        |L5.1948|
                  |L5.1912|
000778  e59f008c          LDR      r0,|L5.2060|
00077c  e5900000          LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
000780  e590000c          LDR      r0,[r0,#0xc]          ;747
000784  e59f1080          LDR      r1,|L5.2060|
000788  e5810000          STR      r0,[r1,#0]            ;747  ; tcp_tmp_pcb
                  |L5.1932|
00078c  e59f0078          LDR      r0,|L5.2060|
000790  e5900000          LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
000794  e3500000          CMP      r0,#0                 ;747
000798  1affffec          BNE      |L5.1872|
                  |L5.1948|
00079c  e1a00000          MOV      r0,r0                 ;747
                  |L5.1952|
0007a0  e3a00000          MOV      r0,#0                 ;747
0007a4  e584000c          STR      r0,[r4,#0xc]          ;747
0007a8  e1a00000          MOV      r0,r0                 ;747
0007ac  e3a00001          MOV      r0,#1                 ;747
0007b0  e59f1058          LDR      r1,|L5.2064|
0007b4  e5c10000          STRB     r0,[r1,#0]            ;747  ; tcp_active_pcbs_changed
0007b8  e1a00000          MOV      r0,r0                 ;747
0007bc  e3a0000a          MOV      r0,#0xa               ;748
0007c0  e5c40018          STRB     r0,[r4,#0x18]         ;748
0007c4  e1a00000          MOV      r0,r0                 ;749
0007c8  e59f0044          LDR      r0,|L5.2068|
0007cc  e5900000          LDR      r0,[r0,#0]            ;749  ; tcp_tw_pcbs
0007d0  e584000c          STR      r0,[r4,#0xc]          ;749
0007d4  e59f0038          LDR      r0,|L5.2068|
0007d8  e5804000          STR      r4,[r0,#0]            ;749  ; tcp_tw_pcbs
0007dc  ebfffffe          BL       tcp_timer_needed
0007e0  ea000020          B        |L5.2152|
                  |L5.2020|
                          DCD      tcplen
                  |L5.2024|
                          DCD      current_iphdr_src
                  |L5.2028|
                          DCD      current_iphdr_dest
                  |L5.2032|
                          DCD      0x000002b3
                  |L5.2036|
0007f4  7063622d          DCB      "pcb->accept != NULL",0
0007f8  3e616363
0007fc  65707420
000800  213d204e
000804  554c4c00
                  |L5.2056|
                          DCD      tcp_active_pcbs
                  |L5.2060|
                          DCD      tcp_tmp_pcb
                  |L5.2064|
                          DCD      tcp_active_pcbs_changed
                  |L5.2068|
                          DCD      tcp_tw_pcbs
                  |L5.2072|
000818  e1a00000          MOV      r0,r0                 ;751
00081c  e5d4001e          LDRB     r0,[r4,#0x1e]         ;751
000820  e3800002          ORR      r0,r0,#2              ;751
000824  e5c4001e          STRB     r0,[r4,#0x1e]         ;751
000828  e1a00000          MOV      r0,r0                 ;751
00082c  e3a00008          MOV      r0,#8                 ;752
000830  e5c40018          STRB     r0,[r4,#0x18]         ;752
000834  ea00000b          B        |L5.2152|
                  |L5.2104|
000838  e51f04f4          LDR      r0,|L5.844|
00083c  e5d00000          LDRB     r0,[r0,#0]            ;754  ; flags
000840  e2000010          AND      r0,r0,#0x10           ;754
000844  e3500000          CMP      r0,#0                 ;754
000848  0a000006          BEQ      |L5.2152|
00084c  e51f1504          LDR      r1,|L5.848|
000850  e5940050          LDR      r0,[r4,#0x50]         ;754
000854  e5911000          LDR      r1,[r1,#0]            ;754  ; ackno
000858  e1500001          CMP      r0,r1                 ;754
00085c  1a000001          BNE      |L5.2152|
000860  e3a00006          MOV      r0,#6                 ;755
000864  e5c40018          STRB     r0,[r4,#0x18]         ;755
                  |L5.2152|
000868  ea0000a0          B        |L5.2800|
                  |L5.2156|
00086c  e1a00000          MOV      r0,r0                 ;758
000870  e1a00004          MOV      r0,r4                 ;759
000874  ebfffffe          BL       tcp_receive
000878  e51f04bc          LDR      r0,|L5.964|
00087c  e5d00000          LDRB     r0,[r0,#0]            ;760  ; recv_flags
000880  e2000020          AND      r0,r0,#0x20           ;760
000884  e3500000          CMP      r0,#0                 ;760
000888  0a00003c          BEQ      |L5.2432|
00088c  e1a00000          MOV      r0,r0                 ;762
000890  e5d4001e          LDRB     r0,[r4,#0x1e]         ;762
000894  e3800002          ORR      r0,r0,#2              ;762
000898  e5c4001e          STRB     r0,[r4,#0x1e]         ;762
00089c  e1a00000          MOV      r0,r0                 ;762
0008a0  e1a00004          MOV      r0,r4                 ;763
0008a4  ebfffffe          BL       tcp_pcb_purge
0008a8  e1a00000          MOV      r0,r0                 ;764
0008ac  e1a00000          MOV      r0,r0                 ;764
0008b0  e51f00b0          LDR      r0,|L5.2056|
0008b4  e5900000          LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
0008b8  e1500004          CMP      r0,r4                 ;764
0008bc  1a000005          BNE      |L5.2264|
0008c0  e51f00c0          LDR      r0,|L5.2056|
0008c4  e5900000          LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
0008c8  e590000c          LDR      r0,[r0,#0xc]          ;764
0008cc  e51f10cc          LDR      r1,|L5.2056|
0008d0  e5810000          STR      r0,[r1,#0]            ;764  ; tcp_active_pcbs
0008d4  ea000018          B        |L5.2364|
                  |L5.2264|
0008d8  e51f00d8          LDR      r0,|L5.2056|
0008dc  e5900000          LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
0008e0  e51f10dc          LDR      r1,|L5.2060|
0008e4  e5810000          STR      r0,[r1,#0]            ;764  ; tcp_tmp_pcb
0008e8  ea00000e          B        |L5.2344|
                  |L5.2284|
0008ec  e51f00e8          LDR      r0,|L5.2060|
0008f0  e5900000          LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
0008f4  e590000c          LDR      r0,[r0,#0xc]          ;764
0008f8  e1500004          CMP      r0,r4                 ;764
0008fc  1a000004          BNE      |L5.2324|
000900  e51f10fc          LDR      r1,|L5.2060|
000904  e594000c          LDR      r0,[r4,#0xc]          ;764
000908  e5911000          LDR      r1,[r1,#0]            ;764  ; tcp_tmp_pcb
00090c  e581000c          STR      r0,[r1,#0xc]          ;764
000910  ea000008          B        |L5.2360|
                  |L5.2324|
000914  e51f0110          LDR      r0,|L5.2060|
000918  e5900000          LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
00091c  e590000c          LDR      r0,[r0,#0xc]          ;764
000920  e51f111c          LDR      r1,|L5.2060|
000924  e5810000          STR      r0,[r1,#0]            ;764  ; tcp_tmp_pcb
                  |L5.2344|
000928  e51f0124          LDR      r0,|L5.2060|
00092c  e5900000          LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
000930  e3500000          CMP      r0,#0                 ;764
000934  1affffec          BNE      |L5.2284|
                  |L5.2360|
000938  e1a00000          MOV      r0,r0                 ;764
                  |L5.2364|
00093c  e3a00000          MOV      r0,#0                 ;764
000940  e584000c          STR      r0,[r4,#0xc]          ;764
000944  e1a00000          MOV      r0,r0                 ;764
000948  e3a00001          MOV      r0,#1                 ;764
00094c  e51f1144          LDR      r1,|L5.2064|
000950  e5c10000          STRB     r0,[r1,#0]            ;764  ; tcp_active_pcbs_changed
000954  e1a00000          MOV      r0,r0                 ;764
000958  e3a0000a          MOV      r0,#0xa               ;765
00095c  e5c40018          STRB     r0,[r4,#0x18]         ;765
000960  e1a00000          MOV      r0,r0                 ;766
000964  e51f0158          LDR      r0,|L5.2068|
000968  e5900000          LDR      r0,[r0,#0]            ;766  ; tcp_tw_pcbs
00096c  e584000c          STR      r0,[r4,#0xc]          ;766
000970  e51f0164          LDR      r0,|L5.2068|
000974  e5804000          STR      r4,[r0,#0]            ;766  ; tcp_tw_pcbs
000978  ebfffffe          BL       tcp_timer_needed
00097c  e1a00000          MOV      r0,r0                 ;766
                  |L5.2432|
000980  ea00005a          B        |L5.2800|
                  |L5.2436|
000984  e1a00000          MOV      r0,r0                 ;769
000988  e1a00004          MOV      r0,r4                 ;770
00098c  ebfffffe          BL       tcp_receive
000990  e51f064c          LDR      r0,|L5.844|
000994  e5d00000          LDRB     r0,[r0,#0]            ;771  ; flags
000998  e2000010          AND      r0,r0,#0x10           ;771
00099c  e3500000          CMP      r0,#0                 ;771
0009a0  0a00003c          BEQ      |L5.2712|
0009a4  e51f165c          LDR      r1,|L5.848|
0009a8  e5940050          LDR      r0,[r4,#0x50]         ;771
0009ac  e5911000          LDR      r1,[r1,#0]            ;771  ; ackno
0009b0  e1500001          CMP      r0,r1                 ;771
0009b4  1a000037          BNE      |L5.2712|
0009b8  e1a00004          MOV      r0,r4                 ;773
0009bc  ebfffffe          BL       tcp_pcb_purge
0009c0  e1a00000          MOV      r0,r0                 ;774
0009c4  e1a00000          MOV      r0,r0                 ;774
0009c8  e51f01c8          LDR      r0,|L5.2056|
0009cc  e5900000          LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
0009d0  e1500004          CMP      r0,r4                 ;774
0009d4  1a000005          BNE      |L5.2544|
0009d8  e51f01d8          LDR      r0,|L5.2056|
0009dc  e5900000          LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
0009e0  e590000c          LDR      r0,[r0,#0xc]          ;774
0009e4  e51f11e4          LDR      r1,|L5.2056|
0009e8  e5810000          STR      r0,[r1,#0]            ;774  ; tcp_active_pcbs
0009ec  ea000018          B        |L5.2644|
                  |L5.2544|
0009f0  e51f01f0          LDR      r0,|L5.2056|
0009f4  e5900000          LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
0009f8  e51f11f4          LDR      r1,|L5.2060|
0009fc  e5810000          STR      r0,[r1,#0]            ;774  ; tcp_tmp_pcb
000a00  ea00000e          B        |L5.2624|
                  |L5.2564|
000a04  e51f0200          LDR      r0,|L5.2060|
000a08  e5900000          LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
000a0c  e590000c          LDR      r0,[r0,#0xc]          ;774
000a10  e1500004          CMP      r0,r4                 ;774
000a14  1a000004          BNE      |L5.2604|
000a18  e51f1214          LDR      r1,|L5.2060|
000a1c  e594000c          LDR      r0,[r4,#0xc]          ;774
000a20  e5911000          LDR      r1,[r1,#0]            ;774  ; tcp_tmp_pcb
000a24  e581000c          STR      r0,[r1,#0xc]          ;774
000a28  ea000008          B        |L5.2640|
                  |L5.2604|
000a2c  e51f0228          LDR      r0,|L5.2060|
000a30  e5900000          LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
000a34  e590000c          LDR      r0,[r0,#0xc]          ;774
000a38  e51f1234          LDR      r1,|L5.2060|
000a3c  e5810000          STR      r0,[r1,#0]            ;774  ; tcp_tmp_pcb
                  |L5.2624|
000a40  e51f023c          LDR      r0,|L5.2060|
000a44  e5900000          LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
000a48  e3500000          CMP      r0,#0                 ;774
000a4c  1affffec          BNE      |L5.2564|
                  |L5.2640|
000a50  e1a00000          MOV      r0,r0                 ;774
                  |L5.2644|
000a54  e3a00000          MOV      r0,#0                 ;774
000a58  e584000c          STR      r0,[r4,#0xc]          ;774
000a5c  e1a00000          MOV      r0,r0                 ;774
000a60  e3a00001          MOV      r0,#1                 ;774
000a64  e51f125c          LDR      r1,|L5.2064|
000a68  e5c10000          STRB     r0,[r1,#0]            ;774  ; tcp_active_pcbs_changed
000a6c  e1a00000          MOV      r0,r0                 ;774
000a70  e3a0000a          MOV      r0,#0xa               ;775
000a74  e5c40018          STRB     r0,[r4,#0x18]         ;775
000a78  e1a00000          MOV      r0,r0                 ;776
000a7c  e51f0270          LDR      r0,|L5.2068|
000a80  e5900000          LDR      r0,[r0,#0]            ;776  ; tcp_tw_pcbs
000a84  e584000c          STR      r0,[r4,#0xc]          ;776
000a88  e51f027c          LDR      r0,|L5.2068|
000a8c  e5804000          STR      r4,[r0,#0]            ;776  ; tcp_tw_pcbs
000a90  ebfffffe          BL       tcp_timer_needed
000a94  e1a00000          MOV      r0,r0                 ;776
                  |L5.2712|
000a98  ea000014          B        |L5.2800|
                  |L5.2716|
000a9c  e1a00000          MOV      r0,r0                 ;779
000aa0  e1a00004          MOV      r0,r4                 ;780
000aa4  ebfffffe          BL       tcp_receive
000aa8  e51f0764          LDR      r0,|L5.844|
000aac  e5d00000          LDRB     r0,[r0,#0]            ;781  ; flags
000ab0  e2000010          AND      r0,r0,#0x10           ;781
000ab4  e3500000          CMP      r0,#0                 ;781
000ab8  0a000009          BEQ      |L5.2788|
000abc  e51f1774          LDR      r1,|L5.848|
000ac0  e5940050          LDR      r0,[r4,#0x50]         ;781
000ac4  e5911000          LDR      r1,[r1,#0]            ;781  ; ackno
000ac8  e1500001          CMP      r0,r1                 ;781
000acc  1a000004          BNE      |L5.2788|
000ad0  e51f0714          LDR      r0,|L5.964|
000ad4  e5d00000          LDRB     r0,[r0,#0]            ;784  ; recv_flags
000ad8  e3800010          ORR      r0,r0,#0x10           ;784
000adc  e51f1720          LDR      r1,|L5.964|
000ae0  e5c10000          STRB     r0,[r1,#0]            ;784  ; recv_flags
                  |L5.2788|
000ae4  ea000001          B        |L5.2800|
                  |L5.2792|
000ae8  e1a00000          MOV      r0,r0                 ;787
000aec  e1a00000          MOV      r0,r0                 ;788
                  |L5.2800|
000af0  e1a00000          MOV      r0,r0                 ;682
000af4  e3a00000          MOV      r0,#0                 ;790
000af8  eafffd78          B        |L5.224|
;;;792    
                          ENDP


                          AREA ||i.tcp_receive||, CODE, READONLY, ALIGN=2

                  tcp_receive PROC
;;;846    static void
;;;847    tcp_receive(struct tcp_pcb *pcb)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;848    {
000004  e1a04000          MOV      r4,r0
;;;849      struct tcp_seg *next;
;;;850    #if TCP_QUEUE_OOSEQ
;;;851      struct tcp_seg *prev, *cseg;
;;;852    #endif /* TCP_QUEUE_OOSEQ */
;;;853      struct pbuf *p;
;;;854      s32_t off;
;;;855      s16_t m;
;;;856      u32_t right_wnd_edge;
;;;857      u16_t new_tot_len;
;;;858      int found_dupack = 0;
000008  e3a00000          MOV      r0,#0
00000c  e58d0004          STR      r0,[sp,#4]
;;;859    #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;860      u32_t ooseq_blen;
;;;861      u16_t ooseq_qlen;
;;;862    #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;863    
;;;864      LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
000010  e1a00000          MOV      r0,r0
000014  e5d40018          LDRB     r0,[r4,#0x18]
000018  e3500004          CMP      r0,#4
00001c  aa000006          BGE      |L6.60|
000020  e1a00000          MOV      r0,r0
000024  e28f3e35          ADR      r3,|L6.892|
000028  e3a02e36          MOV      r2,#0x360
00002c  e28f1fda          ADR      r1,|L6.924|
000030  e28f0d0e          ADR      r0,|L6.952|
000034  ebfffffe          BL       sysprintf
000038  e1a00000          MOV      r0,r0
                  |L6.60|
00003c  e1a00000          MOV      r0,r0
;;;865    
;;;866      if (flags & TCP_ACK) {
000040  e59f0398          LDR      r0,|L6.992|
000044  e5d00000          LDRB     r0,[r0,#0]  ; flags
000048  e2000010          AND      r0,r0,#0x10
00004c  e3500000          CMP      r0,#0
000050  0a000201          BEQ      |L6.2140|
;;;867        right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
000054  e1d406b0          LDRH     r0,[r4,#0x60]
000058  e5941058          LDR      r1,[r4,#0x58]
00005c  e0800001          ADD      r0,r0,r1
000060  e58d000c          STR      r0,[sp,#0xc]
;;;868    
;;;869        /* Update window. */
;;;870        if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
000064  e59f1378          LDR      r1,|L6.996|
000068  e5940054          LDR      r0,[r4,#0x54]
00006c  e5911000          LDR      r1,[r1,#0]  ; seqno
000070  e0500001          SUBS     r0,r0,r1
000074  4a000016          BMI      |L6.212|
;;;871           (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
000078  e59f1364          LDR      r1,|L6.996|
00007c  e5940054          LDR      r0,[r4,#0x54]
000080  e5911000          LDR      r1,[r1,#0]  ; seqno
000084  e1500001          CMP      r0,r1
000088  1a000004          BNE      |L6.160|
00008c  e59f1354          LDR      r1,|L6.1000|
000090  e5940058          LDR      r0,[r4,#0x58]
000094  e5911000          LDR      r1,[r1,#0]  ; ackno
000098  e0500001          SUBS     r0,r0,r1
00009c  4a00000c          BMI      |L6.212|
                  |L6.160|
;;;872           (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
0000a0  e59f1340          LDR      r1,|L6.1000|
0000a4  e5940058          LDR      r0,[r4,#0x58]
0000a8  e5911000          LDR      r1,[r1,#0]  ; ackno
0000ac  e1500001          CMP      r0,r1
0000b0  1a000031          BNE      |L6.380|
0000b4  e59f0330          LDR      r0,|L6.1004|
0000b8  e5900000          LDR      r0,[r0,#0]  ; tcphdr
0000bc  e5d0100f          LDRB     r1,[r0,#0xf]
0000c0  e5d0000e          LDRB     r0,[r0,#0xe]
0000c4  e1800401          ORR      r0,r0,r1,LSL #8
0000c8  e1d416b0          LDRH     r1,[r4,#0x60]
0000cc  e1500001          CMP      r0,r1
0000d0  da000029          BLE      |L6.380|
                  |L6.212|
;;;873          pcb->snd_wnd = tcphdr->wnd;
0000d4  e59f0310          LDR      r0,|L6.1004|
0000d8  e5900000          LDR      r0,[r0,#0]  ; tcphdr
0000dc  e5d0100f          LDRB     r1,[r0,#0xf]
0000e0  e5d0000e          LDRB     r0,[r0,#0xe]
0000e4  e1800401          ORR      r0,r0,r1,LSL #8
0000e8  e1c406b0          STRH     r0,[r4,#0x60]
;;;874          /* keep track of the biggest window announced by the remote host to calculate
;;;875             the maximum segment size */
;;;876          if (pcb->snd_wnd_max < tcphdr->wnd) {
0000ec  e1d406b2          LDRH     r0,[r4,#0x62]
0000f0  e59f12f4          LDR      r1,|L6.1004|
0000f4  e5911000          LDR      r1,[r1,#0]  ; tcphdr
0000f8  e5d1200f          LDRB     r2,[r1,#0xf]
0000fc  e5d1100e          LDRB     r1,[r1,#0xe]
000100  e1811402          ORR      r1,r1,r2,LSL #8
000104  e1500001          CMP      r0,r1
000108  aa000005          BGE      |L6.292|
;;;877            pcb->snd_wnd_max = tcphdr->wnd;
00010c  e59f02d8          LDR      r0,|L6.1004|
000110  e5900000          LDR      r0,[r0,#0]  ; tcphdr
000114  e5d0100f          LDRB     r1,[r0,#0xf]
000118  e5d0000e          LDRB     r0,[r0,#0xe]
00011c  e1800401          ORR      r0,r0,r1,LSL #8
000120  e1c406b2          STRH     r0,[r4,#0x62]
                  |L6.292|
;;;878          }
;;;879          pcb->snd_wl1 = seqno;
000124  e59f02b8          LDR      r0,|L6.996|
000128  e5900000          LDR      r0,[r0,#0]  ; seqno
00012c  e5840054          STR      r0,[r4,#0x54]
;;;880          pcb->snd_wl2 = ackno;
000130  e59f02b0          LDR      r0,|L6.1000|
000134  e5900000          LDR      r0,[r0,#0]  ; ackno
000138  e5840058          STR      r0,[r4,#0x58]
;;;881          if (pcb->snd_wnd == 0) {
00013c  e1d406b0          LDRH     r0,[r4,#0x60]
000140  e3500000          CMP      r0,#0
000144  1a000007          BNE      |L6.360|
;;;882            if (pcb->persist_backoff == 0) {
000148  e5d40095          LDRB     r0,[r4,#0x95]
00014c  e3500000          CMP      r0,#0
000150  1a000009          BNE      |L6.380|
;;;883              /* start persist timer */
;;;884              pcb->persist_cnt = 0;
000154  e3a00000          MOV      r0,#0
000158  e5c40094          STRB     r0,[r4,#0x94]
;;;885              pcb->persist_backoff = 1;
00015c  e3a00001          MOV      r0,#1
000160  e5c40095          STRB     r0,[r4,#0x95]
000164  ea000004          B        |L6.380|
                  |L6.360|
;;;886            }
;;;887          } else if (pcb->persist_backoff > 0) {
000168  e5d40095          LDRB     r0,[r4,#0x95]
00016c  e3500000          CMP      r0,#0
000170  da000001          BLE      |L6.380|
;;;888            /* stop persist timer */
;;;889              pcb->persist_backoff = 0;
000174  e3a00000          MOV      r0,#0
000178  e5c40095          STRB     r0,[r4,#0x95]
                  |L6.380|
;;;890          }
;;;891          LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"U16_F"\n", pcb->snd_wnd));
;;;892    #if TCP_WND_DEBUG
;;;893        } else {
;;;894          if (pcb->snd_wnd != tcphdr->wnd) {
;;;895            LWIP_DEBUGF(TCP_WND_DEBUG, 
;;;896                        ("tcp_receive: no window update lastack %"U32_F" ackno %"
;;;897                         U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
;;;898                         pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
;;;899          }
;;;900    #endif /* TCP_WND_DEBUG */
;;;901        }
;;;902    
;;;903        /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
;;;904         * duplicate ack if:
;;;905         * 1) It doesn't ACK new data 
;;;906         * 2) length of received packet is zero (i.e. no payload) 
;;;907         * 3) the advertised window hasn't changed 
;;;908         * 4) There is outstanding unacknowledged data (retransmission timer running)
;;;909         * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
;;;910         * 
;;;911         * If it passes all five, should process as a dupack: 
;;;912         * a) dupacks < 3: do nothing 
;;;913         * b) dupacks == 3: fast retransmit 
;;;914         * c) dupacks > 3: increase cwnd 
;;;915         * 
;;;916         * If it only passes 1-3, should reset dupack counter (and add to
;;;917         * stats, which we don't do in lwIP)
;;;918         *
;;;919         * If it only passes 1, should reset dupack counter
;;;920         *
;;;921         */
;;;922    
;;;923        /* Clause 1 */
;;;924        if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
00017c  e59f1264          LDR      r1,|L6.1000|
000180  e5940048          LDR      r0,[r4,#0x48]
000184  e5911000          LDR      r1,[r1,#0]  ; ackno
000188  e0410000          SUB      r0,r1,r0
00018c  e3500000          CMP      r0,#0
000190  ca000039          BGT      |L6.636|
;;;925          pcb->acked = 0;
000194  e3a00000          MOV      r0,#0
000198  e1c406b4          STRH     r0,[r4,#0x64]
;;;926          /* Clause 2 */
;;;927          if (tcplen == 0) {
00019c  e59f024c          LDR      r0,|L6.1008|
0001a0  e1d000b0          LDRH     r0,[r0,#0]  ; tcplen
0001a4  e3500000          CMP      r0,#0
0001a8  1a00002d          BNE      |L6.612|
;;;928            /* Clause 3 */
;;;929            if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
0001ac  e5940058          LDR      r0,[r4,#0x58]
0001b0  e1d416b0          LDRH     r1,[r4,#0x60]
0001b4  e0811000          ADD      r1,r1,r0
0001b8  e59d000c          LDR      r0,[sp,#0xc]
0001bc  e1510000          CMP      r1,r0
0001c0  1a000027          BNE      |L6.612|
;;;930              /* Clause 4 */
;;;931              if (pcb->rtime >= 0) {
0001c4  e1d403f4          LDRSH    r0,[r4,#0x34]
0001c8  e3500000          CMP      r0,#0
0001cc  ba000024          BLT      |L6.612|
;;;932                /* Clause 5 */
;;;933                if (pcb->lastack == ackno) {
0001d0  e59f1210          LDR      r1,|L6.1000|
0001d4  e5940048          LDR      r0,[r4,#0x48]
0001d8  e5911000          LDR      r1,[r1,#0]  ; ackno
0001dc  e1500001          CMP      r0,r1
0001e0  1a00001f          BNE      |L6.612|
;;;934                  found_dupack = 1;
0001e4  e3a00001          MOV      r0,#1
0001e8  e58d0004          STR      r0,[sp,#4]
;;;935                  if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
0001ec  e5d40047          LDRB     r0,[r4,#0x47]
0001f0  e2800001          ADD      r0,r0,#1
0001f4  e20000ff          AND      r0,r0,#0xff
0001f8  e5d41047          LDRB     r1,[r4,#0x47]
0001fc  e1500001          CMP      r0,r1
000200  da000002          BLE      |L6.528|
;;;936                    ++pcb->dupacks;
000204  e5d40047          LDRB     r0,[r4,#0x47]
000208  e2800001          ADD      r0,r0,#1
00020c  e5c40047          STRB     r0,[r4,#0x47]
                  |L6.528|
;;;937                  }
;;;938                  if (pcb->dupacks > 3) {
000210  e5d40047          LDRB     r0,[r4,#0x47]
000214  e3500003          CMP      r0,#3
000218  da00000c          BLE      |L6.592|
;;;939                    /* Inflate the congestion window, but not if it means that
;;;940                       the value overflows. */
;;;941                    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
00021c  e1d404bc          LDRH     r0,[r4,#0x4c]
000220  e1d413b6          LDRH     r1,[r4,#0x36]
000224  e0800001          ADD      r0,r0,r1
000228  e3c00801          BIC      r0,r0,#0x10000
00022c  e1d414bc          LDRH     r1,[r4,#0x4c]
000230  e1500001          CMP      r0,r1
000234  da00000a          BLE      |L6.612|
;;;942                      pcb->cwnd += pcb->mss;
000238  e1d404bc          LDRH     r0,[r4,#0x4c]
00023c  e1d413b6          LDRH     r1,[r4,#0x36]
000240  e0800001          ADD      r0,r0,r1
000244  e3c00801          BIC      r0,r0,#0x10000
000248  e1c404bc          STRH     r0,[r4,#0x4c]
00024c  ea000004          B        |L6.612|
                  |L6.592|
;;;943                    }
;;;944                  } else if (pcb->dupacks == 3) {
000250  e5d40047          LDRB     r0,[r4,#0x47]
000254  e3500003          CMP      r0,#3
000258  1a000001          BNE      |L6.612|
;;;945                    /* Do fast retransmit */
;;;946                    tcp_rexmit_fast(pcb);
00025c  e1a00004          MOV      r0,r4
000260  ebfffffe          BL       tcp_rexmit_fast
                  |L6.612|
;;;947                  }
;;;948                }
;;;949              }
;;;950            }
;;;951          }
;;;952          /* If Clause (1) or more is true, but not a duplicate ack, reset
;;;953           * count of consecutive duplicate acks */
;;;954          if (!found_dupack) {
000264  e59d0004          LDR      r0,[sp,#4]
000268  e3500000          CMP      r0,#0
00026c  1a0000d3          BNE      |L6.1472|
;;;955            pcb->dupacks = 0;
000270  e3a00000          MOV      r0,#0
000274  e5c40047          STRB     r0,[r4,#0x47]
000278  ea0000d0          B        |L6.1472|
                  |L6.636|
;;;956          }
;;;957        } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
00027c  e5940048          LDR      r0,[r4,#0x48]
000280  e2800001          ADD      r0,r0,#1
000284  e59f115c          LDR      r1,|L6.1000|
000288  e5911000          LDR      r1,[r1,#0]  ; ackno
00028c  e0510000          SUBS     r0,r1,r0
000290  4a0000c8          BMI      |L6.1464|
000294  e59f114c          LDR      r1,|L6.1000|
000298  e5940050          LDR      r0,[r4,#0x50]
00029c  e5911000          LDR      r1,[r1,#0]  ; ackno
0002a0  e0410000          SUB      r0,r1,r0
0002a4  e3500000          CMP      r0,#0
0002a8  ca0000c2          BGT      |L6.1464|
;;;958          /* We come here when the ACK acknowledges new data. */
;;;959    
;;;960          /* Reset the "IN Fast Retransmit" flag, since we are no longer
;;;961             in fast retransmit. Also reset the congestion window to the
;;;962             slow start threshold. */
;;;963          if (pcb->flags & TF_INFR) {
0002ac  e5d4001e          LDRB     r0,[r4,#0x1e]
0002b0  e2000004          AND      r0,r0,#4
0002b4  e3500000          CMP      r0,#0
0002b8  0a000004          BEQ      |L6.720|
;;;964            pcb->flags &= ~TF_INFR;
0002bc  e5d4001e          LDRB     r0,[r4,#0x1e]
0002c0  e3c00004          BIC      r0,r0,#4
0002c4  e5c4001e          STRB     r0,[r4,#0x1e]
;;;965            pcb->cwnd = pcb->ssthresh;
0002c8  e1d404be          LDRH     r0,[r4,#0x4e]
0002cc  e1c404bc          STRH     r0,[r4,#0x4c]
                  |L6.720|
;;;966          }
;;;967    
;;;968          /* Reset the number of retransmissions. */
;;;969          pcb->nrtx = 0;
0002d0  e3a00000          MOV      r0,#0
0002d4  e5c40046          STRB     r0,[r4,#0x46]
;;;970    
;;;971          /* Reset the retransmission time-out. */
;;;972          pcb->rto = (pcb->sa >> 3) + pcb->sv;
0002d8  e1d404b2          LDRH     r0,[r4,#0x42]
0002dc  e1d414f0          LDRSH    r1,[r4,#0x40]
0002e0  e08001c1          ADD      r0,r0,r1,ASR #3
0002e4  e1a00800          LSL      r0,r0,#16
0002e8  e1a00840          ASR      r0,r0,#16
0002ec  e1c404b4          STRH     r0,[r4,#0x44]
;;;973    
;;;974          /* Update the send buffer space. Diff between the two can never exceed 64K? */
;;;975          pcb->acked = (u16_t)(ackno - pcb->lastack);
0002f0  e1d404b8          LDRH     r0,[r4,#0x48]
0002f4  e59f10ec          LDR      r1,|L6.1000|
0002f8  e1d110b0          LDRH     r1,[r1,#0]  ; ackno
0002fc  e0410000          SUB      r0,r1,r0
000300  e1c406b4          STRH     r0,[r4,#0x64]
;;;976    
;;;977          pcb->snd_buf += pcb->acked;
000304  e1d406b6          LDRH     r0,[r4,#0x66]
000308  e1d416b4          LDRH     r1,[r4,#0x64]
00030c  e0800001          ADD      r0,r0,r1
000310  e3c00801          BIC      r0,r0,#0x10000
000314  e1c406b6          STRH     r0,[r4,#0x66]
;;;978    
;;;979          /* Reset the fast retransmit variables. */
;;;980          pcb->dupacks = 0;
000318  e3a00000          MOV      r0,#0
00031c  e5c40047          STRB     r0,[r4,#0x47]
;;;981          pcb->lastack = ackno;
000320  e59f00c0          LDR      r0,|L6.1000|
000324  e5900000          LDR      r0,[r0,#0]  ; ackno
000328  e5840048          STR      r0,[r4,#0x48]
;;;982    
;;;983          /* Update the congestion control variables (cwnd and
;;;984             ssthresh). */
;;;985          if (pcb->state >= ESTABLISHED) {
00032c  e5d40018          LDRB     r0,[r4,#0x18]
000330  e3500004          CMP      r0,#4
000334  ba00003b          BLT      |L6.1064|
;;;986            if (pcb->cwnd < pcb->ssthresh) {
000338  e1d404bc          LDRH     r0,[r4,#0x4c]
00033c  e1d414be          LDRH     r1,[r4,#0x4e]
000340  e1500001          CMP      r0,r1
000344  aa00002a          BGE      |L6.1012|
;;;987              if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
000348  e1d404bc          LDRH     r0,[r4,#0x4c]
00034c  e1d413b6          LDRH     r1,[r4,#0x36]
000350  e0800001          ADD      r0,r0,r1
000354  e3c00801          BIC      r0,r0,#0x10000
000358  e1d414bc          LDRH     r1,[r4,#0x4c]
00035c  e1500001          CMP      r0,r1
000360  da000030          BLE      |L6.1064|
;;;988                pcb->cwnd += pcb->mss;
000364  e1d404bc          LDRH     r0,[r4,#0x4c]
000368  e1d413b6          LDRH     r1,[r4,#0x36]
00036c  e0800001          ADD      r0,r0,r1
000370  e3c00801          BIC      r0,r0,#0x10000
000374  e1c404bc          STRH     r0,[r4,#0x4c]
000378  ea00002a          B        |L6.1064|
                  |L6.892|
00037c  6c776970          DCB      "lwip-1.4.1\\src\\core\\tcp_in.c",0
000380  2d312e34
000384  2e315c73
000388  72635c63
00038c  6f72655c
000390  7463705f
000394  696e2e63
000398  00      
000399  00                DCB      0
00039a  00                DCB      0
00039b  00                DCB      0
                  |L6.924|
00039c  7463705f          DCB      "tcp_receive: wrong state",0
0003a0  72656365
0003a4  6976653a
0003a8  2077726f
0003ac  6e672073
0003b0  74617465
0003b4  00      
0003b5  00                DCB      0
0003b6  00                DCB      0
0003b7  00                DCB      0
                  |L6.952|
0003b8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0003bc  7274696f
0003c0  6e202225
0003c4  73222066
0003c8  61696c65
0003cc  64206174
0003d0  206c696e
0003d4  65202564
0003d8  20696e20
0003dc  25730a00
                  |L6.992|
                          DCD      flags
                  |L6.996|
                          DCD      seqno
                  |L6.1000|
                          DCD      ackno
                  |L6.1004|
                          DCD      tcphdr
                  |L6.1008|
                          DCD      tcplen
                  |L6.1012|
;;;989              }
;;;990              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
;;;991            } else {
;;;992              u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
0003f4  e1d423b6          LDRH     r2,[r4,#0x36]
0003f8  e0000292          MUL      r0,r2,r2
0003fc  e1d414bc          LDRH     r1,[r4,#0x4c]
000400  ebfffffe          BL       __aeabi_idivmod
000404  e1d414bc          LDRH     r1,[r4,#0x4c]
000408  e0800001          ADD      r0,r0,r1
00040c  e1a0b800          LSL      r11,r0,#16
000410  e1a0b82b          LSR      r11,r11,#16
;;;993              if (new_cwnd > pcb->cwnd) {
000414  e1d404bc          LDRH     r0,[r4,#0x4c]
000418  e150000b          CMP      r0,r11
00041c  aa000000          BGE      |L6.1060|
;;;994                pcb->cwnd = new_cwnd;
000420  e1c4b4bc          STRH     r11,[r4,#0x4c]
                  |L6.1060|
;;;995              }
;;;996              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"U16_F"\n", pcb->cwnd));
;;;997            }
000424  e1a00000          MOV      r0,r0
                  |L6.1064|
;;;998          }
;;;999          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
;;;1000                                       ackno,
;;;1001                                       pcb->unacked != NULL?
;;;1002                                       ntohl(pcb->unacked->tcphdr->seqno): 0,
;;;1003                                       pcb->unacked != NULL?
;;;1004                                       ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));
;;;1005   
;;;1006         /* Remove segment from the unacknowledged list if the incoming
;;;1007            ACK acknowlegdes them. */
;;;1008         while (pcb->unacked != NULL &&
000428  ea000038          B        |L6.1296|
                  |L6.1068|
;;;1009                TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
;;;1010                            TCP_TCPLEN(pcb->unacked), ackno)) {
;;;1011           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
;;;1012                                         ntohl(pcb->unacked->tcphdr->seqno),
;;;1013                                         ntohl(pcb->unacked->tcphdr->seqno) +
;;;1014                                         TCP_TCPLEN(pcb->unacked)));
;;;1015   
;;;1016           next = pcb->unacked;
00042c  e5945070          LDR      r5,[r4,#0x70]
;;;1017           pcb->unacked = pcb->unacked->next;
000430  e5940070          LDR      r0,[r4,#0x70]
000434  e5900000          LDR      r0,[r0,#0]
000438  e5840070          STR      r0,[r4,#0x70]
;;;1018   
;;;1019           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
;;;1020           LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
00043c  e1a00000          MOV      r0,r0
000440  e5950004          LDR      r0,[r5,#4]
000444  ebfffffe          BL       pbuf_clen
000448  e1d416b8          LDRH     r1,[r4,#0x68]
00044c  e1500001          CMP      r0,r1
000450  da000006          BLE      |L6.1136|
000454  e1a00000          MOV      r0,r0
000458  e24f30e4          ADR      r3,|L6.892|
00045c  e3a02fff          MOV      r2,#0x3fc
000460  e28f1fe6          ADR      r1,|L6.2048|
000464  e24f00b4          ADR      r0,|L6.952|
000468  ebfffffe          BL       sysprintf
00046c  e1a00000          MOV      r0,r0
                  |L6.1136|
000470  e1a00000          MOV      r0,r0
;;;1021           /* Prevent ACK for FIN to generate a sent event */
;;;1022           if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
000474  e1d406b4          LDRH     r0,[r4,#0x64]
000478  e3500000          CMP      r0,#0
00047c  0a00000a          BEQ      |L6.1196|
000480  e5951010          LDR      r1,[r5,#0x10]
000484  e5d1200d          LDRB     r2,[r1,#0xd]
000488  e5d1100c          LDRB     r1,[r1,#0xc]
00048c  e1810402          ORR      r0,r1,r2,LSL #8
000490  ebfffffe          BL       lwip_ntohs
000494  e2000001          AND      r0,r0,#1
000498  e3500000          CMP      r0,#0
00049c  0a000002          BEQ      |L6.1196|
;;;1023             pcb->acked--;
0004a0  e1d406b4          LDRH     r0,[r4,#0x64]
0004a4  e2400001          SUB      r0,r0,#1
0004a8  e1c406b4          STRH     r0,[r4,#0x64]
                  |L6.1196|
;;;1024           }
;;;1025   
;;;1026           pcb->snd_queuelen -= pbuf_clen(next->p);
0004ac  e5950004          LDR      r0,[r5,#4]
0004b0  ebfffffe          BL       pbuf_clen
0004b4  e1d416b8          LDRH     r1,[r4,#0x68]
0004b8  e0410000          SUB      r0,r1,r0
0004bc  e1c406b8          STRH     r0,[r4,#0x68]
;;;1027           tcp_seg_free(next);
0004c0  e1a00005          MOV      r0,r5
0004c4  ebfffffe          BL       tcp_seg_free
;;;1028   
;;;1029           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
;;;1030           if (pcb->snd_queuelen != 0) {
0004c8  e1d406b8          LDRH     r0,[r4,#0x68]
0004cc  e3500000          CMP      r0,#0
0004d0  0a00000e          BEQ      |L6.1296|
;;;1031             LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
0004d4  e1a00000          MOV      r0,r0
0004d8  e5940070          LDR      r0,[r4,#0x70]
0004dc  e3500000          CMP      r0,#0
0004e0  1a000009          BNE      |L6.1292|
0004e4  e594006c          LDR      r0,[r4,#0x6c]
0004e8  e3500000          CMP      r0,#0
0004ec  1a000006          BNE      |L6.1292|
0004f0  e1a00000          MOV      r0,r0
0004f4  e24f3d06          ADR      r3,|L6.892|
0004f8  e59f2328          LDR      r2,|L6.2088|
0004fc  e28f1fca          ADR      r1,|L6.2092|
000500  e24f0e15          ADR      r0,|L6.952|
000504  ebfffffe          BL       sysprintf
000508  e1a00000          MOV      r0,r0
                  |L6.1292|
00050c  e1a00000          MOV      r0,r0
                  |L6.1296|
000510  e5940070          LDR      r0,[r4,#0x70]         ;1008
000514  e3500000          CMP      r0,#0                 ;1008
000518  0a00001b          BEQ      |L6.1420|
00051c  e5941070          LDR      r1,[r4,#0x70]         ;1009
000520  e5911010          LDR      r1,[r1,#0x10]         ;1009
000524  e2810004          ADD      r0,r1,#4              ;1009
000528  ebfffffe          BL       __aeabi_uread4
00052c  e58d0000          STR      r0,[sp,#0]            ;1009
000530  ebfffffe          BL       lwip_ntohl
000534  e1a0b000          MOV      r11,r0                ;1009
000538  e5941070          LDR      r1,[r4,#0x70]         ;1009
00053c  e5911010          LDR      r1,[r1,#0x10]         ;1009
000540  e5d1200d          LDRB     r2,[r1,#0xd]          ;1009
000544  e5d1100c          LDRB     r1,[r1,#0xc]          ;1009
000548  e1810402          ORR      r0,r1,r2,LSL #8       ;1009
00054c  ebfffffe          BL       lwip_ntohs
000550  e2000003          AND      r0,r0,#3              ;1009
000554  e3500000          CMP      r0,#0                 ;1009
000558  0a000001          BEQ      |L6.1380|
00055c  e3a00001          MOV      r0,#1                 ;1009
000560  ea000000          B        |L6.1384|
                  |L6.1380|
000564  e3a00000          MOV      r0,#0                 ;1009
                  |L6.1384|
000568  e5941070          LDR      r1,[r4,#0x70]         ;1009
00056c  e1d110b8          LDRH     r1,[r1,#8]            ;1009
000570  e0800001          ADD      r0,r0,r1              ;1009
000574  e080000b          ADD      r0,r0,r11             ;1009
000578  e51f1198          LDR      r1,|L6.1000|
00057c  e5911000          LDR      r1,[r1,#0]            ;1009  ; ackno
000580  e0400001          SUB      r0,r0,r1              ;1009
000584  e3500000          CMP      r0,#0                 ;1009
000588  daffffa7          BLE      |L6.1068|
                  |L6.1420|
;;;1032                         pcb->unsent != NULL);
;;;1033           }
;;;1034         }
;;;1035   
;;;1036         /* If there's nothing left to acknowledge, stop the retransmit
;;;1037            timer, otherwise reset it to start again */
;;;1038         if(pcb->unacked == NULL)
00058c  e5940070          LDR      r0,[r4,#0x70]
000590  e3500000          CMP      r0,#0
000594  1a000002          BNE      |L6.1444|
;;;1039           pcb->rtime = -1;
000598  e3e00000          MVN      r0,#0
00059c  e1c403b4          STRH     r0,[r4,#0x34]
0005a0  ea000001          B        |L6.1452|
                  |L6.1444|
;;;1040         else
;;;1041           pcb->rtime = 0;
0005a4  e3a00000          MOV      r0,#0
0005a8  e1c403b4          STRH     r0,[r4,#0x34]
                  |L6.1452|
;;;1042   
;;;1043         pcb->polltmr = 0;
0005ac  e3a00000          MOV      r0,#0
0005b0  e5c4001f          STRB     r0,[r4,#0x1f]
0005b4  ea000001          B        |L6.1472|
                  |L6.1464|
;;;1044       } else {
;;;1045         /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
;;;1046         pcb->acked = 0;
0005b8  e3a00000          MOV      r0,#0
0005bc  e1c406b4          STRH     r0,[r4,#0x64]
                  |L6.1472|
;;;1047       }
;;;1048   
;;;1049       /* We go through the ->unsent list to see if any of the segments
;;;1050          on the list are acknowledged by the ACK. This may seem
;;;1051          strange since an "unsent" segment shouldn't be acked. The
;;;1052          rationale is that lwIP puts all outstanding segments on the
;;;1053          ->unsent list after a retransmission, so these segments may
;;;1054          in fact have been sent once. */
;;;1055       while (pcb->unsent != NULL &&
0005c0  ea00003d          B        |L6.1724|
                  |L6.1476|
;;;1056              TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
;;;1057                              TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
;;;1058         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
;;;1059                                       ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
;;;1060                                       TCP_TCPLEN(pcb->unsent)));
;;;1061   
;;;1062         next = pcb->unsent;
0005c4  e594506c          LDR      r5,[r4,#0x6c]
;;;1063         pcb->unsent = pcb->unsent->next;
0005c8  e594006c          LDR      r0,[r4,#0x6c]
0005cc  e5900000          LDR      r0,[r0,#0]
0005d0  e584006c          STR      r0,[r4,#0x6c]
;;;1064   #if TCP_OVERSIZE
;;;1065         if (pcb->unsent == NULL) {
0005d4  e594006c          LDR      r0,[r4,#0x6c]
0005d8  e3500000          CMP      r0,#0
0005dc  1a000001          BNE      |L6.1512|
;;;1066           pcb->unsent_oversize = 0;
0005e0  e3a00000          MOV      r0,#0
0005e4  e1c406ba          STRH     r0,[r4,#0x6a]
                  |L6.1512|
;;;1067         }
;;;1068   #endif /* TCP_OVERSIZE */ 
;;;1069         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
;;;1070         LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
0005e8  e1a00000          MOV      r0,r0
0005ec  e5950004          LDR      r0,[r5,#4]
0005f0  ebfffffe          BL       pbuf_clen
0005f4  e1d416b8          LDRH     r1,[r4,#0x68]
0005f8  e1500001          CMP      r0,r1
0005fc  da000006          BLE      |L6.1564|
000600  e1a00000          MOV      r0,r0
000604  e24f3e29          ADR      r3,|L6.892|
000608  e59f223c          LDR      r2,|L6.2124|
00060c  e28f1f7b          ADR      r1,|L6.2048|
000610  e24f0e26          ADR      r0,|L6.952|
000614  ebfffffe          BL       sysprintf
000618  e1a00000          MOV      r0,r0
                  |L6.1564|
00061c  e1a00000          MOV      r0,r0
;;;1071         /* Prevent ACK for FIN to generate a sent event */
;;;1072         if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
000620  e1d406b4          LDRH     r0,[r4,#0x64]
000624  e3500000          CMP      r0,#0
000628  0a00000a          BEQ      |L6.1624|
00062c  e5952010          LDR      r2,[r5,#0x10]
000630  e5d2100d          LDRB     r1,[r2,#0xd]
000634  e5d2200c          LDRB     r2,[r2,#0xc]
000638  e1820401          ORR      r0,r2,r1,LSL #8
00063c  ebfffffe          BL       lwip_ntohs
000640  e2000001          AND      r0,r0,#1
000644  e3500000          CMP      r0,#0
000648  0a000002          BEQ      |L6.1624|
;;;1073           pcb->acked--;
00064c  e1d406b4          LDRH     r0,[r4,#0x64]
000650  e2400001          SUB      r0,r0,#1
000654  e1c406b4          STRH     r0,[r4,#0x64]
                  |L6.1624|
;;;1074         }
;;;1075         pcb->snd_queuelen -= pbuf_clen(next->p);
000658  e5950004          LDR      r0,[r5,#4]
00065c  ebfffffe          BL       pbuf_clen
000660  e1d416b8          LDRH     r1,[r4,#0x68]
000664  e0410000          SUB      r0,r1,r0
000668  e1c406b8          STRH     r0,[r4,#0x68]
;;;1076         tcp_seg_free(next);
00066c  e1a00005          MOV      r0,r5
000670  ebfffffe          BL       tcp_seg_free
;;;1077         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
;;;1078         if (pcb->snd_queuelen != 0) {
000674  e1d406b8          LDRH     r0,[r4,#0x68]
000678  e3500000          CMP      r0,#0
00067c  0a00000e          BEQ      |L6.1724|
;;;1079           LWIP_ASSERT("tcp_receive: valid queue length",
000680  e1a00000          MOV      r0,r0
000684  e5940070          LDR      r0,[r4,#0x70]
000688  e3500000          CMP      r0,#0
00068c  1a000009          BNE      |L6.1720|
000690  e594006c          LDR      r0,[r4,#0x6c]
000694  e3500000          CMP      r0,#0
000698  1a000006          BNE      |L6.1720|
00069c  e1a00000          MOV      r0,r0
0006a0  e24f3fcb          ADR      r3,|L6.892|
0006a4  e59f21a4          LDR      r2,|L6.2128|
0006a8  e28f1f5f          ADR      r1,|L6.2092|
0006ac  e24f0fbf          ADR      r0,|L6.952|
0006b0  ebfffffe          BL       sysprintf
0006b4  e1a00000          MOV      r0,r0
                  |L6.1720|
0006b8  e1a00000          MOV      r0,r0
                  |L6.1724|
0006bc  e594006c          LDR      r0,[r4,#0x6c]         ;1055
0006c0  e3500000          CMP      r0,#0                 ;1055
0006c4  0a000020          BEQ      |L6.1868|
0006c8  e594106c          LDR      r1,[r4,#0x6c]         ;1056
0006cc  e5911010          LDR      r1,[r1,#0x10]         ;1056
0006d0  e2810004          ADD      r0,r1,#4              ;1056
0006d4  ebfffffe          BL       __aeabi_uread4
0006d8  e58d0000          STR      r0,[sp,#0]            ;1056
0006dc  ebfffffe          BL       lwip_ntohl
0006e0  e1a0b000          MOV      r11,r0                ;1056
0006e4  e594106c          LDR      r1,[r4,#0x6c]         ;1056
0006e8  e5912010          LDR      r2,[r1,#0x10]         ;1056
0006ec  e5d2100d          LDRB     r1,[r2,#0xd]          ;1056
0006f0  e5d2200c          LDRB     r2,[r2,#0xc]          ;1056
0006f4  e1820401          ORR      r0,r2,r1,LSL #8       ;1056
0006f8  ebfffffe          BL       lwip_ntohs
0006fc  e2000003          AND      r0,r0,#3              ;1056
000700  e3500000          CMP      r0,#0                 ;1056
000704  0a000001          BEQ      |L6.1808|
000708  e3a00001          MOV      r0,#1                 ;1056
00070c  ea000000          B        |L6.1812|
                  |L6.1808|
000710  e3a00000          MOV      r0,#0                 ;1056
                  |L6.1812|
000714  e594106c          LDR      r1,[r4,#0x6c]         ;1056
000718  e1d110b8          LDRH     r1,[r1,#8]            ;1056
00071c  e0800001          ADD      r0,r0,r1              ;1056
000720  e080000b          ADD      r0,r0,r11             ;1056
000724  e51f1344          LDR      r1,|L6.1000|
000728  e5911000          LDR      r1,[r1,#0]            ;1056  ; ackno
00072c  e0510000          SUBS     r0,r1,r0              ;1056
000730  4a000005          BMI      |L6.1868|
000734  e51f1354          LDR      r1,|L6.1000|
000738  e5940050          LDR      r0,[r4,#0x50]         ;1056
00073c  e5911000          LDR      r1,[r1,#0]            ;1056  ; ackno
000740  e0410000          SUB      r0,r1,r0              ;1056
000744  e3500000          CMP      r0,#0                 ;1056
000748  daffff9d          BLE      |L6.1476|
                  |L6.1868|
;;;1080             pcb->unacked != NULL || pcb->unsent != NULL);
;;;1081         }
;;;1082       }
;;;1083       /* End of ACK for new data processing. */
;;;1084   
;;;1085       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
;;;1086                                   pcb->rttest, pcb->rtseq, ackno));
;;;1087   
;;;1088       /* RTT estimation calculations. This is done by checking if the
;;;1089          incoming segment acknowledges the segment we use to take a
;;;1090          round-trip time measurement. */
;;;1091       if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
00074c  e5940038          LDR      r0,[r4,#0x38]
000750  e3500000          CMP      r0,#0
000754  0a000040          BEQ      |L6.2140|
000758  e51f1378          LDR      r1,|L6.1000|
00075c  e594003c          LDR      r0,[r4,#0x3c]
000760  e5911000          LDR      r1,[r1,#0]  ; ackno
000764  e0500001          SUBS     r0,r0,r1
000768  5a00003b          BPL      |L6.2140|
;;;1092         /* diff between this shouldn't exceed 32K since this are tcp timer ticks
;;;1093            and a round-trip shouldn't be that long... */
;;;1094         m = (s16_t)(tcp_ticks - pcb->rttest);
00076c  e1d403b8          LDRH     r0,[r4,#0x38]
000770  e59f10dc          LDR      r1,|L6.2132|
000774  e1d110b0          LDRH     r1,[r1,#0]  ; tcp_ticks
000778  e0410000          SUB      r0,r1,r0
00077c  e1a00800          LSL      r0,r0,#16
000780  e1a0a840          ASR      r10,r0,#16
;;;1095   
;;;1096         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
;;;1097                                     m, m * TCP_SLOW_INTERVAL));
;;;1098   
;;;1099         /* This is taken directly from VJs original code in his paper */
;;;1100         m = m - (pcb->sa >> 3);
000784  e1d404f0          LDRSH    r0,[r4,#0x40]
000788  e04a01c0          SUB      r0,r10,r0,ASR #3
00078c  e1a00800          LSL      r0,r0,#16
000790  e1a0a840          ASR      r10,r0,#16
;;;1101         pcb->sa += m;
000794  e1d404b0          LDRH     r0,[r4,#0x40]
000798  e080000a          ADD      r0,r0,r10
00079c  e1a00800          LSL      r0,r0,#16
0007a0  e1a00840          ASR      r0,r0,#16
0007a4  e1c404b0          STRH     r0,[r4,#0x40]
;;;1102         if (m < 0) {
0007a8  e35a0000          CMP      r10,#0
0007ac  aa000002          BGE      |L6.1980|
;;;1103           m = -m;
0007b0  e26a0000          RSB      r0,r10,#0
0007b4  e1a00800          LSL      r0,r0,#16
0007b8  e1a0a840          ASR      r10,r0,#16
                  |L6.1980|
;;;1104         }
;;;1105         m = m - (pcb->sv >> 2);
0007bc  e1d404f2          LDRSH    r0,[r4,#0x42]
0007c0  e04a0140          SUB      r0,r10,r0,ASR #2
0007c4  e1a00800          LSL      r0,r0,#16
0007c8  e1a0a840          ASR      r10,r0,#16
;;;1106         pcb->sv += m;
0007cc  e1d404b2          LDRH     r0,[r4,#0x42]
0007d0  e080000a          ADD      r0,r0,r10
0007d4  e1a00800          LSL      r0,r0,#16
0007d8  e1a00840          ASR      r0,r0,#16
0007dc  e1c404b2          STRH     r0,[r4,#0x42]
;;;1107         pcb->rto = (pcb->sa >> 3) + pcb->sv;
0007e0  e1d404b2          LDRH     r0,[r4,#0x42]
0007e4  e1d414f0          LDRSH    r1,[r4,#0x40]
0007e8  e08001c1          ADD      r0,r0,r1,ASR #3
0007ec  e1a00800          LSL      r0,r0,#16
0007f0  e1a00840          ASR      r0,r0,#16
0007f4  e1c404b4          STRH     r0,[r4,#0x44]
;;;1108   
;;;1109         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
;;;1110                                     pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));
;;;1111   
;;;1112         pcb->rttest = 0;
0007f8  e3a00000          MOV      r0,#0
0007fc  ea000015          B        |L6.2136|
                  |L6.2048|
000800  7063622d          DCB      "pcb->snd_queuelen >= pbuf_clen(next->p)",0
000804  3e736e64
000808  5f717565
00080c  75656c65
000810  6e203e3d
000814  20706275
000818  665f636c
00081c  656e286e
000820  6578742d
000824  3e702900
                  |L6.2088|
                          DCD      0x00000407
                  |L6.2092|
00082c  7463705f          DCB      "tcp_receive: valid queue length",0
000830  72656365
000834  6976653a
000838  2076616c
00083c  69642071
000840  75657565
000844  206c656e
000848  67746800
                  |L6.2124|
                          DCD      0x0000042e
                  |L6.2128|
                          DCD      0x00000437
                  |L6.2132|
                          DCD      tcp_ticks
                  |L6.2136|
000858  e5840038          STR      r0,[r4,#0x38]
                  |L6.2140|
;;;1113       }
;;;1114     }
;;;1115   
;;;1116     /* If the incoming segment contains data, we must process it
;;;1117        further unless the pcb already received a FIN.
;;;1118        (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
;;;1119        LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
;;;1120     if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
00085c  e51f0474          LDR      r0,|L6.1008|
000860  e1d000b0          LDRH     r0,[r0,#0]  ; tcplen
000864  e3500000          CMP      r0,#0
000868  da0003bb          BLE      |L6.5980|
00086c  e5d40018          LDRB     r0,[r4,#0x18]
000870  e3500007          CMP      r0,#7
000874  aa0003b8          BGE      |L6.5980|
;;;1121       /* This code basically does three things:
;;;1122   
;;;1123       +) If the incoming segment contains data that is the next
;;;1124       in-sequence data, this data is passed to the application. This
;;;1125       might involve trimming the first edge of the data. The rcv_nxt
;;;1126       variable and the advertised window are adjusted.
;;;1127   
;;;1128       +) If the incoming segment has data that is above the next
;;;1129       sequence number expected (->rcv_nxt), the segment is placed on
;;;1130       the ->ooseq queue. This is done by finding the appropriate
;;;1131       place in the ->ooseq queue (which is ordered by sequence
;;;1132       number) and trim the segment in both ends if needed. An
;;;1133       immediate ACK is sent to indicate that we received an
;;;1134       out-of-sequence segment.
;;;1135   
;;;1136       +) Finally, we check if the first segment on the ->ooseq queue
;;;1137       now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
;;;1138       rcv_nxt > ooseq->seqno, we must trim the first edge of the
;;;1139       segment on ->ooseq before we adjust rcv_nxt. The data in the
;;;1140       segments that are now on sequence are chained onto the
;;;1141       incoming segment so that we only need to call the application
;;;1142       once.
;;;1143       */
;;;1144   
;;;1145       /* First, we check if we must trim the first edge. We have to do
;;;1146          this if the sequence number of the incoming segment is less
;;;1147          than rcv_nxt, and the sequence number plus the length of the
;;;1148          segment is larger than rcv_nxt. */
;;;1149       /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1150             if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
;;;1151       if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
000878  e51f149c          LDR      r1,|L6.996|
00087c  e5940028          LDR      r0,[r4,#0x28]
000880  e5911000          LDR      r1,[r1,#0]  ; seqno
000884  e2811001          ADD      r1,r1,#1
000888  e0500001          SUBS     r0,r0,r1
00088c  4a00007f          BMI      |L6.2704|
000890  e51f14b4          LDR      r1,|L6.996|
000894  e5940028          LDR      r0,[r4,#0x28]
000898  e5911000          LDR      r1,[r1,#0]  ; seqno
00089c  e51f24b4          LDR      r2,|L6.1008|
0008a0  e1d220b0          LDRH     r2,[r2,#0]  ; tcplen
0008a4  e0811002          ADD      r1,r1,r2
0008a8  e2411001          SUB      r1,r1,#1
0008ac  e0400001          SUB      r0,r0,r1
0008b0  e3500000          CMP      r0,#0
0008b4  ca000075          BGT      |L6.2704|
;;;1152         /* Trimming the first edge is done by pushing the payload
;;;1153            pointer in the pbuf downwards. This is somewhat tricky since
;;;1154            we do not want to discard the full contents of the pbuf up to
;;;1155            the new starting point of the data since we have to keep the
;;;1156            TCP header which is present in the first pbuf in the chain.
;;;1157   
;;;1158            What is done is really quite a nasty hack: the first pbuf in
;;;1159            the pbuf chain is pointed to by inseg.p. Since we need to be
;;;1160            able to deallocate the whole pbuf, we cannot change this
;;;1161            inseg.p pointer to point to any of the later pbufs in the
;;;1162            chain. Instead, we point the ->payload pointer in the first
;;;1163            pbuf to data in one of the later pbufs. We also set the
;;;1164            inseg.data pointer to point to the right place. This way, the
;;;1165            ->p pointer will still point to the first pbuf, but the
;;;1166            ->p->payload pointer will point to data in another pbuf.
;;;1167   
;;;1168            After we are done with adjusting the pbuf pointers we must
;;;1169            adjust the ->data pointer in the seg and the segment
;;;1170            length.*/
;;;1171   
;;;1172         off = pcb->rcv_nxt - seqno;
0008b8  e51f14dc          LDR      r1,|L6.996|
0008bc  e5940028          LDR      r0,[r4,#0x28]
0008c0  e5911000          LDR      r1,[r1,#0]  ; seqno
0008c4  e0408001          SUB      r8,r0,r1
;;;1173         p = inseg.p;
0008c8  e59f0380          LDR      r0,|L6.3152|
0008cc  e5909004          LDR      r9,[r0,#4]  ; inseg
;;;1174         LWIP_ASSERT("inseg.p != NULL", inseg.p);
0008d0  e1a00000          MOV      r0,r0
0008d4  e5900004          LDR      r0,[r0,#4]  ; inseg
0008d8  e3500000          CMP      r0,#0
0008dc  1a000006          BNE      |L6.2300|
0008e0  e1a00000          MOV      r0,r0
0008e4  e59f3368          LDR      r3,|L6.3156|
0008e8  e59f2368          LDR      r2,|L6.3160|
0008ec  e28f1fda          ADR      r1,|L6.3164|
0008f0  e59f0374          LDR      r0,|L6.3180|
0008f4  ebfffffe          BL       sysprintf
0008f8  e1a00000          MOV      r0,r0
                  |L6.2300|
0008fc  e1a00000          MOV      r0,r0
;;;1175         LWIP_ASSERT("insane offset!", (off < 0x7fff));
000900  e1a00000          MOV      r0,r0
000904  e59f0364          LDR      r0,|L6.3184|
000908  e1580000          CMP      r8,r0
00090c  ba000006          BLT      |L6.2348|
000910  e1a00000          MOV      r0,r0
000914  e59f3338          LDR      r3,|L6.3156|
000918  e59f2354          LDR      r2,|L6.3188|
00091c  e28f1fd5          ADR      r1,|L6.3192|
000920  e59f0344          LDR      r0,|L6.3180|
000924  ebfffffe          BL       sysprintf
000928  e1a00000          MOV      r0,r0
                  |L6.2348|
00092c  e1a00000          MOV      r0,r0
;;;1176         if (inseg.p->len < off) {
000930  e59f0318          LDR      r0,|L6.3152|
000934  e5900004          LDR      r0,[r0,#4]  ; inseg
000938  e1d000ba          LDRH     r0,[r0,#0xa]
00093c  e1500008          CMP      r0,r8
000940  aa00002f          BGE      |L6.2564|
;;;1177           LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
000944  e1a00000          MOV      r0,r0
000948  e59f0300          LDR      r0,|L6.3152|
00094c  e5900004          LDR      r0,[r0,#4]  ; inseg
000950  e1d000b8          LDRH     r0,[r0,#8]
000954  e1500008          CMP      r0,r8
000958  aa000006          BGE      |L6.2424|
00095c  e1a00000          MOV      r0,r0
000960  e59f32ec          LDR      r3,|L6.3156|
000964  e59f231c          LDR      r2,|L6.3208|
000968  e28f1fc7          ADR      r1,|L6.3212|
00096c  e59f02f8          LDR      r0,|L6.3180|
000970  ebfffffe          BL       sysprintf
000974  e1a00000          MOV      r0,r0
                  |L6.2424|
000978  e1a00000          MOV      r0,r0
;;;1178           new_tot_len = (u16_t)(inseg.p->tot_len - off);
00097c  e59f02cc          LDR      r0,|L6.3152|
000980  e5900004          LDR      r0,[r0,#4]  ; inseg
000984  e1d000b8          LDRH     r0,[r0,#8]
000988  e0400008          SUB      r0,r0,r8
00098c  e1a00800          LSL      r0,r0,#16
000990  e1a00820          LSR      r0,r0,#16
000994  e58d0008          STR      r0,[sp,#8]
;;;1179           while (p->len < off) {
000998  ea000006          B        |L6.2488|
                  |L6.2460|
;;;1180             off -= p->len;
00099c  e1d900ba          LDRH     r0,[r9,#0xa]
0009a0  e0488000          SUB      r8,r8,r0
;;;1181             /* KJM following line changed (with addition of new_tot_len var)
;;;1182                to fix bug #9076
;;;1183                inseg.p->tot_len -= p->len; */
;;;1184             p->tot_len = new_tot_len;
0009a4  e59d0008          LDR      r0,[sp,#8]
0009a8  e1c900b8          STRH     r0,[r9,#8]
;;;1185             p->len = 0;
0009ac  e3a00000          MOV      r0,#0
0009b0  e1c900ba          STRH     r0,[r9,#0xa]
;;;1186             p = p->next;
0009b4  e5999000          LDR      r9,[r9,#0]
                  |L6.2488|
0009b8  e1d900ba          LDRH     r0,[r9,#0xa]          ;1179
0009bc  e1500008          CMP      r0,r8                 ;1179
0009c0  bafffff5          BLT      |L6.2460|
;;;1187           }
;;;1188           if(pbuf_header(p, (s16_t)-off)) {
0009c4  e2680000          RSB      r0,r8,#0
0009c8  e1a01800          LSL      r1,r0,#16
0009cc  e1a01841          ASR      r1,r1,#16
0009d0  e1a00009          MOV      r0,r9
0009d4  ebfffffe          BL       pbuf_header
0009d8  e3500000          CMP      r0,#0
0009dc  0a000019          BEQ      |L6.2632|
;;;1189             /* Do we need to cope with this failing?  Assert for now */
;;;1190             LWIP_ASSERT("pbuf_header failed", 0);
0009e0  e1a00000          MOV      r0,r0
0009e4  e1a00000          MOV      r0,r0
0009e8  e59f3264          LDR      r3,|L6.3156|
0009ec  e59f22a8          LDR      r2,|L6.3228|
0009f0  e28f1faa          ADR      r1,|L6.3232|
0009f4  e59f0270          LDR      r0,|L6.3180|
0009f8  ebfffffe          BL       sysprintf
0009fc  e1a00000          MOV      r0,r0
000a00  ea000010          B        |L6.2632|
                  |L6.2564|
;;;1191           }
;;;1192         } else {
;;;1193           if(pbuf_header(inseg.p, (s16_t)-off)) {
000a04  e59f1244          LDR      r1,|L6.3152|
000a08  e5910004          LDR      r0,[r1,#4]  ; inseg
000a0c  e2681000          RSB      r1,r8,#0
000a10  e1a01801          LSL      r1,r1,#16
000a14  e1a01841          ASR      r1,r1,#16
000a18  ebfffffe          BL       pbuf_header
000a1c  e3500000          CMP      r0,#0
000a20  0a000008          BEQ      |L6.2632|
;;;1194             /* Do we need to cope with this failing?  Assert for now */
;;;1195             LWIP_ASSERT("pbuf_header failed", 0);
000a24  e1a00000          MOV      r0,r0
000a28  e1a00000          MOV      r0,r0
000a2c  e59f3220          LDR      r3,|L6.3156|
000a30  e59f227c          LDR      r2,|L6.3252|
000a34  e28f1f99          ADR      r1,|L6.3232|
000a38  e59f022c          LDR      r0,|L6.3180|
000a3c  ebfffffe          BL       sysprintf
000a40  e1a00000          MOV      r0,r0
000a44  e1a00000          MOV      r0,r0
                  |L6.2632|
;;;1196           }
;;;1197         }
;;;1198         inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
000a48  e59f0200          LDR      r0,|L6.3152|
000a4c  e1d010b8          LDRH     r1,[r0,#8]  ; inseg
000a50  e1d402b8          LDRH     r0,[r4,#0x28]
000a54  e51f2678          LDR      r2,|L6.996|
000a58  e1d220b0          LDRH     r2,[r2,#0]  ; seqno
000a5c  e0400002          SUB      r0,r0,r2
000a60  e0410000          SUB      r0,r1,r0
000a64  e59f11e4          LDR      r1,|L6.3152|
000a68  e1c100b8          STRH     r0,[r1,#8]  ; inseg
;;;1199         inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
000a6c  e2812000          ADD      r2,r1,#0
000a70  e5922010          LDR      r2,[r2,#0x10]  ; inseg
000a74  e2821004          ADD      r1,r2,#4
000a78  e51f369c          LDR      r3,|L6.996|
000a7c  e5942028          LDR      r2,[r4,#0x28]
000a80  e5832000          STR      r2,[r3,#0]  ; seqno
000a84  e1a00002          MOV      r0,r2
000a88  ebfffffe          BL       __aeabi_uwrite4
000a8c  ea000009          B        |L6.2744|
                  |L6.2704|
;;;1200       }
;;;1201       else {
;;;1202         if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
000a90  e51f16b4          LDR      r1,|L6.996|
000a94  e5940028          LDR      r0,[r4,#0x28]
000a98  e5911000          LDR      r1,[r1,#0]  ; seqno
000a9c  e0510000          SUBS     r0,r1,r0
000aa0  5a000004          BPL      |L6.2744|
;;;1203           /* the whole segment is < rcv_nxt */
;;;1204           /* must be a duplicate of a packet that has already been correctly handled */
;;;1205   
;;;1206           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
;;;1207           tcp_ack_now(pcb);
000aa4  e1a00000          MOV      r0,r0
000aa8  e5d4001e          LDRB     r0,[r4,#0x1e]
000aac  e3800002          ORR      r0,r0,#2
000ab0  e5c4001e          STRB     r0,[r4,#0x1e]
000ab4  e1a00000          MOV      r0,r0
                  |L6.2744|
;;;1208         }
;;;1209       }
;;;1210   
;;;1211       /* The sequence number must be within the window (above rcv_nxt
;;;1212          and below rcv_nxt + rcv_wnd) in order to be further
;;;1213          processed. */
;;;1214       if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
000ab8  e51f16dc          LDR      r1,|L6.996|
000abc  e5940028          LDR      r0,[r4,#0x28]
000ac0  e5911000          LDR      r1,[r1,#0]  ; seqno
000ac4  e0510000          SUBS     r0,r1,r0
000ac8  4a000320          BMI      |L6.5968|
000acc  e5940028          LDR      r0,[r4,#0x28]
000ad0  e1d412bc          LDRH     r1,[r4,#0x2c]
000ad4  e0800001          ADD      r0,r0,r1
000ad8  e2400001          SUB      r0,r0,#1
000adc  e51f1700          LDR      r1,|L6.996|
000ae0  e5911000          LDR      r1,[r1,#0]  ; seqno
000ae4  e0410000          SUB      r0,r1,r0
000ae8  e3500000          CMP      r0,#0
000aec  ca000317          BGT      |L6.5968|
;;;1215                           pcb->rcv_nxt + pcb->rcv_wnd - 1)){
;;;1216         if (pcb->rcv_nxt == seqno) {
000af0  e51f1714          LDR      r1,|L6.996|
000af4  e5940028          LDR      r0,[r4,#0x28]
000af8  e5911000          LDR      r1,[r1,#0]  ; seqno
000afc  e1500001          CMP      r0,r1
000b00  1a000210          BNE      |L6.4936|
;;;1217           /* The incoming segment is the next in sequence. We check if
;;;1218              we have to trim the end of the segment and update rcv_nxt
;;;1219              and pass the data to the application. */
;;;1220           tcplen = TCP_TCPLEN(&inseg);
000b04  e59f1144          LDR      r1,|L6.3152|
000b08  e5912010          LDR      r2,[r1,#0x10]  ; inseg
000b0c  e5d2100d          LDRB     r1,[r2,#0xd]
000b10  e5d2200c          LDRB     r2,[r2,#0xc]
000b14  e1820401          ORR      r0,r2,r1,LSL #8
000b18  ebfffffe          BL       lwip_ntohs
000b1c  e2000003          AND      r0,r0,#3
000b20  e3500000          CMP      r0,#0
000b24  0a000001          BEQ      |L6.2864|
000b28  e3a00001          MOV      r0,#1
000b2c  ea000000          B        |L6.2868|
                  |L6.2864|
000b30  e3a00000          MOV      r0,#0
                  |L6.2868|
000b34  e59f1114          LDR      r1,|L6.3152|
000b38  e1d110b8          LDRH     r1,[r1,#8]  ; inseg
000b3c  e0800001          ADD      r0,r0,r1
000b40  e51f1758          LDR      r1,|L6.1008|
000b44  e1c100b0          STRH     r0,[r1,#0]  ; tcplen
;;;1221   
;;;1222           if (tcplen > pcb->rcv_wnd) {
000b48  e1d402bc          LDRH     r0,[r4,#0x2c]
000b4c  e1d110b0          LDRH     r1,[r1,#0]  ; tcplen
000b50  e1500001          CMP      r0,r1
000b54  aa000071          BGE      |L6.3360|
;;;1223             LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1224                         ("tcp_receive: other end overran receive window"
;;;1225                          "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1226                          seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1227             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000b58  e59f10f0          LDR      r1,|L6.3152|
000b5c  e5912010          LDR      r2,[r1,#0x10]  ; inseg
000b60  e5d2100d          LDRB     r1,[r2,#0xd]
000b64  e5d2200c          LDRB     r2,[r2,#0xc]
000b68  e1820401          ORR      r0,r2,r1,LSL #8
000b6c  ebfffffe          BL       lwip_ntohs
000b70  e2000001          AND      r0,r0,#1
000b74  e3500000          CMP      r0,#0
000b78  0a000015          BEQ      |L6.3028|
;;;1228               /* Must remove the FIN from the header as we're trimming 
;;;1229                * that byte of sequence-space from the packet */
;;;1230               TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
000b7c  e59f10cc          LDR      r1,|L6.3152|
000b80  e5912010          LDR      r2,[r1,#0x10]  ; inseg
000b84  e5d2100d          LDRB     r1,[r2,#0xd]
000b88  e5d2200c          LDRB     r2,[r2,#0xc]
000b8c  e1820401          ORR      r0,r2,r1,LSL #8
000b90  ebfffffe          BL       lwip_ntohs
000b94  e200b03e          AND      r11,r0,#0x3e
000b98  e1a0000b          MOV      r0,r11
000b9c  ebfffffe          BL       lwip_htons
000ba0  e59f10a8          LDR      r1,|L6.3152|
000ba4  e5912010          LDR      r2,[r1,#0x10]  ; inseg
000ba8  e5d2100d          LDRB     r1,[r2,#0xd]
000bac  e5d2200c          LDRB     r2,[r2,#0xc]
000bb0  e1821401          ORR      r1,r2,r1,LSL #8
000bb4  e59f20fc          LDR      r2,|L6.3256|
000bb8  e0011002          AND      r1,r1,r2
000bbc  e1800001          ORR      r0,r0,r1
000bc0  e59f1088          LDR      r1,|L6.3152|
000bc4  e5911010          LDR      r1,[r1,#0x10]  ; inseg
000bc8  e5c1000c          STRB     r0,[r1,#0xc]
000bcc  e1a00420          LSR      r0,r0,#8
000bd0  e5c1000d          STRB     r0,[r1,#0xd]
                  |L6.3028|
;;;1231             }
;;;1232             /* Adjust length of segment to fit in the window. */
;;;1233             inseg.len = pcb->rcv_wnd;
000bd4  e1d402bc          LDRH     r0,[r4,#0x2c]
000bd8  e59f1070          LDR      r1,|L6.3152|
000bdc  e1c100b8          STRH     r0,[r1,#8]  ; inseg
;;;1234             if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
000be0  e5912010          LDR      r2,[r1,#0x10]  ; inseg
000be4  e5d2100d          LDRB     r1,[r2,#0xd]
000be8  e5d2200c          LDRB     r2,[r2,#0xc]
000bec  e1820401          ORR      r0,r2,r1,LSL #8
000bf0  ebfffffe          BL       lwip_ntohs
000bf4  e2000002          AND      r0,r0,#2
000bf8  e3500000          CMP      r0,#0
000bfc  0a000004          BEQ      |L6.3092|
;;;1235               inseg.len -= 1;
000c00  e59f0048          LDR      r0,|L6.3152|
000c04  e1d000b8          LDRH     r0,[r0,#8]  ; inseg
000c08  e2400001          SUB      r0,r0,#1
000c0c  e59f103c          LDR      r1,|L6.3152|
000c10  e1c100b8          STRH     r0,[r1,#8]  ; inseg
                  |L6.3092|
;;;1236             }
;;;1237             pbuf_realloc(inseg.p, inseg.len);
000c14  e59f2034          LDR      r2,|L6.3152|
000c18  e1d210b8          LDRH     r1,[r2,#8]  ; inseg
000c1c  e5920004          LDR      r0,[r2,#4]  ; inseg
000c20  ebfffffe          BL       pbuf_realloc
;;;1238             tcplen = TCP_TCPLEN(&inseg);
000c24  e59f1024          LDR      r1,|L6.3152|
000c28  e5911010          LDR      r1,[r1,#0x10]  ; inseg
000c2c  e5d1200d          LDRB     r2,[r1,#0xd]
000c30  e5d1100c          LDRB     r1,[r1,#0xc]
000c34  e1810402          ORR      r0,r1,r2,LSL #8
000c38  ebfffffe          BL       lwip_ntohs
000c3c  e2000003          AND      r0,r0,#3
000c40  e3500000          CMP      r0,#0
000c44  0a00001c          BEQ      |L6.3260|
000c48  e3a00001          MOV      r0,#1
000c4c  ea00001b          B        |L6.3264|
                  |L6.3152|
                          DCD      inseg
                  |L6.3156|
                          DCD      ||i.tcp_receive||+0x37c
                  |L6.3160|
                          DCD      0x00000496
                  |L6.3164|
000c5c  696e7365          DCB      "inseg.p != NULL",0
000c60  672e7020
000c64  213d204e
000c68  554c4c00
                  |L6.3180|
                          DCD      ||i.tcp_receive||+0x3b8
                  |L6.3184|
                          DCD      0x00007fff
                  |L6.3188|
                          DCD      0x00000497
                  |L6.3192|
000c78  696e7361          DCB      "insane offset!",0
000c7c  6e65206f
000c80  66667365
000c84  742100  
000c87  00                DCB      0
                  |L6.3208|
                          DCD      0x00000499
                  |L6.3212|
000c8c  70627566          DCB      "pbuf too short!",0
000c90  20746f6f
000c94  2073686f
000c98  72742100
                  |L6.3228|
                          DCD      0x000004a6
                  |L6.3232|
000ca0  70627566          DCB      "pbuf_header failed",0
000ca4  5f686561
000ca8  64657220
000cac  6661696c
000cb0  656400  
000cb3  00                DCB      0
                  |L6.3252|
                          DCD      0x000004ab
                  |L6.3256|
                          DCD      0x0000c0ff
                  |L6.3260|
000cbc  e3a00000          MOV      r0,#0
                  |L6.3264|
000cc0  e51f1078          LDR      r1,|L6.3152|
000cc4  e1d110b8          LDRH     r1,[r1,#8]  ; inseg
000cc8  e0800001          ADD      r0,r0,r1
000ccc  e51f18e4          LDR      r1,|L6.1008|
000cd0  e1c100b0          STRH     r0,[r1,#0]  ; tcplen
;;;1239             LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
000cd4  e1a00000          MOV      r0,r0
000cd8  e5940028          LDR      r0,[r4,#0x28]
000cdc  e1d412bc          LDRH     r1,[r4,#0x2c]
000ce0  e0811000          ADD      r1,r1,r0
000ce4  e51f0908          LDR      r0,|L6.996|
000ce8  e5900000          LDR      r0,[r0,#0]  ; seqno
000cec  e51f2904          LDR      r2,|L6.1008|
000cf0  e1d220b0          LDRH     r2,[r2,#0]  ; tcplen
000cf4  e0800002          ADD      r0,r0,r2
000cf8  e1510000          CMP      r1,r0
000cfc  0a000006          BEQ      |L6.3356|
000d00  e1a00000          MOV      r0,r0
000d04  e51f30b8          LDR      r3,|L6.3156|
000d08  e59f2380          LDR      r2,|L6.4240|
000d0c  e28f1d0e          ADR      r1,|L6.4244|
000d10  e51f00ac          LDR      r0,|L6.3180|
000d14  ebfffffe          BL       sysprintf
000d18  e1a00000          MOV      r0,r0
                  |L6.3356|
000d1c  e1a00000          MOV      r0,r0
                  |L6.3360|
;;;1240                         (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1241           }
;;;1242   #if TCP_QUEUE_OOSEQ
;;;1243           /* Received in-sequence data, adjust ooseq data if:
;;;1244              - FIN has been received or
;;;1245              - inseq overlaps with ooseq */
;;;1246           if (pcb->ooseq != NULL) {
000d20  e5940074          LDR      r0,[r4,#0x74]
000d24  e3500000          CMP      r0,#0
000d28  0a0000a2          BEQ      |L6.4024|
;;;1247             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000d2c  e51f10e4          LDR      r1,|L6.3152|
000d30  e5911010          LDR      r1,[r1,#0x10]  ; inseg
000d34  e5d1200d          LDRB     r2,[r1,#0xd]
000d38  e5d1100c          LDRB     r1,[r1,#0xc]
000d3c  e1810402          ORR      r0,r1,r2,LSL #8
000d40  ebfffffe          BL       lwip_ntohs
000d44  e2000001          AND      r0,r0,#1
000d48  e3500000          CMP      r0,#0
000d4c  0a00000b          BEQ      |L6.3456|
;;;1248               LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1249                           ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
;;;1250               /* Received in-order FIN means anything that was received
;;;1251                * out of order must now have been received in-order, so
;;;1252                * bin the ooseq queue */
;;;1253               while (pcb->ooseq != NULL) {
000d50  ea000006          B        |L6.3440|
                  |L6.3412|
;;;1254                 struct tcp_seg *old_ooseq = pcb->ooseq;
000d54  e594b074          LDR      r11,[r4,#0x74]
;;;1255                 pcb->ooseq = pcb->ooseq->next;
000d58  e5940074          LDR      r0,[r4,#0x74]
000d5c  e5900000          LDR      r0,[r0,#0]
000d60  e5840074          STR      r0,[r4,#0x74]
;;;1256                 tcp_seg_free(old_ooseq);
000d64  e1a0000b          MOV      r0,r11
000d68  ebfffffe          BL       tcp_seg_free
;;;1257               }
000d6c  e1a00000          MOV      r0,r0
                  |L6.3440|
000d70  e5940074          LDR      r0,[r4,#0x74]         ;1253
000d74  e3500000          CMP      r0,#0                 ;1253
000d78  1afffff5          BNE      |L6.3412|
000d7c  ea00008d          B        |L6.4024|
                  |L6.3456|
;;;1258             } else {
;;;1259               next = pcb->ooseq;
000d80  e5945074          LDR      r5,[r4,#0x74]
;;;1260               /* Remove all segments on ooseq that are covered by inseg already.
;;;1261                * FIN is copied from ooseq to inseg if present. */
;;;1262               while (next &&
000d84  ea000032          B        |L6.3668|
                  |L6.3464|
;;;1263                      TCP_SEQ_GEQ(seqno + tcplen,
;;;1264                                  next->tcphdr->seqno + next->len)) {
;;;1265                 /* inseg cannot have FIN here (already processed above) */
;;;1266                 if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
000d88  e5952010          LDR      r2,[r5,#0x10]
000d8c  e5d2100d          LDRB     r1,[r2,#0xd]
000d90  e5d2200c          LDRB     r2,[r2,#0xc]
000d94  e1820401          ORR      r0,r2,r1,LSL #8
000d98  ebfffffe          BL       lwip_ntohs
000d9c  e2000001          AND      r0,r0,#1
000da0  e3500000          CMP      r0,#0
000da4  0a000026          BEQ      |L6.3652|
;;;1267                     (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
000da8  e51f1160          LDR      r1,|L6.3152|
000dac  e5912010          LDR      r2,[r1,#0x10]  ; inseg
000db0  e5d2100d          LDRB     r1,[r2,#0xd]
000db4  e5d2200c          LDRB     r2,[r2,#0xc]
000db8  e1820401          ORR      r0,r2,r1,LSL #8
000dbc  ebfffffe          BL       lwip_ntohs
000dc0  e2000002          AND      r0,r0,#2
000dc4  e3500000          CMP      r0,#0
000dc8  1a00001d          BNE      |L6.3652|
;;;1268                   TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
000dcc  e3a00001          MOV      r0,#1
000dd0  ebfffffe          BL       lwip_htons
000dd4  e51f118c          LDR      r1,|L6.3152|
000dd8  e5912010          LDR      r2,[r1,#0x10]  ; inseg
000ddc  e5d2100d          LDRB     r1,[r2,#0xd]
000de0  e5d2200c          LDRB     r2,[r2,#0xc]
000de4  e1821401          ORR      r1,r2,r1,LSL #8
000de8  e1800001          ORR      r0,r0,r1
000dec  e51f11a4          LDR      r1,|L6.3152|
000df0  e5911010          LDR      r1,[r1,#0x10]  ; inseg
000df4  e5c1000c          STRB     r0,[r1,#0xc]
000df8  e1a00420          LSR      r0,r0,#8
000dfc  e5c1000d          STRB     r0,[r1,#0xd]
;;;1269                   tcplen = TCP_TCPLEN(&inseg);
000e00  e51f11b8          LDR      r1,|L6.3152|
000e04  e5912010          LDR      r2,[r1,#0x10]  ; inseg
000e08  e5d2100d          LDRB     r1,[r2,#0xd]
000e0c  e5d2200c          LDRB     r2,[r2,#0xc]
000e10  e1820401          ORR      r0,r2,r1,LSL #8
000e14  ebfffffe          BL       lwip_ntohs
000e18  e2000003          AND      r0,r0,#3
000e1c  e3500000          CMP      r0,#0
000e20  0a000001          BEQ      |L6.3628|
000e24  e3a00001          MOV      r0,#1
000e28  ea000000          B        |L6.3632|
                  |L6.3628|
000e2c  e3a00000          MOV      r0,#0
                  |L6.3632|
000e30  e51f11e8          LDR      r1,|L6.3152|
000e34  e1d110b8          LDRH     r1,[r1,#8]  ; inseg
000e38  e0800001          ADD      r0,r0,r1
000e3c  e51f1a54          LDR      r1,|L6.1008|
000e40  e1c100b0          STRH     r0,[r1,#0]  ; tcplen
                  |L6.3652|
;;;1270                 }
;;;1271                 prev = next;
000e44  e1a07005          MOV      r7,r5
;;;1272                 next = next->next;
000e48  e5955000          LDR      r5,[r5,#0]
;;;1273                 tcp_seg_free(prev);
000e4c  e1a00007          MOV      r0,r7
000e50  ebfffffe          BL       tcp_seg_free
                  |L6.3668|
000e54  e3550000          CMP      r5,#0                 ;1262
000e58  0a00000b          BEQ      |L6.3724|
000e5c  e5951010          LDR      r1,[r5,#0x10]         ;1263
000e60  e2810004          ADD      r0,r1,#4              ;1263
000e64  ebfffffe          BL       __aeabi_uread4
000e68  e1d510b8          LDRH     r1,[r5,#8]            ;1263
000e6c  e0811000          ADD      r1,r1,r0              ;1263
000e70  e51f0a94          LDR      r0,|L6.996|
000e74  e5900000          LDR      r0,[r0,#0]            ;1263  ; seqno
000e78  e51f2a90          LDR      r2,|L6.1008|
000e7c  e1d220b0          LDRH     r2,[r2,#0]            ;1263  ; tcplen
000e80  e0800002          ADD      r0,r0,r2              ;1263
000e84  e0500001          SUBS     r0,r0,r1              ;1263
000e88  5affffbe          BPL      |L6.3464|
                  |L6.3724|
;;;1274               }
;;;1275               /* Now trim right side of inseg if it overlaps with the first
;;;1276                * segment on ooseq */
;;;1277               if (next &&
000e8c  e3550000          CMP      r5,#0
000e90  0a000047          BEQ      |L6.4020|
;;;1278                   TCP_SEQ_GT(seqno + tcplen,
000e94  e5951010          LDR      r1,[r5,#0x10]
000e98  e2810004          ADD      r0,r1,#4
000e9c  ebfffffe          BL       __aeabi_uread4
000ea0  e51f1ac4          LDR      r1,|L6.996|
000ea4  e5911000          LDR      r1,[r1,#0]  ; seqno
000ea8  e51f2ac0          LDR      r2,|L6.1008|
000eac  e1d220b0          LDRH     r2,[r2,#0]  ; tcplen
000eb0  e0811002          ADD      r1,r1,r2
000eb4  e0410000          SUB      r0,r1,r0
000eb8  e3500000          CMP      r0,#0
000ebc  da00003c          BLE      |L6.4020|
;;;1279                              next->tcphdr->seqno)) {
;;;1280                 /* inseg cannot have FIN here (already processed above) */
;;;1281                 inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
000ec0  e5951010          LDR      r1,[r5,#0x10]
000ec4  e2810004          ADD      r0,r1,#4
000ec8  ebfffffe          BL       __aeabi_uread4
000ecc  e51f1af0          LDR      r1,|L6.996|
000ed0  e1d110b0          LDRH     r1,[r1,#0]  ; seqno
000ed4  e0400001          SUB      r0,r0,r1
000ed8  e51f1290          LDR      r1,|L6.3152|
000edc  e1c100b8          STRH     r0,[r1,#8]  ; inseg
;;;1282                 if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
000ee0  e5911010          LDR      r1,[r1,#0x10]  ; inseg
000ee4  e5d1200d          LDRB     r2,[r1,#0xd]
000ee8  e5d1100c          LDRB     r1,[r1,#0xc]
000eec  e1810402          ORR      r0,r1,r2,LSL #8
000ef0  ebfffffe          BL       lwip_ntohs
000ef4  e2000002          AND      r0,r0,#2
000ef8  e3500000          CMP      r0,#0
000efc  0a000004          BEQ      |L6.3860|
;;;1283                   inseg.len -= 1;
000f00  e51f02b8          LDR      r0,|L6.3152|
000f04  e1d000b8          LDRH     r0,[r0,#8]  ; inseg
000f08  e2400001          SUB      r0,r0,#1
000f0c  e51f12c4          LDR      r1,|L6.3152|
000f10  e1c100b8          STRH     r0,[r1,#8]  ; inseg
                  |L6.3860|
;;;1284                 }
;;;1285                 pbuf_realloc(inseg.p, inseg.len);
000f14  e51f22cc          LDR      r2,|L6.3152|
000f18  e1d210b8          LDRH     r1,[r2,#8]  ; inseg
000f1c  e5920004          LDR      r0,[r2,#4]  ; inseg
000f20  ebfffffe          BL       pbuf_realloc
;;;1286                 tcplen = TCP_TCPLEN(&inseg);
000f24  e51f12dc          LDR      r1,|L6.3152|
000f28  e5912010          LDR      r2,[r1,#0x10]  ; inseg
000f2c  e5d2100d          LDRB     r1,[r2,#0xd]
000f30  e5d2200c          LDRB     r2,[r2,#0xc]
000f34  e1820401          ORR      r0,r2,r1,LSL #8
000f38  ebfffffe          BL       lwip_ntohs
000f3c  e2000003          AND      r0,r0,#3
000f40  e3500000          CMP      r0,#0
000f44  0a000001          BEQ      |L6.3920|
000f48  e3a00001          MOV      r0,#1
000f4c  ea000000          B        |L6.3924|
                  |L6.3920|
000f50  e3a00000          MOV      r0,#0
                  |L6.3924|
000f54  e51f130c          LDR      r1,|L6.3152|
000f58  e1d110b8          LDRH     r1,[r1,#8]  ; inseg
000f5c  e0800001          ADD      r0,r0,r1
000f60  e51f1b78          LDR      r1,|L6.1008|
000f64  e1c100b0          STRH     r0,[r1,#0]  ; tcplen
;;;1287                 LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
000f68  e1a00000          MOV      r0,r0
000f6c  e5951010          LDR      r1,[r5,#0x10]
000f70  e2810004          ADD      r0,r1,#4
000f74  ebfffffe          BL       __aeabi_uread4
000f78  e51f1b9c          LDR      r1,|L6.996|
000f7c  e5911000          LDR      r1,[r1,#0]  ; seqno
000f80  e51f2b98          LDR      r2,|L6.1008|
000f84  e1d220b0          LDRH     r2,[r2,#0]  ; tcplen
000f88  e0811002          ADD      r1,r1,r2
000f8c  e1500001          CMP      r0,r1
000f90  0a000006          BEQ      |L6.4016|
000f94  e1a00000          MOV      r0,r0
000f98  e51f334c          LDR      r3,|L6.3156|
000f9c  e59f2128          LDR      r2,|L6.4300|
000fa0  e28f1f4a          ADR      r1,|L6.4304|
000fa4  e51f0340          LDR      r0,|L6.3180|
000fa8  ebfffffe          BL       sysprintf
000fac  e1a00000          MOV      r0,r0
                  |L6.4016|
000fb0  e1a00000          MOV      r0,r0
                  |L6.4020|
;;;1288                             (seqno + tcplen) == next->tcphdr->seqno);
;;;1289               }
;;;1290               pcb->ooseq = next;
000fb4  e5845074          STR      r5,[r4,#0x74]
                  |L6.4024|
;;;1291             }
;;;1292           }
;;;1293   #endif /* TCP_QUEUE_OOSEQ */
;;;1294   
;;;1295           pcb->rcv_nxt = seqno + tcplen;
000fb8  e51f0bdc          LDR      r0,|L6.996|
000fbc  e5900000          LDR      r0,[r0,#0]  ; seqno
000fc0  e51f1bd8          LDR      r1,|L6.1008|
000fc4  e1d110b0          LDRH     r1,[r1,#0]  ; tcplen
000fc8  e0800001          ADD      r0,r0,r1
000fcc  e5840028          STR      r0,[r4,#0x28]
;;;1296   
;;;1297           /* Update the receiver's (our) window. */
;;;1298           LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
000fd0  e1a00000          MOV      r0,r0
000fd4  e1d402bc          LDRH     r0,[r4,#0x2c]
000fd8  e51f1bf0          LDR      r1,|L6.1008|
000fdc  e1d110b0          LDRH     r1,[r1,#0]  ; tcplen
000fe0  e1500001          CMP      r0,r1
000fe4  aa000006          BGE      |L6.4100|
000fe8  e1a00000          MOV      r0,r0
000fec  e51f33a0          LDR      r3,|L6.3156|
000ff0  e59f2114          LDR      r2,|L6.4364|
000ff4  e28f1f45          ADR      r1,|L6.4368|
000ff8  e51f0394          LDR      r0,|L6.3180|
000ffc  ebfffffe          BL       sysprintf
001000  e1a00000          MOV      r0,r0
                  |L6.4100|
001004  e1a00000          MOV      r0,r0
;;;1299           pcb->rcv_wnd -= tcplen;
001008  e1d402bc          LDRH     r0,[r4,#0x2c]
00100c  e51f1c24          LDR      r1,|L6.1008|
001010  e1d110b0          LDRH     r1,[r1,#0]  ; tcplen
001014  e0400001          SUB      r0,r0,r1
001018  e1c402bc          STRH     r0,[r4,#0x2c]
;;;1300   
;;;1301           tcp_update_rcv_ann_wnd(pcb);
00101c  e1a00004          MOV      r0,r4
001020  ebfffffe          BL       tcp_update_rcv_ann_wnd
;;;1302   
;;;1303           /* If there is data in the segment, we make preparations to
;;;1304              pass this up to the application. The ->recv_data variable
;;;1305              is used for holding the pbuf that goes to the
;;;1306              application. The code for reassembling out-of-sequence data
;;;1307              chains its data on this pbuf as well.
;;;1308   
;;;1309              If the segment was a FIN, we set the TF_GOT_FIN flag that will
;;;1310              be used to indicate to the application that the remote side has
;;;1311              closed its end of the connection. */
;;;1312           if (inseg.p->tot_len > 0) {
001024  e51f03dc          LDR      r0,|L6.3152|
001028  e5900004          LDR      r0,[r0,#4]  ; inseg
00102c  e1d000b8          LDRH     r0,[r0,#8]
001030  e3500000          CMP      r0,#0
001034  da000006          BLE      |L6.4180|
;;;1313             recv_data = inseg.p;
001038  e51f03f0          LDR      r0,|L6.3152|
00103c  e5900004          LDR      r0,[r0,#4]  ; inseg
001040  e59f10e8          LDR      r1,|L6.4400|
001044  e5810000          STR      r0,[r1,#0]  ; recv_data
;;;1314             /* Since this pbuf now is the responsibility of the
;;;1315                application, we delete our reference to it so that we won't
;;;1316                (mistakingly) deallocate it. */
;;;1317             inseg.p = NULL;
001048  e3a00000          MOV      r0,#0
00104c  e51f1404          LDR      r1,|L6.3152|
001050  e5810004          STR      r0,[r1,#4]  ; inseg
                  |L6.4180|
;;;1318           }
;;;1319           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
001054  e51f140c          LDR      r1,|L6.3152|
001058  e5912010          LDR      r2,[r1,#0x10]  ; inseg
00105c  e5d2100d          LDRB     r1,[r2,#0xd]
001060  e5d2200c          LDRB     r2,[r2,#0xc]
001064  e1820401          ORR      r0,r2,r1,LSL #8
001068  ebfffffe          BL       lwip_ntohs
00106c  e2000001          AND      r0,r0,#1
001070  e3500000          CMP      r0,#0
001074  0a000004          BEQ      |L6.4236|
;;;1320             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
;;;1321             recv_flags |= TF_GOT_FIN;
001078  e59f00b4          LDR      r0,|L6.4404|
00107c  e5d00000          LDRB     r0,[r0,#0]  ; recv_flags
001080  e3800020          ORR      r0,r0,#0x20
001084  e59f10a8          LDR      r1,|L6.4404|
001088  e5c10000          STRB     r0,[r1,#0]  ; recv_flags
                  |L6.4236|
;;;1322           }
;;;1323   
;;;1324   #if TCP_QUEUE_OOSEQ
;;;1325           /* We now check if we have segments on the ->ooseq queue that
;;;1326              are now in sequence. */
;;;1327           while (pcb->ooseq != NULL &&
00108c  ea000093          B        |L6.4832|
                  |L6.4240|
                          DCD      0x000004d7
                  |L6.4244|
001094  7463705f          DCB      "tcp_receive: segment not trimmed correctly to rcv_wnd\n"
001098  72656365
00109c  6976653a
0010a0  20736567
0010a4  6d656e74
0010a8  206e6f74
0010ac  20747269
0010b0  6d6d6564
0010b4  20636f72
0010b8  72656374
0010bc  6c792074
0010c0  6f207263
0010c4  765f776e
0010c8  640a    
0010ca  00                DCB      0
0010cb  00                DCB      0
                  |L6.4300|
                          DCD      0x00000507
                  |L6.4304|
0010d0  7463705f          DCB      "tcp_receive: segment not trimmed correctly to ooseq que"
0010d4  72656365
0010d8  6976653a
0010dc  20736567
0010e0  6d656e74
0010e4  206e6f74
0010e8  20747269
0010ec  6d6d6564
0010f0  20636f72
0010f4  72656374
0010f8  6c792074
0010fc  6f206f6f
001100  73657120
001104  717565  
001107  75650a00          DCB      "ue\n",0
00110b  00                DCB      0
                  |L6.4364|
                          DCD      0x00000512
                  |L6.4368|
001110  7463705f          DCB      "tcp_receive: tcplen > rcv_wnd\n",0
001114  72656365
001118  6976653a
00111c  20746370
001120  6c656e20
001124  3e207263
001128  765f776e
00112c  640a00  
00112f  00                DCB      0
                  |L6.4400|
                          DCD      recv_data
                  |L6.4404|
                          DCD      recv_flags
                  |L6.4408|
;;;1328                  pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
;;;1329   
;;;1330             cseg = pcb->ooseq;
001138  e5946074          LDR      r6,[r4,#0x74]
;;;1331             seqno = pcb->ooseq->tcphdr->seqno;
00113c  e5941074          LDR      r1,[r4,#0x74]
001140  e5911010          LDR      r1,[r1,#0x10]
001144  e2810004          ADD      r0,r1,#4
001148  ebfffffe          BL       __aeabi_uread4
00114c  e51f1d70          LDR      r1,|L6.996|
001150  e5810000          STR      r0,[r1,#0]  ; seqno
;;;1332   
;;;1333             pcb->rcv_nxt += TCP_TCPLEN(cseg);
001154  e5962010          LDR      r2,[r6,#0x10]
001158  e5d2100d          LDRB     r1,[r2,#0xd]
00115c  e5d2200c          LDRB     r2,[r2,#0xc]
001160  e1820401          ORR      r0,r2,r1,LSL #8
001164  ebfffffe          BL       lwip_ntohs
001168  e2000003          AND      r0,r0,#3
00116c  e3500000          CMP      r0,#0
001170  0a000001          BEQ      |L6.4476|
001174  e3a00001          MOV      r0,#1
001178  ea000000          B        |L6.4480|
                  |L6.4476|
00117c  e3a00000          MOV      r0,#0
                  |L6.4480|
001180  e1d610b8          LDRH     r1,[r6,#8]
001184  e0800001          ADD      r0,r0,r1
001188  e5941028          LDR      r1,[r4,#0x28]
00118c  e0800001          ADD      r0,r0,r1
001190  e5840028          STR      r0,[r4,#0x28]
;;;1334             LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
001194  e1a00000          MOV      r0,r0
001198  e5962010          LDR      r2,[r6,#0x10]
00119c  e5d2100d          LDRB     r1,[r2,#0xd]
0011a0  e5d2200c          LDRB     r2,[r2,#0xc]
0011a4  e1820401          ORR      r0,r2,r1,LSL #8
0011a8  ebfffffe          BL       lwip_ntohs
0011ac  e2000003          AND      r0,r0,#3
0011b0  e3500000          CMP      r0,#0
0011b4  0a000001          BEQ      |L6.4544|
0011b8  e3a00001          MOV      r0,#1
0011bc  ea000000          B        |L6.4548|
                  |L6.4544|
0011c0  e3a00000          MOV      r0,#0
                  |L6.4548|
0011c4  e1d610b8          LDRH     r1,[r6,#8]
0011c8  e0800001          ADD      r0,r0,r1
0011cc  e1d412bc          LDRH     r1,[r4,#0x2c]
0011d0  e1500001          CMP      r0,r1
0011d4  da000006          BLE      |L6.4596|
0011d8  e1a00000          MOV      r0,r0
0011dc  e51f3590          LDR      r3,|L6.3156|
0011e0  e59f2304          LDR      r2,|L6.5356|
0011e4  e28f1fc1          ADR      r1,|L6.5360|
0011e8  e51f0584          LDR      r0,|L6.3180|
0011ec  ebfffffe          BL       sysprintf
0011f0  e1a00000          MOV      r0,r0
                  |L6.4596|
0011f4  e1a00000          MOV      r0,r0
;;;1335                         pcb->rcv_wnd >= TCP_TCPLEN(cseg));
;;;1336             pcb->rcv_wnd -= TCP_TCPLEN(cseg);
0011f8  e5961010          LDR      r1,[r6,#0x10]
0011fc  e5d1200d          LDRB     r2,[r1,#0xd]
001200  e5d1100c          LDRB     r1,[r1,#0xc]
001204  e1810402          ORR      r0,r1,r2,LSL #8
001208  ebfffffe          BL       lwip_ntohs
00120c  e2000003          AND      r0,r0,#3
001210  e3500000          CMP      r0,#0
001214  0a000001          BEQ      |L6.4640|
001218  e3a00001          MOV      r0,#1
00121c  ea000000          B        |L6.4644|
                  |L6.4640|
001220  e3a00000          MOV      r0,#0
                  |L6.4644|
001224  e1d610b8          LDRH     r1,[r6,#8]
001228  e0800001          ADD      r0,r0,r1
00122c  e1d412bc          LDRH     r1,[r4,#0x2c]
001230  e0410000          SUB      r0,r1,r0
001234  e1c402bc          STRH     r0,[r4,#0x2c]
;;;1337   
;;;1338             tcp_update_rcv_ann_wnd(pcb);
001238  e1a00004          MOV      r0,r4
00123c  ebfffffe          BL       tcp_update_rcv_ann_wnd
;;;1339   
;;;1340             if (cseg->p->tot_len > 0) {
001240  e5960004          LDR      r0,[r6,#4]
001244  e1d000b8          LDRH     r0,[r0,#8]
001248  e3500000          CMP      r0,#0
00124c  da00000d          BLE      |L6.4744|
;;;1341               /* Chain this pbuf onto the pbuf that we will pass to
;;;1342                  the application. */
;;;1343               if (recv_data) {
001250  e51f0128          LDR      r0,|L6.4400|
001254  e5900000          LDR      r0,[r0,#0]  ; recv_data
001258  e3500000          CMP      r0,#0
00125c  0a000004          BEQ      |L6.4724|
;;;1344                 pbuf_cat(recv_data, cseg->p);
001260  e51f0138          LDR      r0,|L6.4400|
001264  e5961004          LDR      r1,[r6,#4]
001268  e5900000          LDR      r0,[r0,#0]  ; recv_data
00126c  ebfffffe          BL       pbuf_cat
001270  ea000002          B        |L6.4736|
                  |L6.4724|
;;;1345               } else {
;;;1346                 recv_data = cseg->p;
001274  e51f114c          LDR      r1,|L6.4400|
001278  e5960004          LDR      r0,[r6,#4]
00127c  e5810000          STR      r0,[r1,#0]  ; recv_data
                  |L6.4736|
;;;1347               }
;;;1348               cseg->p = NULL;
001280  e3a00000          MOV      r0,#0
001284  e5860004          STR      r0,[r6,#4]
                  |L6.4744|
;;;1349             }
;;;1350             if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
001288  e5961010          LDR      r1,[r6,#0x10]
00128c  e5d1200d          LDRB     r2,[r1,#0xd]
001290  e5d1100c          LDRB     r1,[r1,#0xc]
001294  e1810402          ORR      r0,r1,r2,LSL #8
001298  ebfffffe          BL       lwip_ntohs
00129c  e2000001          AND      r0,r0,#1
0012a0  e3500000          CMP      r0,#0
0012a4  0a000009          BEQ      |L6.4816|
;;;1351               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
;;;1352               recv_flags |= TF_GOT_FIN;
0012a8  e51f017c          LDR      r0,|L6.4404|
0012ac  e5d00000          LDRB     r0,[r0,#0]  ; recv_flags
0012b0  e3800020          ORR      r0,r0,#0x20
0012b4  e51f1188          LDR      r1,|L6.4404|
0012b8  e5c10000          STRB     r0,[r1,#0]  ; recv_flags
;;;1353               if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
0012bc  e5d40018          LDRB     r0,[r4,#0x18]
0012c0  e3500004          CMP      r0,#4
0012c4  1a000001          BNE      |L6.4816|
;;;1354                 pcb->state = CLOSE_WAIT;
0012c8  e3a00007          MOV      r0,#7
0012cc  e5c40018          STRB     r0,[r4,#0x18]
                  |L6.4816|
;;;1355               } 
;;;1356             }
;;;1357   
;;;1358             pcb->ooseq = cseg->next;
0012d0  e5960000          LDR      r0,[r6,#0]
0012d4  e5840074          STR      r0,[r4,#0x74]
;;;1359             tcp_seg_free(cseg);
0012d8  e1a00006          MOV      r0,r6
0012dc  ebfffffe          BL       tcp_seg_free
                  |L6.4832|
0012e0  e5940074          LDR      r0,[r4,#0x74]         ;1327
0012e4  e3500000          CMP      r0,#0                 ;1327
0012e8  0a000006          BEQ      |L6.4872|
0012ec  e5941074          LDR      r1,[r4,#0x74]         ;1328
0012f0  e5911010          LDR      r1,[r1,#0x10]         ;1328
0012f4  e2810004          ADD      r0,r1,#4              ;1328
0012f8  ebfffffe          BL       __aeabi_uread4
0012fc  e5941028          LDR      r1,[r4,#0x28]         ;1328
001300  e1500001          CMP      r0,r1                 ;1328
001304  0affff8b          BEQ      |L6.4408|
                  |L6.4872|
;;;1360           }
;;;1361   #endif /* TCP_QUEUE_OOSEQ */
;;;1362   
;;;1363   
;;;1364           /* Acknowledge the segment(s). */
;;;1365           tcp_ack(pcb);
001308  e1a00000          MOV      r0,r0
00130c  e5d4001e          LDRB     r0,[r4,#0x1e]
001310  e2000001          AND      r0,r0,#1
001314  e3500000          CMP      r0,#0
001318  0a000006          BEQ      |L6.4920|
00131c  e5d4001e          LDRB     r0,[r4,#0x1e]
001320  e3c00001          BIC      r0,r0,#1
001324  e5c4001e          STRB     r0,[r4,#0x1e]
001328  e5d4001e          LDRB     r0,[r4,#0x1e]
00132c  e3800002          ORR      r0,r0,#2
001330  e5c4001e          STRB     r0,[r4,#0x1e]
001334  ea000002          B        |L6.4932|
                  |L6.4920|
001338  e5d4001e          LDRB     r0,[r4,#0x1e]
00133c  e3800001          ORR      r0,r0,#1
001340  e5c4001e          STRB     r0,[r4,#0x1e]
                  |L6.4932|
001344  ea000117          B        |L6.6056|
                  |L6.4936|
;;;1366   
;;;1367         } else {
;;;1368           /* We get here if the incoming segment is out-of-sequence. */
;;;1369           tcp_send_empty_ack(pcb);
001348  e1a00004          MOV      r0,r4
00134c  ebfffffe          BL       tcp_send_empty_ack
;;;1370   #if TCP_QUEUE_OOSEQ
;;;1371           /* We queue the segment on the ->ooseq queue. */
;;;1372           if (pcb->ooseq == NULL) {
001350  e5940074          LDR      r0,[r4,#0x74]
001354  e3500000          CMP      r0,#0
001358  1a000003          BNE      |L6.4972|
;;;1373             pcb->ooseq = tcp_seg_copy(&inseg);
00135c  e51f0714          LDR      r0,|L6.3152|
001360  ebfffffe          BL       tcp_seg_copy
001364  e5840074          STR      r0,[r4,#0x74]
001368  ea00010e          B        |L6.6056|
                  |L6.4972|
;;;1374           } else {
;;;1375             /* If the queue is not empty, we walk through the queue and
;;;1376                try to find a place where the sequence number of the
;;;1377                incoming segment is between the sequence numbers of the
;;;1378                previous and the next segment on the ->ooseq queue. That is
;;;1379                the place where we put the incoming segment. If needed, we
;;;1380                trim the second edges of the previous and the incoming
;;;1381                segment so that it will fit into the sequence.
;;;1382   
;;;1383                If the incoming segment has the same sequence number as a
;;;1384                segment on the ->ooseq queue, we discard the segment that
;;;1385                contains less data. */
;;;1386   
;;;1387             prev = NULL;
00136c  e3a07000          MOV      r7,#0
;;;1388             for(next = pcb->ooseq; next != NULL; next = next->next) {
001370  e5945074          LDR      r5,[r4,#0x74]
001374  ea0000f2          B        |L6.5956|
                  |L6.4984|
;;;1389               if (seqno == next->tcphdr->seqno) {
001378  e5951010          LDR      r1,[r5,#0x10]
00137c  e2810004          ADD      r0,r1,#4
001380  ebfffffe          BL       __aeabi_uread4
001384  e51f1fa8          LDR      r1,|L6.996|
001388  e5911000          LDR      r1,[r1,#0]  ; seqno
00138c  e1500001          CMP      r0,r1
001390  1a000013          BNE      |L6.5092|
;;;1390                 /* The sequence number of the incoming segment is the
;;;1391                    same as the sequence number of the segment on
;;;1392                    ->ooseq. We check the lengths to see which one to
;;;1393                    discard. */
;;;1394                 if (inseg.len > next->len) {
001394  e51f074c          LDR      r0,|L6.3152|
001398  e1d000b8          LDRH     r0,[r0,#8]  ; inseg
00139c  e1d510b8          LDRH     r1,[r5,#8]
0013a0  e1500001          CMP      r0,r1
0013a4  da00000d          BLE      |L6.5088|
;;;1395                   /* The incoming segment is larger than the old
;;;1396                      segment. We replace some segments with the new
;;;1397                      one. */
;;;1398                   cseg = tcp_seg_copy(&inseg);
0013a8  e51f0760          LDR      r0,|L6.3152|
0013ac  ebfffffe          BL       tcp_seg_copy
0013b0  e1a06000          MOV      r6,r0
;;;1399                   if (cseg != NULL) {
0013b4  e3560000          CMP      r6,#0
0013b8  0a000007          BEQ      |L6.5084|
;;;1400                     if (prev != NULL) {
0013bc  e3570000          CMP      r7,#0
0013c0  0a000001          BEQ      |L6.5068|
;;;1401                       prev->next = cseg;
0013c4  e5876000          STR      r6,[r7,#0]
0013c8  ea000000          B        |L6.5072|
                  |L6.5068|
;;;1402                     } else {
;;;1403                       pcb->ooseq = cseg;
0013cc  e5846074          STR      r6,[r4,#0x74]
                  |L6.5072|
;;;1404                     }
;;;1405                     tcp_oos_insert_segment(cseg, next);
0013d0  e1a01005          MOV      r1,r5
0013d4  e1a00006          MOV      r0,r6
0013d8  ebfffffe          BL       tcp_oos_insert_segment
                  |L6.5084|
;;;1406                   }
;;;1407                   break;
0013dc  ea0000da          B        |L6.5964|
                  |L6.5088|
;;;1408                 } else {
;;;1409                   /* Either the lenghts are the same or the incoming
;;;1410                      segment was smaller than the old one; in either
;;;1411                      case, we ditch the incoming segment. */
;;;1412                   break;
0013e0  ea0000d9          B        |L6.5964|
                  |L6.5092|
;;;1413                 }
;;;1414               } else {
;;;1415                 if (prev == NULL) {
0013e4  e3570000          CMP      r7,#0
0013e8  1a000010          BNE      |L6.5168|
;;;1416                   if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
0013ec  e5951010          LDR      r1,[r5,#0x10]
0013f0  e2810004          ADD      r0,r1,#4
0013f4  ebfffffe          BL       __aeabi_uread4
0013f8  e59f1118          LDR      r1,|L6.5400|
0013fc  e5911000          LDR      r1,[r1,#0]  ; seqno
001400  e0510000          SUBS     r0,r1,r0
001404  5a000044          BPL      |L6.5404|
;;;1417                     /* The sequence number of the incoming segment is lower
;;;1418                        than the sequence number of the first segment on the
;;;1419                        queue. We put the incoming segment first on the
;;;1420                        queue. */
;;;1421                     cseg = tcp_seg_copy(&inseg);
001408  e51f07c0          LDR      r0,|L6.3152|
00140c  ebfffffe          BL       tcp_seg_copy
001410  e1a06000          MOV      r6,r0
;;;1422                     if (cseg != NULL) {
001414  e3560000          CMP      r6,#0
001418  0a000003          BEQ      |L6.5164|
;;;1423                       pcb->ooseq = cseg;
00141c  e5846074          STR      r6,[r4,#0x74]
;;;1424                       tcp_oos_insert_segment(cseg, next);
001420  e1a01005          MOV      r1,r5
001424  e1a00006          MOV      r0,r6
001428  ebfffffe          BL       tcp_oos_insert_segment
                  |L6.5164|
;;;1425                     }
;;;1426                     break;
00142c  ea0000c6          B        |L6.5964|
                  |L6.5168|
;;;1427                   }
;;;1428                 } else {
;;;1429                   /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
;;;1430                     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
;;;1431                   if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
001430  e5971010          LDR      r1,[r7,#0x10]
001434  e2810004          ADD      r0,r1,#4
001438  ebfffffe          BL       __aeabi_uread4
00143c  e2800001          ADD      r0,r0,#1
001440  e59f10d0          LDR      r1,|L6.5400|
001444  e5911000          LDR      r1,[r1,#0]  ; seqno
001448  e0510000          SUBS     r0,r1,r0
00144c  4a000032          BMI      |L6.5404|
001450  e5951010          LDR      r1,[r5,#0x10]
001454  e2810004          ADD      r0,r1,#4
001458  ebfffffe          BL       __aeabi_uread4
00145c  e2400001          SUB      r0,r0,#1
001460  e59f10b0          LDR      r1,|L6.5400|
001464  e5911000          LDR      r1,[r1,#0]  ; seqno
001468  e0410000          SUB      r0,r1,r0
00146c  e3500000          CMP      r0,#0
001470  ca000029          BGT      |L6.5404|
;;;1432                     /* The sequence number of the incoming segment is in
;;;1433                        between the sequence numbers of the previous and
;;;1434                        the next segment on ->ooseq. We trim trim the previous
;;;1435                        segment, delete next segments that included in received segment
;;;1436                        and trim received, if needed. */
;;;1437                     cseg = tcp_seg_copy(&inseg);
001474  e51f082c          LDR      r0,|L6.3152|
001478  ebfffffe          BL       tcp_seg_copy
00147c  e1a06000          MOV      r6,r0
;;;1438                     if (cseg != NULL) {
001480  e3560000          CMP      r6,#0
001484  0a000017          BEQ      |L6.5352|
;;;1439                       if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
001488  e5971010          LDR      r1,[r7,#0x10]
00148c  e2810004          ADD      r0,r1,#4
001490  ebfffffe          BL       __aeabi_uread4
001494  e1d710b8          LDRH     r1,[r7,#8]
001498  e0800001          ADD      r0,r0,r1
00149c  e59f1074          LDR      r1,|L6.5400|
0014a0  e5911000          LDR      r1,[r1,#0]  ; seqno
0014a4  e0400001          SUB      r0,r0,r1
0014a8  e3500000          CMP      r0,#0
0014ac  da000009          BLE      |L6.5336|
;;;1440                         /* We need to trim the prev segment. */
;;;1441                         prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
0014b0  e5971010          LDR      r1,[r7,#0x10]
0014b4  e2810004          ADD      r0,r1,#4
0014b8  ebfffffe          BL       __aeabi_uread4
0014bc  e59f1054          LDR      r1,|L6.5400|
0014c0  e1d110b0          LDRH     r1,[r1,#0]  ; seqno
0014c4  e0410000          SUB      r0,r1,r0
0014c8  e1c700b8          STRH     r0,[r7,#8]
;;;1442                         pbuf_realloc(prev->p, prev->len);
0014cc  e1d710b8          LDRH     r1,[r7,#8]
0014d0  e5970004          LDR      r0,[r7,#4]
0014d4  ebfffffe          BL       pbuf_realloc
                  |L6.5336|
;;;1443                       }
;;;1444                       prev->next = cseg;
0014d8  e5876000          STR      r6,[r7,#0]
;;;1445                       tcp_oos_insert_segment(cseg, next);
0014dc  e1a01005          MOV      r1,r5
0014e0  e1a00006          MOV      r0,r6
0014e4  ebfffffe          BL       tcp_oos_insert_segment
                  |L6.5352|
;;;1446                     }
;;;1447                     break;
0014e8  ea000097          B        |L6.5964|
                  |L6.5356|
                          DCD      0x00000536
                  |L6.5360|
0014f0  7463705f          DCB      "tcp_receive: ooseq tcplen > rcv_wnd\n",0
0014f4  72656365
0014f8  6976653a
0014fc  206f6f73
001500  65712074
001504  63706c65
001508  6e203e20
00150c  7263765f
001510  776e640a
001514  00      
001515  00                DCB      0
001516  00                DCB      0
001517  00                DCB      0
                  |L6.5400|
                          DCD      seqno
                  |L6.5404|
;;;1448                   }
;;;1449                 }
;;;1450                 /* If the "next" segment is the last segment on the
;;;1451                    ooseq queue, we add the incoming segment to the end
;;;1452                    of the list. */
;;;1453                 if (next->next == NULL &&
00151c  e5950000          LDR      r0,[r5,#0]
001520  e3500000          CMP      r0,#0
001524  1a000084          BNE      |L6.5948|
;;;1454                     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
001528  e5951010          LDR      r1,[r5,#0x10]
00152c  e2810004          ADD      r0,r1,#4
001530  ebfffffe          BL       __aeabi_uread4
001534  e51f1024          LDR      r1,|L6.5400|
001538  e5911000          LDR      r1,[r1,#0]  ; seqno
00153c  e0410000          SUB      r0,r1,r0
001540  e3500000          CMP      r0,#0
001544  da00007c          BLE      |L6.5948|
;;;1455                   if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
001548  e5952010          LDR      r2,[r5,#0x10]
00154c  e5d2100d          LDRB     r1,[r2,#0xd]
001550  e5d2200c          LDRB     r2,[r2,#0xc]
001554  e1820401          ORR      r0,r2,r1,LSL #8
001558  ebfffffe          BL       lwip_ntohs
00155c  e2000001          AND      r0,r0,#1
001560  e3500000          CMP      r0,#0
001564  0a000000          BEQ      |L6.5484|
;;;1456                     /* segment "next" already contains all data */
;;;1457                     break;
001568  ea000077          B        |L6.5964|
                  |L6.5484|
;;;1458                   }
;;;1459                   next->next = tcp_seg_copy(&inseg);
00156c  e51f0924          LDR      r0,|L6.3152|
001570  ebfffffe          BL       tcp_seg_copy
001574  e5850000          STR      r0,[r5,#0]
;;;1460                   if (next->next != NULL) {
001578  e5950000          LDR      r0,[r5,#0]
00157c  e3500000          CMP      r0,#0
001580  0a00006c          BEQ      |L6.5944|
;;;1461                     if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
001584  e5951010          LDR      r1,[r5,#0x10]
001588  e2810004          ADD      r0,r1,#4
00158c  ebfffffe          BL       __aeabi_uread4
001590  e1d510b8          LDRH     r1,[r5,#8]
001594  e0800001          ADD      r0,r0,r1
001598  e51f1088          LDR      r1,|L6.5400|
00159c  e5911000          LDR      r1,[r1,#0]  ; seqno
0015a0  e0400001          SUB      r0,r0,r1
0015a4  e3500000          CMP      r0,#0
0015a8  da000009          BLE      |L6.5588|
;;;1462                       /* We need to trim the last segment. */
;;;1463                       next->len = (u16_t)(seqno - next->tcphdr->seqno);
0015ac  e5951010          LDR      r1,[r5,#0x10]
0015b0  e2810004          ADD      r0,r1,#4
0015b4  ebfffffe          BL       __aeabi_uread4
0015b8  e51f10a8          LDR      r1,|L6.5400|
0015bc  e1d110b0          LDRH     r1,[r1,#0]  ; seqno
0015c0  e0410000          SUB      r0,r1,r0
0015c4  e1c500b8          STRH     r0,[r5,#8]
;;;1464                       pbuf_realloc(next->p, next->len);
0015c8  e1d510b8          LDRH     r1,[r5,#8]
0015cc  e5950004          LDR      r0,[r5,#4]
0015d0  ebfffffe          BL       pbuf_realloc
                  |L6.5588|
;;;1465                     }
;;;1466                     /* check if the remote side overruns our receive window */
;;;1467                     if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
0015d4  e5940028          LDR      r0,[r4,#0x28]
0015d8  e1d412bc          LDRH     r1,[r4,#0x2c]
0015dc  e0811000          ADD      r1,r1,r0
0015e0  e59f01c4          LDR      r0,|L6.6060|
0015e4  e1d000b0          LDRH     r0,[r0,#0]  ; tcplen
0015e8  e51f20d8          LDR      r2,|L6.5400|
0015ec  e5922000          LDR      r2,[r2,#0]  ; seqno
0015f0  e0800002          ADD      r0,r0,r2
0015f4  e1510000          CMP      r1,r0
0015f8  2a00004e          BCS      |L6.5944|
;;;1468                       LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1469                                   ("tcp_receive: other end overran receive window"
;;;1470                                    "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1471                                    seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1472                       if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
0015fc  e5951000          LDR      r1,[r5,#0]
001600  e5912010          LDR      r2,[r1,#0x10]
001604  e5d2100d          LDRB     r1,[r2,#0xd]
001608  e5d2200c          LDRB     r2,[r2,#0xc]
00160c  e1820401          ORR      r0,r2,r1,LSL #8
001610  ebfffffe          BL       lwip_ntohs
001614  e2000001          AND      r0,r0,#1
001618  e3500000          CMP      r0,#0
00161c  0a000015          BEQ      |L6.5752|
;;;1473                         /* Must remove the FIN from the header as we're trimming 
;;;1474                          * that byte of sequence-space from the packet */
;;;1475                         TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
001620  e5951000          LDR      r1,[r5,#0]
001624  e5912010          LDR      r2,[r1,#0x10]
001628  e5d2100d          LDRB     r1,[r2,#0xd]
00162c  e5d2200c          LDRB     r2,[r2,#0xc]
001630  e1820401          ORR      r0,r2,r1,LSL #8
001634  ebfffffe          BL       lwip_ntohs
001638  e200b03e          AND      r11,r0,#0x3e
00163c  e1a0000b          MOV      r0,r11
001640  ebfffffe          BL       lwip_htons
001644  e5951000          LDR      r1,[r5,#0]
001648  e5912010          LDR      r2,[r1,#0x10]
00164c  e5d2100d          LDRB     r1,[r2,#0xd]
001650  e5d2200c          LDRB     r2,[r2,#0xc]
001654  e1821401          ORR      r1,r2,r1,LSL #8
001658  e51f29a8          LDR      r2,|L6.3256|
00165c  e0011002          AND      r1,r1,r2
001660  e1800001          ORR      r0,r0,r1
001664  e5951000          LDR      r1,[r5,#0]
001668  e5911010          LDR      r1,[r1,#0x10]
00166c  e5c1000c          STRB     r0,[r1,#0xc]
001670  e1a00420          LSR      r0,r0,#8
001674  e5c1000d          STRB     r0,[r1,#0xd]
                  |L6.5752|
;;;1476                       }
;;;1477                       /* Adjust length of segment to fit in the window. */
;;;1478                       next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
001678  e1d402b8          LDRH     r0,[r4,#0x28]
00167c  e1d412bc          LDRH     r1,[r4,#0x2c]
001680  e0800001          ADD      r0,r0,r1
001684  e51f1174          LDR      r1,|L6.5400|
001688  e1d110b0          LDRH     r1,[r1,#0]  ; seqno
00168c  e0400001          SUB      r0,r0,r1
001690  e5951000          LDR      r1,[r5,#0]
001694  e1c100b8          STRH     r0,[r1,#8]
;;;1479                       pbuf_realloc(next->next->p, next->next->len);
001698  e5952000          LDR      r2,[r5,#0]
00169c  e1d210b8          LDRH     r1,[r2,#8]
0016a0  e5920004          LDR      r0,[r2,#4]
0016a4  ebfffffe          BL       pbuf_realloc
;;;1480                       tcplen = TCP_TCPLEN(next->next);
0016a8  e5951000          LDR      r1,[r5,#0]
0016ac  e5912010          LDR      r2,[r1,#0x10]
0016b0  e5d2100d          LDRB     r1,[r2,#0xd]
0016b4  e5d2200c          LDRB     r2,[r2,#0xc]
0016b8  e1820401          ORR      r0,r2,r1,LSL #8
0016bc  ebfffffe          BL       lwip_ntohs
0016c0  e2000003          AND      r0,r0,#3
0016c4  e3500000          CMP      r0,#0
0016c8  0a000001          BEQ      |L6.5844|
0016cc  e3a00001          MOV      r0,#1
0016d0  ea000000          B        |L6.5848|
                  |L6.5844|
0016d4  e3a00000          MOV      r0,#0
                  |L6.5848|
0016d8  e5951000          LDR      r1,[r5,#0]
0016dc  e1d110b8          LDRH     r1,[r1,#8]
0016e0  e0800001          ADD      r0,r0,r1
0016e4  e59f10c0          LDR      r1,|L6.6060|
0016e8  e1c100b0          STRH     r0,[r1,#0]  ; tcplen
;;;1481                       LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
0016ec  e1a00000          MOV      r0,r0
0016f0  e5940028          LDR      r0,[r4,#0x28]
0016f4  e1d412bc          LDRH     r1,[r4,#0x2c]
0016f8  e0800001          ADD      r0,r0,r1
0016fc  e51f11ec          LDR      r1,|L6.5400|
001700  e5911000          LDR      r1,[r1,#0]  ; seqno
001704  e59f20a0          LDR      r2,|L6.6060|
001708  e1d220b0          LDRH     r2,[r2,#0]  ; tcplen
00170c  e0811002          ADD      r1,r1,r2
001710  e1500001          CMP      r0,r1
001714  0a000006          BEQ      |L6.5940|
001718  e1a00000          MOV      r0,r0
00171c  e51f3ad0          LDR      r3,|L6.3156|
001720  e59f2088          LDR      r2,|L6.6064|
001724  e59f1088          LDR      r1,|L6.6068|
001728  e51f0ac4          LDR      r0,|L6.3180|
00172c  ebfffffe          BL       sysprintf
001730  e1a00000          MOV      r0,r0
                  |L6.5940|
001734  e1a00000          MOV      r0,r0
                  |L6.5944|
;;;1482                                   (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1483                     }
;;;1484                   }
;;;1485                   break;
001738  ea000003          B        |L6.5964|
                  |L6.5948|
;;;1486                 }
;;;1487               }
;;;1488               prev = next;
00173c  e1a07005          MOV      r7,r5
001740  e5955000          LDR      r5,[r5,#0]            ;1388
                  |L6.5956|
001744  e3550000          CMP      r5,#0                 ;1388
001748  1affff0a          BNE      |L6.4984|
                  |L6.5964|
00174c  ea000015          B        |L6.6056|
                  |L6.5968|
;;;1489             }
;;;1490           }
;;;1491   #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;1492           /* Check that the data on ooseq doesn't exceed one of the limits
;;;1493              and throw away everything above that limit. */
;;;1494           ooseq_blen = 0;
;;;1495           ooseq_qlen = 0;
;;;1496           prev = NULL;
;;;1497           for(next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
;;;1498             struct pbuf *p = next->p;
;;;1499             ooseq_blen += p->tot_len;
;;;1500             ooseq_qlen += pbuf_clen(p);
;;;1501             if ((ooseq_blen > TCP_OOSEQ_MAX_BYTES) ||
;;;1502                 (ooseq_qlen > TCP_OOSEQ_MAX_PBUFS)) {
;;;1503                /* too much ooseq data, dump this and everything after it */
;;;1504                tcp_segs_free(next);
;;;1505                if (prev == NULL) {
;;;1506                  /* first ooseq segment is too much, dump the whole queue */
;;;1507                  pcb->ooseq = NULL;
;;;1508                } else {
;;;1509                  /* just dump 'next' and everything after it */
;;;1510                  prev->next = NULL;
;;;1511                }
;;;1512                break;
;;;1513             }
;;;1514           }
;;;1515   #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;1516   #endif /* TCP_QUEUE_OOSEQ */
;;;1517         }
;;;1518       } else {
;;;1519         /* The incoming segment is not withing the window. */
;;;1520         tcp_send_empty_ack(pcb);
001750  e1a00004          MOV      r0,r4
001754  ebfffffe          BL       tcp_send_empty_ack
001758  ea000012          B        |L6.6056|
                  |L6.5980|
;;;1521       }
;;;1522     } else {
;;;1523       /* Segments with length 0 is taken care of here. Segments that
;;;1524          fall out of the window are ACKed. */
;;;1525       /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
;;;1526         TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
;;;1527       if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
00175c  e51f124c          LDR      r1,|L6.5400|
001760  e5940028          LDR      r0,[r4,#0x28]
001764  e5911000          LDR      r1,[r1,#0]  ; seqno
001768  e0510000          SUBS     r0,r1,r0
00176c  4a000008          BMI      |L6.6036|
001770  e5940028          LDR      r0,[r4,#0x28]
001774  e1d412bc          LDRH     r1,[r4,#0x2c]
001778  e0800001          ADD      r0,r0,r1
00177c  e2400001          SUB      r0,r0,#1
001780  e51f1270          LDR      r1,|L6.5400|
001784  e5911000          LDR      r1,[r1,#0]  ; seqno
001788  e0410000          SUB      r0,r1,r0
00178c  e3500000          CMP      r0,#0
001790  da000004          BLE      |L6.6056|
                  |L6.6036|
;;;1528         tcp_ack_now(pcb);
001794  e1a00000          MOV      r0,r0
001798  e5d4001e          LDRB     r0,[r4,#0x1e]
00179c  e3800002          ORR      r0,r0,#2
0017a0  e5c4001e          STRB     r0,[r4,#0x1e]
0017a4  e1a00000          MOV      r0,r0
                  |L6.6056|
;;;1529       }
;;;1530     }
;;;1531   }
0017a8  e8bd9fff          POP      {r0-r12,pc}
;;;1532   
                          ENDP

                  |L6.6060|
                          DCD      tcplen
                  |L6.6064|
                          DCD      0x000005c9
                  |L6.6068|
                          DCD      ||i.tcp_receive||+0x1094

                          AREA ||i.tcp_timewait_input||, CODE, READONLY, ALIGN=2

                  tcp_timewait_input PROC
;;;528    static err_t
;;;529    tcp_timewait_input(struct tcp_pcb *pcb)
000000  e92d401c          PUSH     {r2-r4,lr}
;;;530    {
000004  e1a04000          MOV      r4,r0
;;;531      /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
;;;532      /* RFC 793 3.9 Event Processing - Segment Arrives:
;;;533       * - first check sequence number - we skip that one in TIME_WAIT (always
;;;534       *   acceptable since we only send ACKs)
;;;535       * - second check the RST bit (... return) */
;;;536      if (flags & TCP_RST)  {
000008  e59f010c          LDR      r0,|L7.284|
00000c  e5d00000          LDRB     r0,[r0,#0]  ; flags
000010  e2000004          AND      r0,r0,#4
000014  e3500000          CMP      r0,#0
000018  0a000001          BEQ      |L7.36|
;;;537        return ERR_OK;
00001c  e3a00000          MOV      r0,#0
                  |L7.32|
;;;538      }
;;;539      /* - fourth, check the SYN bit, */
;;;540      if (flags & TCP_SYN) {
;;;541        /* If an incoming segment is not acceptable, an acknowledgment
;;;542           should be sent in reply */
;;;543        if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;544          /* If the SYN is in the window it is an error, send a reset */
;;;545          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;546            tcphdr->dest, tcphdr->src);
;;;547          return ERR_OK;
;;;548        }
;;;549      } else if (flags & TCP_FIN) {
;;;550        /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
;;;551             Restart the 2 MSL time-wait timeout.*/
;;;552        pcb->tmr = tcp_ticks;
;;;553      }
;;;554    
;;;555      if ((tcplen > 0))  {
;;;556        /* Acknowledge data, FIN or out-of-window SYN */
;;;557        pcb->flags |= TF_ACK_NOW;
;;;558        return tcp_output(pcb);
;;;559      }
;;;560      return ERR_OK;
;;;561    }
000020  e8bd801c          POP      {r2-r4,pc}
                  |L7.36|
000024  e59f00f0          LDR      r0,|L7.284|
000028  e5d00000          LDRB     r0,[r0,#0]            ;540  ; flags
00002c  e2000002          AND      r0,r0,#2              ;540
000030  e3500000          CMP      r0,#0                 ;540
000034  0a000024          BEQ      |L7.204|
000038  e59f10e0          LDR      r1,|L7.288|
00003c  e5940028          LDR      r0,[r4,#0x28]         ;543
000040  e5911000          LDR      r1,[r1,#0]            ;543  ; seqno
000044  e0510000          SUBS     r0,r1,r0              ;543
000048  4a000027          BMI      |L7.236|
00004c  e5940028          LDR      r0,[r4,#0x28]         ;543
000050  e1d412bc          LDRH     r1,[r4,#0x2c]         ;543
000054  e0800001          ADD      r0,r0,r1              ;543
000058  e59f10c0          LDR      r1,|L7.288|
00005c  e5911000          LDR      r1,[r1,#0]            ;543  ; seqno
000060  e0410000          SUB      r0,r1,r0              ;543
000064  e3500000          CMP      r0,#0                 ;543
000068  ca00001f          BGT      |L7.236|
00006c  e59f00b0          LDR      r0,|L7.292|
000070  e5901000          LDR      r1,[r0,#0]            ;545  ; tcphdr
000074  e5d10001          LDRB     r0,[r1,#1]            ;545
000078  e5d11000          LDRB     r1,[r1,#0]            ;545
00007c  e1810400          ORR      r0,r1,r0,LSL #8       ;545
000080  e59f109c          LDR      r1,|L7.292|
000084  e5911000          LDR      r1,[r1,#0]            ;545  ; tcphdr
000088  e5d12003          LDRB     r2,[r1,#3]            ;545
00008c  e5d11002          LDRB     r1,[r1,#2]            ;545
000090  e1811402          ORR      r1,r1,r2,LSL #8       ;545
000094  e58d0004          STR      r0,[sp,#4]            ;545
000098  e59f0080          LDR      r0,|L7.288|
00009c  e58d1000          STR      r1,[sp,#0]            ;545
0000a0  e5900000          LDR      r0,[r0,#0]            ;545  ; seqno
0000a4  e59f207c          LDR      r2,|L7.296|
0000a8  e1d220b0          LDRH     r2,[r2,#0]            ;545  ; tcplen
0000ac  e0801002          ADD      r1,r0,r2              ;545
0000b0  e59f3074          LDR      r3,|L7.300|
0000b4  e59f2074          LDR      r2,|L7.304|
0000b8  e59f0074          LDR      r0,|L7.308|
0000bc  e5900000          LDR      r0,[r0,#0]            ;545  ; ackno
0000c0  ebfffffe          BL       tcp_rst
0000c4  e3a00000          MOV      r0,#0                 ;547
0000c8  eaffffd4          B        |L7.32|
                  |L7.204|
0000cc  e59f0048          LDR      r0,|L7.284|
0000d0  e5d00000          LDRB     r0,[r0,#0]            ;549  ; flags
0000d4  e2000001          AND      r0,r0,#1              ;549
0000d8  e3500000          CMP      r0,#0                 ;549
0000dc  0a000002          BEQ      |L7.236|
0000e0  e59f0050          LDR      r0,|L7.312|
0000e4  e5900000          LDR      r0,[r0,#0]            ;552  ; tcp_ticks
0000e8  e5840024          STR      r0,[r4,#0x24]         ;552
                  |L7.236|
0000ec  e59f0034          LDR      r0,|L7.296|
0000f0  e1d000b0          LDRH     r0,[r0,#0]            ;555  ; tcplen
0000f4  e3500000          CMP      r0,#0                 ;555
0000f8  da000005          BLE      |L7.276|
0000fc  e5d4001e          LDRB     r0,[r4,#0x1e]         ;557
000100  e3800002          ORR      r0,r0,#2              ;557
000104  e5c4001e          STRB     r0,[r4,#0x1e]         ;557
000108  e1a00004          MOV      r0,r4                 ;558
00010c  ebfffffe          BL       tcp_output
000110  eaffffc2          B        |L7.32|
                  |L7.276|
000114  e3a00000          MOV      r0,#0                 ;560
000118  eaffffc0          B        |L7.32|
;;;562    
                          ENDP

                  |L7.284|
                          DCD      flags
                  |L7.288|
                          DCD      seqno
                  |L7.292|
                          DCD      tcphdr
                  |L7.296|
                          DCD      tcplen
                  |L7.300|
                          DCD      current_iphdr_src
                  |L7.304|
                          DCD      current_iphdr_dest
                  |L7.308|
                          DCD      ackno
                  |L7.312|
                          DCD      tcp_ticks

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  inseg
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  tcphdr
                          DCD      0x00000000
                  iphdr
                          DCD      0x00000000
                  seqno
                          DCD      0x00000000
                  ackno
                          DCD      0x00000000
                  flags
000010  0000              DCB      0x00,0x00
                  tcplen
000012  0000              DCB      0x00,0x00
                  recv_flags
000014  00000000          DCB      0x00,0x00,0x00,0x00
                  recv_data
                          DCD      0x00000000
                  tcp_input_pcb
                          DCD      0x00000000
