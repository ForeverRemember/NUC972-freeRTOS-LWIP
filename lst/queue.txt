; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\queue.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\queue.d --cpu=ARM926EJ-S --apcs=interwork -O0 --diag_suppress=9931,1295,177,550 -I.\Driver\Include -I.\lwip-1.4.1\include -I.\lwip-1.4.1\src\include\ipv4 -I.\lwip-1.4.1\src\include\ -I.\FreeRTOS\Source\include -I.\FreeRTOS\Source\portable\MemMang -I.\FreeRTOS\Source\portable\RVDS\ARM9_NUC970 -I"C:\Program Study\Keil5\ARM\RV31\INC" -I"C:\Program Study\Keil5\ARM\CMSIS\Include" -I"C:\Program Study\Keil5\ARM\INC\Toshiba" -D__UVISION_VERSION=524 --omf_browse=.\obj\queue.crf FreeRTOS\Source\queue.c]
                          ARM

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=2

                  prvCopyDataFromQueue PROC
;;;1775   
;;;1776   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1777   {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;1778   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
00000c  e5940040          LDR      r0,[r4,#0x40]
000010  e3500000          CMP      r0,#0
000014  0a00000d          BEQ      |L1.80|
;;;1779   	{
;;;1780   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
000018  e594000c          LDR      r0,[r4,#0xc]
00001c  e5941040          LDR      r1,[r4,#0x40]
000020  e0800001          ADD      r0,r0,r1
000024  e584000c          STR      r0,[r4,#0xc]
;;;1781   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
000028  e594000c          LDR      r0,[r4,#0xc]
00002c  e5941004          LDR      r1,[r4,#4]
000030  e1500001          CMP      r0,r1
000034  3a000001          BCC      |L1.64|
;;;1782   		{
;;;1783   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
000038  e5940000          LDR      r0,[r4,#0]
00003c  e584000c          STR      r0,[r4,#0xc]
                  |L1.64|
;;;1784   		}
;;;1785   		else
;;;1786   		{
;;;1787   			mtCOVERAGE_TEST_MARKER();
;;;1788   		}
;;;1789   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
000040  e1a00005          MOV      r0,r5
000044  e594100c          LDR      r1,[r4,#0xc]
000048  e5942040          LDR      r2,[r4,#0x40]
00004c  ebfffffe          BL       __aeabi_memcpy
                  |L1.80|
;;;1790   	}
;;;1791   }
000050  e8bd8070          POP      {r4-r6,pc}
;;;1792   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=2

                  prvCopyDataToQueue PROC
;;;1696   
;;;1697   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1698   {
000004  e1a04000          MOV      r4,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a05002          MOV      r5,r2
;;;1699   BaseType_t xReturn = pdFALSE;
000010  e3a08000          MOV      r8,#0
;;;1700   UBaseType_t uxMessagesWaiting;
;;;1701   
;;;1702   	/* This function is called from a critical section. */
;;;1703   
;;;1704   	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000014  e5946038          LDR      r6,[r4,#0x38]
;;;1705   
;;;1706   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
000018  e5940040          LDR      r0,[r4,#0x40]
00001c  e3500000          CMP      r0,#0
000020  0a000025          BEQ      |L2.188|
;;;1707   	{
;;;1708   		#if ( configUSE_MUTEXES == 1 )
;;;1709   		{
;;;1710   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1711   			{
;;;1712   				/* The mutex is no longer being held. */
;;;1713   				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
;;;1714   				pxQueue->pxMutexHolder = NULL;
;;;1715   			}
;;;1716   			else
;;;1717   			{
;;;1718   				mtCOVERAGE_TEST_MARKER();
;;;1719   			}
;;;1720   		}
;;;1721   		#endif /* configUSE_MUTEXES */
;;;1722   	}
;;;1723   	else if( xPosition == queueSEND_TO_BACK )
000024  e3550000          CMP      r5,#0
000028  1a00000e          BNE      |L2.104|
;;;1724   	{
;;;1725   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
00002c  e1a01007          MOV      r1,r7
000030  e5940008          LDR      r0,[r4,#8]
000034  e5942040          LDR      r2,[r4,#0x40]
000038  ebfffffe          BL       __aeabi_memcpy
;;;1726   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
00003c  e5940008          LDR      r0,[r4,#8]
000040  e5941040          LDR      r1,[r4,#0x40]
000044  e0800001          ADD      r0,r0,r1
000048  e5840008          STR      r0,[r4,#8]
;;;1727   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00004c  e5940008          LDR      r0,[r4,#8]
000050  e5941004          LDR      r1,[r4,#4]
000054  e1500001          CMP      r0,r1
000058  3a000017          BCC      |L2.188|
;;;1728   		{
;;;1729   			pxQueue->pcWriteTo = pxQueue->pcHead;
00005c  e5940000          LDR      r0,[r4,#0]
000060  e5840008          STR      r0,[r4,#8]
000064  ea000014          B        |L2.188|
                  |L2.104|
;;;1730   		}
;;;1731   		else
;;;1732   		{
;;;1733   			mtCOVERAGE_TEST_MARKER();
;;;1734   		}
;;;1735   	}
;;;1736   	else
;;;1737   	{
;;;1738   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000068  e1a01007          MOV      r1,r7
00006c  e594000c          LDR      r0,[r4,#0xc]
000070  e5942040          LDR      r2,[r4,#0x40]
000074  ebfffffe          BL       __aeabi_memcpy
;;;1739   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
000078  e594000c          LDR      r0,[r4,#0xc]
00007c  e5941040          LDR      r1,[r4,#0x40]
000080  e0400001          SUB      r0,r0,r1
000084  e584000c          STR      r0,[r4,#0xc]
;;;1740   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000088  e594000c          LDR      r0,[r4,#0xc]
00008c  e5941000          LDR      r1,[r4,#0]
000090  e1500001          CMP      r0,r1
000094  2a000003          BCS      |L2.168|
;;;1741   		{
;;;1742   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
000098  e5940004          LDR      r0,[r4,#4]
00009c  e5941040          LDR      r1,[r4,#0x40]
0000a0  e0400001          SUB      r0,r0,r1
0000a4  e584000c          STR      r0,[r4,#0xc]
                  |L2.168|
;;;1743   		}
;;;1744   		else
;;;1745   		{
;;;1746   			mtCOVERAGE_TEST_MARKER();
;;;1747   		}
;;;1748   
;;;1749   		if( xPosition == queueOVERWRITE )
0000a8  e3550002          CMP      r5,#2
0000ac  1a000002          BNE      |L2.188|
;;;1750   		{
;;;1751   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
0000b0  e3560000          CMP      r6,#0
0000b4  0a000000          BEQ      |L2.188|
;;;1752   			{
;;;1753   				/* An item is not being added but overwritten, so subtract
;;;1754   				one from the recorded number of items in the queue so when
;;;1755   				one is added again below the number of recorded items remains
;;;1756   				correct. */
;;;1757   				--uxMessagesWaiting;
0000b8  e2466001          SUB      r6,r6,#1
                  |L2.188|
;;;1758   			}
;;;1759   			else
;;;1760   			{
;;;1761   				mtCOVERAGE_TEST_MARKER();
;;;1762   			}
;;;1763   		}
;;;1764   		else
;;;1765   		{
;;;1766   			mtCOVERAGE_TEST_MARKER();
;;;1767   		}
;;;1768   	}
;;;1769   
;;;1770   	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
0000bc  e2860001          ADD      r0,r6,#1
0000c0  e5840038          STR      r0,[r4,#0x38]
;;;1771   
;;;1772   	return xReturn;
0000c4  e1a00008          MOV      r0,r8
;;;1773   }
0000c8  e8bd81f0          POP      {r4-r8,pc}
;;;1774   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseNewQueue||, CODE, READONLY, ALIGN=2

                  prvInitialiseNewQueue PROC
;;;431    
;;;432    static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;433    {
000004  e1a06000          MOV      r6,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a07002          MOV      r7,r2
000010  e1a08003          MOV      r8,r3
000014  e59d4018          LDR      r4,[sp,#0x18]
;;;434    	/* Remove compiler warnings about unused parameters should
;;;435    	configUSE_TRACE_FACILITY not be set to 1. */
;;;436    	( void ) ucQueueType;
;;;437    
;;;438    	if( uxItemSize == ( UBaseType_t ) 0 )
000018  e3550000          CMP      r5,#0
00001c  1a000001          BNE      |L3.40|
;;;439    	{
;;;440    		/* No RAM was allocated for the queue storage area, but PC head cannot
;;;441    		be set to NULL because NULL is used as a key to say the queue is used as
;;;442    		a mutex.  Therefore just set pcHead to point to the queue as a benign
;;;443    		value that is known to be within the memory map. */
;;;444    		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
000020  e5844000          STR      r4,[r4,#0]
000024  ea000000          B        |L3.44|
                  |L3.40|
;;;445    	}
;;;446    	else
;;;447    	{
;;;448    		/* Set the head to the start of the queue storage area. */
;;;449    		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
000028  e5847000          STR      r7,[r4,#0]
                  |L3.44|
;;;450    	}
;;;451    
;;;452    	/* Initialise the queue members as described where the queue type is
;;;453    	defined. */
;;;454    	pxNewQueue->uxLength = uxQueueLength;
00002c  e584603c          STR      r6,[r4,#0x3c]
;;;455    	pxNewQueue->uxItemSize = uxItemSize;
000030  e5845040          STR      r5,[r4,#0x40]
;;;456    	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
000034  e3a01001          MOV      r1,#1
000038  e1a00004          MOV      r0,r4
00003c  ebfffffe          BL       xQueueGenericReset
;;;457    
;;;458    	#if ( configUSE_TRACE_FACILITY == 1 )
;;;459    	{
;;;460    		pxNewQueue->ucQueueType = ucQueueType;
000040  e5c4804c          STRB     r8,[r4,#0x4c]
;;;461    	}
;;;462    	#endif /* configUSE_TRACE_FACILITY */
;;;463    
;;;464    	#if( configUSE_QUEUE_SETS == 1 )
;;;465    	{
;;;466    		pxNewQueue->pxQueueSetContainer = NULL;
;;;467    	}
;;;468    	#endif /* configUSE_QUEUE_SETS */
;;;469    
;;;470    	traceQUEUE_CREATE( pxNewQueue );
;;;471    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;472    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=2

                  prvIsQueueEmpty PROC
;;;1913   
;;;1914   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1915   {
000004  e1a05000          MOV      r5,r0
;;;1916   BaseType_t xReturn;
;;;1917   
;;;1918   	taskENTER_CRITICAL();
000008  ebfffffe          BL       vPortEnterCritical
;;;1919   	{
;;;1920   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
00000c  e5950038          LDR      r0,[r5,#0x38]
000010  e3500000          CMP      r0,#0
000014  1a000001          BNE      |L4.32|
;;;1921   		{
;;;1922   			xReturn = pdTRUE;
000018  e3a04001          MOV      r4,#1
00001c  ea000000          B        |L4.36|
                  |L4.32|
;;;1923   		}
;;;1924   		else
;;;1925   		{
;;;1926   			xReturn = pdFALSE;
000020  e3a04000          MOV      r4,#0
                  |L4.36|
;;;1927   		}
;;;1928   	}
;;;1929   	taskEXIT_CRITICAL();
000024  ebfffffe          BL       vPortExitCritical
;;;1930   
;;;1931   	return xReturn;
000028  e1a00004          MOV      r0,r4
;;;1932   }
00002c  e8bd8070          POP      {r4-r6,pc}
;;;1933   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueFull||, CODE, READONLY, ALIGN=2

                  prvIsQueueFull PROC
;;;1952   
;;;1953   static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1954   {
000004  e1a05000          MOV      r5,r0
;;;1955   BaseType_t xReturn;
;;;1956   
;;;1957   	taskENTER_CRITICAL();
000008  ebfffffe          BL       vPortEnterCritical
;;;1958   	{
;;;1959   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
00000c  e5950038          LDR      r0,[r5,#0x38]
000010  e595103c          LDR      r1,[r5,#0x3c]
000014  e1500001          CMP      r0,r1
000018  1a000001          BNE      |L5.36|
;;;1960   		{
;;;1961   			xReturn = pdTRUE;
00001c  e3a04001          MOV      r4,#1
000020  ea000000          B        |L5.40|
                  |L5.36|
;;;1962   		}
;;;1963   		else
;;;1964   		{
;;;1965   			xReturn = pdFALSE;
000024  e3a04000          MOV      r4,#0
                  |L5.40|
;;;1966   		}
;;;1967   	}
;;;1968   	taskEXIT_CRITICAL();
000028  ebfffffe          BL       vPortExitCritical
;;;1969   
;;;1970   	return xReturn;
00002c  e1a00004          MOV      r0,r4
;;;1971   }
000030  e8bd8070          POP      {r4-r6,pc}
;;;1972   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=2

                  prvUnlockQueue PROC
;;;1793   
;;;1794   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1795   {
000004  e1a04000          MOV      r4,r0
;;;1796   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1797   
;;;1798   	/* The lock counts contains the number of extra data items placed or
;;;1799   	removed from the queue while the queue was locked.  When a queue is
;;;1800   	locked items can be added or removed, but the event lists cannot be
;;;1801   	updated. */
;;;1802   	taskENTER_CRITICAL();
000008  ebfffffe          BL       vPortEnterCritical
;;;1803   	{
;;;1804   		int8_t cTxLock = pxQueue->cTxLock;
00000c  e1d454d5          LDRSB    r5,[r4,#0x45]
;;;1805   
;;;1806   		/* See if data was added to the queue while it was locked. */
;;;1807   		while( cTxLock > queueLOCKED_UNMODIFIED )
000010  ea000011          B        |L6.92|
                  |L6.20|
;;;1808   		{
;;;1809   			/* Data was posted while the queue was locked.  Are any tasks
;;;1810   			blocked waiting for data to become available? */
;;;1811   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1812   			{
;;;1813   				if( pxQueue->pxQueueSetContainer != NULL )
;;;1814   				{
;;;1815   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;1816   					{
;;;1817   						/* The queue is a member of a queue set, and posting to
;;;1818   						the queue set caused a higher priority task to unblock.
;;;1819   						A context switch is required. */
;;;1820   						vTaskMissedYield();
;;;1821   					}
;;;1822   					else
;;;1823   					{
;;;1824   						mtCOVERAGE_TEST_MARKER();
;;;1825   					}
;;;1826   				}
;;;1827   				else
;;;1828   				{
;;;1829   					/* Tasks that are removed from the event list will get
;;;1830   					added to the pending ready list as the scheduler is still
;;;1831   					suspended. */
;;;1832   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1833   					{
;;;1834   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1835   						{
;;;1836   							/* The task waiting has a higher priority so record that a
;;;1837   							context	switch is required. */
;;;1838   							vTaskMissedYield();
;;;1839   						}
;;;1840   						else
;;;1841   						{
;;;1842   							mtCOVERAGE_TEST_MARKER();
;;;1843   						}
;;;1844   					}
;;;1845   					else
;;;1846   					{
;;;1847   						break;
;;;1848   					}
;;;1849   				}
;;;1850   			}
;;;1851   			#else /* configUSE_QUEUE_SETS */
;;;1852   			{
;;;1853   				/* Tasks that are removed from the event list will get added to
;;;1854   				the pending ready list as the scheduler is still suspended. */
;;;1855   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000014  e5940024          LDR      r0,[r4,#0x24]
000018  e3500000          CMP      r0,#0
00001c  1a000001          BNE      |L6.40|
000020  e3a00001          MOV      r0,#1
000024  ea000000          B        |L6.44|
                  |L6.40|
000028  e3a00000          MOV      r0,#0
                  |L6.44|
00002c  e3500000          CMP      r0,#0
000030  1a000005          BNE      |L6.76|
;;;1856   				{
;;;1857   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000034  e2840024          ADD      r0,r4,#0x24
000038  ebfffffe          BL       xTaskRemoveFromEventList
00003c  e3500000          CMP      r0,#0
000040  0a000002          BEQ      |L6.80|
;;;1858   					{
;;;1859   						/* The task waiting has a higher priority so record that
;;;1860   						a context switch is required. */
;;;1861   						vTaskMissedYield();
000044  ebfffffe          BL       vTaskMissedYield
000048  ea000000          B        |L6.80|
                  |L6.76|
;;;1862   					}
;;;1863   					else
;;;1864   					{
;;;1865   						mtCOVERAGE_TEST_MARKER();
;;;1866   					}
;;;1867   				}
;;;1868   				else
;;;1869   				{
;;;1870   					break;
00004c  ea000004          B        |L6.100|
                  |L6.80|
;;;1871   				}
;;;1872   			}
;;;1873   			#endif /* configUSE_QUEUE_SETS */
;;;1874   
;;;1875   			--cTxLock;
000050  e2450001          SUB      r0,r5,#1
000054  e1a00c00          LSL      r0,r0,#24
000058  e1a05c40          ASR      r5,r0,#24
                  |L6.92|
00005c  e3550000          CMP      r5,#0                 ;1807
000060  caffffeb          BGT      |L6.20|
                  |L6.100|
000064  e1a00000          MOV      r0,r0                 ;1870
;;;1876   		}
;;;1877   
;;;1878   		pxQueue->cTxLock = queueUNLOCKED;
000068  e3a000ff          MOV      r0,#0xff
00006c  e5c40045          STRB     r0,[r4,#0x45]
;;;1879   	}
;;;1880   	taskEXIT_CRITICAL();
000070  ebfffffe          BL       vPortExitCritical
;;;1881   
;;;1882   	/* Do the same for the Rx lock. */
;;;1883   	taskENTER_CRITICAL();
000074  ebfffffe          BL       vPortEnterCritical
;;;1884   	{
;;;1885   		int8_t cRxLock = pxQueue->cRxLock;
000078  e1d454d4          LDRSB    r5,[r4,#0x44]
;;;1886   
;;;1887   		while( cRxLock > queueLOCKED_UNMODIFIED )
00007c  ea000011          B        |L6.200|
                  |L6.128|
;;;1888   		{
;;;1889   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000080  e5940010          LDR      r0,[r4,#0x10]
000084  e3500000          CMP      r0,#0
000088  1a000001          BNE      |L6.148|
00008c  e3a00001          MOV      r0,#1
000090  ea000000          B        |L6.152|
                  |L6.148|
000094  e3a00000          MOV      r0,#0
                  |L6.152|
000098  e3500000          CMP      r0,#0
00009c  1a000008          BNE      |L6.196|
;;;1890   			{
;;;1891   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0000a0  e2840010          ADD      r0,r4,#0x10
0000a4  ebfffffe          BL       xTaskRemoveFromEventList
0000a8  e3500000          CMP      r0,#0
0000ac  0a000000          BEQ      |L6.180|
;;;1892   				{
;;;1893   					vTaskMissedYield();
0000b0  ebfffffe          BL       vTaskMissedYield
                  |L6.180|
;;;1894   				}
;;;1895   				else
;;;1896   				{
;;;1897   					mtCOVERAGE_TEST_MARKER();
;;;1898   				}
;;;1899   
;;;1900   				--cRxLock;
0000b4  e2450001          SUB      r0,r5,#1
0000b8  e1a00c00          LSL      r0,r0,#24
0000bc  e1a05c40          ASR      r5,r0,#24
0000c0  ea000000          B        |L6.200|
                  |L6.196|
;;;1901   			}
;;;1902   			else
;;;1903   			{
;;;1904   				break;
0000c4  ea000001          B        |L6.208|
                  |L6.200|
0000c8  e3550000          CMP      r5,#0                 ;1887
0000cc  caffffeb          BGT      |L6.128|
                  |L6.208|
0000d0  e1a00000          MOV      r0,r0
;;;1905   			}
;;;1906   		}
;;;1907   
;;;1908   		pxQueue->cRxLock = queueUNLOCKED;
0000d4  e3a000ff          MOV      r0,#0xff
0000d8  e5c40044          STRB     r0,[r4,#0x44]
;;;1909   	}
;;;1910   	taskEXIT_CRITICAL();
0000dc  ebfffffe          BL       vPortExitCritical
;;;1911   }
0000e0  e8bd8070          POP      {r4-r6,pc}
;;;1912   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.ucQueueGetQueueType||, CODE, READONLY, ALIGN=2

                  ucQueueGetQueueType PROC
;;;1688   
;;;1689   	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
000000  e1a01000          MOV      r1,r0
;;;1690   	{
;;;1691   		return ( ( Queue_t * ) xQueue )->ucQueueType;
000004  e5d1004c          LDRB     r0,[r1,#0x4c]
;;;1692   	}
000008  e12fff1e          BX       lr
;;;1693   
                          ENDP


                          AREA ||i.uxQueueGetQueueNumber||, CODE, READONLY, ALIGN=2

                  uxQueueGetQueueNumber PROC
;;;1668   
;;;1669   	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
000000  e1a01000          MOV      r1,r0
;;;1670   	{
;;;1671   		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
000004  e5910048          LDR      r0,[r1,#0x48]
;;;1672   	}
000008  e12fff1e          BX       lr
;;;1673   
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=2

                  uxQueueMessagesWaiting PROC
;;;1578   
;;;1579   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1580   {
000004  e1a04000          MOV      r4,r0
;;;1581   UBaseType_t uxReturn;
;;;1582   
;;;1583   	configASSERT( xQueue );
000008  e3540000          CMP      r4,#0
00000c  1a000005          BNE      |L9.40|
000010  e1a00000          MOV      r0,r0
000014  e28f2020          ADR      r2,|L9.60|
000018  e59f1034          LDR      r1,|L9.84|
00001c  e28f0034          ADR      r0,|L9.88|
000020  ebfffffe          BL       sysprintf
000024  e1a00000          MOV      r0,r0
                  |L9.40|
;;;1584   
;;;1585   	taskENTER_CRITICAL();
000028  ebfffffe          BL       vPortEnterCritical
;;;1586   	{
;;;1587   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
00002c  e5945038          LDR      r5,[r4,#0x38]
;;;1588   	}
;;;1589   	taskEXIT_CRITICAL();
000030  ebfffffe          BL       vPortExitCritical
;;;1590   
;;;1591   	return uxReturn;
000034  e1a00005          MOV      r0,r5
;;;1592   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000038  e8bd8070          POP      {r4-r6,pc}
;;;1593   /*-----------------------------------------------------------*/
                          ENDP

                  |L9.60|
00003c  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
000040  52544f53
000044  5c536f75
000048  7263655c
00004c  71756575
000050  652e6300
                  |L9.84|
                          DCD      0x0000062f
                  |L9.88|
000058  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
00005c  7274696f
000060  6e202220
000064  3f3f3f20
000068  22206661
00006c  696c6564
000070  20617420
000074  6c696e65
000078  20256420
00007c  696e2025
000080  730a00  
000083  00                DCB      0

                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=2

                  uxQueueMessagesWaitingFromISR PROC
;;;1612   
;;;1613   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1614   {
000004  e1a04000          MOV      r4,r0
;;;1615   UBaseType_t uxReturn;
;;;1616   
;;;1617   	configASSERT( xQueue );
000008  e3540000          CMP      r4,#0
00000c  1a000005          BNE      |L10.40|
000010  e1a00000          MOV      r0,r0
000014  e28f2018          ADR      r2,|L10.52|
000018  e59f102c          LDR      r1,|L10.76|
00001c  e28f002c          ADR      r0,|L10.80|
000020  ebfffffe          BL       sysprintf
000024  e1a00000          MOV      r0,r0
                  |L10.40|
;;;1618   
;;;1619   	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000028  e5945038          LDR      r5,[r4,#0x38]
;;;1620   
;;;1621   	return uxReturn;
00002c  e1a00005          MOV      r0,r5
;;;1622   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000030  e8bd8070          POP      {r4-r6,pc}
;;;1623   /*-----------------------------------------------------------*/
                          ENDP

                  |L10.52|
000034  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
000038  52544f53
00003c  5c536f75
000040  7263655c
000044  71756575
000048  652e6300
                  |L10.76|
                          DCD      0x00000651
                  |L10.80|
000050  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000054  7274696f
000058  6e202220
00005c  3f3f3f20
000060  22206661
000064  696c6564
000068  20617420
00006c  6c696e65
000070  20256420
000074  696e2025
000078  730a00  
00007b  00                DCB      0

                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=2

                  uxQueueSpacesAvailable PROC
;;;1594   
;;;1595   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1596   {
000004  e1a04000          MOV      r4,r0
;;;1597   UBaseType_t uxReturn;
;;;1598   Queue_t *pxQueue;
;;;1599   
;;;1600   	pxQueue = ( Queue_t * ) xQueue;
000008  e1a05004          MOV      r5,r4
;;;1601   	configASSERT( pxQueue );
00000c  e3550000          CMP      r5,#0
000010  1a000005          BNE      |L11.44|
000014  e1a00000          MOV      r0,r0
000018  e28f2028          ADR      r2,|L11.72|
00001c  e59f103c          LDR      r1,|L11.96|
000020  e28f003c          ADR      r0,|L11.100|
000024  ebfffffe          BL       sysprintf
000028  e1a00000          MOV      r0,r0
                  |L11.44|
;;;1602   
;;;1603   	taskENTER_CRITICAL();
00002c  ebfffffe          BL       vPortEnterCritical
;;;1604   	{
;;;1605   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
000030  e595003c          LDR      r0,[r5,#0x3c]
000034  e5951038          LDR      r1,[r5,#0x38]
000038  e0406001          SUB      r6,r0,r1
;;;1606   	}
;;;1607   	taskEXIT_CRITICAL();
00003c  ebfffffe          BL       vPortExitCritical
;;;1608   
;;;1609   	return uxReturn;
000040  e1a00006          MOV      r0,r6
;;;1610   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000044  e8bd8070          POP      {r4-r6,pc}
;;;1611   /*-----------------------------------------------------------*/
                          ENDP

                  |L11.72|
000048  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
00004c  52544f53
000050  5c536f75
000054  7263655c
000058  71756575
00005c  652e6300
                  |L11.96|
                          DCD      0x00000641
                  |L11.100|
000064  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000068  7274696f
00006c  6e202220
000070  3f3f3f20
000074  22206661
000078  696c6564
00007c  20617420
000080  6c696e65
000084  20256420
000088  696e2025
00008c  730a00  
00008f  00                DCB      0

                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=2

                  vQueueDelete PROC
;;;1624   
;;;1625   void vQueueDelete( QueueHandle_t xQueue )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1626   {
000004  e1a04000          MOV      r4,r0
;;;1627   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000008  e1a05004          MOV      r5,r4
;;;1628   
;;;1629   	configASSERT( pxQueue );
00000c  e3550000          CMP      r5,#0
000010  1a000005          BNE      |L12.44|
000014  e1a00000          MOV      r0,r0
000018  e28f2018          ADR      r2,|L12.56|
00001c  e59f102c          LDR      r1,|L12.80|
000020  e28f002c          ADR      r0,|L12.84|
000024  ebfffffe          BL       sysprintf
000028  e1a00000          MOV      r0,r0
                  |L12.44|
;;;1630   	traceQUEUE_DELETE( pxQueue );
;;;1631   
;;;1632   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1633   	{
;;;1634   		vQueueUnregisterQueue( pxQueue );
;;;1635   	}
;;;1636   	#endif
;;;1637   
;;;1638   	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;1639   	{
;;;1640   		/* The queue can only have been allocated dynamically - free it
;;;1641   		again. */
;;;1642   		vPortFree( pxQueue );
00002c  e1a00005          MOV      r0,r5
000030  ebfffffe          BL       vPortFree
;;;1643   	}
;;;1644   	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;1645   	{
;;;1646   		/* The queue could have been allocated statically or dynamically, so
;;;1647   		check before attempting to free the memory. */
;;;1648   		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;1649   		{
;;;1650   			vPortFree( pxQueue );
;;;1651   		}
;;;1652   		else
;;;1653   		{
;;;1654   			mtCOVERAGE_TEST_MARKER();
;;;1655   		}
;;;1656   	}
;;;1657   	#else
;;;1658   	{
;;;1659   		/* The queue must have been statically allocated, so is not going to be
;;;1660   		deleted.  Avoid compiler warnings about the unused parameter. */
;;;1661   		( void ) pxQueue;
;;;1662   	}
;;;1663   	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;1664   }
000034  e8bd8070          POP      {r4-r6,pc}
;;;1665   /*-----------------------------------------------------------*/
                          ENDP

                  |L12.56|
000038  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
00003c  52544f53
000040  5c536f75
000044  7263655c
000048  71756575
00004c  652e6300
                  |L12.80|
                          DCD      0x0000065d
                  |L12.84|
000054  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000058  7274696f
00005c  6e202220
000060  3f3f3f20
000064  22206661
000068  696c6564
00006c  20617420
000070  6c696e65
000074  20256420
000078  696e2025
00007c  730a00  
00007f  00                DCB      0

                          AREA ||i.vQueueSetQueueNumber||, CODE, READONLY, ALIGN=2

                  vQueueSetQueueNumber PROC
;;;1678   
;;;1679   	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
000000  e5801048          STR      r1,[r0,#0x48]
;;;1680   	{
;;;1681   		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
;;;1682   	}
000004  e12fff1e          BX       lr
;;;1683   
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=2

                  xQueueGenericCreate PROC
;;;385    
;;;386    	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;387    	{
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
00000c  e1a08002          MOV      r8,r2
;;;388    	Queue_t *pxNewQueue;
;;;389    	size_t xQueueSizeInBytes;
;;;390    	uint8_t *pucQueueStorage;
;;;391    
;;;392    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
000010  e3550000          CMP      r5,#0
000014  0a000001          BEQ      |L14.32|
000018  e3a00001          MOV      r0,#1
00001c  ea000000          B        |L14.36|
                  |L14.32|
000020  e3a00000          MOV      r0,#0
                  |L14.36|
000024  e3500000          CMP      r0,#0
000028  1a000005          BNE      |L14.68|
00002c  e1a00000          MOV      r0,r0
000030  e28f2058          ADR      r2,|L14.144|
000034  e3a01f62          MOV      r1,#0x188
000038  e28f0068          ADR      r0,|L14.168|
00003c  ebfffffe          BL       sysprintf
000040  e1a00000          MOV      r0,r0
                  |L14.68|
;;;393    
;;;394    		if( uxItemSize == ( UBaseType_t ) 0 )
000044  e3560000          CMP      r6,#0
000048  1a000001          BNE      |L14.84|
;;;395    		{
;;;396    			/* There is not going to be a queue storage area. */
;;;397    			xQueueSizeInBytes = ( size_t ) 0;
00004c  e3a07000          MOV      r7,#0
000050  ea000000          B        |L14.88|
                  |L14.84|
;;;398    		}
;;;399    		else
;;;400    		{
;;;401    			/* Allocate enough space to hold the maximum number of items that
;;;402    			can be in the queue at any time. */
;;;403    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000054  e0070695          MUL      r7,r5,r6
                  |L14.88|
;;;404    		}
;;;405    
;;;406    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
000058  e2870050          ADD      r0,r7,#0x50
00005c  ebfffffe          BL       pvPortMalloc
000060  e1a04000          MOV      r4,r0
;;;407    
;;;408    		if( pxNewQueue != NULL )
000064  e3540000          CMP      r4,#0
000068  0a000006          BEQ      |L14.136|
;;;409    		{
;;;410    			/* Jump past the queue structure to find the location of the queue
;;;411    			storage area. */
;;;412    			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
00006c  e2849050          ADD      r9,r4,#0x50
;;;413    
;;;414    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;415    			{
;;;416    				/* Queues can be created either statically or dynamically, so
;;;417    				note this task was created dynamically in case it is later
;;;418    				deleted. */
;;;419    				pxNewQueue->ucStaticallyAllocated = pdFALSE;
;;;420    			}
;;;421    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;422    
;;;423    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
000070  e1a03008          MOV      r3,r8
000074  e1a02009          MOV      r2,r9
000078  e1a01006          MOV      r1,r6
00007c  e1a00005          MOV      r0,r5
000080  e58d4000          STR      r4,[sp,#0]
000084  ebfffffe          BL       prvInitialiseNewQueue
                  |L14.136|
;;;424    		}
;;;425    
;;;426    		return pxNewQueue;
000088  e1a00004          MOV      r0,r4
;;;427    	}
00008c  e8bd83f8          POP      {r3-r9,pc}
;;;428    
                          ENDP

                  |L14.144|
000090  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
000094  52544f53
000098  5c536f75
00009c  7263655c
0000a0  71756575
0000a4  652e6300
                  |L14.168|
0000a8  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000ac  7274696f
0000b0  6e202220
0000b4  3f3f3f20
0000b8  22206661
0000bc  696c6564
0000c0  20617420
0000c4  6c696e65
0000c8  20256420
0000cc  696e2025
0000d0  730a00  
0000d3  00                DCB      0

                          AREA ||i.xQueueGenericReceive||, CODE, READONLY, ALIGN=2

                  xQueueGenericReceive PROC
;;;1236   
;;;1237   BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;1238   {
000004  e24dd008          SUB      sp,sp,#8
000008  e1a05000          MOV      r5,r0
00000c  e1a06001          MOV      r6,r1
000010  e1a07003          MOV      r7,r3
;;;1239   BaseType_t xEntryTimeSet = pdFALSE;
000014  e3a0a000          MOV      r10,#0
;;;1240   TimeOut_t xTimeOut;
;;;1241   int8_t *pcOriginalReadPosition;
;;;1242   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000018  e1a04005          MOV      r4,r5
;;;1243   
;;;1244   	configASSERT( pxQueue );
00001c  e3540000          CMP      r4,#0
000020  1a000005          BNE      |L15.60|
000024  e1a00000          MOV      r0,r0
000028  e28f2f8a          ADR      r2,|L15.600|
00002c  e59f123c          LDR      r1,|L15.624|
000030  e28f0f8f          ADR      r0,|L15.628|
000034  ebfffffe          BL       sysprintf
000038  e1a00000          MOV      r0,r0
                  |L15.60|
;;;1245   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00003c  e3560000          CMP      r6,#0
000040  1a000002          BNE      |L15.80|
000044  e5940040          LDR      r0,[r4,#0x40]
000048  e3500000          CMP      r0,#0
00004c  1a000001          BNE      |L15.88|
                  |L15.80|
000050  e3a00001          MOV      r0,#1
000054  ea000000          B        |L15.92|
                  |L15.88|
000058  e3a00000          MOV      r0,#0
                  |L15.92|
00005c  e3500000          CMP      r0,#0
000060  1a000005          BNE      |L15.124|
000064  e1a00000          MOV      r0,r0
000068  e28f2f7a          ADR      r2,|L15.600|
00006c  e59f122c          LDR      r1,|L15.672|
000070  e28f0f7f          ADR      r0,|L15.628|
000074  ebfffffe          BL       sysprintf
000078  e1a00000          MOV      r0,r0
                  |L15.124|
;;;1246   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1247   	{
;;;1248   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00007c  ebfffffe          BL       xTaskGetSchedulerState
000080  e3500000          CMP      r0,#0
000084  1a000002          BNE      |L15.148|
000088  e59d0010          LDR      r0,[sp,#0x10]
00008c  e3500000          CMP      r0,#0
000090  1a000001          BNE      |L15.156|
                  |L15.148|
000094  e3a00001          MOV      r0,#1
000098  ea000000          B        |L15.160|
                  |L15.156|
00009c  e3a00000          MOV      r0,#0
                  |L15.160|
0000a0  e3500000          CMP      r0,#0
0000a4  1a000005          BNE      |L15.192|
0000a8  e1a00000          MOV      r0,r0
0000ac  e28f2f69          ADR      r2,|L15.600|
0000b0  e3a01e4e          MOV      r1,#0x4e0
0000b4  e28f0f6e          ADR      r0,|L15.628|
0000b8  ebfffffe          BL       sysprintf
0000bc  e1a00000          MOV      r0,r0
                  |L15.192|
;;;1249   	}
;;;1250   	#endif
;;;1251   
;;;1252   	/* This function relaxes the coding standard somewhat to allow return
;;;1253   	statements within the function itself.  This is done in the interest
;;;1254   	of execution time efficiency. */
;;;1255   
;;;1256   	for( ;; )
0000c0  e1a00000          MOV      r0,r0
                  |L15.196|
;;;1257   	{
;;;1258   		taskENTER_CRITICAL();
0000c4  ebfffffe          BL       vPortEnterCritical
;;;1259   		{
;;;1260   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
0000c8  e5949038          LDR      r9,[r4,#0x38]
;;;1261   
;;;1262   			/* Is there data in the queue now?  To be running the calling task
;;;1263   			must be the highest priority task wanting to access the queue. */
;;;1264   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
0000cc  e3590000          CMP      r9,#0
0000d0  0a000027          BEQ      |L15.372|
;;;1265   			{
;;;1266   				/* Remember the read position in case the queue is only being
;;;1267   				peeked. */
;;;1268   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
0000d4  e594800c          LDR      r8,[r4,#0xc]
;;;1269   
;;;1270   				prvCopyDataFromQueue( pxQueue, pvBuffer );
0000d8  e1a01006          MOV      r1,r6
0000dc  e1a00004          MOV      r0,r4
0000e0  ebfffffe          BL       prvCopyDataFromQueue
;;;1271   
;;;1272   				if( xJustPeeking == pdFALSE )
0000e4  e3570000          CMP      r7,#0
0000e8  1a00000f          BNE      |L15.300|
;;;1273   				{
;;;1274   					traceQUEUE_RECEIVE( pxQueue );
;;;1275   
;;;1276   					/* Actually removing data, not just peeking. */
;;;1277   					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
0000ec  e2490001          SUB      r0,r9,#1
0000f0  e5840038          STR      r0,[r4,#0x38]
;;;1278   
;;;1279   					#if ( configUSE_MUTEXES == 1 )
;;;1280   					{
;;;1281   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1282   						{
;;;1283   							/* Record the information required to implement
;;;1284   							priority inheritance should it become necessary. */
;;;1285   							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
;;;1286   						}
;;;1287   						else
;;;1288   						{
;;;1289   							mtCOVERAGE_TEST_MARKER();
;;;1290   						}
;;;1291   					}
;;;1292   					#endif /* configUSE_MUTEXES */
;;;1293   
;;;1294   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
0000f4  e5940010          LDR      r0,[r4,#0x10]
0000f8  e3500000          CMP      r0,#0
0000fc  1a000001          BNE      |L15.264|
000100  e3a00001          MOV      r0,#1
000104  ea000000          B        |L15.268|
                  |L15.264|
000108  e3a00000          MOV      r0,#0
                  |L15.268|
00010c  e3500000          CMP      r0,#0
000110  1a000013          BNE      |L15.356|
;;;1295   					{
;;;1296   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000114  e2840010          ADD      r0,r4,#0x10
000118  ebfffffe          BL       xTaskRemoveFromEventList
00011c  e3500000          CMP      r0,#0
000120  0a00000f          BEQ      |L15.356|
;;;1297   						{
;;;1298   							queueYIELD_IF_USING_PREEMPTION();
000124  ebfffffe          BL       vPortYield
000128  ea00000d          B        |L15.356|
                  |L15.300|
;;;1299   						}
;;;1300   						else
;;;1301   						{
;;;1302   							mtCOVERAGE_TEST_MARKER();
;;;1303   						}
;;;1304   					}
;;;1305   					else
;;;1306   					{
;;;1307   						mtCOVERAGE_TEST_MARKER();
;;;1308   					}
;;;1309   				}
;;;1310   				else
;;;1311   				{
;;;1312   					traceQUEUE_PEEK( pxQueue );
;;;1313   
;;;1314   					/* The data is not being removed, so reset the read
;;;1315   					pointer. */
;;;1316   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
00012c  e584800c          STR      r8,[r4,#0xc]
;;;1317   
;;;1318   					/* The data is being left in the queue, so see if there are
;;;1319   					any other tasks waiting for the data. */
;;;1320   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000130  e5940024          LDR      r0,[r4,#0x24]
000134  e3500000          CMP      r0,#0
000138  1a000001          BNE      |L15.324|
00013c  e3a00001          MOV      r0,#1
000140  ea000000          B        |L15.328|
                  |L15.324|
000144  e3a00000          MOV      r0,#0
                  |L15.328|
000148  e3500000          CMP      r0,#0
00014c  1a000004          BNE      |L15.356|
;;;1321   					{
;;;1322   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000150  e2840024          ADD      r0,r4,#0x24
000154  ebfffffe          BL       xTaskRemoveFromEventList
000158  e3500000          CMP      r0,#0
00015c  0a000000          BEQ      |L15.356|
;;;1323   						{
;;;1324   							/* The task waiting has a higher priority than this task. */
;;;1325   							queueYIELD_IF_USING_PREEMPTION();
000160  ebfffffe          BL       vPortYield
                  |L15.356|
;;;1326   						}
;;;1327   						else
;;;1328   						{
;;;1329   							mtCOVERAGE_TEST_MARKER();
;;;1330   						}
;;;1331   					}
;;;1332   					else
;;;1333   					{
;;;1334   						mtCOVERAGE_TEST_MARKER();
;;;1335   					}
;;;1336   				}
;;;1337   
;;;1338   				taskEXIT_CRITICAL();
000164  ebfffffe          BL       vPortExitCritical
;;;1339   				return pdPASS;
000168  e3a00001          MOV      r0,#1
                  |L15.364|
00016c  e28dd018          ADD      sp,sp,#0x18
;;;1340   			}
;;;1341   			else
;;;1342   			{
;;;1343   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1344   				{
;;;1345   					/* The queue was empty and no block time is specified (or
;;;1346   					the block time has expired) so leave now. */
;;;1347   					taskEXIT_CRITICAL();
;;;1348   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1349   					return errQUEUE_EMPTY;
;;;1350   				}
;;;1351   				else if( xEntryTimeSet == pdFALSE )
;;;1352   				{
;;;1353   					/* The queue was empty and a block time was specified so
;;;1354   					configure the timeout structure. */
;;;1355   					vTaskSetTimeOutState( &xTimeOut );
;;;1356   					xEntryTimeSet = pdTRUE;
;;;1357   				}
;;;1358   				else
;;;1359   				{
;;;1360   					/* Entry time was already set. */
;;;1361   					mtCOVERAGE_TEST_MARKER();
;;;1362   				}
;;;1363   			}
;;;1364   		}
;;;1365   		taskEXIT_CRITICAL();
;;;1366   
;;;1367   		/* Interrupts and other tasks can send to and receive from the queue
;;;1368   		now the critical section has been exited. */
;;;1369   
;;;1370   		vTaskSuspendAll();
;;;1371   		prvLockQueue( pxQueue );
;;;1372   
;;;1373   		/* Update the timeout state to see if it has expired yet. */
;;;1374   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1375   		{
;;;1376   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1377   			{
;;;1378   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1379   
;;;1380   				#if ( configUSE_MUTEXES == 1 )
;;;1381   				{
;;;1382   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1383   					{
;;;1384   						taskENTER_CRITICAL();
;;;1385   						{
;;;1386   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1387   						}
;;;1388   						taskEXIT_CRITICAL();
;;;1389   					}
;;;1390   					else
;;;1391   					{
;;;1392   						mtCOVERAGE_TEST_MARKER();
;;;1393   					}
;;;1394   				}
;;;1395   				#endif
;;;1396   
;;;1397   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1398   				prvUnlockQueue( pxQueue );
;;;1399   				if( xTaskResumeAll() == pdFALSE )
;;;1400   				{
;;;1401   					portYIELD_WITHIN_API();
;;;1402   				}
;;;1403   				else
;;;1404   				{
;;;1405   					mtCOVERAGE_TEST_MARKER();
;;;1406   				}
;;;1407   			}
;;;1408   			else
;;;1409   			{
;;;1410   				/* Try again. */
;;;1411   				prvUnlockQueue( pxQueue );
;;;1412   				( void ) xTaskResumeAll();
;;;1413   			}
;;;1414   		}
;;;1415   		else
;;;1416   		{
;;;1417   			prvUnlockQueue( pxQueue );
;;;1418   			( void ) xTaskResumeAll();
;;;1419   
;;;1420   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1421   			{
;;;1422   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1423   				return errQUEUE_EMPTY;
;;;1424   			}
;;;1425   			else
;;;1426   			{
;;;1427   				mtCOVERAGE_TEST_MARKER();
;;;1428   			}
;;;1429   		}
;;;1430   	}
;;;1431   }
000170  e8bd87f0          POP      {r4-r10,pc}
                  |L15.372|
000174  e59d0010          LDR      r0,[sp,#0x10]         ;1343
000178  e3500000          CMP      r0,#0                 ;1343
00017c  1a000002          BNE      |L15.396|
000180  ebfffffe          BL       vPortExitCritical
000184  e3a00000          MOV      r0,#0                 ;1349
000188  eafffff7          B        |L15.364|
                  |L15.396|
00018c  e35a0000          CMP      r10,#0                ;1351
000190  1a000002          BNE      |L15.416|
000194  e1a0000d          MOV      r0,sp                 ;1355
000198  ebfffffe          BL       vTaskSetTimeOutState
00019c  e3a0a001          MOV      r10,#1                ;1356
                  |L15.416|
0001a0  ebfffffe          BL       vPortExitCritical
0001a4  ebfffffe          BL       vTaskSuspendAll
0001a8  ebfffffe          BL       vPortEnterCritical
0001ac  e1d404d4          LDRSB    r0,[r4,#0x44]         ;1371
0001b0  e3700001          CMN      r0,#1                 ;1371
0001b4  1a000001          BNE      |L15.448|
0001b8  e3a00000          MOV      r0,#0                 ;1371
0001bc  e5c40044          STRB     r0,[r4,#0x44]         ;1371
                  |L15.448|
0001c0  e1d404d5          LDRSB    r0,[r4,#0x45]         ;1371
0001c4  e3700001          CMN      r0,#1                 ;1371
0001c8  1a000001          BNE      |L15.468|
0001cc  e3a00000          MOV      r0,#0                 ;1371
0001d0  e5c40045          STRB     r0,[r4,#0x45]         ;1371
                  |L15.468|
0001d4  ebfffffe          BL       vPortExitCritical
0001d8  e28d1010          ADD      r1,sp,#0x10           ;1374
0001dc  e1a0000d          MOV      r0,sp                 ;1374
0001e0  ebfffffe          BL       xTaskCheckForTimeOut
0001e4  e3500000          CMP      r0,#0                 ;1374
0001e8  1a000011          BNE      |L15.564|
0001ec  e1a00004          MOV      r0,r4                 ;1376
0001f0  ebfffffe          BL       prvIsQueueEmpty
0001f4  e3500000          CMP      r0,#0                 ;1376
0001f8  0a000009          BEQ      |L15.548|
0001fc  e2840024          ADD      r0,r4,#0x24           ;1397
000200  e59d1010          LDR      r1,[sp,#0x10]         ;1397
000204  ebfffffe          BL       vTaskPlaceOnEventList
000208  e1a00004          MOV      r0,r4                 ;1398
00020c  ebfffffe          BL       prvUnlockQueue
000210  ebfffffe          BL       xTaskResumeAll
000214  e3500000          CMP      r0,#0                 ;1399
000218  1affffa9          BNE      |L15.196|
00021c  ebfffffe          BL       vPortYield
000220  eaffffa7          B        |L15.196|
                  |L15.548|
000224  e1a00004          MOV      r0,r4                 ;1411
000228  ebfffffe          BL       prvUnlockQueue
00022c  ebfffffe          BL       xTaskResumeAll
000230  eaffffa3          B        |L15.196|
                  |L15.564|
000234  e1a00004          MOV      r0,r4                 ;1417
000238  ebfffffe          BL       prvUnlockQueue
00023c  ebfffffe          BL       xTaskResumeAll
000240  e1a00004          MOV      r0,r4                 ;1420
000244  ebfffffe          BL       prvIsQueueEmpty
000248  e3500000          CMP      r0,#0                 ;1420
00024c  0affff9c          BEQ      |L15.196|
000250  e3a00000          MOV      r0,#0                 ;1423
000254  eaffffc4          B        |L15.364|
                  |L15.600|
000258  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
00025c  52544f53
000260  5c536f75
000264  7263655c
000268  71756575
00026c  652e6300
                  |L15.624|
                          DCD      0x000004dc
                  |L15.628|
000274  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000278  7274696f
00027c  6e202220
000280  3f3f3f20
000284  22206661
000288  696c6564
00028c  20617420
000290  6c696e65
000294  20256420
000298  696e2025
00029c  730a00  
00029f  00                DCB      0
                  |L15.672|
                          DCD      0x000004dd
                          ENDP


                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;278    
;;;279    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;280    {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;281    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00000c  e1a04005          MOV      r4,r5
;;;282    
;;;283    	configASSERT( pxQueue );
000010  e3540000          CMP      r4,#0
000014  1a000005          BNE      |L16.48|
000018  e1a00000          MOV      r0,r0
00001c  e28f20b4          ADR      r2,|L16.216|
000020  e59f10c8          LDR      r1,|L16.240|
000024  e28f00c8          ADR      r0,|L16.244|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L16.48|
;;;284    
;;;285    	taskENTER_CRITICAL();
000030  ebfffffe          BL       vPortEnterCritical
;;;286    	{
;;;287    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
000034  e5940000          LDR      r0,[r4,#0]
000038  e594103c          LDR      r1,[r4,#0x3c]
00003c  e5942040          LDR      r2,[r4,#0x40]
000040  e0200291          MLA      r0,r1,r2,r0
000044  e5840004          STR      r0,[r4,#4]
;;;288    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000048  e3a00000          MOV      r0,#0
00004c  e5840038          STR      r0,[r4,#0x38]
;;;289    		pxQueue->pcWriteTo = pxQueue->pcHead;
000050  e5940000          LDR      r0,[r4,#0]
000054  e5840008          STR      r0,[r4,#8]
;;;290    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
000058  e594103c          LDR      r1,[r4,#0x3c]
00005c  e2411001          SUB      r1,r1,#1
000060  e5940000          LDR      r0,[r4,#0]
000064  e5942040          LDR      r2,[r4,#0x40]
000068  e0200291          MLA      r0,r1,r2,r0
00006c  e584000c          STR      r0,[r4,#0xc]
;;;291    		pxQueue->cRxLock = queueUNLOCKED;
000070  e3a000ff          MOV      r0,#0xff
000074  e5c40044          STRB     r0,[r4,#0x44]
;;;292    		pxQueue->cTxLock = queueUNLOCKED;
000078  e5c40045          STRB     r0,[r4,#0x45]
;;;293    
;;;294    		if( xNewQueue == pdFALSE )
00007c  e3560000          CMP      r6,#0
000080  1a00000d          BNE      |L16.188|
;;;295    		{
;;;296    			/* If there are tasks blocked waiting to read from the queue, then
;;;297    			the tasks will remain blocked as after this function exits the queue
;;;298    			will still be empty.  If there are tasks blocked waiting to write to
;;;299    			the queue, then one should be unblocked as after this function exits
;;;300    			it will be possible to write to it. */
;;;301    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000084  e5940010          LDR      r0,[r4,#0x10]
000088  e3500000          CMP      r0,#0
00008c  1a000001          BNE      |L16.152|
000090  e3a00001          MOV      r0,#1
000094  ea000000          B        |L16.156|
                  |L16.152|
000098  e3a00000          MOV      r0,#0
                  |L16.156|
00009c  e3500000          CMP      r0,#0
0000a0  1a000009          BNE      |L16.204|
;;;302    			{
;;;303    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0000a4  e2840010          ADD      r0,r4,#0x10
0000a8  ebfffffe          BL       xTaskRemoveFromEventList
0000ac  e3500000          CMP      r0,#0
0000b0  0a000005          BEQ      |L16.204|
;;;304    				{
;;;305    					queueYIELD_IF_USING_PREEMPTION();
0000b4  ebfffffe          BL       vPortYield
0000b8  ea000003          B        |L16.204|
                  |L16.188|
;;;306    				}
;;;307    				else
;;;308    				{
;;;309    					mtCOVERAGE_TEST_MARKER();
;;;310    				}
;;;311    			}
;;;312    			else
;;;313    			{
;;;314    				mtCOVERAGE_TEST_MARKER();
;;;315    			}
;;;316    		}
;;;317    		else
;;;318    		{
;;;319    			/* Ensure the event queues start in the correct state. */
;;;320    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
0000bc  e2840010          ADD      r0,r4,#0x10
0000c0  ebfffffe          BL       vListInitialise
;;;321    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
0000c4  e2840024          ADD      r0,r4,#0x24
0000c8  ebfffffe          BL       vListInitialise
                  |L16.204|
;;;322    		}
;;;323    	}
;;;324    	taskEXIT_CRITICAL();
0000cc  ebfffffe          BL       vPortExitCritical
;;;325    
;;;326    	/* A value is returned for calling semantic consistency with previous
;;;327    	versions. */
;;;328    	return pdPASS;
0000d0  e3a00001          MOV      r0,#1
;;;329    }
0000d4  e8bd8070          POP      {r4-r6,pc}
;;;330    /*-----------------------------------------------------------*/
                          ENDP

                  |L16.216|
0000d8  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
0000dc  52544f53
0000e0  5c536f75
0000e4  7263655c
0000e8  71756575
0000ec  652e6300
                  |L16.240|
                          DCD      0x0000011b
                  |L16.244|
0000f4  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
0000f8  7274696f
0000fc  6e202220
000100  3f3f3f20
000104  22206661
000108  696c6564
00010c  20617420
000110  6c696e65
000114  20256420
000118  696e2025
00011c  730a00  
00011f  00                DCB      0

                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=2

                  xQueueGenericSend PROC
;;;722    
;;;723    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  e92d43ff          PUSH     {r0-r9,lr}
;;;724    {
000004  e24dd00c          SUB      sp,sp,#0xc
000008  e1a06000          MOV      r6,r0
00000c  e1a08001          MOV      r8,r1
000010  e1a05003          MOV      r5,r3
;;;725    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
000014  e3a09000          MOV      r9,#0
;;;726    TimeOut_t xTimeOut;
;;;727    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000018  e1a04006          MOV      r4,r6
;;;728    
;;;729    	configASSERT( pxQueue );
00001c  e3540000          CMP      r4,#0
000020  1a000005          BNE      |L17.60|
000024  e1a00000          MOV      r0,r0
000028  e28f2f8b          ADR      r2,|L17.604|
00002c  e59f1240          LDR      r1,|L17.628|
000030  e28f0d09          ADR      r0,|L17.632|
000034  ebfffffe          BL       sysprintf
000038  e1a00000          MOV      r0,r0
                  |L17.60|
;;;730    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00003c  e3580000          CMP      r8,#0
000040  1a000002          BNE      |L17.80|
000044  e5940040          LDR      r0,[r4,#0x40]
000048  e3500000          CMP      r0,#0
00004c  1a000001          BNE      |L17.88|
                  |L17.80|
000050  e3a00001          MOV      r0,#1
000054  ea000000          B        |L17.92|
                  |L17.88|
000058  e3a00000          MOV      r0,#0
                  |L17.92|
00005c  e3500000          CMP      r0,#0
000060  1a000005          BNE      |L17.124|
000064  e1a00000          MOV      r0,r0
000068  e28f2f7b          ADR      r2,|L17.604|
00006c  e59f1230          LDR      r1,|L17.676|
000070  e28f0c02          ADR      r0,|L17.632|
000074  ebfffffe          BL       sysprintf
000078  e1a00000          MOV      r0,r0
                  |L17.124|
;;;731    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
00007c  e3550002          CMP      r5,#2
000080  1a000002          BNE      |L17.144|
000084  e594003c          LDR      r0,[r4,#0x3c]
000088  e3500001          CMP      r0,#1
00008c  1a000001          BNE      |L17.152|
                  |L17.144|
000090  e3a00001          MOV      r0,#1
000094  ea000000          B        |L17.156|
                  |L17.152|
000098  e3a00000          MOV      r0,#0
                  |L17.156|
00009c  e3500000          CMP      r0,#0
0000a0  1a000005          BNE      |L17.188|
0000a4  e1a00000          MOV      r0,r0
0000a8  e28f2f6b          ADR      r2,|L17.604|
0000ac  e59f11f4          LDR      r1,|L17.680|
0000b0  e28f0d07          ADR      r0,|L17.632|
0000b4  ebfffffe          BL       sysprintf
0000b8  e1a00000          MOV      r0,r0
                  |L17.188|
;;;732    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;733    	{
;;;734    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
0000bc  ebfffffe          BL       xTaskGetSchedulerState
0000c0  e3500000          CMP      r0,#0
0000c4  1a000002          BNE      |L17.212|
0000c8  e59d0014          LDR      r0,[sp,#0x14]
0000cc  e3500000          CMP      r0,#0
0000d0  1a000001          BNE      |L17.220|
                  |L17.212|
0000d4  e3a00001          MOV      r0,#1
0000d8  ea000000          B        |L17.224|
                  |L17.220|
0000dc  e3a00000          MOV      r0,#0
                  |L17.224|
0000e0  e3500000          CMP      r0,#0
0000e4  1a000005          BNE      |L17.256|
0000e8  e1a00000          MOV      r0,r0
0000ec  e28f2f5a          ADR      r2,|L17.604|
0000f0  e59f11b4          LDR      r1,|L17.684|
0000f4  e28f0f5f          ADR      r0,|L17.632|
0000f8  ebfffffe          BL       sysprintf
0000fc  e1a00000          MOV      r0,r0
                  |L17.256|
;;;735    	}
;;;736    	#endif
;;;737    
;;;738    
;;;739    	/* This function relaxes the coding standard somewhat to allow return
;;;740    	statements within the function itself.  This is done in the interest
;;;741    	of execution time efficiency. */
;;;742    	for( ;; )
000100  e1a00000          MOV      r0,r0
                  |L17.260|
;;;743    	{
;;;744    		taskENTER_CRITICAL();
000104  ebfffffe          BL       vPortEnterCritical
;;;745    		{
;;;746    			/* Is there room on the queue now?  The running task must be the
;;;747    			highest priority task wanting to access the queue.  If the head item
;;;748    			in the queue is to be overwritten then it does not matter if the
;;;749    			queue is full. */
;;;750    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000108  e5940038          LDR      r0,[r4,#0x38]
00010c  e594103c          LDR      r1,[r4,#0x3c]
000110  e1500001          CMP      r0,r1
000114  3a000001          BCC      |L17.288|
000118  e3550002          CMP      r5,#2
00011c  1a000019          BNE      |L17.392|
                  |L17.288|
;;;751    			{
;;;752    				traceQUEUE_SEND( pxQueue );
;;;753    				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
000120  e1a02005          MOV      r2,r5
000124  e1a01008          MOV      r1,r8
000128  e1a00004          MOV      r0,r4
00012c  ebfffffe          BL       prvCopyDataToQueue
000130  e1a07000          MOV      r7,r0
;;;754    
;;;755    				#if ( configUSE_QUEUE_SETS == 1 )
;;;756    				{
;;;757    					if( pxQueue->pxQueueSetContainer != NULL )
;;;758    					{
;;;759    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;760    						{
;;;761    							/* The queue is a member of a queue set, and posting
;;;762    							to the queue set caused a higher priority task to
;;;763    							unblock. A context switch is required. */
;;;764    							queueYIELD_IF_USING_PREEMPTION();
;;;765    						}
;;;766    						else
;;;767    						{
;;;768    							mtCOVERAGE_TEST_MARKER();
;;;769    						}
;;;770    					}
;;;771    					else
;;;772    					{
;;;773    						/* If there was a task waiting for data to arrive on the
;;;774    						queue then unblock it now. */
;;;775    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;776    						{
;;;777    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;778    							{
;;;779    								/* The unblocked task has a priority higher than
;;;780    								our own so yield immediately.  Yes it is ok to
;;;781    								do this from within the critical section - the
;;;782    								kernel takes care of that. */
;;;783    								queueYIELD_IF_USING_PREEMPTION();
;;;784    							}
;;;785    							else
;;;786    							{
;;;787    								mtCOVERAGE_TEST_MARKER();
;;;788    							}
;;;789    						}
;;;790    						else if( xYieldRequired != pdFALSE )
;;;791    						{
;;;792    							/* This path is a special case that will only get
;;;793    							executed if the task was holding multiple mutexes
;;;794    							and the mutexes were given back in an order that is
;;;795    							different to that in which they were taken. */
;;;796    							queueYIELD_IF_USING_PREEMPTION();
;;;797    						}
;;;798    						else
;;;799    						{
;;;800    							mtCOVERAGE_TEST_MARKER();
;;;801    						}
;;;802    					}
;;;803    				}
;;;804    				#else /* configUSE_QUEUE_SETS */
;;;805    				{
;;;806    					/* If there was a task waiting for data to arrive on the
;;;807    					queue then unblock it now. */
;;;808    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000134  e5940024          LDR      r0,[r4,#0x24]
000138  e3500000          CMP      r0,#0
00013c  1a000001          BNE      |L17.328|
000140  e3a00001          MOV      r0,#1
000144  ea000000          B        |L17.332|
                  |L17.328|
000148  e3a00000          MOV      r0,#0
                  |L17.332|
00014c  e3500000          CMP      r0,#0
000150  1a000005          BNE      |L17.364|
;;;809    					{
;;;810    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000154  e2840024          ADD      r0,r4,#0x24
000158  ebfffffe          BL       xTaskRemoveFromEventList
00015c  e3500000          CMP      r0,#0
000160  0a000004          BEQ      |L17.376|
;;;811    						{
;;;812    							/* The unblocked task has a priority higher than
;;;813    							our own so yield immediately.  Yes it is ok to do
;;;814    							this from within the critical section - the kernel
;;;815    							takes care of that. */
;;;816    							queueYIELD_IF_USING_PREEMPTION();
000164  ebfffffe          BL       vPortYield
000168  ea000002          B        |L17.376|
                  |L17.364|
;;;817    						}
;;;818    						else
;;;819    						{
;;;820    							mtCOVERAGE_TEST_MARKER();
;;;821    						}
;;;822    					}
;;;823    					else if( xYieldRequired != pdFALSE )
00016c  e3570000          CMP      r7,#0
000170  0a000000          BEQ      |L17.376|
;;;824    					{
;;;825    						/* This path is a special case that will only get
;;;826    						executed if the task was holding multiple mutexes and
;;;827    						the mutexes were given back in an order that is
;;;828    						different to that in which they were taken. */
;;;829    						queueYIELD_IF_USING_PREEMPTION();
000174  ebfffffe          BL       vPortYield
                  |L17.376|
;;;830    					}
;;;831    					else
;;;832    					{
;;;833    						mtCOVERAGE_TEST_MARKER();
;;;834    					}
;;;835    				}
;;;836    				#endif /* configUSE_QUEUE_SETS */
;;;837    
;;;838    				taskEXIT_CRITICAL();
000178  ebfffffe          BL       vPortExitCritical
;;;839    				return pdPASS;
00017c  e3a00001          MOV      r0,#1
                  |L17.384|
000180  e28dd01c          ADD      sp,sp,#0x1c
;;;840    			}
;;;841    			else
;;;842    			{
;;;843    				if( xTicksToWait == ( TickType_t ) 0 )
;;;844    				{
;;;845    					/* The queue was full and no block time is specified (or
;;;846    					the block time has expired) so leave now. */
;;;847    					taskEXIT_CRITICAL();
;;;848    
;;;849    					/* Return to the original privilege level before exiting
;;;850    					the function. */
;;;851    					traceQUEUE_SEND_FAILED( pxQueue );
;;;852    					return errQUEUE_FULL;
;;;853    				}
;;;854    				else if( xEntryTimeSet == pdFALSE )
;;;855    				{
;;;856    					/* The queue was full and a block time was specified so
;;;857    					configure the timeout structure. */
;;;858    					vTaskSetTimeOutState( &xTimeOut );
;;;859    					xEntryTimeSet = pdTRUE;
;;;860    				}
;;;861    				else
;;;862    				{
;;;863    					/* Entry time was already set. */
;;;864    					mtCOVERAGE_TEST_MARKER();
;;;865    				}
;;;866    			}
;;;867    		}
;;;868    		taskEXIT_CRITICAL();
;;;869    
;;;870    		/* Interrupts and other tasks can send to and receive from the queue
;;;871    		now the critical section has been exited. */
;;;872    
;;;873    		vTaskSuspendAll();
;;;874    		prvLockQueue( pxQueue );
;;;875    
;;;876    		/* Update the timeout state to see if it has expired yet. */
;;;877    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;878    		{
;;;879    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;880    			{
;;;881    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;882    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;883    
;;;884    				/* Unlocking the queue means queue events can effect the
;;;885    				event list.  It is possible	that interrupts occurring now
;;;886    				remove this task from the event	list again - but as the
;;;887    				scheduler is suspended the task will go onto the pending
;;;888    				ready last instead of the actual ready list. */
;;;889    				prvUnlockQueue( pxQueue );
;;;890    
;;;891    				/* Resuming the scheduler will move tasks from the pending
;;;892    				ready list into the ready list - so it is feasible that this
;;;893    				task is already in a ready list before it yields - in which
;;;894    				case the yield will not cause a context switch unless there
;;;895    				is also a higher priority task in the pending ready list. */
;;;896    				if( xTaskResumeAll() == pdFALSE )
;;;897    				{
;;;898    					portYIELD_WITHIN_API();
;;;899    				}
;;;900    			}
;;;901    			else
;;;902    			{
;;;903    				/* Try again. */
;;;904    				prvUnlockQueue( pxQueue );
;;;905    				( void ) xTaskResumeAll();
;;;906    			}
;;;907    		}
;;;908    		else
;;;909    		{
;;;910    			/* The timeout has expired. */
;;;911    			prvUnlockQueue( pxQueue );
;;;912    			( void ) xTaskResumeAll();
;;;913    
;;;914    			traceQUEUE_SEND_FAILED( pxQueue );
;;;915    			return errQUEUE_FULL;
;;;916    		}
;;;917    	}
;;;918    }
000184  e8bd83f0          POP      {r4-r9,pc}
                  |L17.392|
000188  e59d0014          LDR      r0,[sp,#0x14]         ;843
00018c  e3500000          CMP      r0,#0                 ;843
000190  1a000002          BNE      |L17.416|
000194  ebfffffe          BL       vPortExitCritical
000198  e3a00000          MOV      r0,#0                 ;852
00019c  eafffff7          B        |L17.384|
                  |L17.416|
0001a0  e3590000          CMP      r9,#0                 ;854
0001a4  1a000002          BNE      |L17.436|
0001a8  e28d0004          ADD      r0,sp,#4              ;858
0001ac  ebfffffe          BL       vTaskSetTimeOutState
0001b0  e3a09001          MOV      r9,#1                 ;859
                  |L17.436|
0001b4  ebfffffe          BL       vPortExitCritical
0001b8  ebfffffe          BL       vTaskSuspendAll
0001bc  ebfffffe          BL       vPortEnterCritical
0001c0  e1d404d4          LDRSB    r0,[r4,#0x44]         ;874
0001c4  e3700001          CMN      r0,#1                 ;874
0001c8  1a000001          BNE      |L17.468|
0001cc  e3a00000          MOV      r0,#0                 ;874
0001d0  e5c40044          STRB     r0,[r4,#0x44]         ;874
                  |L17.468|
0001d4  e1d404d5          LDRSB    r0,[r4,#0x45]         ;874
0001d8  e3700001          CMN      r0,#1                 ;874
0001dc  1a000001          BNE      |L17.488|
0001e0  e3a00000          MOV      r0,#0                 ;874
0001e4  e5c40045          STRB     r0,[r4,#0x45]         ;874
                  |L17.488|
0001e8  ebfffffe          BL       vPortExitCritical
0001ec  e28d1014          ADD      r1,sp,#0x14           ;877
0001f0  e28d0004          ADD      r0,sp,#4              ;877
0001f4  ebfffffe          BL       xTaskCheckForTimeOut
0001f8  e3500000          CMP      r0,#0                 ;877
0001fc  1a000011          BNE      |L17.584|
000200  e1a00004          MOV      r0,r4                 ;879
000204  ebfffffe          BL       prvIsQueueFull
000208  e3500000          CMP      r0,#0                 ;879
00020c  0a000009          BEQ      |L17.568|
000210  e2840010          ADD      r0,r4,#0x10           ;882
000214  e59d1014          LDR      r1,[sp,#0x14]         ;882
000218  ebfffffe          BL       vTaskPlaceOnEventList
00021c  e1a00004          MOV      r0,r4                 ;889
000220  ebfffffe          BL       prvUnlockQueue
000224  ebfffffe          BL       xTaskResumeAll
000228  e3500000          CMP      r0,#0                 ;896
00022c  1affffb4          BNE      |L17.260|
000230  ebfffffe          BL       vPortYield
000234  eaffffb2          B        |L17.260|
                  |L17.568|
000238  e1a00004          MOV      r0,r4                 ;904
00023c  ebfffffe          BL       prvUnlockQueue
000240  ebfffffe          BL       xTaskResumeAll
000244  eaffffae          B        |L17.260|
                  |L17.584|
000248  e1a00004          MOV      r0,r4                 ;911
00024c  ebfffffe          BL       prvUnlockQueue
000250  ebfffffe          BL       xTaskResumeAll
000254  e3a00000          MOV      r0,#0                 ;915
000258  eaffffc8          B        |L17.384|
                  |L17.604|
00025c  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
000260  52544f53
000264  5c536f75
000268  7263655c
00026c  71756575
000270  652e6300
                  |L17.628|
                          DCD      0x000002d9
                  |L17.632|
000278  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
00027c  7274696f
000280  6e202220
000284  3f3f3f20
000288  22206661
00028c  696c6564
000290  20617420
000294  6c696e65
000298  20256420
00029c  696e2025
0002a0  730a00  
0002a3  00                DCB      0
                  |L17.676|
                          DCD      0x000002da
                  |L17.680|
                          DCD      0x000002db
                  |L17.684|
                          DCD      0x000002de
                          ENDP


                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=2

                  xQueueGenericSendFromISR PROC
;;;920    
;;;921    BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;922    {
000004  e1a06000          MOV      r6,r0
000008  e1a09001          MOV      r9,r1
00000c  e1a07002          MOV      r7,r2
000010  e1a05003          MOV      r5,r3
;;;923    BaseType_t xReturn;
;;;924    UBaseType_t uxSavedInterruptStatus;
;;;925    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000014  e1a04006          MOV      r4,r6
;;;926    
;;;927    	configASSERT( pxQueue );
000018  e3540000          CMP      r4,#0
00001c  1a000005          BNE      |L18.56|
000020  e1a00000          MOV      r0,r0
000024  e28f2f4b          ADR      r2,|L18.344|
000028  e59f1140          LDR      r1,|L18.368|
00002c  e28f0d05          ADR      r0,|L18.372|
000030  ebfffffe          BL       sysprintf
000034  e1a00000          MOV      r0,r0
                  |L18.56|
;;;928    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000038  e3590000          CMP      r9,#0
00003c  1a000002          BNE      |L18.76|
000040  e5940040          LDR      r0,[r4,#0x40]
000044  e3500000          CMP      r0,#0
000048  1a000001          BNE      |L18.84|
                  |L18.76|
00004c  e3a00001          MOV      r0,#1
000050  ea000000          B        |L18.88|
                  |L18.84|
000054  e3a00000          MOV      r0,#0
                  |L18.88|
000058  e3500000          CMP      r0,#0
00005c  1a000005          BNE      |L18.120|
000060  e1a00000          MOV      r0,r0
000064  e28f20ec          ADR      r2,|L18.344|
000068  e3a01e3a          MOV      r1,#0x3a0
00006c  e28f0c01          ADR      r0,|L18.372|
000070  ebfffffe          BL       sysprintf
000074  e1a00000          MOV      r0,r0
                  |L18.120|
;;;929    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
000078  e3550002          CMP      r5,#2
00007c  1a000002          BNE      |L18.140|
000080  e594003c          LDR      r0,[r4,#0x3c]
000084  e3500001          CMP      r0,#1
000088  1a000001          BNE      |L18.148|
                  |L18.140|
00008c  e3a00001          MOV      r0,#1
000090  ea000000          B        |L18.152|
                  |L18.148|
000094  e3a00000          MOV      r0,#0
                  |L18.152|
000098  e3500000          CMP      r0,#0
00009c  1a000005          BNE      |L18.184|
0000a0  e1a00000          MOV      r0,r0
0000a4  e28f20ac          ADR      r2,|L18.344|
0000a8  e59f10f0          LDR      r1,|L18.416|
0000ac  e28f00c0          ADR      r0,|L18.372|
0000b0  ebfffffe          BL       sysprintf
0000b4  e1a00000          MOV      r0,r0
                  |L18.184|
;;;930    
;;;931    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;932    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;933    	above the maximum system call priority are kept permanently enabled, even
;;;934    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;935    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;936    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;937    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;938    	assigned a priority above the configured maximum system call priority.
;;;939    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;940    	that have been assigned a priority at or (logically) below the maximum
;;;941    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;942    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;943    	More information (albeit Cortex-M specific) is provided on the following
;;;944    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;945    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;946    
;;;947    	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;948    	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;949    	read, instead return a flag to say whether a context switch is required or
;;;950    	not (i.e. has a task with a higher priority than us been woken by this
;;;951    	post). */
;;;952    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0000b8  e3a0b000          MOV      r11,#0
;;;953    	{
;;;954    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
0000bc  e5940038          LDR      r0,[r4,#0x38]
0000c0  e594103c          LDR      r1,[r4,#0x3c]
0000c4  e1500001          CMP      r0,r1
0000c8  3a000001          BCC      |L18.212|
0000cc  e3550002          CMP      r5,#2
0000d0  1a00001d          BNE      |L18.332|
                  |L18.212|
;;;955    		{
;;;956    			const int8_t cTxLock = pxQueue->cTxLock;
0000d4  e1d4a4d5          LDRSB    r10,[r4,#0x45]
;;;957    
;;;958    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;959    
;;;960    			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;961    			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;962    			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;963    			called here even though the disinherit function does not check if
;;;964    			the scheduler is suspended before accessing the ready lists. */
;;;965    			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
0000d8  e1a02005          MOV      r2,r5
0000dc  e1a01009          MOV      r1,r9
0000e0  e1a00004          MOV      r0,r4
0000e4  ebfffffe          BL       prvCopyDataToQueue
;;;966    
;;;967    			/* The event list is not altered if the queue is locked.  This will
;;;968    			be done when the queue is unlocked later. */
;;;969    			if( cTxLock == queueUNLOCKED )
0000e8  e37a0001          CMN      r10,#1
0000ec  1a000010          BNE      |L18.308|
;;;970    			{
;;;971    				#if ( configUSE_QUEUE_SETS == 1 )
;;;972    				{
;;;973    					if( pxQueue->pxQueueSetContainer != NULL )
;;;974    					{
;;;975    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;976    						{
;;;977    							/* The queue is a member of a queue set, and posting
;;;978    							to the queue set caused a higher priority task to
;;;979    							unblock.  A context switch is required. */
;;;980    							if( pxHigherPriorityTaskWoken != NULL )
;;;981    							{
;;;982    								*pxHigherPriorityTaskWoken = pdTRUE;
;;;983    							}
;;;984    							else
;;;985    							{
;;;986    								mtCOVERAGE_TEST_MARKER();
;;;987    							}
;;;988    						}
;;;989    						else
;;;990    						{
;;;991    							mtCOVERAGE_TEST_MARKER();
;;;992    						}
;;;993    					}
;;;994    					else
;;;995    					{
;;;996    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;997    						{
;;;998    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;999    							{
;;;1000   								/* The task waiting has a higher priority so
;;;1001   								record that a context switch is required. */
;;;1002   								if( pxHigherPriorityTaskWoken != NULL )
;;;1003   								{
;;;1004   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1005   								}
;;;1006   								else
;;;1007   								{
;;;1008   									mtCOVERAGE_TEST_MARKER();
;;;1009   								}
;;;1010   							}
;;;1011   							else
;;;1012   							{
;;;1013   								mtCOVERAGE_TEST_MARKER();
;;;1014   							}
;;;1015   						}
;;;1016   						else
;;;1017   						{
;;;1018   							mtCOVERAGE_TEST_MARKER();
;;;1019   						}
;;;1020   					}
;;;1021   				}
;;;1022   				#else /* configUSE_QUEUE_SETS */
;;;1023   				{
;;;1024   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000f0  e5940024          LDR      r0,[r4,#0x24]
0000f4  e3500000          CMP      r0,#0
0000f8  1a000001          BNE      |L18.260|
0000fc  e3a00001          MOV      r0,#1
000100  ea000000          B        |L18.264|
                  |L18.260|
000104  e3a00000          MOV      r0,#0
                  |L18.264|
000108  e3500000          CMP      r0,#0
00010c  1a00000c          BNE      |L18.324|
;;;1025   					{
;;;1026   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000110  e2840024          ADD      r0,r4,#0x24
000114  ebfffffe          BL       xTaskRemoveFromEventList
000118  e3500000          CMP      r0,#0
00011c  0a000008          BEQ      |L18.324|
;;;1027   						{
;;;1028   							/* The task waiting has a higher priority so record that a
;;;1029   							context	switch is required. */
;;;1030   							if( pxHigherPriorityTaskWoken != NULL )
000120  e3570000          CMP      r7,#0
000124  0a000006          BEQ      |L18.324|
;;;1031   							{
;;;1032   								*pxHigherPriorityTaskWoken = pdTRUE;
000128  e3a00001          MOV      r0,#1
00012c  e5870000          STR      r0,[r7,#0]
000130  ea000003          B        |L18.324|
                  |L18.308|
;;;1033   							}
;;;1034   							else
;;;1035   							{
;;;1036   								mtCOVERAGE_TEST_MARKER();
;;;1037   							}
;;;1038   						}
;;;1039   						else
;;;1040   						{
;;;1041   							mtCOVERAGE_TEST_MARKER();
;;;1042   						}
;;;1043   					}
;;;1044   					else
;;;1045   					{
;;;1046   						mtCOVERAGE_TEST_MARKER();
;;;1047   					}
;;;1048   				}
;;;1049   				#endif /* configUSE_QUEUE_SETS */
;;;1050   			}
;;;1051   			else
;;;1052   			{
;;;1053   				/* Increment the lock count so the task that unlocks the queue
;;;1054   				knows that data was posted while it was locked. */
;;;1055   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
000134  e28a0001          ADD      r0,r10,#1
000138  e1a00c00          LSL      r0,r0,#24
00013c  e1a00c40          ASR      r0,r0,#24
000140  e5c40045          STRB     r0,[r4,#0x45]
                  |L18.324|
;;;1056   			}
;;;1057   
;;;1058   			xReturn = pdPASS;
000144  e3a08001          MOV      r8,#1
;;;1059   		}
000148  ea000000          B        |L18.336|
                  |L18.332|
;;;1060   		else
;;;1061   		{
;;;1062   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1063   			xReturn = errQUEUE_FULL;
00014c  e3a08000          MOV      r8,#0
                  |L18.336|
;;;1064   		}
;;;1065   	}
;;;1066   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1067   
;;;1068   	return xReturn;
000150  e1a00008          MOV      r0,r8
;;;1069   }
000154  e8bd9ff0          POP      {r4-r12,pc}
;;;1070   /*-----------------------------------------------------------*/
                          ENDP

                  |L18.344|
000158  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
00015c  52544f53
000160  5c536f75
000164  7263655c
000168  71756575
00016c  652e6300
                  |L18.368|
                          DCD      0x0000039f
                  |L18.372|
000174  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000178  7274696f
00017c  6e202220
000180  3f3f3f20
000184  22206661
000188  696c6564
00018c  20617420
000190  6c696e65
000194  20256420
000198  696e2025
00019c  730a00  
00019f  00                DCB      0
                  |L18.416|
                          DCD      0x000003a1

                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=2

                  xQueueGiveFromISR PROC
;;;1071   
;;;1072   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1073   {
000004  e1a05000          MOV      r5,r0
000008  e1a06001          MOV      r6,r1
;;;1074   BaseType_t xReturn;
;;;1075   UBaseType_t uxSavedInterruptStatus;
;;;1076   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00000c  e1a04005          MOV      r4,r5
;;;1077   
;;;1078   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1079   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1080   	read, instead return a flag to say whether a context switch is required or
;;;1081   	not (i.e. has a task with a higher priority than us been woken by this
;;;1082   	post). */
;;;1083   
;;;1084   	configASSERT( pxQueue );
000010  e3540000          CMP      r4,#0
000014  1a000005          BNE      |L19.48|
000018  e1a00000          MOV      r0,r0
00001c  e28f2f46          ADR      r2,|L19.316|
000020  e59f112c          LDR      r1,|L19.340|
000024  e28f0f4b          ADR      r0,|L19.344|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L19.48|
;;;1085   
;;;1086   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1087   	if the item size is not 0. */
;;;1088   	configASSERT( pxQueue->uxItemSize == 0 );
000030  e5940040          LDR      r0,[r4,#0x40]
000034  e3500000          CMP      r0,#0
000038  1a000001          BNE      |L19.68|
00003c  e3a00001          MOV      r0,#1
000040  ea000000          B        |L19.72|
                  |L19.68|
000044  e3a00000          MOV      r0,#0
                  |L19.72|
000048  e3500000          CMP      r0,#0
00004c  1a000005          BNE      |L19.104|
000050  e1a00000          MOV      r0,r0
000054  e28f20e0          ADR      r2,|L19.316|
000058  e3a01d11          MOV      r1,#0x440
00005c  e28f00f4          ADR      r0,|L19.344|
000060  ebfffffe          BL       sysprintf
000064  e1a00000          MOV      r0,r0
                  |L19.104|
;;;1089   
;;;1090   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1091   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1092   	interrupts, only tasks. */
;;;1093   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
000068  e5940000          LDR      r0,[r4,#0]
00006c  e3500000          CMP      r0,#0
000070  1a000002          BNE      |L19.128|
000074  e5940004          LDR      r0,[r4,#4]
000078  e3500000          CMP      r0,#0
00007c  1a000001          BNE      |L19.136|
                  |L19.128|
000080  e3a00001          MOV      r0,#1
000084  ea000000          B        |L19.140|
                  |L19.136|
000088  e3a00000          MOV      r0,#0
                  |L19.140|
00008c  e3500000          CMP      r0,#0
000090  1a000005          BNE      |L19.172|
000094  e1a00000          MOV      r0,r0
000098  e28f209c          ADR      r2,|L19.316|
00009c  e59f10e0          LDR      r1,|L19.388|
0000a0  e28f00b0          ADR      r0,|L19.344|
0000a4  ebfffffe          BL       sysprintf
0000a8  e1a00000          MOV      r0,r0
                  |L19.172|
;;;1094   
;;;1095   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1096   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1097   	above the maximum system call priority are kept permanently enabled, even
;;;1098   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1099   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1100   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1101   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1102   	assigned a priority above the configured maximum system call priority.
;;;1103   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1104   	that have been assigned a priority at or (logically) below the maximum
;;;1105   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1106   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1107   	More information (albeit Cortex-M specific) is provided on the following
;;;1108   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1109   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1110   
;;;1111   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0000ac  e3a0a000          MOV      r10,#0
;;;1112   	{
;;;1113   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
0000b0  e5948038          LDR      r8,[r4,#0x38]
;;;1114   
;;;1115   		/* When the queue is used to implement a semaphore no data is ever
;;;1116   		moved through the queue but it is still valid to see if the queue 'has
;;;1117   		space'. */
;;;1118   		if( uxMessagesWaiting < pxQueue->uxLength )
0000b4  e594003c          LDR      r0,[r4,#0x3c]
0000b8  e1500008          CMP      r0,r8
0000bc  9a00001b          BLS      |L19.304|
;;;1119   		{
;;;1120   			const int8_t cTxLock = pxQueue->cTxLock;
0000c0  e1d494d5          LDRSB    r9,[r4,#0x45]
;;;1121   
;;;1122   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1123   
;;;1124   			/* A task can only have an inherited priority if it is a mutex
;;;1125   			holder - and if there is a mutex holder then the mutex cannot be
;;;1126   			given from an ISR.  As this is the ISR version of the function it
;;;1127   			can be assumed there is no mutex holder and no need to determine if
;;;1128   			priority disinheritance is needed.  Simply increase the count of
;;;1129   			messages (semaphores) available. */
;;;1130   			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
0000c4  e2880001          ADD      r0,r8,#1
0000c8  e5840038          STR      r0,[r4,#0x38]
;;;1131   
;;;1132   			/* The event list is not altered if the queue is locked.  This will
;;;1133   			be done when the queue is unlocked later. */
;;;1134   			if( cTxLock == queueUNLOCKED )
0000cc  e3790001          CMN      r9,#1
0000d0  1a000010          BNE      |L19.280|
;;;1135   			{
;;;1136   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1137   				{
;;;1138   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1139   					{
;;;1140   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;1141   						{
;;;1142   							/* The semaphore is a member of a queue set, and
;;;1143   							posting	to the queue set caused a higher priority
;;;1144   							task to	unblock.  A context switch is required. */
;;;1145   							if( pxHigherPriorityTaskWoken != NULL )
;;;1146   							{
;;;1147   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1148   							}
;;;1149   							else
;;;1150   							{
;;;1151   								mtCOVERAGE_TEST_MARKER();
;;;1152   							}
;;;1153   						}
;;;1154   						else
;;;1155   						{
;;;1156   							mtCOVERAGE_TEST_MARKER();
;;;1157   						}
;;;1158   					}
;;;1159   					else
;;;1160   					{
;;;1161   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1162   						{
;;;1163   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1164   							{
;;;1165   								/* The task waiting has a higher priority so
;;;1166   								record that a context switch is required. */
;;;1167   								if( pxHigherPriorityTaskWoken != NULL )
;;;1168   								{
;;;1169   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1170   								}
;;;1171   								else
;;;1172   								{
;;;1173   									mtCOVERAGE_TEST_MARKER();
;;;1174   								}
;;;1175   							}
;;;1176   							else
;;;1177   							{
;;;1178   								mtCOVERAGE_TEST_MARKER();
;;;1179   							}
;;;1180   						}
;;;1181   						else
;;;1182   						{
;;;1183   							mtCOVERAGE_TEST_MARKER();
;;;1184   						}
;;;1185   					}
;;;1186   				}
;;;1187   				#else /* configUSE_QUEUE_SETS */
;;;1188   				{
;;;1189   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000d4  e5940024          LDR      r0,[r4,#0x24]
0000d8  e3500000          CMP      r0,#0
0000dc  1a000001          BNE      |L19.232|
0000e0  e3a00001          MOV      r0,#1
0000e4  ea000000          B        |L19.236|
                  |L19.232|
0000e8  e3a00000          MOV      r0,#0
                  |L19.236|
0000ec  e3500000          CMP      r0,#0
0000f0  1a00000c          BNE      |L19.296|
;;;1190   					{
;;;1191   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000f4  e2840024          ADD      r0,r4,#0x24
0000f8  ebfffffe          BL       xTaskRemoveFromEventList
0000fc  e3500000          CMP      r0,#0
000100  0a000008          BEQ      |L19.296|
;;;1192   						{
;;;1193   							/* The task waiting has a higher priority so record that a
;;;1194   							context	switch is required. */
;;;1195   							if( pxHigherPriorityTaskWoken != NULL )
000104  e3560000          CMP      r6,#0
000108  0a000006          BEQ      |L19.296|
;;;1196   							{
;;;1197   								*pxHigherPriorityTaskWoken = pdTRUE;
00010c  e3a00001          MOV      r0,#1
000110  e5860000          STR      r0,[r6,#0]
000114  ea000003          B        |L19.296|
                  |L19.280|
;;;1198   							}
;;;1199   							else
;;;1200   							{
;;;1201   								mtCOVERAGE_TEST_MARKER();
;;;1202   							}
;;;1203   						}
;;;1204   						else
;;;1205   						{
;;;1206   							mtCOVERAGE_TEST_MARKER();
;;;1207   						}
;;;1208   					}
;;;1209   					else
;;;1210   					{
;;;1211   						mtCOVERAGE_TEST_MARKER();
;;;1212   					}
;;;1213   				}
;;;1214   				#endif /* configUSE_QUEUE_SETS */
;;;1215   			}
;;;1216   			else
;;;1217   			{
;;;1218   				/* Increment the lock count so the task that unlocks the queue
;;;1219   				knows that data was posted while it was locked. */
;;;1220   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
000118  e2890001          ADD      r0,r9,#1
00011c  e1a00c00          LSL      r0,r0,#24
000120  e1a00c40          ASR      r0,r0,#24
000124  e5c40045          STRB     r0,[r4,#0x45]
                  |L19.296|
;;;1221   			}
;;;1222   
;;;1223   			xReturn = pdPASS;
000128  e3a07001          MOV      r7,#1
;;;1224   		}
00012c  ea000000          B        |L19.308|
                  |L19.304|
;;;1225   		else
;;;1226   		{
;;;1227   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1228   			xReturn = errQUEUE_FULL;
000130  e3a07000          MOV      r7,#0
                  |L19.308|
;;;1229   		}
;;;1230   	}
;;;1231   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1232   
;;;1233   	return xReturn;
000134  e1a00007          MOV      r0,r7
;;;1234   }
000138  e8bd87f0          POP      {r4-r10,pc}
;;;1235   /*-----------------------------------------------------------*/
                          ENDP

                  |L19.316|
00013c  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
000140  52544f53
000144  5c536f75
000148  7263655c
00014c  71756575
000150  652e6300
                  |L19.340|
                          DCD      0x0000043c
                  |L19.344|
000158  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
00015c  7274696f
000160  6e202220
000164  3f3f3f20
000168  22206661
00016c  696c6564
000170  20617420
000174  6c696e65
000178  20256420
00017c  696e2025
000180  730a00  
000183  00                DCB      0
                  |L19.388|
                          DCD      0x00000445

                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=2

                  xQueueIsQueueEmptyFromISR PROC
;;;1934   
;;;1935   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1936   {
000004  e1a05000          MOV      r5,r0
;;;1937   BaseType_t xReturn;
;;;1938   
;;;1939   	configASSERT( xQueue );
000008  e3550000          CMP      r5,#0
00000c  1a000005          BNE      |L20.40|
000010  e1a00000          MOV      r0,r0
000014  e28f202c          ADR      r2,|L20.72|
000018  e59f1040          LDR      r1,|L20.96|
00001c  e28f0040          ADR      r0,|L20.100|
000020  ebfffffe          BL       sysprintf
000024  e1a00000          MOV      r0,r0
                  |L20.40|
;;;1940   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
000028  e5950038          LDR      r0,[r5,#0x38]
00002c  e3500000          CMP      r0,#0
000030  1a000001          BNE      |L20.60|
;;;1941   	{
;;;1942   		xReturn = pdTRUE;
000034  e3a04001          MOV      r4,#1
000038  ea000000          B        |L20.64|
                  |L20.60|
;;;1943   	}
;;;1944   	else
;;;1945   	{
;;;1946   		xReturn = pdFALSE;
00003c  e3a04000          MOV      r4,#0
                  |L20.64|
;;;1947   	}
;;;1948   
;;;1949   	return xReturn;
000040  e1a00004          MOV      r0,r4
;;;1950   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000044  e8bd8070          POP      {r4-r6,pc}
;;;1951   /*-----------------------------------------------------------*/
                          ENDP

                  |L20.72|
000048  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
00004c  52544f53
000050  5c536f75
000054  7263655c
000058  71756575
00005c  652e6300
                  |L20.96|
                          DCD      0x00000793
                  |L20.100|
000064  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000068  7274696f
00006c  6e202220
000070  3f3f3f20
000074  22206661
000078  696c6564
00007c  20617420
000080  6c696e65
000084  20256420
000088  696e2025
00008c  730a00  
00008f  00                DCB      0

                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=2

                  xQueueIsQueueFullFromISR PROC
;;;1973   
;;;1974   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;1975   {
000004  e1a04000          MOV      r4,r0
;;;1976   BaseType_t xReturn;
;;;1977   
;;;1978   	configASSERT( xQueue );
000008  e3540000          CMP      r4,#0
00000c  1a000005          BNE      |L21.40|
000010  e1a00000          MOV      r0,r0
000014  e28f2030          ADR      r2,|L21.76|
000018  e59f1044          LDR      r1,|L21.100|
00001c  e28f0044          ADR      r0,|L21.104|
000020  ebfffffe          BL       sysprintf
000024  e1a00000          MOV      r0,r0
                  |L21.40|
;;;1979   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
000028  e5940038          LDR      r0,[r4,#0x38]
00002c  e594103c          LDR      r1,[r4,#0x3c]
000030  e1500001          CMP      r0,r1
000034  1a000001          BNE      |L21.64|
;;;1980   	{
;;;1981   		xReturn = pdTRUE;
000038  e3a05001          MOV      r5,#1
00003c  ea000000          B        |L21.68|
                  |L21.64|
;;;1982   	}
;;;1983   	else
;;;1984   	{
;;;1985   		xReturn = pdFALSE;
000040  e3a05000          MOV      r5,#0
                  |L21.68|
;;;1986   	}
;;;1987   
;;;1988   	return xReturn;
000044  e1a00005          MOV      r0,r5
;;;1989   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000048  e8bd8070          POP      {r4-r6,pc}
;;;1990   /*-----------------------------------------------------------*/
                          ENDP

                  |L21.76|
00004c  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
000050  52544f53
000054  5c536f75
000058  7263655c
00005c  71756575
000060  652e6300
                  |L21.100|
                          DCD      0x000007ba
                  |L21.104|
000068  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
00006c  7274696f
000070  6e202220
000074  3f3f3f20
000078  22206661
00007c  696c6564
000080  20617420
000084  6c696e65
000088  20256420
00008c  696e2025
000090  730a00  
000093  00                DCB      0

                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=2

                  xQueuePeekFromISR PROC
;;;1524   
;;;1525   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1526   {
000004  e1a05000          MOV      r5,r0
000008  e1a07001          MOV      r7,r1
;;;1527   BaseType_t xReturn;
;;;1528   UBaseType_t uxSavedInterruptStatus;
;;;1529   int8_t *pcOriginalReadPosition;
;;;1530   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00000c  e1a04005          MOV      r4,r5
;;;1531   
;;;1532   	configASSERT( pxQueue );
000010  e3540000          CMP      r4,#0
000014  1a000005          BNE      |L22.48|
000018  e1a00000          MOV      r0,r0
00001c  e28f20bc          ADR      r2,|L22.224|
000020  e59f10d0          LDR      r1,|L22.248|
000024  e28f00d0          ADR      r0,|L22.252|
000028  ebfffffe          BL       sysprintf
00002c  e1a00000          MOV      r0,r0
                  |L22.48|
;;;1533   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000030  e3570000          CMP      r7,#0
000034  1a000002          BNE      |L22.68|
000038  e5940040          LDR      r0,[r4,#0x40]
00003c  e3500000          CMP      r0,#0
000040  1a000001          BNE      |L22.76|
                  |L22.68|
000044  e3a00001          MOV      r0,#1
000048  ea000000          B        |L22.80|
                  |L22.76|
00004c  e3a00000          MOV      r0,#0
                  |L22.80|
000050  e3500000          CMP      r0,#0
000054  1a000005          BNE      |L22.112|
000058  e1a00000          MOV      r0,r0
00005c  e28f207c          ADR      r2,|L22.224|
000060  e59f10c0          LDR      r1,|L22.296|
000064  e28f0090          ADR      r0,|L22.252|
000068  ebfffffe          BL       sysprintf
00006c  e1a00000          MOV      r0,r0
                  |L22.112|
;;;1534   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
000070  e5940040          LDR      r0,[r4,#0x40]
000074  e3500000          CMP      r0,#0
000078  0a000001          BEQ      |L22.132|
00007c  e3a00001          MOV      r0,#1
000080  ea000000          B        |L22.136|
                  |L22.132|
000084  e3a00000          MOV      r0,#0
                  |L22.136|
000088  e3500000          CMP      r0,#0
00008c  1a000005          BNE      |L22.168|
000090  e1a00000          MOV      r0,r0
000094  e28f2044          ADR      r2,|L22.224|
000098  e59f108c          LDR      r1,|L22.300|
00009c  e28f0058          ADR      r0,|L22.252|
0000a0  ebfffffe          BL       sysprintf
0000a4  e1a00000          MOV      r0,r0
                  |L22.168|
;;;1535   
;;;1536   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1537   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1538   	above the maximum system call priority are kept permanently enabled, even
;;;1539   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1540   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1541   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1542   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1543   	assigned a priority above the configured maximum system call priority.
;;;1544   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1545   	that have been assigned a priority at or (logically) below the maximum
;;;1546   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1547   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1548   	More information (albeit Cortex-M specific) is provided on the following
;;;1549   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1550   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1551   
;;;1552   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0000a8  e3a09000          MOV      r9,#0
;;;1553   	{
;;;1554   		/* Cannot block in an ISR, so check there is data available. */
;;;1555   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
0000ac  e5940038          LDR      r0,[r4,#0x38]
0000b0  e3500000          CMP      r0,#0
0000b4  0a000006          BEQ      |L22.212|
;;;1556   		{
;;;1557   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1558   
;;;1559   			/* Remember the read position so it can be reset as nothing is
;;;1560   			actually being removed from the queue. */
;;;1561   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
0000b8  e594800c          LDR      r8,[r4,#0xc]
;;;1562   			prvCopyDataFromQueue( pxQueue, pvBuffer );
0000bc  e1a01007          MOV      r1,r7
0000c0  e1a00004          MOV      r0,r4
0000c4  ebfffffe          BL       prvCopyDataFromQueue
;;;1563   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
0000c8  e584800c          STR      r8,[r4,#0xc]
;;;1564   
;;;1565   			xReturn = pdPASS;
0000cc  e3a06001          MOV      r6,#1
0000d0  ea000000          B        |L22.216|
                  |L22.212|
;;;1566   		}
;;;1567   		else
;;;1568   		{
;;;1569   			xReturn = pdFAIL;
0000d4  e3a06000          MOV      r6,#0
                  |L22.216|
;;;1570   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1571   		}
;;;1572   	}
;;;1573   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1574   
;;;1575   	return xReturn;
0000d8  e1a00006          MOV      r0,r6
;;;1576   }
0000dc  e8bd87f0          POP      {r4-r10,pc}
;;;1577   /*-----------------------------------------------------------*/
                          ENDP

                  |L22.224|
0000e0  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
0000e4  52544f53
0000e8  5c536f75
0000ec  7263655c
0000f0  71756575
0000f4  652e6300
                  |L22.248|
                          DCD      0x000005fc
                  |L22.252|
0000fc  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000100  7274696f
000104  6e202220
000108  3f3f3f20
00010c  22206661
000110  696c6564
000114  20617420
000118  6c696e65
00011c  20256420
000120  696e2025
000124  730a00  
000127  00                DCB      0
                  |L22.296|
                          DCD      0x000005fd
                  |L22.300|
                          DCD      0x000005fe

                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=2

                  xQueueReceiveFromISR PROC
;;;1433   
;;;1434   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1435   {
000004  e1a05000          MOV      r5,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a06002          MOV      r6,r2
;;;1436   BaseType_t xReturn;
;;;1437   UBaseType_t uxSavedInterruptStatus;
;;;1438   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000010  e1a04005          MOV      r4,r5
;;;1439   
;;;1440   	configASSERT( pxQueue );
000014  e3540000          CMP      r4,#0
000018  1a000005          BNE      |L23.52|
00001c  e1a00000          MOV      r0,r0
000020  e28f20e4          ADR      r2,|L23.268|
000024  e3a01e5a          MOV      r1,#0x5a0
000028  e28f00f4          ADR      r0,|L23.292|
00002c  ebfffffe          BL       sysprintf
000030  e1a00000          MOV      r0,r0
                  |L23.52|
;;;1441   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000034  e3580000          CMP      r8,#0
000038  1a000002          BNE      |L23.72|
00003c  e5940040          LDR      r0,[r4,#0x40]
000040  e3500000          CMP      r0,#0
000044  1a000001          BNE      |L23.80|
                  |L23.72|
000048  e3a00001          MOV      r0,#1
00004c  ea000000          B        |L23.84|
                  |L23.80|
000050  e3a00000          MOV      r0,#0
                  |L23.84|
000054  e3500000          CMP      r0,#0
000058  1a000005          BNE      |L23.116|
00005c  e1a00000          MOV      r0,r0
000060  e28f20a4          ADR      r2,|L23.268|
000064  e59f10e4          LDR      r1,|L23.336|
000068  e28f00b4          ADR      r0,|L23.292|
00006c  ebfffffe          BL       sysprintf
000070  e1a00000          MOV      r0,r0
                  |L23.116|
;;;1442   
;;;1443   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1444   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1445   	above the maximum system call priority are kept permanently enabled, even
;;;1446   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1447   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1448   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1449   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1450   	assigned a priority above the configured maximum system call priority.
;;;1451   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1452   	that have been assigned a priority at or (logically) below the maximum
;;;1453   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1454   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1455   	More information (albeit Cortex-M specific) is provided on the following
;;;1456   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1457   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1458   
;;;1459   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000074  e3a0b000          MOV      r11,#0
;;;1460   	{
;;;1461   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000078  e5949038          LDR      r9,[r4,#0x38]
;;;1462   
;;;1463   		/* Cannot block in an ISR, so check there is data available. */
;;;1464   		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00007c  e3590000          CMP      r9,#0
000080  0a00001e          BEQ      |L23.256|
;;;1465   		{
;;;1466   			const int8_t cRxLock = pxQueue->cRxLock;
000084  e1d4a4d4          LDRSB    r10,[r4,#0x44]
;;;1467   
;;;1468   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1469   
;;;1470   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000088  e1a01008          MOV      r1,r8
00008c  e1a00004          MOV      r0,r4
000090  ebfffffe          BL       prvCopyDataFromQueue
;;;1471   			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
000094  e2490001          SUB      r0,r9,#1
000098  e5840038          STR      r0,[r4,#0x38]
;;;1472   
;;;1473   			/* If the queue is locked the event list will not be modified.
;;;1474   			Instead update the lock count so the task that unlocks the queue
;;;1475   			will know that an ISR has removed data while the queue was
;;;1476   			locked. */
;;;1477   			if( cRxLock == queueUNLOCKED )
00009c  e37a0001          CMN      r10,#1
0000a0  1a000010          BNE      |L23.232|
;;;1478   			{
;;;1479   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
0000a4  e5940010          LDR      r0,[r4,#0x10]
0000a8  e3500000          CMP      r0,#0
0000ac  1a000001          BNE      |L23.184|
0000b0  e3a00001          MOV      r0,#1
0000b4  ea000000          B        |L23.188|
                  |L23.184|
0000b8  e3a00000          MOV      r0,#0
                  |L23.188|
0000bc  e3500000          CMP      r0,#0
0000c0  1a00000c          BNE      |L23.248|
;;;1480   				{
;;;1481   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0000c4  e2840010          ADD      r0,r4,#0x10
0000c8  ebfffffe          BL       xTaskRemoveFromEventList
0000cc  e3500000          CMP      r0,#0
0000d0  0a000008          BEQ      |L23.248|
;;;1482   					{
;;;1483   						/* The task waiting has a higher priority than us so
;;;1484   						force a context switch. */
;;;1485   						if( pxHigherPriorityTaskWoken != NULL )
0000d4  e3560000          CMP      r6,#0
0000d8  0a000006          BEQ      |L23.248|
;;;1486   						{
;;;1487   							*pxHigherPriorityTaskWoken = pdTRUE;
0000dc  e3a00001          MOV      r0,#1
0000e0  e5860000          STR      r0,[r6,#0]
0000e4  ea000003          B        |L23.248|
                  |L23.232|
;;;1488   						}
;;;1489   						else
;;;1490   						{
;;;1491   							mtCOVERAGE_TEST_MARKER();
;;;1492   						}
;;;1493   					}
;;;1494   					else
;;;1495   					{
;;;1496   						mtCOVERAGE_TEST_MARKER();
;;;1497   					}
;;;1498   				}
;;;1499   				else
;;;1500   				{
;;;1501   					mtCOVERAGE_TEST_MARKER();
;;;1502   				}
;;;1503   			}
;;;1504   			else
;;;1505   			{
;;;1506   				/* Increment the lock count so the task that unlocks the queue
;;;1507   				knows that data was removed while it was locked. */
;;;1508   				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
0000e8  e28a0001          ADD      r0,r10,#1
0000ec  e1a00c00          LSL      r0,r0,#24
0000f0  e1a00c40          ASR      r0,r0,#24
0000f4  e5c40044          STRB     r0,[r4,#0x44]
                  |L23.248|
;;;1509   			}
;;;1510   
;;;1511   			xReturn = pdPASS;
0000f8  e3a07001          MOV      r7,#1
;;;1512   		}
0000fc  ea000000          B        |L23.260|
                  |L23.256|
;;;1513   		else
;;;1514   		{
;;;1515   			xReturn = pdFAIL;
000100  e3a07000          MOV      r7,#0
                  |L23.260|
;;;1516   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1517   		}
;;;1518   	}
;;;1519   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1520   
;;;1521   	return xReturn;
000104  e1a00007          MOV      r0,r7
;;;1522   }
000108  e8bd9ff0          POP      {r4-r12,pc}
;;;1523   /*-----------------------------------------------------------*/
                          ENDP

                  |L23.268|
00010c  46726565          DCB      "FreeRTOS\\Source\\queue.c",0
000110  52544f53
000114  5c536f75
000118  7263655c
00011c  71756575
000120  652e6300
                  |L23.292|
000124  41737365          DCB      "Assertion "" ??? "" failed at line %d in %s\n",0
000128  7274696f
00012c  6e202220
000130  3f3f3f20
000134  22206661
000138  696c6564
00013c  20617420
000140  6c696e65
000144  20256420
000148  696e2025
00014c  730a00  
00014f  00                DCB      0
                  |L23.336|
                          DCD      0x000005a1
